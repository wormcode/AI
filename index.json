[{"authors":["admin"],"categories":null,"content":"JM Liu is a engineer of artificial intelligence. He learns lots of artificial intelligence courses and practiced lots of hands on projects and had read many papers.\n","date":1559347200,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1559347200,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://wormcode.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"JM Liu is a engineer of artificial intelligence. He learns lots of artificial intelligence courses and practiced lots of hands on projects and had read many papers.","tags":null,"title":"JM  Liu","type":"authors"},{"authors":null,"categories":null,"content":" Flexibility This feature can be used for publishing content such as:\n Online courses Project or software documentation Tutorials  The courses folder may be renamed. For example, we can rename it to docs for software/project documentation or tutorials for creating an online course.\nDelete tutorials To remove these pages, delete the courses folder and see below to delete the associated menu link.\nUpdate site menu After renaming or deleting the courses folder, you may wish to update any [[main]] menu links to it by editing your menu configuration at config/_default/menus.toml.\nFor example, if you delete this folder, you can remove the following from your menu configuration:\n[[main]] name = \u0026quot;Courses\u0026quot; url = \u0026quot;courses/\u0026quot; weight = 50  Or, if you are creating a software documentation site, you can rename the courses folder to docs and update the associated Courses menu configuration to:\n[[main]] name = \u0026quot;Docs\u0026quot; url = \u0026quot;docs/\u0026quot; weight = 50  Update the docs menu If you use the docs layout, note that the name of the menu in the front matter should be in the form [menu.X] where X is the folder name. Hence, if you rename the courses/example/ folder, you should also rename the menu definitions in the front matter of files within courses/example/ from [menu.example] to [menu.\u0026lt;NewFolderName\u0026gt;].\n","date":1536451200,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":1536451200,"objectID":"59c3ce8e202293146a8a934d37a4070b","permalink":"https://wormcode.github.io/courses/example/","publishdate":"2018-09-09T00:00:00Z","relpermalink":"/courses/example/","section":"courses","summary":"Learn how to use Academic's docs layout for publishing online courses, software documentation, and tutorials.","tags":null,"title":"Overview","type":"docs"},{"authors":null,"categories":null,"content":" In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 2 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"74533bae41439377bd30f645c4677a27","permalink":"https://wormcode.github.io/courses/example/example1/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example1/","section":"courses","summary":"In this tutorial, I\u0026rsquo;ll share my top 10 tips for getting started with Academic:\nTip 1 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim.","tags":null,"title":"Example Page 1","type":"docs"},{"authors":null,"categories":null,"content":" Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\nTip 4 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1557010800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1557010800,"objectID":"1c2b5a11257c768c90d5050637d77d6a","permalink":"https://wormcode.github.io/courses/example/example2/","publishdate":"2019-05-05T00:00:00+01:00","relpermalink":"/courses/example/example2/","section":"courses","summary":"Here are some more tips for getting started with Academic:\nTip 3 Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus.","tags":null,"title":"Example Page 2","type":"docs"},{"authors":[],"categories":null,"content":" Click on the Slides button above to view the built-in slides feature.   Slides can be added in a few ways:\n Create slides using Academic\u0026rsquo;s Slides feature and link using slides parameter in the front matter of the talk file Upload an existing slide deck to static/ and link using url_slides parameter in the front matter of the talk file Embed your slides (e.g. Google Slides) or presentation video on this page using shortcodes.  Further talk details can easily be added to this page using Markdown and $\\rm \\LaTeX$ math code.\n","date":1906549200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1906549200,"objectID":"96344c08df50a1b693cc40432115cbe3","permalink":"https://wormcode.github.io/talk/example/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/talk/example/","section":"talk","summary":"An example talk using Academic's Markdown slides feature.","tags":[],"title":"Example Talk","type":"talk"},{"authors":["JM  Liu"],"categories":[],"content":"  v\\:* {behavior:url(#default#VML);} o\\:* {behavior:url(#default#VML);} w\\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);}    common Normal common 2 233 2019-06-01T06:56:00Z 2019-06-01T06:56:00Z 544 199385 1136498 Microsoft Corporation 9470 2666 1333217 14.00         false   9.05 pt 9.05 pt  false false false  EN-US ZH-CN X-NONE                        /* Style Definitions */ table.MsoNormalTable {mso-style-name:\"Table Normal\"; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-priority:99; mso-style-parent:\"\"; mso-padding-alt:0cm 5.4pt 0cm 5.4pt; mso-para-margin:0cm; mso-para-margin-bottom:.0001pt; mso-pagination:none; font-size:12.0pt; font-family:\"Courier New\";}     \nReinforcement Learning An Introduction\nSecond edition, in progress \\9A\\EC\\9A\\EC\\9A\\EC\\9A\\ECDraft\\9A\\EC\\9A\\EC\\9A\\EC\\9A\\EC\nRichard S. Sutton and Andrew G. Barto \u0026copy;2014\\A3\\AC2015\\A3\\AC2016\\A3\\AC2017\nA Bradford Book\nThe MIT Press Cambridge, Massachusetts London, England\n \nIn memory of A. Harry Klopf\n \nContents\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z Preface to the First Edition\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ix\nPreface to the Second Edition\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; xiii\nSummary of Notation\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; xvii\n1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The\u0026nbsp;\u0026nbsp; Reinforcement Learning Problem\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1\n1.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Reinforcement Learning............................................................................... 1\n1.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Examples..................................................................................................... 4\n1.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Elements of Reinforcement Learning............................................................ 6\n1.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Limitations and Scope.................................................................................. 7\n1.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; An Extended Example: Tic-Tac-Toe......................................................  10\n1.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary................................................................................................  15\n1.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Early History of Reinforcement Learning.................................................  15\n1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;Tabular Solution Methods\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 25\n2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;Multi-armed Bandits\u0026nbsp;\u0026nbsp; 27\n2.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; A k-armed Bandit Problem...................................................................... 28\n2.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Action-value Methods............................................................................ 29\n2.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The 10-armed Testbed.......................................................................... 30\n2.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Incremental Implementation .................................................................... \u0026nbsp;33\n2.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Tracking a Nonstationary Problem ......................................................... \u0026nbsp;34\n2.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimistic Initial Values .......................................................................... \u0026nbsp;36\n2.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Upper-Confidence-Bound ActionSelection............................................. 37\n2.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Gradient Bandit Algorithms .................................................................... \u0026nbsp;39\n2.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Associative Search (Contextual Bandits) ............................................... \u0026nbsp;42\n2.10\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary ............................................................................................... \u0026nbsp;43\n3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Finite Markov Decision\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Processes\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 49\n3.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Agent-Environment Interface .......................................................... 49\n3.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Goals and Rewards................................................................................  53\n3.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Returns...................................................................................................  54\n3.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Unified Notation for Episodic and Continuing Tasks.................................  57\n3.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *The Markov Property............................................................................  58\n3.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Markov Decision Processes.................................................................. 62\n3.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Value Functions...................................................................................... 65\n3.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimal Value Functions.........................................................................  70\n3.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimality and Approximation..................................................................  75\n3.10\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary ............................................................................................... \u0026nbsp;76\n4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Dynamic Programming\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 81\n4.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Evaluation .................................................................................... \u0026nbsp;82\n4.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Improvement ............................................................................... \u0026nbsp;86\n4.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Iteration ....................................................................................... \u0026nbsp;88\n4.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Value Iteration ........................................................................................ \u0026nbsp;91\n4.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Asynchronous Dynamic Programming .................................................... \u0026nbsp;93\n4.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Generalized Policy Iteration ................................................................... \u0026nbsp;95\n4.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Efficiency of Dynamic Programming........................................................ 96\n4.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary ............................................................................................... \u0026nbsp;97\n5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Methods\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 101\n5.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Prediction .......................................................................... \u0026nbsp;102\n5.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Estimation of Action Values ................................................ \u0026nbsp;106\n5.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Control ............................................................................... \u0026nbsp;107\n5.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Control without Exploring Starts .......................................... 110\n5.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Prediction via Importance Sampling........................................ 113\n5.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Incremental Implementation .................................................................... \u0026nbsp;119\n5.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Monte Carlo Control............................................................... 120\n5.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *Discounting-aware Importance Sampling.............................................. 122\n5.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *Per-reward Importance Sampling.......................................................... 124\n5.10\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Returns.................................................................................. 125\n5.11\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary ............................................................................................... \u0026nbsp;125\n6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Temporal-Difference Learning\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 129\n6.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD Prediction ........................................................................................ \u0026nbsp;129\n6.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Advantages of TD Prediction Methods ................................................... \u0026nbsp;133\n6.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimality of TD(0).................................................................................. 136\n6.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sarsa: On-policy TD Control................................................................... 139\n6.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Q-learning: Off-policy TD Control........................................................... 142\n6.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Expected Sarsa...................................................................................... 144\n6.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Maximization Bias and Double Learning................................................... 145\n6.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Games, Afterstates, and Other SpecialCases......................................... 147\n6.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary................................................................................................. 149\n7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Multi-step Bootstrapping\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 153\n7.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step TD Prediction.............................................................................. 153\n7.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Sarsa.......................................................................................... 158\n7.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Off-policy Learning by Importance Sampling ............................... 160\n7.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *Per-reward Off-policy Methods ........................................................... \u0026nbsp;162\n7.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Learning Without ImportanceSampling:\nThe n-step Tree Backup Algorithm......................................................... 163\n7.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *A Unifying Algorithm: n-step Q(\\A6\\D2).......................................................... 166\n7.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary................................................................................................. 170\n8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Planning and Learning with Tabular\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Methods\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 173\n8.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Models and Planning............................................................................... 173\n8.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Dyna: Integrating Planning, Acting,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; andLearning.................................... 176\n8.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; When the Model Is Wrong ....................................................................... \u0026nbsp;180\n8.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Prioritized Sweeping .............................................................................. \u0026nbsp;183\n8.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Full vs. Sample Backups ........................................................................ \u0026nbsp;187\n8.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Trajectory Sampling ............................................................................... \u0026nbsp;190\n8.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Real-time Dynamic Programming ............................................................ \u0026nbsp;193\n8.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Planning at Decision Time ...................................................................... \u0026nbsp;197\n8.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Heuristic Search .................................................................................... \u0026nbsp;198\n8.10\u0026nbsp;\u0026nbsp;\u0026nbsp; Rollout Algorithms .................................................................................. \u0026nbsp;200\n8.11\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Tree Search ....................................................................... \u0026nbsp;202\n8.12\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary ................................................................................................ \u0026nbsp;205\nII\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Approximate Solution Methods\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 208\n9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; On-policy Prediction with Approximation\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 211\n9.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Value-function Approximation ................................................................ \u0026nbsp;211\n9.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Prediction Objective (MSVE) ........................................................... \u0026nbsp;212\n9.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Stochastic-gradient and Semi-gradientMethods .................................... \u0026nbsp;214\n9.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Linear Methods ...................................................................................... \u0026nbsp;218\n9.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Feature Construction for Linear Methods ................................................ \u0026nbsp;224\n9.5.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Polynomials ................................................................................. \u0026nbsp;224\n9.5.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Fourier Basis .............................................................................. \u0026nbsp;225\n9.5.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Coarse Coding ............................................................................ \u0026nbsp;228\n9.5.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Tile Coding .................................................................................. \u0026nbsp;231\n9.5.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Radial Basis Functions ................................................................ \u0026nbsp;235\n9.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Nonlinear Function Approximation: Artificial Neural Networks . . . . 236\n9.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Least-Squares TD ................................................................................. 241\n9.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Memory-based Function Approximation ................................................. \u0026nbsp;243\n9.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Kernel-based Function Approximation .................................................... \u0026nbsp;245\n9.10\u0026nbsp;\u0026nbsp; Looking Deeper at On-policy Learning: Interest and Emphasis . . . . 246\n9.11\u0026nbsp;\u0026nbsp; Summary ................................................................................................ \u0026nbsp;247\n10\u0026nbsp;\u0026nbsp; On-policy\u0026nbsp;\u0026nbsp;\u0026nbsp; Controlwith Approximation\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 255\n10.1\u0026nbsp;\u0026nbsp; Episodic Semi-gradient Control .............................................................. \u0026nbsp;255\n10.2\u0026nbsp;\u0026nbsp; n-step Semi-gradient Sarsa ................................................................... 259\n10.3\u0026nbsp;\u0026nbsp; Average Reward: A New Problem Setting for Continuing Tasks . . . . 261\n10.4\u0026nbsp;\u0026nbsp; Deprecating the Discounted Setting ........................................................ \u0026nbsp;264\n10.5\u0026nbsp;\u0026nbsp; n-step Differential Semi-gradient Sarsa................................................... 266\n10.6\u0026nbsp;\u0026nbsp; Summary ................................................................................................ \u0026nbsp;267\n11\u0026nbsp;\u0026nbsp; Off-policy\u0026nbsp;\u0026nbsp;\u0026nbsp; Methods\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; with\u0026nbsp;\u0026nbsp;\u0026nbsp; Approximation\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 269\n11.1\u0026nbsp;\u0026nbsp; Semi-gradient Methods .......................................................................... \u0026nbsp;270\n11.2\u0026nbsp;\u0026nbsp; Examples of Off-policy Divergence ........................................................ \u0026nbsp;272\n11.3\u0026nbsp;\u0026nbsp; The Deadly Triad .................................................................................... \u0026nbsp;276\n11.4\u0026nbsp;\u0026nbsp; Linear Value-function Geometry ............................................................. \u0026nbsp;278\n11.5\u0026nbsp;\u0026nbsp; Stochastic Gradient Descent in the Bellman Error ................................... \u0026nbsp;282\n11.6\u0026nbsp;\u0026nbsp; Learnability of the Bellman Error ............................................................. \u0026nbsp;287\n11.7\u0026nbsp;\u0026nbsp; Gradient-TD Methods............................................................................. 291\n11.8\u0026nbsp;\u0026nbsp; Emphatic-TD Methods ........................................................................... \u0026nbsp;295\n11.9\u0026nbsp;\u0026nbsp; Reducing Variance ................................................................................. \u0026nbsp;296\n11.10Summary ................................................................................................. \u0026nbsp;298\n12\u0026nbsp;\u0026nbsp; Eligibility\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Traces\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 301\n12.1\u0026nbsp;\u0026nbsp; The \\A6\\CB-return........................................................................................... 302\n12.2\u0026nbsp;\u0026nbsp; TD(\\A6\\CB)...................................................................................................... 306\n12.3\u0026nbsp;\u0026nbsp; n-step Truncated\\A6\\CB-return Methods ...................................................... \u0026nbsp;310\n12.4\u0026nbsp;\u0026nbsp; Redoing Updates: The Online\\A6\\CB-return Algorithm.................................... 311\n12.5\u0026nbsp;\u0026nbsp; True Online TD(\\A6\\CB)................................................................................... 313\n12.6\u0026nbsp;\u0026nbsp; Dutch Traces in Monte Carlo Learning .................................................... \u0026nbsp;315\n12.7\u0026nbsp;\u0026nbsp; Sarsa(\\A6\\CB) ................................................................................................. \u0026nbsp;317\n12.8\u0026nbsp;\u0026nbsp; Variable A and \\A6\\C3..................................................................................... 322\n12.9\u0026nbsp;\u0026nbsp; Off-policy Eligibility Traces..................................................................... 323\n12.10Watkins\\A1\\AFs Q(\\A6\\CB) to Tree-Backup(\\A6\\CB)........................................................... 327\n12.11Stable Off-policy Methods with Traces ..................................................... 329\n12.12Implementation Issues ............................................................................. \u0026nbsp;330\n12.13Conclusions ............................................................................................. \u0026nbsp;331\n13\u0026nbsp;\u0026nbsp; Policy Gradient Methods\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 335\n13.1\u0026nbsp;\u0026nbsp; Policy Approximation and its Advantages ............................................... \u0026nbsp;336\n13.2\u0026nbsp;\u0026nbsp; The Policy Gradient Theorem ................................................................. \u0026nbsp;338\n13.3\u0026nbsp;\u0026nbsp; REINFORCE: Monte Carlo Policy Gradient ................................................ \u0026nbsp;340\n13.4\u0026nbsp;\u0026nbsp; REINFORCE with Baseline ....................................................................... \u0026nbsp;342\n13.5\u0026nbsp;\u0026nbsp; Actor-Critic Methods ............................................................................. \u0026nbsp;343\n13.6\u0026nbsp;\u0026nbsp; Policy\u0026nbsp;\u0026nbsp; Gradient for Continuing Problems ............................................... \u0026nbsp;345\n13.7\u0026nbsp;\u0026nbsp; Policy\u0026nbsp;\u0026nbsp; Parameterization for Continuous Actions..................................... 348\n13.8\u0026nbsp;\u0026nbsp; Summary .................................................................................................. \u0026nbsp;349\nIII\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Looking Deeper\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 352\n14\u0026nbsp;\u0026nbsp; Psychology\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 353\n14.1\u0026nbsp;\u0026nbsp; Prediction and Control ............................................................................ \u0026nbsp;354\n14.2\u0026nbsp;\u0026nbsp; Classical Conditioning ............................................................................ \u0026nbsp;355\n14.2.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Blocking and Higher-order Conditioning ..................................... \u0026nbsp;357\n14.2.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Rescorla-Wagner Model ..................................................... \u0026nbsp;359\n14.2.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The TD Model ............................................................................ \u0026nbsp;361\n14.2.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD Model Simulations ................................................................. \u0026nbsp;363\n14.3\u0026nbsp;\u0026nbsp; Instrumental Conditioning......................................................................... 372\n14.4\u0026nbsp;\u0026nbsp; Delayed Reinforcement........................................................................... 376\n14.5\u0026nbsp;\u0026nbsp; Cognitive Maps....................................................................................... 378\n14.6\u0026nbsp;\u0026nbsp; Habitual and Goal-directed Behavior....................................................... 379\n14.7\u0026nbsp;\u0026nbsp; Summary ................................................................................................ \u0026nbsp;384\n15\u0026nbsp;\u0026nbsp; Neuroscience\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 393\n15.1\u0026nbsp;\u0026nbsp; Neuroscience Basics .............................................................................. \u0026nbsp;394\n15.2\u0026nbsp;\u0026nbsp; Reward Signals, Reinforcement Signals, Values, and Prediction Errors 396\n15.3\u0026nbsp;\u0026nbsp; The Reward Prediction Error Hypothesis ................................................. \u0026nbsp;398\n15.4\u0026nbsp;\u0026nbsp; Dopamine ................................................................................................ \u0026nbsp;399\n15.5\u0026nbsp;\u0026nbsp; Experimental Support for the Reward Prediction Error Hypothesis . . 404\n15.6\u0026nbsp;\u0026nbsp; TD Error/Dopamine Correspondence ...................................................... \u0026nbsp;406\n15.7\u0026nbsp;\u0026nbsp; Neural Actor-Critic ................................................................................... 412\n15.8\u0026nbsp;\u0026nbsp; Actor and Critic Learning Rules ............................................................... \u0026nbsp;415\n15.9\u0026nbsp;\u0026nbsp; Hedonistic Neurons ................................................................................. \u0026nbsp;420\n15.10Collective Reinforcement Learning .......................................................... \u0026nbsp;422\n15.11Model-based Methods in the Brain .......................................................... \u0026nbsp;425\n15.12Addiction ................................................................................................. \u0026nbsp;427\n15.13Summary ................................................................................................. \u0026nbsp;428\n16\u0026nbsp;\u0026nbsp; Applications and Case Studies\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 439\n16.1\u0026nbsp;\u0026nbsp; TD-Gammon ........................................................................................... \u0026nbsp;439\n16.2\u0026nbsp;\u0026nbsp; Samuel\\A1\\AFs Checkers Player......................................................................... 444\n16.3\u0026nbsp;\u0026nbsp; The Acrobot ............................................................................................ \u0026nbsp;447\n16.4\u0026nbsp;\u0026nbsp; Watson\\A1\\AFs Daily-Double Wagering .............................................................. 451\n16.5\u0026nbsp;\u0026nbsp; Optimizing Memory Control........................................................................ 454\n16.6\u0026nbsp;\u0026nbsp; Human-level Video Game Play................................................................... 458\n16.7\u0026nbsp;\u0026nbsp; Mastering the Game of Go ....................................................................... \u0026nbsp;464\n16.8\u0026nbsp;\u0026nbsp; Personalized Web Services ..................................................................... \u0026nbsp;469\n16.9\u0026nbsp;\u0026nbsp; Thermal Soaring ...................................................................................... \u0026nbsp;473\n17\u0026nbsp;\u0026nbsp; Frontiers\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 477\n   479\n     References\n \nPreface to the First Edition\nWe first came to focus on what is now known as reinforcement learning in late 1979. We were both at the University of Massachusetts, working on one of the earliest projects to revive the idea that networks of neuronlike adaptive elements might prove to be a promising approach to artificial adaptive intelligence. The project explored the \\A1\\B0heterostatic theory of adaptive systems\\A1\\B1 developed by A. Harry Klopf. Harry\\A1\\AFs work was a rich source of ideas, and we were permitted to explore them critically and compare them with the long history of prior work in adaptive systems. Our task became one of teasing the ideas apart and understanding their relationships and relative importance. This continues today, but in 1979 we came to realize that perhaps the simplest of the ideas, which had long been taken for granted, had received surprisingly little attention from a computational perspective. This was simply the idea of a learning system that wants something, that adapts its behavior in order to maximize a special signal from its environment. This was the idea of a \\A1\\B0hedonistic\\A1\\B1 learning system, or, as we would say now, the idea of reinforcement learning.\nLike others, we had a sense that reinforcement learning had been thoroughly ex\u0026shy;plored in the early days of cybernetics and artificial intelligence. On closer inspection, though, we found that it had been explored only slightly. While reinforcement learn\u0026shy;ing had clearly motivated some of the earliest computational studies of learning, most of these researchers had gone on to other things, such as pattern classifica\u0026shy;tion, supervised learning, and adaptive control, or they had abandoned the study of learning altogether. As a result, the special issues involved in learning how to get something from the environment received relatively little attention. In retrospect, focusing on this idea was the critical step that set this branch of research in motion. Little progress could be made in the computational study of reinforcement learning until it was recognized that such a fundamental idea had not yet been thoroughly explored.\nThe field has come a long way since then, evolving and maturing in several direc\u0026shy;tions. Reinforcement learning has gradually become one of the most active research areas in machine learning, artificial intelligence, and neural network research. The field has developed strong mathematical foundations and impressive applications. The computational study of reinforcement learning is now a large field, with hun\u0026shy;dreds of active researchers around the world in diverse disciplines such as psychology, control theory, artificial intelligence, and neuroscience. Particularly important have been the contributions establishing and developing the relationships to the theory of optimal control and dynamic programming. The overall problem of learning from interaction to achieve goals is still far from being solved, but our understanding of it has improved significantly. We can now place component ideas, such as temporal- difference learning, dynamic programming, and function approximation, within a coherent perspective with respect to the overall problem.\n\\B4\\D3\\C4\\C7ʱ\\C6\\F0\\A3\\AC\\D5\\E2\\B8\\F6\\C1\\EC\\D3\\F2\\D2\\D1\\BE\\AD\\D7\\DF\\C1˺\\DC\\B3\\A4\\B5\\C4һ\\B6\\CE·\\A3\\AC\\D4ڼ\\B8\\B8\\F6\\B7\\BD\\CF\\F2\\B7\\A2չ\\BAͳ\\C9\\CA졣ǿ\\BB\\AFѧϰ\\D6\\F0\\BD\\A5\\B3\\C9Ϊ\\BB\\FA\\C6\\F7ѧϰ\\A3\\AC\\C8˹\\A4\\D6\\C7\\C4ܺ\\CD\\C9\\F1\\BE\\AD\\CD\\F8\\C2\\E7\\D1\\D0\\BE\\BF\\B5\\C4\\D7\\EE\\BB\\EEԾ\\B5\\C4\\D1\\D0\\BE\\BF\\C1\\EC\\D3\\F2֮һ\\A1\\A3\\B8\\C3\\C1\\EC\\D3\\F2\\D2\\D1\\BE\\AD\\D0γ\\C9\\C1\\CBǿ\\B4\\F3\\B5\\C4\\CA\\FDѧ\\BB\\F9\\B4\\A1\\BA\\CD\\C1\\EE\\C8\\CBӡ\\CF\\F3\\C9\\EE\\BF̵\\C4Ӧǿ\\BB\\AFѧϰ\\B5\\C4\\BC\\C6\\CB\\E3\\D1\\D0\\BE\\BF\\CF\\D6\\D4\\DA\\CA\\C7һ\\B8\\F6\\B4\\F3\\B5\\C4\\C1\\EC\\D3\\F2\\A3\\AC\\D4\\DA\\CA\\C0\\BD緶Χ\\C4ڻ\\FD\\BC\\AB\\B5\\C4\\D1\\D0\\BE\\BF\\C8\\CBԱ\\D4\\DA\\D0\\C4\\C0\\EDѧ\\A3\\AC\\BF\\D8\\D6\\C6\\C0\\ED\\C2\\DB\\A3\\AC\\C8˹\\A4\\D6\\C7\\C4ܺ\\CD\\C9\\F1\\BE\\AD\\BF\\C6ѧ\\B5Ȳ\\BBͬѧ\\BFƶ\\BC\\D3С\\A3\\CC\\D8\\B1\\F0\\D6\\D8Ҫ\\B5\\C4\\CAǽ\\A8\\C1\\A2\\BA\\CD\\B7\\A2չ\\D3\\EB\\D7\\EE\\D3\\C5\\BF\\D8\\D6ƺ\\CD\\B6\\AF̬\\B9滮\\C0\\ED\\C2\\DB\\B5\\C4\\B9\\D8ϵ\\A1\\A3\\B4\\D3\\BD\\BB\\BB\\A5ѧϰ\\B5\\BDʵ\\CF\\D6Ŀ\\B1\\EA\\B5\\C4\\D7\\DC\\CC\\E5\\CE\\CA\\CC⻹ԶԶû\\D3н\\E2\\BE\\F6\\A3\\AC\\B5\\AB\\CE\\D2\\C3Ƕ\\D4\\CB\\FC\\B5\\C4\\C0\\ED\\BD\\E2\\D3\\D0\\C1\\CB\\C3\\F7\\CF\\D4\\B5\\C4\\CC\\E1\\B8ߡ\\A3\\CE\\D2\\C3\\C7\\CF\\D6\\D4ڿ\\C9\\D2\\D4\\D4\\DAһ\\B8\\F6\\C1\\AC\\B9\\E1\\B5ĽǶ\\C8\\C0\\B4\\BF\\BC\\C2\\C7\\D5\\FB\\CC\\E5\\CE\\CA\\CC\\E2\\A3\\AC\\B0\\D1ʱ\\BC\\E4\\B2\\EE\\B7\\D6ѧϰ\\A3\\AC\\B6\\AF̬\\B9滮\\BAͺ\\AF\\CA\\FD\\B1ƽ\\FC\\B5\\C8\\D7\\E9\\BC\\FE˼\\CF\\EB\\B7\\C5\\D4\\DAһ\\C6\\F0\nOur goal in writing this book was to provide a clear and simple account of the key ideas and algorithms of reinforcement learning. We wanted our treatment to be accessible to readers in all of the related disciplines, but we could not cover all of these perspectives in detail. For the most part, our treatment takes the point of view of artificial intelligence and engineering. Coverage of connections to other fields we leave to others or to another time. We also chose not to produce a rigorous formal treatment of reinforcement learning. We did not reach for the highest possible level of mathematical abstraction and did not rely on a theorem-proof format. We tried to choose a level of mathematical detail that points the mathematically inclined in the right directions without distracting from the simplicity and potential generality of the underlying ideas.\nThe book is largely self-contained. The only mathematical background assumed is familiarity with elementary concepts of probability, such as expectations of random variables. Chapter 9 is substantially easier to digest if the reader has some knowledge of artificial neural networks or some other kind of supervised learning method, but it can be read without prior background. We strongly recommend working the exercises provided throughout the book. Solution manuals are available to instructors. This and other related and timely material is available via the Internet.\nAt the end of most chapters is a section entitled \\A1\\B0Bibliographical and Histori\u0026shy;cal Remarks,\\A1\\B1 wherein we credit the sources of the ideas presented in that chapter, provide pointers to further reading and ongoing research, and describe relevant his\u0026shy;torical background. Despite our attempts to make these sections authoritative and complete, we have undoubtedly left out some important prior work. For that we apol\u0026shy;ogize, and welcome corrections and extensions for incorporation into a subsequent edition.\nIn some sense we have been working toward this book for thirty years, and we have lots of people to thank. First, we thank those who have personally helped us develop the overall view presented in this book: Harry Klopf, for helping us recognize that reinforcement learning needed to be revived; Chris Watkins, Dimitri Bertsekas, John Tsitsiklis, and Paul Werbos, for helping us see the value of the relationships to dynamic programming; John Moore and Jim Kehoe, for insights and inspirations from animal learning theory; Oliver Selfridge, for emphasizing the breadth and im\u0026shy;portance of adaptation; and, more generally, our colleagues and students who have contributed in countless ways: Ron Williams, Charles Anderson, Satinder Singh, Sridhar Mahadevan, Steve Bradtke, Bob Crites, Peter Dayan, and Leemon Baird. Our view of reinforcement learning has been significantly enriched by discussions with Paul Cohen, Paul Utgoff, Martha Steenstrup, Gerry Tesauro, Mike Jordan, Leslie Kaelbling, Andrew Moore, Chris Atkeson, Tom Mitchell, Nils Nilsson, Stuart Russell, Tom Dietterich, Tom Dean, and Bob Narendra. We thank Michael Littman,\nGerry Tesauro, Bob Crites, Satinder Singh, and Wei Zhang for providing specifics of Sections 4.7, 15.1, 15.4, 15.5, and 15.6 respectively. We thank the Air Force Office of Scientific Research, the National Science Foundation, and GTE Laboratories for their long and farsighted support.\nWe also wish to thank the many people who have read drafts of this book and provided valuable comments, including Tom Kalt, John Tsitsiklis, Pawel Cichosz, Olle Gallmo, Chuck Anderson, Stuart Russell, Ben Van Roy, Paul Steenstrup, Paul Cohen, Sridhar Mahadevan, Jette Randlov, Brian Sheppard, Thomas O\\A1\\AFConnell, Richard Coggins, Cristina Versino, John H. Hiett, Andreas Badelt, Jay Ponte, Joe Beck, Justus Piater, Martha Steenstrup, Satinder Singh, Tommi Jaakkola, Dimitri Bertsekas, Torbjorn Ekman, Christina Bjorkman, Jakob Carlstrom, and Olle Palm- gren. Finally, we thank Gwyn Mitchell for helping in many ways, and Harry Stanton and Bob Prior for being our champions at MIT Press.\n \nxii\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Prefaceto\u0026nbsp; the\u0026nbsp; First\u0026nbsp; Edition\nPreface to the Second Edition\nThe nearly twenty years since the publication of the first edition of this book have seen tremendous progress in artificial intelligence, propelled in large part by advances in machine learning, including advances in reinforcement learning. Although the impressive computational power that became available is responsible for some of these advances, new developments in theory and algorithms have been driving forces as well. In the face of this progress, we decided that a second edition of our 1998 book was long overdue, and we finally began the project in 2013. Our goal for the second edition was the same as our goal for the first: to provide a clear and simple account of the key ideas and algorithms of reinforcement learning that is accessible to readers in all the related disciplines. The edition remains an introduction, and we retain a focus on core, on-line learning algorithms. This edition includes some new topics that rose to importance over the intervening years, and we expanded coverage of topics that we now understand better. But we made no attempt to provide comprehensive coverage of the field, which has exploded in many different directions with outstanding contributions by many active researchers. We apologize for having to leave out all but a handful of these contributions.\nAs for the first edition, we chose not to produce a rigorous formal treatment of reinforcement learning, or to formulate it in the most general terms. However, since the first edition, our deeper understanding of some topics required a bit more mathematics to explain, though we have set off the more mathematical parts in shaded boxes that the non-mathematically-inclined may choose to skip. We also use a slightly different notation than we used in the first edition. In teaching, we have found that the new notation helps to address some common points of confusion. It emphasizes the difference between random variables, denoted with capital letters, and their instantiations, denoted in lower case. For example, the state, action, and reward at time step t are denoted St, At, and Rt, while their possible values might be denoted s, a, and r. Along with this, it is natural to use lower case for value functions (e.g., \\A6\\D4\\A6\\D0) and restrict capitals to their tabular estimates (e.g., Qt(s, a)). Approximate value functions are deterministic functions of random parameters and are thus also in lower case (e.g., V(s,wt) ~ vn(s)). Vectors, such as wt and xt, are bold and written in lowercase even if they are random variables. Uppercase bold is reserved for matrices. All the changes in notation are summarized in a table on page xvii.\nThe contents and scope of the book have been significantly enlarged compared to the first edition. The most obvious additions are the chapters on reinforcement learning\\A1\\AFs relationships to psychology (Chapter 14) and neuroscience (Chapter 15), and the much more extensive treatment of function approximation (Chapters 9-13). The latter comprise the whole second part of the book, whereas the first part of the book (Chapters 2-8) is a comprehensive treatment of reinforcement learning while restricting to the tabular case for which exact solutions can be found. More subtly, the second edition significantly expands the treatment of off-policy learning in Chapters 5-7, throughout Chapter 11, and in Chapter 12(eligibility traces). Another subtle change is that we separate the forward-view idea of multi-step bootstrapping (now treated solely and more fully in Chapter 7) from the backward-view idea of eligibility traces (now given their own chapter in the function approximation part of the book). Many additional algorithms are presented in the tabular part of the book (e.g., UCB, Expected Sarsa, Double learning, n-step methods, tree-backup, Q(a), RLDP, and MCTS) and of course in the function approximation chapters (e.g., artificial neural networks, the fourier basis, LSTD, kernel-based methods, Gradient- TD and Emphatic-TD methods, average-reward methods, true online TD(A), and policy-gradient methods). The chapter on case studies has been updated with a selection of recent applications including Atari game playing, Watson, and AlphaGo. Still, out of necessity we have included only a small subset of all that is done in the field. Our choices reflect our long-standing interests in inexpensive model-free methods that should scale well to large applications. The final chapter now includes a discussion of the future societal impacts of reinforcement learning. For better or worse, the second edition is about two-thirds longer than the first.\nThis book is designed to be used as the primary text for a one- or two-semester course on reinforcement learning. For a one-semester course, the first ten chapters should be covered in order and form a good core, to which can be added material from the other chapters, from other books such as Bertsekas and Tsitsiklis (1996) or Szepesvari (2010), or from the literature, according to taste. Depending of the student\\A1\\AFs background, some additional material on online supervised learning may be helpful. I often cover the ideas of options and option models (Sutton, Precup and Singh, 1999). A two-semester course can cover all the chapters as well as supple\u0026shy;mentary material. The book can also be used as part of broader courses on machine learning, artificial intelligence, or neural networks. In this case, it may be desirable to cover only a subset of the material. We recommend covering Chapter 1 for a brief overview, Chapter 2 through Section 2.2, Chapter 3 except Sections 3.4, 3.5 and 3.9, and then selecting sections from the remaining chapters according to time and inter\u0026shy;ests. Chapter 6is the most important for the subject and for the rest of the book. A course focusing on machine learning or neural networks should cover Chapters 9 and 10, and a course focusing on artificial intelligence or planning should cover Chapter 8. Throughout the book, sections that are more difficult and not essential to the rest of the book are marked with a *. These can be omitted on first reading without creating problems later on. Some exercises are also marked with a * to indicate that they are more advanced and not essential to understanding the basic material of the chapter.\n \nMost chapters end with a section entitled \\A1\\B0Bibliographical and Historical Re\u0026shy;marks,\\A1\\B1 wherein we credit the sources of the ideas presented in that chapter, provide pointers to further reading and ongoing research, and describe relevant historical background. Despite our attempts to make these sections authoritative and com\u0026shy;plete, we have undoubtedly left out some important prior work. For that we again apologize, and we welcome corrections and extensions for incorporation into the elec\u0026shy;tronic version of the book.\nLike the first edition, this edition of the book is dedicated to the memory of A. Harry Klopf. It was Harry who introduced us to each other, and it was his ideas about the brain and artificial intelligence that launched our long excursion into re\u0026shy;inforcement learning. Trained in neurophysiology and long interested in machine intelligence, Harry was a senior scientist affiliated with the Avionics Directorate of the Air Force Office of Scientific Research (AFOSR) at Wright-Patterson Air Force Base, Ohio. He was dissatisfied with the great importance attributed to equilibrium- seeking processes, including homeostasis and error-correcting pattern classification methods, in explaining natural intelligence and in providing a basis for machine in\u0026shy;telligence. He noted that systems that try to maximize something (whatever that might be) are qualitatively different form equilibrium-seeking systems, and he ar\u0026shy;gued that maximizing systems hold the key to understanding important aspects of natural intelligence and for building artificial intelligences. Harry was instrumental in obtaining funding from AFOSR for a project to assess the scientific merit of these and related ideas. The project was conducted in the late 1970s at the University of Massachusetts Amherst (UMass Amherst), initially under the direction of Michael Arbib, William Kilmer, and Nico Spinelli, professors in the Department of Com\u0026shy;puter and Information Science at UMass Amherst, and founding members of the Cybernetics Center for Systems Neuroscience at the University, a farsighted group focusing on the intersection of neuroscience and artificial intelligence. Barto, a re\u0026shy;cent Ph.D. from the University of Michigan, was hired as post doctoral researcher on the project. Meanwhile, Sutton, an undergraduate studying computer science and psychology at Stanford, had been corresponding with Harry regarding their mutual interest in the role of stimulus timing in classical conditioning. Harry suggested to the UMass group that Sutton would be a great addition to the project. Thus, Sut\u0026shy;ton became a UMass graduate student, whose Ph.D. was directed by Barto, who had become an Associate Professor. The study of reinforcement learning as presented in this book is rightfully an outcome of that project instigated by Harry and inspired by his ideas. Further, Harry was responsible for bringing us, the authors, together in what has been a long and enjoyable interaction. By dedicating this book to Harry we honor his essential contributions, not only to the field of reinforcement learning, but also to our collaboration. We also thank Professors Arbib, Kilmer, and Spinelli for the opportunity they provided to us to begin exploring these ideas. Finally, we thank AFOSR for generous support over the early years of our research, and NSF for its generous support over many of the following years.\nWe have very many people to thank for their inspiration and help with this sec\u0026shy;ond edition. Everyone we acknowledged for their inspiration and help with the first edition deserve our deepest gratitude for this edition as well, which would not ex\u0026shy;ist were it not for their contributions to edition number one. To that long list we must add many others who contributed specifically to the second edition. Our stu\u0026shy;dents over the many years that we have taught from the first edition contributed in countless ways: exposing errors, offering fixes, and\\A1\\AAnot the least\\A1\\AAbeing confused in places where we could have explained things better. The chapters on psychology and neuroscience could not have been written without the help of many experts in those fields. We thank John Moore for his patient tutoring over many many years on animal learning experiments, theory, and neuroscience, and for his careful reading of multiple drafts of Chapters 14 and 15. We also thank Matt Botvinick, Nathaniel Daw, Peter Dayan, and Yael Niv for their penetrating comments on drafts of these chapter, their essential guidance through the massive literature, and their intercep\u0026shy;tion of many of our errors in early drafts. Of course, the remaining errors in these chapters\\A1\\AAand there must still be some\\A1\\AAare totally our own. We owe Phil Thomas thanks for helping us make these chapters accessible to non-psychologists and non\u0026shy;neuroscientists. We thank Jim Houk for introducing us to the subject of information processing in the basal ganglia. Jose Martinez, Terry Sejnowski, David Silver, Gerry Tesauro, Georgios Theocharous, and Phil Thomas generously helped us understand details of their reinforcement learning applications for inclusion in the case-studies chapter and commented on drafts of these sections. Special thanks is owed to David Silver for helping us better understand Monte Carlo Tree Search. We thank George Konidaris for his help with the section on the Fourier basis. Emilio Cartoni, Stefan Dernbach, Clemens Rosenbaum, and Patrick Taylor helped us in a number important ways for which we are most grateful.\nSutton would also like to thank the members of the Reinforcement Learning and Artificial Intelligence (RLAI) laboratory at the University of Alberta for contribu\u0026shy;tions to the second edition. We owe a particular debt to Rupam Mahmood for essen\u0026shy;tial contributions to the treatment of off-policy Monte Carlo methods in Chapter 5, to Hamid Maei for helping develop the perspective on off-policy learning presented in Chapter 11, to Harm van Seijen for insights that led to the separation of n-step methods from eligibility traces and, along with Hado van Hasselt, for the ideas involv\u0026shy;ing exact equivalence of forward and backward views of eligibility traces presented in Chapter 12. Sutton would also like to gratefully acknowledge the support and freedom he has granted by the Government of Alberta and the National Science and Engineering Research Council of Canada throughout the period during which the second edition was conceived and written. In particular, he would like to thank Randy Goebel for creating a supportive and far-sighted environment for research in Alberta.\n   Capital let the values to be real variables).\n        Summary of Notation\n     ters are used for random variables, whereas lower case letters are used for of random variables and for scalar functions. Quantities that are required -valued vectors are written in bold and in lower case (even if random Matrices are bold capitals.\nan equality relationship that is true by definition expectation of random variable X\nprobability that the random variable X takes on the value x (a) a value of a at which f (a) takes its maximal value\nprobability of taking a random action in an ^-greedy policy\nstep-size parameters\ndiscount-rate parameter\ndecay-rate parameter for eligibility traces\nt problem:\nnumber of actions/arms true value of action a estimate at time t of q^(a)\nthe number of times action a has been selected up through time t learned preference for selecting action a\nov Decision Process: states action reward\n   s+^:Rt T\\A1\\AF^t^S\n     set of all nonterminal states\nset of all states, including the terminal state\nset of all actions possible in state s\nset of all possible rewards\ndiscrete time step\nfinal time step of an episode, or of the episode including time t action at time t\nstate at time t, typically due, stochastically, to St-1and At-1\n \nreward at time t, typically due, stochastically, to St-i and At-i\n   tt i:A AiAi:Ai:\nKG-GGGGG\n     return (cumulative discounted reward) following time t (Section 3.3) flat return (uncorrected, undiscounted) from t + 1 to h (Section 5.8) A-return, corrected by estimated state values (Section 12.1)\nA-return, corrected by estimated action values (Section 12.1) truncated, corrected A-return, with state values (Section 12.3) truncated, corrected A-return, with action values (Section 12.3)\n   n(s)\nn(a|\nV(s',\np(s'\\\n     policy, decision-making rule\n   a)\n        a)\n     action taken in state s under deterministic policy n probability of taking action a in state s under stochastic policy n probability of transition to state sf with reward r, from state s and action a probability of transition to state sf, from state s taking action a\nbehavior policy selecting actions while estimating values for target policy n\nor a function giving a baseline b(s) for each state s\n   pt\npt:h\nr(n)\nRt\n     importance sampling ratio for time t (Section 5.5)\nimportance sampling ratio for time t to time h (Section 5.5)\naverage reward (reward rate) for policy n\nestimate at time t of r(n)\nvalue of state s under policy n (expected return)\nvalue of state s under the optimal policy\nvalue of taking action a in state s under policy n\nvalue of taking action a in state s under the optimal policy\narray estimates of state-value function vn or\n   St\n temporal-difference error at t(a random variable) (secrefTD-prediction)\n  w, w\n d-vector of weights underlying an approximate value function\n  \u0026nbsp;\n ith component of learnable weight vector\n  d\n dimensionality\\A1\\AAthe number of components of the main weight vector\n  m\n number of 1s in a sparse binary feature vector, or\n  \u0026nbsp;\n dimensionality of a secondary vector\n  V(s,w)\n approximate value of state sgiven weight vector w\n  Vw (s)\n alternate notation for V(s,w)\n  q(s,a, w)\n approximate value of state-action pair s, agiven weight vector w\n  x(s)\n vector of features visible when in state s\n  x(s, a)\n vector of features visible when in state staking action a\n  xi(s),xi(s,a)\n ith component of feature vector\n  x\n shorthand for x(S) or x(S, A)\n  wTx\n inner product of vectors, wTx J2i w%xi\\A3\\BBe.g., V(s,w) == wTx(s)\n  v,vt\n secondary d-vector of weights, used to learn w\n  et\n d-vector of eligibility traces at time t\n    \u0026nbsp;\n     array estimates of action-value function qn or q*\nh(s, a)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; learned preference for selecting action a\u0026nbsp;\u0026nbsp; instate s\n6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; , 6t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; parameter vector of target policy (Chapter\u0026nbsp;\u0026nbsp; 12)\nne\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; policy corresponding to parameter 6\nJ(n), J(6)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; performance measure for policy n or ne\n \nxx\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; SUMMARY\u0026nbsp; OF\u0026nbsp;\u0026nbsp; NOTATION\n \nChapter 1\nThe Reinforcement Learning Problem\nThe idea that we learn by interacting with our environment is probably the first to occur to us when we think about the nature of learning. When an infant plays, waves its arms, or looks about, it has no explicit teacher, but it does have a direct sensorimotor connection to its environment. Exercising this connection produces a wealth of information about cause and effect, about the consequences of actions, and about what to do in order to achieve goals. Throughout our lives, such interactions are undoubtedly a major source of knowledge about our environment and ourselves. Whether we are learning to drive a car or to hold a conversation, we are acutely aware of how our environment responds to what we do, and we seek to influence what happens through our behavior. Learning from interaction is a foundational idea underlying nearly all theories of learning and intelligence.\nIn this book we explore a computational approach to learning from interaction. Rather than directly theorizing about how people or animals learn, we explore ide\u0026shy;alized learning situations and evaluate the effectiveness of various learning methods. That is, we adopt the perspective of an artificial intelligence researcher or engineer. We explore designs for machines that are effective in solving learning problems of scientific or economic interest, evaluating the designs through mathematical analysis or computational experiments. The approach we explore, called reinforcement learn\u0026shy;ing ,is much more focused on goal-directed learning from interaction than are other approaches to machine learning.\n\\D4ڱ\\BE\\CA\\E9\\D6У\\AC\\CE\\D2\\C3\\C7̽\\CC\\D6\\C1\\CBһ\\D6ִ\\D3\\BD\\BB\\BB\\A5\\D6\\D0ѧϰ\\B5\\C4\\BC\\C6\\CB㷽\\B7\\A8\\A1\\A3 \\CE\\D2\\C3\\C7\\B2\\BB\\CA\\C7ֱ\\BD\\D3\\C0\\ED\\C2\\DB\\C8˻\\F2\\B6\\AF\\CE\\EF\\C8\\E7\\BA\\CEѧϰ\\A3\\AC\\B6\\F8\\CA\\C7̽\\CB\\F7\\C0\\ED\\CF\\EB\\B5\\C4ѧϰ\\C7龳\\A3\\AC\\B2\\A2\\C6\\C0\\B9\\C0\\B8\\F7\\D6\\D6ѧϰ\\B7\\BD\\B7\\A8\\B5\\C4\\D3\\D0Ч\\D0ԡ\\A3 Ҳ\\BE\\CD\\CA\\C7˵\\A3\\AC\\CE\\D2\\C3\\C7\\B2\\C9\\D3\\C3\\C8˹\\A4\\D6\\C7\\C4\\DC\\D1\\D0\\BE\\BF\\D5߻򹤳\\CCʦ\\B5\\C4\\B9\\DB\\B5㡣 \\CE\\D2\\C3\\C7̽\\CB\\F7\\D3\\D0Ч\\BD\\E2\\BE\\F6\\BF\\C6ѧ\\BB\\F2\\BE\\AD\\BC\\C3\\D0\\CBȤ\\B5\\C4ѧϰ\\CE\\CA\\CC\\E2\\B5Ļ\\FA\\C6\\F7\\C9\\E8\\BC\\C6\\A3\\ACͨ\\B9\\FD\\CA\\FDѧ\\B7\\D6\\CE\\F6\\BB\\F2\\BC\\C6\\CB\\E3ʵ\\D1\\E9\\C6\\C0\\B9\\C0\\C9\\E8\\BC\\C6\\A1\\A3 \\CE\\D2\\C3\\C7̽\\CB\\F7\\B5ķ\\BD\\B7\\A8\\B3\\C6Ϊǿ\\BB\\AFѧϰ\\A3\\AC\\B1\\C8\\C6\\E4\\CB\\FB\\BB\\FA\\C6\\F7ѧϰ\\B7\\BD\\B7\\A8\\B8\\FCע\\D6\\D8\\D3ڽ\\BB\\BB\\A5\\B5\\C4Ŀ\\B1굼\\CF\\F2ѧϰ\n1.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Reinforcement Learning\nReinforcement learning, like many topics whose names end with \\A1\\B0ing,\\A1\\B1 such as ma\u0026shy;chine learning and mountaineering, is simultaneously a problem, a class of solution methods that work well on the class of problems, and the field that studies these prob\u0026shy;lems and their solution methods. Reinforcement learning problems involve learning what to do\\A1\\AAhow to map situations to actions\\A1\\AAso as to maximize a numerical re\u0026shy;ward signal. In an essential way these are closed-loop problems because the learning system\\A1\\AFs actions influence its later inputs. Moreover, the learner is not told which actions to take, as in many forms of machine learning, but instead must discover which actions yield the most reward by trying them out. In the most interesting and challenging cases, actions may affect not only the immediate reward but also the next situation and, through that, all subsequent rewards. These three characteristics\\A1\\AA being closed-loop in an essential way, not having direct instructions as to what actions to take, and where the consequences of actions, including reward signals, play out over extended time periods\\A1\\AAare the three most important distinguishing features of the reinforcement learning problem.\nǿ\\BB\\AFѧϰ\\BE\\CD\\CF\\F1\\D0\\ED\\B6\\E0\\C3\\FB\\D7\\D6\\D2ԡ\\B0ing\\A1\\B1\\BD\\E1β\\B5\\C4\\BB\\B0\\CC\\E2\\A3\\AC\\A1\\B0\\C8\\E7\\BB\\FA\\C6\\F7\\A1\\B1ѧϰ\\BA͵\\C7ɽ\\A3\\ACͬʱҲ\\CA\\C7һ\\B8\\F6\\CE\\CA\\CC\\E2\\A3\\ACһ\\C0\\E0\\BD\\E2\\BE\\F6\\B7\\BD\\B0\\B8\\B6\\D4\\D5\\E2\\C0\\E0\\CE\\CA\\CC\\E2\\D3\\D0Ч\\B5ķ\\BD\\B7\\A8\\A3\\AC\\D2Լ\\B0\\D1\\D0\\BE\\BF\\D5\\E2Щ\\CE\\CA\\CC\\E2\\B5\\C4\\C1\\EC\\D3\\F2\\BA\\CD\\CB\\FB\\C3\\C7\\B5Ľ\\E2\\BE\\F6\\B7\\BD\\B7\\A8\\A1\\A3 ǿ\\BB\\AFѧϰ\\CE\\CA\\CC\\E2\\C9漰ѧϰ\\D7\\F6ʲô|\\C8\\E7\\BA\\CE\\BD\\AB\\C7龰ӳ\\C9䵽\\D0\\D0Ϊ|\\B4\\D3\\B6\\F8\\D7\\EE\\B4\\F3\\CF޶ȵ\\D8\\BD\\F8\\D0\\D0\\CA\\FD\\D7ֻ\\AF\\B5\\C4\\D4\\D9ѧϰ\\A3\\AC\\B6\\F8\\CAǱ\\D8\\D0\\EBͨ\\B9\\FD\\B3\\A2\\CA\\D4\\C0\\B4\\B7\\A2\\CF\\D6\\C4\\C4Щ\\D0\\D0Ϊ\\B2\\FA\\C9\\FA\\D7\\EE\\B4\\F3\\B5Ļ\\D8\\B1\\A8\\A1\\A3 \\D4\\DA\\D7\\EE\\D3\\D0Ȥ\\BA\\CD\\D7\\EE\\BE\\DF\\CC\\F4ս\\D0Ե\\C4\\C7\\E9\\BF\\F6\\CF£\\AC\\D0\\D0\\B6\\AF\\B2\\BB\\BD\\F6\\BF\\C9\\D2\\D4Ӱ\\CF\\ECֱ\\BD\\D3\\BD\\B1\\C0\\F8\\A3\\AC\\BB\\B9\\BF\\C9\\D2\\D4Ӱ\\CF\\EC\\CF\\C2һ\\B8\\F6\\C7\\E9\\BF\\F6\\A3\\AC\\B2\\A2ͨ\\B9\\FD\\D5\\E2ЩӰ\\CF\\EC\\C0\\B4Ӱ\\CF\\EC\\CB\\F9\\D3к\\F3\\D0\\F8\\BD\\B1\\C0\\F8\\A1\\A3 \\D5\\E2\\C8\\FD\\B8\\F6\\CCص\\E3\\CA\\C7\\D2\\D4һ\\D6\\D6\\BB\\F9\\B1\\BE\\B5ķ\\BDʽ\\B1ջ\\B7\\B5ģ\\ACû\\D3\\D0ֱ\\BDӵ\\C4ָʾ\\A3\\ACҪ\\B2\\C9ȡʲô\\D0\\D0\\B6\\AF\\A3\\AC\\D2Լ\\B0\\B0\\FC\\C0\\A8\\BD\\B1\\C0\\F8\\D0\\C5\\BA\\C5\\D4\\DA\\C4\\DA\\B5\\C4\\D0\\D0\\B6\\AF\\B5ĺ\\F3\\B9\\FB\\D4\\DA\\B3\\A4ʱ\\BC\\E4\\C4ڷ\\A2\\BB\\D3\\D7\\F7\\D3ã\\AC\\D5\\E2\\C8\\FD\\B8\\F6\\CCص\\E3\\CA\\C7\\C8\\FD\\B8\\F6\\D7\\EE\\D6\\D8Ҫ\\B5\\C4\\C7\\F8\\B1\\F0\\CC\\D8\\D5\\F7\\A3\\BA ǿ\\BB\\AFѧϰ\\CE\\CA\\CC\\E2\\A1\\A3\nA full specification of the reinforcement learning problem in terms of the optimal control of Markov decision processes (MDPs) must wait until Chapter 3, but the basic idea is simply to capture the most important aspects of the real problem facing a learning agent interacting with its environment to achieve a goal. Clearly, such an agent must be able to sense the state of the environment to some extent and must be able to take actions that affect the state. The agent also must have a goal or goals relating to the state of the environment. The MDP formulation is intended to include just these three aspects\\A1\\AAsensation, action, and goal\\A1\\AAin their simplest possible forms without trivializing any of them. Any method that is well suited to solving such problems we consider to be a reinforcement learning method.\nReinforcement learning is different from supervised learning, the kind of learning studied in most current research in the field of machine learning. Supervised learn\u0026shy;ing is learning from a training set of labeled examples provided by a knowledgable external supervisor. Each example is a description of a situation together with a specification\\A1\\AAthe label\\A1\\AAof the correct action the system should take to that situa\u0026shy;tion, which is often to identify a category to which the situation belongs. The object of this kind of learning is for the system to extrapolate, or generalize, its responses so that it acts correctly in situations not present in the training set. This is an important kind of learning, but alone it is not adequate for learning from interac\u0026shy;tion. In interactive problems it is often impractical to obtain examples of desired behavior that are both correct and representative of all the situations in which the agent has to act. In uncharted territory\\A1\\AAwhere one would expect learning to be most beneficial\\A1\\AAan agent must be able to learn from its own experience.\nReinforcement learning is also different from what machine learning researchers call unsupervised learning, which is typically about finding structure hidden in collections of unlabeled data. The terms supervised learning and unsupervised learning appear to exhaustively classify machine learning paradigms, but they do not. Although one might be tempted to think of reinforcement learning as a kind of unsupervised learn\u0026shy;ing because it does not rely on examples of correct behavior, reinforcement learning is trying to maximize a reward signal instead of trying to find hidden structure. Un\u0026shy;covering structure in an agent\\A1\\AFs experience can certainly be useful in reinforcement learning, but by itself does not address the reinforcement learning agent\\A1\\AFs problem of maximizing a reward signal. We therefore consider reinforcement learning to be a third machine learning paradigm, alongside supervised learning and unsupervised\nlearning, and perhaps other paradigms as well.\nǿ\\BB\\AFѧϰҲ\\D3\\EB\\BB\\FA\\C6\\F7ѧϰ\\D1\\D0\\BE\\BF\\D5\\DF\\B3\\C6֮Ϊ\\CE\\DE\\BC\\E0\\B6\\BDѧϰ\\B5ķ\\BDʽ\\B2\\BBͬ\\A3\\AC\\BA\\F3\\D5\\DFͨ\\B3\\A3\\CA\\C7Ѱ\\D5\\D2\\D2\\FE\\B2\\D8\\D4\\DAδ\\B1\\EA\\BC\\C7\\CA\\FD\\BEݼ\\AF\\BA\\CF\\D6е\\C4\\BDṹ\\A1\\A3 \\CA\\F5\\D3\\EF\\BC\\E0\\B6\\BDѧϰ\\BA\\CD\\CE\\DE\\BC\\E0\\B6\\BDѧϰ\\CBƺ\\F5\\BD\\AB\\BB\\FA\\C6\\F7ѧϰ\\B7\\B6\\C0\\FD\\BD\\F8\\D0\\D0\\C1\\CB\\B3\\B9\\B5׵ķ\\D6\\C0\\E0\\A3\\AC\\B5\\AB\\CA\\C7\\CB\\FC\\C3\\C7ȴû\\D3С\\A3 \\CB\\E4Ȼ\\C8\\CB\\C3\\C7\\BF\\C9\\C4\\DC\\BB\\E1\\CF\\EB\\B0\\D1ǿ\\BB\\AFѧϰ\\BF\\B4\\D7\\F7һ\\D6\\D6\\CE\\DE\\BC\\E0\\B6\\BDѧϰ\\A3\\AC\\D2\\F2Ϊ\\CB\\FC\\B2\\BB\\D2\\C0\\C0\\B5\\D3\\DA\\D5\\FDȷ\\D0\\D0Ϊ\\B5\\C4\\C0\\FD\\D7ӣ\\ACǿ\\BB\\AFѧϰ\\CA\\D4ͼ\\D7\\EE\\B4\\F3\\BB\\AFһ\\B8\\F6\\BD\\B1\\C0\\F8\\D0\\C5\\BA\\C5\\A3\\AC\\B6\\F8\\B2\\BB\\CA\\C7\\CA\\D4ͼ\\D5ҵ\\BD\\D2\\FE\\B2ص\\C4\\BDṹ\\A1\\A3 \\D4ڴ\\FA\\C0\\ED\\C8˵\\C4\\BE\\AD\\D1\\E9\\D6н\\D2ʾ\\BDṹ\\B5\\B1Ȼ\\BF\\C9\\D2\\D4\\D3\\C3\\D3\\DAǿ\\BB\\AFѧϰ\\A3\\AC\\B5\\AB\\CAǱ\\BE\\C9\\ED\\B2\\A2û\\D3н\\E2\\BE\\F6ǿ\\BB\\AFѧϰ\\B4\\FA\\C0\\ED\\C8\\CB\\D7\\EE\\B4\\F3\\BB\\AF\\BD\\B1\\C0\\F8\\D0\\C5\\BA\\C5\\B5\\C4\\CE\\CA\\CC\\E2\\A1\\A3 \\D2\\F2\\B4ˣ\\AC\\CE\\D2\\C3\\C7\\C8\\CFΪǿ\\BB\\AFѧϰ\\CA\\C7\\BC\\E0\\B6\\BDѧϰ\\BA\\CD\\CE\\DE\\BC\\E0\\B6\\BDѧϰ\\B5ĵ\\DA\\C8\\FD\\D6\\D6\\BB\\FA\\C6\\F7ѧϰ\\B7\\B6ʽѧϰ\\A3\\ACҲ\\D0\\ED\\BB\\B9\\D3\\D0\\C6\\E4\\CB\\FB\\B7\\B6\\C0\\FD\\A1\\A3\nOne of the challenges that arise in reinforcement learning, and not in other kinds of learning, is the trade-off between exploration and exploitation. To obtain a lot of reward, a reinforcement learning agent must prefer actions that it has tried in the past and found to be effective in producing reward. But to discover such actions, it has to try actions that it has not selected before. The agent has to exploit what it already knows in order to obtain reward, but it also has to explore in order to make better action selections in the future. The dilemma is that neither exploration nor exploitation can be pursued exclusively without failing at the task. The agent must try a variety of actions and progressively favor those that appear to be best. On a stochastic task, each action must be tried many times to gain a reliable estimate of its expected reward. The exploration-exploitation dilemma has been intensively studied by mathematicians for many decades (see Chapter 2). For now, we simply note that the entire issue of balancing exploration and exploitation does not even arise in supervised and unsupervised learning, at least in their purest forms.\nAnother key feature of reinforcement learning is that it explicitly considers the whole problem of a goal-directed agent interacting with an uncertain environment. This is in contrast with many approaches that consider subproblems without address\u0026shy;ing how they might fit into a larger picture. For example, we have mentioned that much of machine learning research is concerned with supervised learning without ex\u0026shy;plicitly specifying how such an ability would finally be useful. Other researchers have developed theories of planning with general goals, but without considering planning\\A1\\AFs role in real-time decision-making, or the question of where the predictive models nec\u0026shy;essary for planning would come from. Although these approaches have yielded many useful results, their focus on isolated subproblems is a significant limitation.\nReinforcement learning takes the opposite tack, starting with a complete, interac\u0026shy;tive, goal-seeking agent. All reinforcement learning agents have explicit goals, can sense aspects of their environments, and can choose actions to influence their envi\u0026shy;ronments. Moreover, it is usually assumed from the beginning that the agent has to operate despite significant uncertainty about the environment it faces. When reinforcement learning involves planning, it has to address the interplay between planning and real-time action selection, as well as the question of how environment models are acquired and improved. When reinforcement learning involves supervised learning, it does so for specific reasons that determine which capabilities are critical and which are not. For learning research to make progress, important subproblems have to be isolated and studied, but they should be subproblems that play clear roles in complete, interactive, goal-seeking agents, even if all the details of the complete agent cannot yet be filled in.\nNow by a complete, interactive, goal-seeking agent we do not always mean some\u0026shy;thing like a complete organism or robot. These are clearly examples, but a complete, interactive, goal-seeking agent can also be a component of a larger behaving system. In this case, the agent directly interacts with the rest of the larger system and indi\u0026shy;rectly interacts with the larger system\\A1\\AFs environment. A simple example is an agent that monitors the charge level of robot\\A1\\AFs battery and sends commands to the robot\\A1\\AFs control architecture. This agent\\A1\\AFs environment is the rest of the robot together with the robot\\A1\\AFs environment. One must look beyond the most obvious examples of agents and their environments to appreciate the generality of the reinforcement learning framework.\nOne of the most exciting aspects of modern reinforcement learning is its sub\u0026shy;stantive and fruitful interactions with other engineering and scientific disciplines. Reinforcement learning is part of a decades-long trend within artificial intelligence and machine learning toward greater integration with statistics, optimization, and other mathematical subjects. For example, the ability of some reinforcement learning methods to learn with parameterized approximators addresses the classical \\A1\\B0curse of dimensionality\\A1\\B1 in operations research and control theory. More distinctively, rein\u0026shy;forcement learning has also interacted strongly with psychology and neuroscience, with substantial benefits going both ways. Of all the forms of machine learning, reinforcement learning is the closest to the kind of learning that humans and other animals do, and many of the core algorithms of reinforcement learning were originally inspired by biological learning systems. And reinforcement learning has also given back, both through a psychological model of animal learning that better matches some of the empirical data, and through an influential model of parts of the brain\\A1\\AFs reward system. The body of this book develops the ideas of reinforcement learning that pertain to engineering and artificial intelligence, with connections to psychology and neuroscience summarized in Chapters 14 and 15.\nFinally, reinforcement learning is also part of a larger trend in artificial intelligence back toward simple general principles. Since the late 1960\\A1\\AFs, many artificial intel\u0026shy;ligence researchers presumed that there are no general principles to be discovered, that intelligence is instead due to the possession of vast numbers of special purpose tricks, procedures, and heuristics. It was sometimes said that if we could just get enough relevant facts into a machine, say one million, or one billion, then it would become intelligent. Methods based on general principles, such as search or learning, were characterized as \\A1\\B0weak methods,\\A1\\B1 whereas those based on specific knowledge were called \\A1\\B0strong methods.\\A1\\B1 This view is still common today, but much less dom\u0026shy;inant. From our point of view, it was simply premature: too little effort had been put into the search for general principles to conclude that there were none. Modern AI now includes much research looking for general principles of learning, search, and decision-making, as well as trying to incorporate vast amounts of domain knowledge. It is not clear how far back the pendulum will swing, but reinforcement learning re\u0026shy;search is certainly part of the swing back toward simpler and fewer general principles of artificial intelligence.\n1.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Examples\nA good way to understand reinforcement learning is to consider some of the examples and possible applications that have guided its development.\n\u0026#8226;\u0026nbsp;\u0026nbsp; A master chess player makes a move. The choice is informed both by planning\\A1\\AA\n \nanticipating possible replies and counterreplies\\A1\\AAand by immediate, intuitive judgments of the desirability of particular positions and moves.\n\u0026#8226;\u0026nbsp;\u0026nbsp; An adaptive controller adjusts parameters of a petroleum refinery\\A1\\AFs operation in real time. The controller optimizes the yield/cost/quality trade-off on the basis of specified marginal costs without sticking strictly to the set points originally suggested by engineers.\n\u0026#8226;\u0026nbsp;\u0026nbsp; A gazelle calf struggles to its feet minutes after being born. Half an hour later it is running at 20miles per hour.\n\u0026#8226;\u0026nbsp;\u0026nbsp; A mobile robot decides whether it should enter a new room in search of more trash to collect or start trying to find its way back to its battery recharging station. It makes its decision based on the current charge level of its battery and how quickly and easily it has been able to find the recharger in the past.\n\u0026#8226;\u0026nbsp;\u0026nbsp; Phil prepares his breakfast. Closely examined, even this apparently mundane activity reveals a complex web of conditional behavior and interlocking goal- subgoal relationships: walking to the cupboard, opening it, selecting a cereal box, then reaching for, grasping, and retrieving the box. Other complex, tuned, interactive sequences of behavior are required to obtain a bowl, spoon, and milk jug. Each step involves a series of eye movements to obtain information and to guide reaching and locomotion. Rapid judgments are continually made about how to carry the objects or whether it is better to ferry some of them to the dining table before obtaining others. Each step is guided by goals, such as grasping a spoon or getting to the refrigerator, and is in service of other goals, such as having the spoon to eat with once the cereal is prepared and ultimately obtaining nourishment. Whether he is aware of it or not, Phil is accessing information about the state of his body that determines his nutritional needs, level of hunger, and food preferences.\nThese examples share features that are so basic that they are easy to overlook. All involve interaction between an active decision-making agent and its environment, within which the agent seeks to achieve a goal despite uncertainty about its environ\u0026shy;ment. The agent\\A1\\AFs actions are permitted to affect the future state of the environment (e.g., the next chess position, the level of reservoirs of the refinery, the robot\\A1\\AFs next location and the future charge level of its battery), thereby affecting the options and opportunities available to the agent at later times. Correct choice requires taking into account indirect, delayed consequences of actions, and thus may require foresight or planning.\nAt the same time, in all these examples the effects of actions cannot be fully predicted; thus the agent must monitor its environment frequently and react appro\u0026shy;priately. For example, Phil must watch the milk he pours into his cereal bowl to keep it from overflowing. All these examples involve goals that are explicit in the sense that the agent can judge progress toward its goal based on what it can sense directly. The chess player knows whether or not he wins, the refinery controller knows how much petroleum is being produced, the mobile robot knows when its batteries run down, and Phil knows whether or not he is enjoying his breakfast.\nIn all of these examples the agent can use its experience to improve its performance over time. The chess player refines the intuition he uses to evaluate positions, thereby improving his play; the gazelle calf improves the efficiency with which it can run; Phil learns to streamline making his breakfast. The knowledge the agent brings to the task at the start\\A1\\AAeither from previous experience with related tasks or built into it by design or evolution\\A1\\AAinfluences what is useful or easy to learn, but interaction with the environment is essential for adjusting behavior to exploit specific features of the task.\n1.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Elements of Reinforcement Learning\nBeyond the agent and the environment, one can identify four main subelements of a reinforcement learning system: a policy, a reward signal, a value function, and, optionally, a model of the environment.\nA policy defines the learning agent\\A1\\AFs way of behaving at a given time. Roughly speaking, a policy is a mapping from perceived states of the environment to actions to be taken when in those states. It corresponds to what in psychology would be called a set of stimulus-response rules or associations (provided that stimuli include those that can come from within the animal). In some cases the policy may be a simple function or lookup table, whereas in others it may involve extensive computation such as a search process. The policy is the core of a reinforcement learning agent in the sense that it alone is sufficient to determine behavior. In general, policies may be stochastic.\nA reward signal defines the goal in a reinforcement learning problem. On each time step, the environment sends to the reinforcement learning agent a single number, a reward. The agent\\A1\\AFs sole objective is to maximize the total reward it receives over the long run. The reward signal thus defines what are the good and bad events for the agent. In a biological system, we might think of rewards as analogous to the experiences of pleasure or pain. They are the immediate and defining features of the problem faced by the agent. As such, the process that generates the reward signal must be unalterable by the agent. The agent can alter the signal that the process produces directly by its actions and indirectly by changing its environment\\A1\\AFs state\\A1\\AA since the reward signal depends on these\\A1\\AAbut it cannot change the function that generates the signal. In other words, the agent cannot simply change the problem it is facing into another one. The reward signal is the primary basis for altering the policy. If an action selected by the policy is followed by low reward, then the policy may be changed to select some other action in that situation in the future. In general, reward signals may be stochastic functions of the state of the environment and the actions taken. In Chapter 3 we explain how the idea of a reward function being unalterable by the agent is consistent with what we see in biology where reward signals are generated within an animal\\A1\\AFs brain.\nWhereas the reward signal indicates what is good in an immediate sense, a value function specifies what is good in the long run. Roughly speaking, the value of a state is the total amount of reward an agent can expect to accumulate over the future, starting from that state. Whereas rewards determine the immediate, intrin\u0026shy;sic desirability of environmental states, values indicate the long-term desirability of states after taking into account the states that are likely to follow, and the rewards available in those states. For example, a state might always yield a low immediate reward but still have a high value because it is regularly followed by other states that yield high rewards. Or the reverse could be true. To make a human analogy, rewards are somewhat like pleasure (if high) and pain (if low), whereas values correspond to a more refined and farsighted judgment of how pleased or displeased we are that our environment is in a particular state. Expressed this way, we hope it is clear that value functions formalize a basic and familiar idea.\nRewards are in a sense primary, whereas values, as predictions of rewards, are secondary. Without rewards there could be no values, and the only purpose of es\u0026shy;timating values is to achieve more reward. Nevertheless, it is values with which we are most concerned when making and evaluating decisions. Action choices are made based on value judgments. We seek actions that bring about states of highest value, not highest reward, because these actions obtain the greatest amount of reward for us over the long run. Unfortunately, it is much harder to determine values than it is to determine rewards. Rewards are basically given directly by the environment, but values must be estimated and re-estimated from the sequences of observations an agent makes over its entire lifetime. In fact, the most important component of almost all reinforcement learning algorithms we consider is a method for efficiently estimat\u0026shy;ing values. The central role of value estimation is arguably the most important thing we have learned about reinforcement learning over the last few decades.\nThe fourth and final element of some reinforcement learning systems is a model of the environment. This is something that mimics the behavior of the environment, or more generally, that allows inferences to be made about how the environment will behave. For example, given a state and action, the model might predict the resultant next state and next reward. Models are used for planning, by which we mean any way of deciding on a course of action by considering possible future situations before they are actually experienced. Methods for solving reinforcement learning problems that use models and planning are called model-based methods, as opposed to simpler model-free methods that are explicitly trial-and-error learners\\A1\\AAviewed as almost the opposite of planning. In Chapter 8we explore reinforcement learning systems that simultaneously learn by trial and error, learn a model of the environment, and use the model for planning. Modern reinforcement learning spans the spectrum from low-level, trial-and-error learning to high-level, deliberative planning.\n1.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Limitations and Scope\nMost of the reinforcement learning methods we consider in this book are struc\u0026shy;tured around estimating value functions, but it is not strictly necessary to do this to solve reinforcement learning problems. For example, methods such as genetic algo\u0026shy;rithms, genetic programming, simulated annealing, and other optimization methods have been used to approach reinforcement learning problems without ever appealing to value functions. These methods evaluate the \\A1\\B0lifetime\\A1\\B1 behavior of many non\u0026shy;learning agents, each using a different policy for interacting with its environment, and select those that are able to obtain the most reward. We call these evolution\u0026shy;ary methods because their operation is analogous to the way biological evolution produces organisms with skilled behavior even when they do not learn during their individual lifetimes. If the space of policies is sufficiently small, or can be structured so that good policies are common or easy to find\\A1\\AAor if a lot of time is available for the search\\A1\\AAthen evolutionary methods can be effective. In addition, evolutionary methods have advantages on problems in which the learning agent cannot accurately sense the state of its environment.\nOur focus is on reinforcement learning methods that involve learning while inter\u0026shy;acting with the environment, which evolutionary methods do not do (unless they evolve learning algorithms, as in some of the approaches that have been studied). It is our belief that methods able to take advantage of the details of individual be\u0026shy;havioral interactions can be much more efficient than evolutionary methods in many cases. Evolutionary methods ignore much of the useful structure of the reinforce\u0026shy;ment learning problem: they do not use the fact that the policy they are searching for is a function from states to actions; they do not notice which states an individual passes through during its lifetime, or which actions it selects. In some cases this information can be misleading (e.g., when states are misperceived), but more often it should enable more efficient search. Although evolution and learning share many features and naturally work together, we do not consider evolutionary methods by themselves to be especially well suited to reinforcement learning problems. For sim\u0026shy;plicity, in this book when we use the term \\A1\\B0reinforcement learning method\\A1\\B1 we do not include evolutionary methods.\nHowever, we do include some methods that, like evolutionary methods, do not appeal to value functions. These methods search in spaces of policies defined by a collection of numerical parameters. They estimate the directions the parameters should be adjusted in order to most rapidly improve a policy\\A1\\AFs performance. Un\u0026shy;like evolutionary methods, however, they produce these estimates while the agent is interacting with its environment and so can take advantage of the details of individ\u0026shy;ual behavioral interactions. Methods like this, called policy gradient methods, have proven useful in many problems, and some of the simplest reinforcement learning methods fall into this category. In fact, some of these methods take advantage of value function estimates to improve their gradient estimates. Overall, the distinc\u0026shy;tion between policy gradient methods and other methods we include as reinforcement learning methods is not sharply defined.\nReinforcement learning\\A1\\AFs connection to optimization methods deserves some ad\u0026shy;ditional comment because it is a source of a common misunderstanding. When we say that a reinforcement learning agent\\A1\\AFs goal is to maximize a numerical reward signal, we of course are not insisting that the agent has to actually achieve the goal of maximum reward. Trying to maximize a quantity does not mean that that quan\u0026shy;tity is ever maximized. The point is that a reinforcement learning agent is always trying to increase the amount of reward it receives. Many factors can prevent it from achieving the maximum, even if one exists. In other words, optimization is not the same as optimality.\nWhether or not an optimization method ever achieves optimality, designing arti\u0026shy;ficial intelligence systems based on optimization requires care because the behavior of these systems is not always predictable. Reinforcement learning agents sometimes discover unexpected ways of making their environments deliver reward. From one perspective, this is a desirable property of intelligence: it is a kind of creativity. A process based on variation and selection\\A1\\AAthe essence of both evolution and reinforce\u0026shy;ment learning\\A1\\AAcan discover new paths to success for whatever challenges an animal population or an artificial intelligence faces. But it raises the important issue of how to make sure these unexpected \\A1\\B0solutions\\A1\\B1 do not have unintended and undesirable consequences.\nThis concern is hardly new with reinforcement learning; it is a primal theme in lit\u0026shy;erature (for example, Goethe\\A1\\AFs 1797 poem\\A1\\B0The Sorcerer\\A1\\AFs Apprentice\\A1\\B1\\A3\\ACamong many others) and is summed up by the trope \\A1\\B0Be careful what you wish for because you just might get it!\\A1\\B1 Approaches to reducing the severity of this problem, such as en\u0026shy;forcing constraints during optimization or by adjusting objective functions to make optimization sensitive to risk, are only partial solutions. Standard engineering prac\u0026shy;tice has long required careful examination of any result of an optimization process before using that result in constructing a product, a structure, or any real-world system whose safe performance people will rely upon. This is also essential prac\u0026shy;tice for engineering uses of reinforcement learning, and special care is needed if a reinforcement learning system is deployed on-line in a domain in which unforeseen consequences can be unacceptable\\A1\\AAnot just for the reinforcement learning agent, but also for the agent\\A1\\AFs environment and the people in it. The fast pace of artifi\u0026shy;cial intelligence, especially as machine learning systems are enabling super-human performance in certain domains, is bringing this concern to the fore.\nThe unpredictability of optimization is just one aspect of the wider subject of how reinforcement learning systems can be deployed responsibly in the real world. This, again, is not significantly different from the same concern about other engineering technologies, and many approaches to mitigating the risk of unwanted consequences have been developed. Particularly relevant are approaches to mitigating risk in ap\u0026shy;plications of optimal control methods, some of which have been adapted to reinforce\u0026shy;ment learning. This is a large and complicated subject, with many dimensions, that goes beyond what we are attempting to cover in this introductory text. However, we cannot emphasize too strongly that when treated as an engineering methodology\\A1\\AA and not just as a theory about learning and intelligence\\A1\\AAreinforcement learning is subject to all the cautions that guide the application of any engineering methodology.\n \n1.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; An Extended Example: Tic-Tac-Toe\nTo illustrate the general idea of reinforcement learning and contrast it with other approaches, we next consider a single example in more detail.\n   X\n O\n O\n  O\n X\n X\n  \u0026nbsp;\n \u0026nbsp;\n X\n    \u0026nbsp;\n     Consider the familiar child\\A1\\AFs game of tic-tac-toe. Two play\u0026shy;ers take turns playing on a three-by-three board. One player plays Xs and the other Os until one player wins by placing three marks in a row, horizontally, vertically, or diagonally, as the X player has in the game shown to the right. If the board fills up with neither player getting three in a row, the game is a draw. Because a skilled player can play so as never to lose, let us assume that we are playing against an imperfect\nplayer, one whose play is sometimes incorrect and allows us to win. For the moment, in fact, let us consider draws and losses to be equally bad for us. How might we construct a player that will find the imperfections in its opponent\\A1\\AFs play and learn to maximize its chances of winning?\nAlthough this is a simple problem, it cannot readily be solved in a satisfactory way through classical techniques. For example, the classical \\A1\\B0minimax\\A1\\B1 solution from game theory is not correct here because it assumes a particular way of playing by the opponent. For example, a minimax player would never reach a game state from which it could lose, even if in fact it always won from that state because of incorrect play by the opponent. Classical optimization methods for sequential decision problems, such as dynamic programming, can compute an optimal solution for any opponent, but require as input a complete specification of that opponent, including the probabilities with which the opponent makes each move in each board state. Let us assume that this information is not available a priori for this problem, as it is not for the vast majority of problems of practical interest. On the other hand, such information can be estimated from experience, in this case by playing many games against the opponent. About the best one can do on this problem is first to learn a model of the opponent\\A1\\AFs behavior, up to some level of confidence, and then apply dynamic programming to compute an optimal solution given the approximate opponent model. In the end, this is not that different from some of the reinforcement learning methods we examine later in this book.\nAn evolutionary method applied to this problem would directly search the space of possible policies for one with a high probability of winning against the opponent. Here, a policy is a rule that tells the player what move to make for every state of the game\\A1\\AAevery possible configuration of Xs and Os on the three-by-three board. For each policy considered, an estimate of its winning probability would be obtained by playing some number of games against the opponent. This evaluation would then direct which policy or policies were considered next. A typical evolutionary method would hill-climb in policy space, successively generating and evaluating policies in an attempt to obtain incremental improvements. Or, perhaps, a genetic-style algorithm could be used that would maintain and evaluate a population of policies. Literally hundreds of different optimization methods could be applied.\nHere is how the tic-tac-toe problem would be approached with a method making use of a value function. First we set up a table of numbers, one for each possible state of the game. Each number will be the latest estimate of the probability of our winning from that state. We treat this estimate as the state\\A1\\AFs value, and the whole table is the learned value function. State A has higher value than state B, or is considered \\A1\\B0better\\A1\\B1 than state B, if the current estimate of the probability of our winning from A is higher than it is from B. Assuming we always play Xs, then for all states with three Xs in a row the probability of winning is 1, because we have already won. Similarly, for all states with three Os in a row, or that are \\A1\\B0filled up,\\A1\\B1 the correct probability is 0, as we cannot win from them. We set the initial values of all the other states to 0.5, representing a guess that we have a 50% chance of winning.\nWe play many games against the opponent. To select our moves we examine the states that would result from each of our possible moves (one for each blank space on the board) and look up their current values in the table. Most of the time we move greedily, selecting the move that leads to the state with greatest value, that is, with the highest estimated probability of winning. Occasionally, however, we select randomly from among the other moves instead. These are called exploratory moves because they cause us to experience states that we might otherwise never see. A sequence of moves made and considered during a game can be diagrammed as in Figure 1.1.\nWhile we are playing, we change the values of the states in which we find ourselves during the game. We attempt to make them more accurate estimates of the proba\u0026shy;bilities of winning. To do this, we \\A1\\B0back up\\A1\\B1 the value of the state after each greedy move to the state before the move, as suggested by the arrows in Figure 1.1. More precisely, the current value of the earlier state is adjusted to be closer to the value of the later state. This can be done by moving the earlier state\\A1\\AFs value a fraction of the way toward the value of the later state. If we let s denote the state before the greedy move, and sf the state after the move, then the update to the estimated value of s, denoted V(s), can be written as\nV(s) ^ V(s) + a[v(s') - V(s^ ,\nwhere a is a small positive fraction called the step-size parameter, which influences the rate of learning. This update rule is an example of a temporal-difference learning method, so called because its changes are based on a difference, V(s') \\A1\\AA V(s), between estimates at two different times.\nThe method described above performs quite well on this task. For example, if the step-size parameter is reduced properly over time (see page 35), this method converges, for any fixed opponent, to the true probabilities of winning from each state given optimal play by our player. Furthermore, the moves then taken (except on exploratory moves) are in fact the optimal moves against this (imperfect) opponent. In other words, the method converges to an optimal policy for playing the game against this opponent. If the step-size parameter is not reduced all the way to zero over time, then this player also plays well against opponents that slowly change their\n \nopponent's move\n   starting position\n  \n     our move\nopponent's move\n \n   Figure 1.1: A sequence of tic-tac-toe moves. The solid lines represent the moves taken during a game; the dashed lines represent moves that we (our reinforcement learning player) considered but did not make. Our second move was an exploratory move, meaning that it was taken even though another sibling move, the one leading to e*, was ranked higher. Exploratory moves do not result in any learning, but each of our other moves does, causing backupsas suggested by the curved arrows and detailed in the text.\n        opponent's move\n        our move\n        our move\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n way of playing.\nThis example illustrates the differences between evolutionary methods and the methods that learn value functions. To evaluate a policy an evolutionary method holds the policy fixed and plays many games against the opponent, or simulates many games using a model of the opponent. The frequency of wins gives an unbiased estimate of the probability of winning with that policy, and can be used to direct the next policy selection. But each policy change is made only after many games, and only the final outcome of each game is used: what happens during the games is ignored. For example, if the player wins, then all of its behavior in the game is given credit, independently of how specific moves might have been critical to the win. Credit is even given to moves that never occurred! Value function methods, in contrast, allow individual states to be evaluated. In the end, evolutionary and value function methods both search the space of policies, but learning a value function takes advantage of information available during the course of play.\nThis simple example illustrates some of the key features of reinforcement learning methods. First, there is the emphasis on learning while interacting with an envi\u0026shy;ronment, in this case with an opponent player. Second, there is a clear goal, and correct behavior requires planning or foresight that takes into account delayed effects of one\\A1\\AFs choices. For example, the simple reinforcement learning player would learn to set up multi-move traps for a shortsighted opponent. It is a striking feature ofthe reinforcement learning solution that it can achieve the effects of planning and lookahead without using a model of the opponent and without conducting an explicit search over possible sequences of future states and actions.\nWhile this example illustrates some of the key features of reinforcement learning, it is so simple that it might give the impression that reinforcement learning is more limited than it really is. Although tic-tac-toe is a two-person game, reinforcement learning also applies in the case in which there is no external adversary, that is, in the case of a \\A1\\B0game against nature.\\A1\\B1 Reinforcement learning also is not restricted to problems in which behavior breaks down into separate episodes, like the separate games of tic-tac-toe, with reward only at the end of each episode. It is just as applica\u0026shy;ble when behavior continues indefinitely and when rewards of various magnitudes can be received at any time. Reinforcement learning is also applicable to problems that do not even break down into discrete time steps, like the plays of tic-tac-toe. The general principles apply to continuous-time problems as well, although the theory gets more complicated and we omit it from this introductory treatment.\nTic-tac-toe has a relatively small, finite state set, whereas reinforcement learning can be used when the state set is very large, or even infinite. For example, Gerry Tesauro (1992, 1995) combined the algorithm described above with an artificial neu\u0026shy;ral network to learn to play backgammon, which has approximately 1020states. With this many states it is impossible ever to experience more than a small fraction of them. Tesauro\\A1\\AFs program learned to play far better than any previous program, and now plays at the level of the world\\A1\\AFs best human players (see Chapter 16). The neural network provides the program with the ability to generalize from its experi\u0026shy;ence, so that in new states it selects moves based on information saved from similar states faced in the past, as determined by its network. How well a reinforcement learning system can work in problems with such large state sets is intimately tied to how appropriately it can generalize from past experience. It is in this role that we have the greatest need for supervised learning methods with reinforcement learning. Neural networks and deep learning (Section 9.6) are not the only, or necessarily the best, way to do this.\nIn this tic-tac-toe example, learning started with no prior knowledge beyond the rules of the game, but reinforcement learning by no means entails a tabula rasa view of learning and intelligence. On the contrary, prior information can be incorporated into reinforcement learning in a variety of ways that can be critical for efficient learning. We also had access to the true state in the tic-tac-toe example, whereas reinforcement learning can also be applied when part of the state is hidden, or when different states appear to the learner to be the same. That case, however, is substantially more difficult, and we do not cover it significantly in this book.\nFinally, the tic-tac-toe player was able to look ahead and know the states that would result from each of its possible moves. To do this, it had to have a model of the game that allowed it to \\A1\\B0think about\\A1\\B1 how its environment would change in response to moves that it might never make. Many problems are like this, but in others even a short-term model of the effects of actions is lacking. Reinforcement learning can be applied in either case. No model is required, but models can easily be used if they are available or can be learned.\nOn the other hand, there are reinforcement learning methods that do not need any kind of environment model at all. Model-free systems cannot even think about how their environments will change in response to a single action. The tic-tac-toe player is model-free in this sense with respect to its opponent: it has no model of its opponent of any kind. Because models have to be reasonably accurate to be useful, model-free methods can have advantages over more complex methods when the real bottleneck in solving a problem is the difficulty of constructing a sufficiently accurate environment model. Model-free methods are also important building blocks for model-based methods. In this book we devote several chapters to model-free methods before we discuss how they can be used as components of more complex model-based methods.\nReinforcement learning can be used at both high and low levels in a system. Al\u0026shy;though the tic-tac-toe player learned only about the basic moves of the game, nothing prevents reinforcement learning from working at higher levels where each of the \\A1\\B0ac\u0026shy;tions\\A1\\B1 may itself be the application of a possibly elaborate problem-solving method. In hierarchical learning systems, reinforcement learning can work simultaneously on several levels.\nExercise 1.1: Self-Play Suppose, instead of playing against a random opponent, the reinforcement learning algorithm described above played against itself, with both sides learning. What do you think would happen in this case? Would it learn a different policy for selecting moves?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 1.2: Symmetries Many tic-tac-toe positions appear different but are really the same because of symmetries. How might we amend the learning process described above to take advantage of this? In what ways would this change improve the learning process? Now think again. Suppose the opponent did not take advantage of symmetries. In that case, should we? Is it true, then, that symmetrically equivalent positions should necessarily have the same value?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 1.3: Greedy Play Suppose the reinforcement learning player was greedy, that is, it always played the move that brought it to the position that it rated the best. Might it learn to play better, or worse, than a nongreedy player? What problems might occur?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 1.4: Learning from Exploration Suppose learning updates occurred after all moves, including exploratory moves. If the step-size parameter is appropriately reduced over time (but not the tendency to explore), then the state values would converge to a set of probabilities. What are the two sets of probabilities computed when we do, and when we do not, learn from exploratory moves? Assuming that we do continue to make exploratory moves, which set of probabilities might be better to learn? Which would result in more wins?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 1.5: Other Improvements Can you think of other ways to improve the reinforcement learning player? Can you think of any better way to solve the tic-tac- toe problem as posed?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n \n1.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nReinforcement learning is a computational approach to understanding and automat\u0026shy;ing goal-directed learning and decision-making. It is distinguished from other com\u0026shy;putational approaches by its emphasis on learning by an agent from direct interaction with its environment, without relying on exemplary supervision or complete models of the environment. In our opinion, reinforcement learning is the first field to se\u0026shy;riously address the computational issues that arise when learning from interaction with an environment in order to achieve long-term goals.\nReinforcement learning uses a formal framework defining the interaction between a learning agent and its environment in terms of states, actions, and rewards. This framework is intended to be a simple way of representing essential features of the artificial intelligence problem. These features include a sense of cause and effect, a sense of uncertainty and nondeterminism, and the existence of explicit goals.\nThe concepts of value and value functions are the key features of most of the reinforcement learning methods that we consider in this book. We take the position that value functions are important for efficient search in the space of policies. The use of value functions distinguishes reinforcement learning methods from evolutionary methods that search directly in policy space guided by scalar evaluations of entire policies.\n1.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Early History of Reinforcement Learning\nThe history of reinforcement learning has two main threads, both long and rich, that were pursued independently before intertwining in modern reinforcement learning. One thread concerns learning by trial and error that started in the psychology of animal learning. This thread runs through some of the earliest work in artificial intelligence and led to the revival of reinforcement learning in the early 1980s. The other thread concerns the problem of optimal control and its solution using value functions and dynamic programming. For the most part, this thread did not involve learning. Although the two threads have been largely independent, the exceptions revolve around a third, less distinct thread concerning temporal-difference methods such as the one used in the tic-tac-toe example in this chapter. All three threads came together in the late 1980s to produce the modern field of reinforcement learning as we present it in this book.\nThe thread focusing on trial-and-error learning is the one with which we are most familiar and about which we have the most to say in this brief history. Before doing that, however, we briefly discuss the optimal control thread.\nThe term \\A1\\B0optimal control\\A1\\B1 came into use in the late 1950s to describe the problem of designing a controller to minimize a measure of a dynamical system\\A1\\AFs behavior over time. One of the approaches to this problem was developed in the mid-1950s by Richard Bellman and others through extending a nineteenth century theory of Hamilton and Jacobi. This approach uses the concepts of a dynamical system\\A1\\AFs state and of a value function, or \\A1\\B0optimal return function,\\A1\\B1 to define a functional equation, now often called the Bellman equation. The class of methods for solving optimal control problems by solving this equation came to be known as dynamic programming (Bellman, 1957a). Bellman (1957b) also introduced the discrete stochastic version of the optimal control problem known as Markovian decision processes (MDPs), and Ronald Howard (1960) devised the policy iteration method for MDPs. All of these are essential elements underlying the theory and algorithms of modern reinforcement learning.\nDynamic programming is widely considered the only feasible way of solving general stochastic optimal control problems. It suffers from what Bellman called \\A1\\B0the curse of dimensionality,\\A1\\B1 meaning that its computational requirements grow exponentially with the number of state variables, but it is still far more efficient and more widely applicable than any other general method. Dynamic programming has been exten\u0026shy;sively developed since the late 1950s, including extensions to partially observable MDPs (surveyed by Lovejoy, 1991), many applications (surveyed by White, 1985, 1988, 1993), approximation methods (surveyed by Rust, 1996), and asynchronous methods (Bertsekas, 1982, 1983). Many excellent modern treatments of dynamic programming are available (e.g., Bertsekas, 2005, 2012; Puterman, 1994; Ross, 1983; and Whittle, 1982, 1983). Bryson (1996) provides an authoritative history of optimal control.\nIn this book, we consider all of the work in optimal control also to be, in a sense, work in reinforcement learning. We define a reinforcement learning method as any ef\u0026shy;fective way of solving reinforcement learning problems, and it is now clear that these problems are closely related to optimal control problems, particularly stochastic op\u0026shy;timal control problems such as those formulated as MDPs. Accordingly, we must consider the solution methods of optimal control, such as dynamic programming, also to be reinforcement learning methods. Because almost all of the conventional methods require complete knowledge of the system to be controlled, it feels a little unnatural to say that they are part of reinforcement learning. On the other hand, many dynamic programming algorithms are incremental and iterative. Like learning methods, they gradually reach the correct answer through successive approximations. As we show in the rest of this book, these similarities are far more than superficial. The theories and solution methods for the cases of complete and incomplete knowl\u0026shy;edge are so closely related that we feel they must be considered together as part of the same subject matter.\nLet us return now to the other major thread leading to the modern field of rein\u0026shy;forcement learning, that centered on the idea of trial-and-error learning. We only touch on the major points of contact here, taking up this topic in more detail in Chapter 14. According to American psychologist R. S. Woodworth the idea of trial- and-error learning goes as far back as the 1850s to Alexander Bain\\A1\\AFs discussion of learning by \\A1\\B0groping and experiment\\A1\\B1 and more explicitly to the British ethologist and psychologist Conway Lloyd Morgan\\A1\\AFs 1894 use of the term to describe his ob\u0026shy;servations of animal behavior (Woodworth, 1938). Perhaps the first to succinctly express the essence of trial-and-error learning as a principle of learning was Edward\nThorndike:\nOf several responses made to the same situation, those which are accom\u0026shy;panied or closely followed by satisfaction to the animal will, other things being equal, be more firmly connected with the situation, so that, when it recurs, they will be more likely to recur; those which are accompanied or closely followed by discomfort to the animal will, other things being equal, have their connections with that situation weakened, so that, when it recurs, they will be less likely to occur. The greater the satisfaction or discomfort, the greater the strengthening or weakening of the bond. (Thorndike, 1911, p. 244)\nThorndike called this the \\A1\\B0Law of Effect\\A1\\B1 because it describes the effect of reinforcing events on the tendency to select actions. Thorndike later modified the law to better account for accumulating data on animal learning (such as differences between the effects of reward and punishment), and the law in its various forms has generated con\u0026shy;siderable controversy among learning theorists (e.g., see Gallistel, 2005; Herrnstein, 1970; Kimble, 1961, 1967; Mazur, 1994). Despite this, the Law of Effect\\A1\\AAin one form or another\\A1\\AAis widely regarded as a basic principle underlying much behavior (e.g., Hilgard and Bower, 1975; Dennett, 1978; Campbell, 1960; Cziko, 1995). It is the basis of the influential learning theories of Clark Hull and experimental methods of B. F. Skinner (e.g., Hull, 1943; Skinner, 1938).\nThe term \\A1\\B0reinforcement\\A1\\B1 in the context of animal learning came into use well after Thorndike\\A1\\AFs expression of the Law of Effect, to the best of our knowledge first appearing in this context in the 1927 English translation of Pavlov\\A1\\AFs monograph on conditioned reflexes. Reinforcement is the strengthening of a pattern of behavior as a result of an animal receiving a stimulus\\A1\\AAa reinforcer\\A1\\AAin an appropriate temporal relationship with another stimulus or with a response. Some psychologists extended its meaning to include the process of weakening in addition to strengthening, as well applying when the omission or termination of an event changes behavior. Reinforce\u0026shy;ment produces changes in behavior that persist after the reinforcer is withdrawn, so that a stimulus that attracts an animal\\A1\\AFs attention or that energizes its behavior without producing lasting changes is not considered to be a reinforcer.\nThe idea of implementing trial-and-error learning in a computer appeared among the earliest thoughts about the possibility of artificial intelligence. In a 1948 report, Alan Turing described a design for a \\A1\\B0pleasure-pain system\\A1\\B1 that worked along the lines of the Law of Effect:\nWhen a configuration is reached for which the action is undetermined, a random choice for the missing data is made and the appropriate entry is made in the description, tentatively, and is applied. When a pain stimulus occurs all tentative entries are cancelled, and when a pleasure stimulus occurs they are all made permanent. (Turing, 1948)\nMany ingenious electro-mechanical machines were constructed that demonstrated trial-and-error learning. The earliest may have been a machine built by Thomas\nRoss (1933) that was able to find its way through a simple maze and remember the path through the settings of switches. In 1951 W. Grey Walter, already known for his \\A1\\B0mechanical tortoise\\A1\\B1 (Walter, 1950), built a version capable of a simple form of learning (Walter, 1951). In 1952 Claude Shannon demonstrated a maze-running mouse named Theseus that used trial and error to find its way through a maze, with the maze itself remembering the successful directions via magnets and relays under its floor (Shannon, 1951, 1952). J. A. Deutsch (1954) described a maze-solving machine based on his behavior theory (Deutsch, 1953) that has some properties in common with model-based reinforcement learning (Chapter 8). In his Ph.D. dis\u0026shy;sertation (Minsky, 1954), Marvin Minsky discussed computational models of rein\u0026shy;forcement learning and described his construction of an analog machine composed of components he called SNARCs (Stochastic Neural-Analog Reinforcement Calcu\u0026shy;lators) meant to resemble modifiable synaptic connections in the brain (Chapter 15) The fascinating web site cyberneticzoo.com contains a wealth of information on these and many other electro-mechanical learning machines.\nBuilding electro-mechanical learning machines gave way to programming digital computers to perform various types of learning, some of which implemented trial- and-error learning. Farley and Clark (1954) described a digital simulation of a neural- network learning machine that learned by trial and error. But their interests soon shifted from trial-and-error learning to generalization and pattern recognition, that is, from reinforcement learning to supervised learning (Clark and Farley, 1955). This began a pattern of confusion about the relationship between these types of learn\u0026shy;ing. Many researchers seemed to believe that they were studying reinforcement learning when they were actually studying supervised learning. For example, neu\u0026shy;ral network pioneers such as Rosenblatt (1962) and Widrow and Hoff (1960) were clearly motivated by reinforcement learning\\A1\\AAthey used the language of rewards and punishments\\A1\\AAbut the systems they studied were supervised learning systems suit\u0026shy;able for pattern recognition and perceptual learning. Even today, some researchers and textbooks minimize or blur the distinction between these types of learning. For example, some neural-network textbooks have used the term \\A1\\B0trial-and-error\\A1\\B1 to describe networks that learn from training examples. This is an understandable con\u0026shy;fusion because these networks use error information to update connection weights, but this misses the essential character of trial-and-error learning as selecting actions on the basis of evaluative feedback that does not rely on knowledge of what the correct action should be.\nPartly as a result of these confusions, research into genuine trial-and-error learn\u0026shy;ing became rare in the the 1960s and 1970s, although there were notable exceptions. In the 1960s the terms \\A1\\B0reinforcement\\A1\\B1 and \\A1\\B0reinforcement learning\\A1\\B1 were used in the engineering literature for the first time to describe engineering uses of trial- and-error learning (e.g., Waltz and Fu, 1965; Mendel, 1966; Fu, 1970; Mendel and McClaren, 1970). Particularly influential was Minsky\\A1\\AFs paper \\A1\\B0Steps Toward Arti\u0026shy;ficial Intelligence\\A1\\B1 (Minsky, 1961), which discussed several issues relevant to trial- and-error learning, including prediction, expectation, and what he called the basic credit-assignment problem for complex reinforcement learning systems: How do you distribute credit for success among the many decisions that may have been involved in producing it? All of the methods we discuss in this book are, in a sense, directed toward solving this problem. Minsky\\A1\\AFs paper is well worth reading today.\nIn the next few paragraphs we discuss some of the other exceptions and partial exceptions to the relative neglect of computational and theoretical study of genuine trial-and-error learning in the 1960s and 1970s.\nOne of these was the work by a New Zealand researcher named John Andreae. Andreae (1963) developed a system called STeLLA that learned by trial and error in interaction with its environment. This system included an internal model of the world and, later, an \\A1\\B0internal monologue\\A1\\B1 to deal with problems of hidden state (Andreae, 1969a). Andreae\\A1\\AFs later work (1977) placed more emphasis on learning from a teacher, but still included trial and error. Unfortunately, his pioneering research was not well known, and did not greatly impact subsequent reinforcement learning research.\nMore influential was the work of Donald Michie. In 1961 and 1963 he described a simple trial-and-error learning system for learning how to play tic-tac-toe (or naughts and crosses) called MENACE (for Matchbox Educable Naughts and Crosses Engine). It consisted of a matchbox for each possible game position, each matchbox containing a number of colored beads, a different color for each possible move from that position. By drawing a bead at random from the matchbox corresponding to the current game position, one could determine MENACE\\A1\\AFs move. When a game was over, beads were added to or removed from the boxes used during play to reinforce or punish MENACE\\A1\\AFs decisions. Michie and Chambers (1968) described another tic-tac-toe reinforcement learner called GLEE (Game Learning Expectimaxing Engine) and a reinforcement learning controller called BOXES. They applied BOXES to the task of learning to balance a pole hinged to a movable cart on the basis of a failure signal occurring only when the pole fell or the cart reached the end of a track. This task was adapted from the earlier work of Widrow and Smith (1964), who used supervised learning methods, assuming instruction from a teacher already able to balance the pole. Michie and Chambers\\A1\\AFs version of pole-balancing is one of the best early examples of a reinforcement learning task under conditions of incomplete knowledge. It influenced much later work in reinforcement learning, beginning with some of our own studies (Barto, Sutton, and Anderson, 1983; Sutton, 1984). Michie consistently emphasized the role of trial and error and learning as essential aspects of artificial intelligence (Michie, 1974).\nWidrow, Gupta, and Maitra (1973) modified the Least-Mean-Square (LMS) al\u0026shy;gorithm of Widrow and Hoff (1960) to produce a reinforcement learning rule that could learn from success and failure signals instead of from training examples. They called this form of learning \\A1\\B0selective bootstrap adaptation\\A1\\B1 and described it as \\A1\\B0learning with a critic\\A1\\B1 instead of \\A1\\B0learning with a teacher.\\A1\\B1 They analyzed this rule and showed how it could learn to play blackjack. This was an isolated foray into reinforcement learning by Widrow, whose contributions to supervised learning were much more influential. Our use of the term \\A1\\B0critic\\A1\\B1 is derived from Widrow, Gupta, and Maitra\\A1\\AFs paper. Buchanan, Mitchell, Smith, and Johnson (1978) inde\u0026shy;pendently used the term critic in the context of machine learning (see also Dietterich and Buchanan, 1984), but for them a critic is an expert system able to do more than evaluate performance.\nResearch on learning automata had a more direct influence on the trial-and-error thread leading to modern reinforcement learning research. These are methods for solving a nonassociative, purely selectional learning problem known as the k-armed bandit by analogy to a slot machine, or \\A1\\B0one-armed bandit,\\A1\\B1 except with k levers (see Chapter 2). Learning automata are simple, low-memory machines for improving the probability of reward in these problems. Learning automata originated with work in the 1960s of the Russian mathematician and physicist M. L. Tsetlin and colleagues (published posthumously in Tsetlin, 1973) and has been extensively developed since then within engineering (see Narendra and Thathachar, 1974, 1989). These devel\u0026shy;opments included the study of stochastic learning automata, which are methods for updating action probabilities on the basis of reward signals. Stochastic learning au\u0026shy;tomata were foreshadowed by earlier work in psychology, beginning with William Estes\\A1\\AF 1950 effort toward a statistical theory of learning (Estes, 1950) and further developed by others, most famously by psychologist Robert Bush and statistician Frederick Mosteller (Bush and Mosteller, 1955).\nThe statistical learning theories developed in psychology were adopted by re\u0026shy;searchers in economics, leading to a thread of research in that field devoted to reinforcement learning. This work began in 1973 with the application of Bush and Mosteller\\A1\\AFs learning theory to a collection of classical economic models (Cross, 1973). One goal of this research was to study artificial agents that act more like real peo\u0026shy;ple than do traditional idealized economic agents (Arthur, 1991). This approach expanded to the study of reinforcement learning in the context of game theory. Although reinforcement learning in economics developed largely independently of the early work in artificial intelligence, reinforcement learning and game theory is a topic of current interest in both fields, but one that is beyond the scope of this book. Camerer (2003) discusses the reinforcement learning tradition in economics, and Nowe et al. (2012) provide an overview of the subject from the point of view of multi-agent extensions to the approach that we introduce in this book. Rein\u0026shy;forcement learning and game theory is a much different subject from reinforcement learning used in programs to play tic-tac-toe, checkers, and other recreational games. See, for example, Szita (2012) for an overview of this aspect of reinforcement learning and games.\nJohn Holland (1975) outlined a general theory of adaptive systems based on selec\u0026shy;tional principles. His early work concerned trial and error primarily in its nonasso\u0026shy;ciative form, as in evolutionary methods and the k-armed bandit. In 1976 and more fully in 1986, he introduced classifier systems, true reinforcement learning systems including association and value functions. A key component of Holland\\A1\\AFs classifier systems was always a genetic algorithm, an evolutionary method whose role was to evolve useful representations. Classifier systems have been extensively developed by many researchers to form a major branch of reinforcement learning research (re\u0026shy;viewed by Urbanowicz and Moore, 2009), but genetic algorithms\\A1\\AAwhich we do not consider to be reinforcement learning systems by themselvesһhave received much more attention, as have other approaches to evolutionary computation (e.g., Fogel, Owens and Walsh, 1966, and Koza, 1992).\nThe individual most responsible for reviving the trial-and-error thread to rein\u0026shy;forcement learning within artificial intelligence was Harry Klopf (1972, 1975, 1982). Klopf recognized that essential aspects of adaptive behavior were being lost as learn\u0026shy;ing researchers came to focus almost exclusively on supervised learning. What was missing, according to Klopf, were the hedonic aspects of behavior, the drive to achieve some result from the environment, to control the environment toward desired ends and away from undesired ends. This is the essential idea of trial-and-error learning. Klopf\\A1\\AFs ideas were especially influential on the authors because our assessment of them (Barto and Sutton, 1981a) led to our appreciation of the distinction between supervised and reinforcement learning, and to our eventual focus on reinforcement learning. Much of the early work that we and colleagues accomplished was directed toward showing that reinforcement learning and supervised learning were indeed different (Barto, Sutton, and Brouwer, 1981; Barto and Sutton, 1981b; Barto and Anandan, 1985). Other studies showed how reinforcement learning could address important problems in neural network learning, in particular, how it could produce learning algorithms for multilayer networks (Barto, Anderson, and Sutton, 1982; Barto and Anderson, 1985; Barto and Anandan, 1985; Barto, 1985, 1986; Barto and Jordan, 1987). We say more about reinforcement learning and neural networks in Chapter 15.\nWe turn now to the third thread to the history of reinforcement learning, that concerning temporal-difference learning. Temporal-difference learning methods are distinctive in being driven by the difference between temporally successive estimates of the same quantityһfor example, of the probability of winning in the tic-tac-toe example. This thread is smaller and less distinct than the other two, but it has played a particularly important role in the field, in part because temporal-difference methods seem to be new and unique to reinforcement learning.\nThe origins of temporal-difference learning are in part in animal learning psychol\u0026shy;ogy, in particular, in the notion of secondary reinforcers. A secondary reinforcer is a stimulus that has been paired with a primary reinforcer such as food or pain and, as a result, has come to take on similar reinforcing properties. Minsky (1954) may have been the first to realize that this psychological principle could be important for artificial learning systems. Arthur Samuel (1959) was the first to propose and implement a learning method that included temporal-difference ideas, as part of his celebrated checkers-playing program.\nSamuel made no reference to Minsky\\A1\\AFs work or to possible connections to animal learning. His inspiration apparently came from Claude Shannon\\A1\\AFs (1950) suggestion that a computer could be programmed to use an evaluation function to play chess, and that it might be able to improve its play by modifying this function on-line. (It is possible that these ideas of Shannon\\A1\\AFs also influenced Bellman, but we know of no evidence for this.) Minsky (1961) extensively discussed Samuel\\A1\\AFs work in his \\A1\\B0Steps\\A1\\B1 paper, suggesting the connection to secondary reinforcement theories, both natural\nand artificial.\nAs we have discussed, in the decade following the work of Minsky and Samuel, little computational work was done on trial-and-error learning, and apparently no computational work at all was done on temporal-difference learning. In 1972, Klopf brought trial-and-error learning together with an important component of temporal-difference learning. Klopf was interested in principles that would scale to learning in large systems, and thus was intrigued by notions of local reinforcement, whereby subcomponents of an overall learning system could reinforce one another. He developed the idea of \\A1\\B0generalized reinforcement,\\A1\\B1 whereby every component (nominally, every neuron) views all of its inputs in reinforcement terms: excitatory inputs as rewards and inhibitory inputs as punishments. This is not the same idea as what we now know as temporal-difference learning, and in retrospect it is farther from it than was Samuel\\A1\\AFs work. On the other hand, Klopf linked the idea with trial-and-error learning and related it to the massive empirical database of animal learning psychology.\nSutton (1978a, 1978b, 1978c) developed Klopf\\A1\\AFs ideas further, particularly the links to animal learning theories, describing learning rules driven by changes in tem\u0026shy;porally successive predictions. He and Barto refined these ideas and developed a psychological model of classical conditioning based on temporal-difference learning (Sutton and Barto, 1981a; Barto and Sutton, 1982). There followed several other in\u0026shy;fluential psychological models of classical conditioning based on temporal-difference learning (e.g., Klopf, 1988; Moore et al., 1986; Sutton and Barto, 1987, 1990). Some neuroscience models developed at this time are well interpreted in terms of temporal- difference learning (Hawkins and Kandel, 1984; Byrne, Gingrich, and Baxter, 1990; Gelperin, Hopfield, and Tank, 1985; Tesauro, 1986; Friston et al., 1994), although in most cases there was no historical connection.\nOur early work on temporal-difference learning was strongly influenced by animal learning theories and by Klopf\\A1\\AFs work. Relationships to Minsky\\A1\\AFs \\A1\\B0Steps\\A1\\B1 paper and to Samuel\\A1\\AFs checkers players appear to have been recognized only afterward. By 1981, however, we were fully aware of all the prior work mentioned above as part of the temporal-difference and trial-and-error threads. At this time we developed a method for using temporal-difference learning in trial-and-error learning, known as the actor- critic architecture, and applied this method to Michie and Chambers\\A1\\AFs pole-balancing problem (Barto, Sutton, and Anderson, 1983). This method was extensively studied in Sutton\\A1\\AFs (1984) Ph.D. dissertation and extended to use backpropagation neural networks in Anderson\\A1\\AFs (1986) Ph.D. dissertation. Around this time, Holland (1986) incorporated temporal-difference ideas explicitly into his classifier systems. A key step was taken by Sutton in 1988 by separating temporal-difference learning from control, treating it as a general prediction method. That paper also introduced the TD(A) algorithm and proved some of its convergence properties.\nAs we were finalizing our work on the actor-critic architecture in 1981, we discov\u0026shy;ered a paper by Ian Witten (1977) that contains the earliest known publication of a temporal-difference learning rule. He proposed the method that we now call tabular TD(0) for use as part of an adaptive controller for solving MDPs. Witten\\A1\\AFs work was a descendant of Andreae\\A1\\AFs early experiments with STeLLA and other trial-and- error learning systems. Thus, Witten\\A1\\AFs 1977 paper spanned both major threads of reinforcement learning research\\A1\\AAtrial-and-error learning and optimal control\\A1\\AAwhile making a distinct early contribution to temporal-difference learning.\nThe temporal-difference and optimal control threads were fully brought together in 1989 with Chris Watkins\\A1\\AFs development of Q-learning. This work extended and integrated prior work in all three threads of reinforcement learning research. Paul Werbos (1987) contributed to this integration by arguing for the convergence of trial- and-error learning and dynamic programming since 1977. By the time of Watkins\\A1\\AFs work there had been tremendous growth in reinforcement learning research, primarily in the machine learning subfield of artificial intelligence, but also in neural networks and artificial intelligence more broadly. In 1992, the remarkable success of Gerry Tesauro\\A1\\AFs backgammon playing program, TD-Gammon, brought additional attention to the field.\nIn the time since publication of the first edition of this book, a flourishing subfield of neuroscience developed that focuses on the relationship between reinforcement learning algorithms and reinforcement learning in the nervous system. Most respon\u0026shy;sible for this is an uncanny similarity between the behavior of temporal-difference algorithms and the activity of dopamine producing neurons in the brain, as pointed out by a number of researchers (Friston et al., 1994; Barto, 1995a; Houk, Adams, and Barto, 1995; Montague, Dayan, and Sejnowski, 1996; and Schultz, Dayan, and Montague, 1997). Chapter 15 provides an introduction to this exciting aspect of reinforcement learning.\nOther important contributions made in the recent history of reinforcement learning are too numerous to mention in this brief account; we cite many of these at the end of the individual chapters in which they arise.\nBibliographical Remarks\nFor additional general coverage of reinforcement learning, we refer the reader to the books by Szepesvari (2010), Bertsekas and Tsitsiklis (1996), Kaelbling (1993a), and Masashi Sugiyama et al. (2013). Books that take a control or operations research perspective are those of Si et al. (2004), Powell (2011), Lewis and Liu (2012), and Bertsekas (2012). Cao\\A1\\AFs (2009) review places reinforcement learning in the context of other approaches to learning and optimization of stochastic dynamic systems Three special issues of the journal Machine Learning focus on reinforcement learning: Sut\u0026shy;ton (1992), Kaelbling (1996), and Singh (2002). Useful surveys are provided by Barto (1995b); Kaelbling, Littman, and Moore (1996); and Keerthi and Ravindran (1997). The volume edited by Weiring and van Otterlo (2012) provides an excellent overview of recent developments.\nThe example of Phil\\A1\\AFs breakfast in this chapter was inspired by Agre (1988). We direct the reader to Chapter 6for references to the kind of temporal-difference method we used in the tic-tac-toe example.\n \nAs we shall see in Chapter 3, the theory of reinforcement learning as we treat it in this book is based on maximizing the expected value of the amount of reward an agent can accumulate over its future. This is in consistent with the classic principle of von Neumann and Morgenstern (1944) that rational decisions are those that maxi\u0026shy;mize expected utility. However, maximizing the expected value of a random quantity is often not the right thing to do because it ignores the quantity\\A1\\AFs variance, which is said to underly risk. Risk-sensitive optimization has been highly developed in fields where excessive risk can be ruinous, such as in finance and optimal control. Risk is important for reinforcement learning as well but beyond our scope here. Heger (1994), Geibel (2001), Mihatsch and Neuneier (2002), and Borkar (2002) are exam\u0026shy;ples of papers that consider risk in reinforcement learning, developing risk-sensitive versions of some of the algorithms we present here. Coraluppi and Marcus (1999) dis\u0026shy;cuss risk in the context of discrete-time, finite-state Markov decision processes that form the basis of our approach to reinforcement learning. We also wholly sidestep utility theory, which is concerned with measuring people\\A1\\AFs desires. Utility theory would be relevant if we were treating reinforcement learning as a theory of human economic behavior, and some of accounts of reinforcement learning equate reward with utility (e.g., Russell and Norvig, 2010). Since that is not our aim here, however, we leave connections with utility theory to others.\n \nPart I: Tabular Solution Methods\nIn this part of the book we describe almost all the core ideas of reinforcement learning algorithms in their simplest forms: that in which the state and action spaces are small enough for the approximate value functions to be represented as arrays, or tables. In this case, the methods can often find exact solutions, that is, they can often find exactly the optimal value function and the optimal policy. This contrasts with the approximate methods described in the next part of the book, which only find approximate solutions, but which in return can be applied effectively to much larger problems.\nThe first chapter of this part of the book describes solution methods for the special case of the reinforcement learning problem in which there is only a single state, called bandit problems. The second chapter describes the general problem formulation that we treat throughout the rest of the book\\A1\\AAfinite Markov decision processes\\A1\\AAand its main ideas including Bellman equations and value functions.\nThe next three chapters describe three fundamental classes of methods for solving finite Markov decision problems: dynamic programming, Monte Carlo methods, and temporal-difference learning. Each class of methods has its strengths and weaknesses. Dynamic programming methods are well developed mathematically, but require a complete and accurate model of the environment. Monte Carlo methods don\\A1\\AFt re\u0026shy;quire a model and are conceptually simple, but are not well suited for step-by-step incremental computation. Finally, temporal-difference methods require no model and are fully incremental, but are more complex to analyze. The methods also differ in several ways with respect to their efficiency and speed of convergence.\nThe remaining two chapters describe how these three classes of methods can be combined to obtain the best features of each of them. In one chapter we describe how the strengths of Monte Carlo methods can be combined with the strengths of temporal-difference methods via the use of eligibility traces. In the final chapter of this part of the book we show how temporal-difference learning methods can be com\u0026shy;bined with model learning and planning methods (such as dynamic programming) for a complete and unified solution to the tabular reinforcement learning problem.\n \n26\n \nChapter 2\nMulti-armed Bandits\nThe most important feature distinguishing reinforcement learning from other types of learning is that it uses training information that evaluates the actions taken rather than instructs by giving correct actions. This is what creates the need for active ex\u0026shy;ploration, for an explicit trial-and-error search for good behavior. Purely evaluative feedback indicates how good the action taken is, but not whether it is the best or the worst action possible. Purely instructive feedback, on the other hand, indicates the correct action to take, independently of the action actually taken. This kind of feedback is the basis of supervised learning, which includes large parts of pat\u0026shy;tern classification, artificial neural networks, and system identification. In their pure forms, these two kinds of feedback are quite distinct: evaluative feedback depends entirely on the action taken, whereas instructive feedback is independent of the ac\u0026shy;tion taken. There are also interesting intermediate cases in which evaluation and instruction blend together.\nIn this chapter we study the evaluative aspect of reinforcement learning in a sim\u0026shy;plified setting, one that does not involve learning to act in more than one situation. This nonassociative setting is the one in which most prior work involving evaluative feedback has been done, and it avoids much of the complexity of the full reinforce\u0026shy;ment learning problem. Studying this case will enable us to see most clearly how evaluative feedback differs from, and yet can be combined with, instructive feedback.\nThe particular nonassociative, evaluative feedback problem that we explore is a simple version of the k-armed bandit problem. We use this problem to introduce a number of basic learning methods which we extend in later chapters to apply to the full reinforcement learning problem. At the end of this chapter, we take a step closer to the full reinforcement learning problem by discussing what happens when the bandit problem becomes associative, that is, when actions are taken in more than one situation.\n2.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; A k-armed Bandit Problem\nConsider the following learning problem. You are faced repeatedly with a choice among k different options, or actions. After each choice you receive a numerical reward chosen from a stationary probability distribution that depends on the action you selected. Your objective is to maximize the expected total reward over some time period, for example, over 1000action selections, or time steps.\nThis is the original form of the k-armed bandit problem, so named by analogy to a slot machine, or \\A1\\B0one-armed bandit,\\A1\\B1 except that it has k levers instead of one. Each action selection is like a play of one of the slot machine\\A1\\AFs levers, and the rewards are the payoffs for hitting the jackpot. Through repeated action selections you are to maximize your winnings by concentrating your actions on the best levers. Another analogy is that of a doctor choosing between experimental treatments for a series of seriously ill patients. Each action selection is a treatment selection, and each reward is the survival or well-being of the patient. Today the term \\A1\\B0bandit problem\\A1\\B1 is sometimes used for a generalization of the problem described above, but in this book we use it to refer just to this simple case.\nIn our k-armed bandit problem, each of the k actions has an expected or mean reward given that that action is selected; let us call this the value of that action. We denote the action selected on time step t as At, and the corresponding reward as R. The value then of an arbitrary action a, denoted q^(a), is the expected reward given that a is selected:\nq*(a) == E[R | At = a].\nIf you knew the value of each action, then it would be trivial to solve the k-armed bandit problem: you would always select the action with highest value. We as\u0026shy;sume that you do not know the action values with certainty, although you may have estimates. We denote the estimated value of action a at time t as Qt(a)\\B0\\D1q^(a).\nIf you maintain estimates of the action values, then at any time step there is at least one action whose estimated value is greatest. We call these the greedy actions. When you select one of these actions, we say that you are exploiting your current knowledge of the values of the actions. If instead you select one of the nongreedy actions, then we say you are exploring, because this enables you to improve your estimate of the nongreedy action\\A1\\AFs value. Exploitation is the right thing to do to maximize the expected reward on the one step, but exploration may produce the greater total reward in the long run. For example, suppose a greedy action\\A1\\AFs value is known with certainty, while several other actions are estimated to be nearly as good but with substantial uncertainty. The uncertainty is such that at least one of these other actions probably is actually better than the greedy action, but you don\\A1\\AFt know which one. If you have many time steps ahead on which to make action selections, then it may be better to explore the nongreedy actions and discover which of them are better than the greedy action. Reward is lower in the short run, during exploration, but higher in the long run because after you have discovered the better actions, you can exploit them many times. Because it is not possible both to explore \n \nand to exploit with any single action selection, one often refers to the \\A1\\B0conflict\\A1\\B1 between exploration and exploitation.\nIn any specific case, whether it is better to explore or exploit depends in a com\u0026shy;plex way on the precise values of the estimates, uncertainties, and the number of remaining steps. There are many sophisticated methods for balancing exploration and exploitation for particular mathematical formulations of the k-armed bandit and related problems. However, most of these methods make strong assumptions about stationarity and prior knowledge that are either violated or impossible to verify in applications and in the full reinforcement learning problem that we consider in sub\u0026shy;sequent chapters. The guarantees of optimality or bounded loss for these methods are of little comfort when the assumptions of their theory do not apply.\nIn this book we do not worry about balancing exploration and exploitation in a sophisticated way; we worry only about balancing them at all. In this chapter we present several simple balancing methods for the k-armed bandit problem and show that they work much better than methods that always exploit. The need to balance exploration and exploitation is a distinctive challenge that arises in reinforcement learning; the simplicity of the k-armed bandit problem enables us to show this in a particularly clear form.\n2.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Action-value Methods\nWe begin by looking more closely at some simple methods for estimating the values of actions and for using the estimates to make action selection decisions. Recall that the true value of an action is the mean reward when that action is selected. One natural way to estimate this is by averaging the rewards actually received:\nsum of rewards when a taken prior to tE^-} Ri \\A1\\F6 1A^=a\nnumber of times a taken prior to t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^2i\\A1\\AA \\1A-=a\nwhere 1predicatedenotes the random variable that is 1if predicate is true and 0if it is not. If the denominator is zero, then we instead define Qt(a) as some default value, such as Qi(a) = 0. As the denominator goes to infinity, by the law of large numbers, Qi(a) converges to q*(a). We call this the sample-average method for estimating action values because each estimate is an average of the sample of relevant rewards. Of course this is just one way to estimate action values, and not necessarily the best one. Nevertheless, for now let us stay with this simple estimation method and turn to the question of how the estimates might be used to select actions.\nThe simplest action selection rule is to select the action (or one of the actions) with highest estimated action value, that is, to select at step t one of the greedy actions, A*, for which Qt(A*) = maxaQt(a). This greedy action selection method can be written as\n   (2.2)\n     At == argmax Qt(a),\na\nwhere argmaxa denotes the value of a at which the expression that follows is maxi\u0026shy;mized (with ties broken arbitrarily). Greedy action selection always exploits current knowledge to maximize immediate reward; it spends no time at all sampling appar\u0026shy;ently inferior actions to see if they might really be better. A simple alternative is to behave greedily most of the time, but every once in a while, say with small probabil\u0026shy;ity ^, instead to select randomly from amongst all the actions with equal probability independently of the action-value estimates. We call methods using this near-greedy action selection rule \u0026pound;-greedy methods. An advantage of these methods is that, in the limit as the number of steps increases, every action will be sampled an infinite number of times, thus ensuring that all the Qt(a) converge to \\81\\96(a). This of course implies that the probability of selecting the optimal action converges to greater than 1 \\A1\\AA \u0026pound;, that is, to near certainty. These are just asymptotic guarantees, however, and say little about the practical effectiveness of the methods.\nExercise 2.1 In \u0026pound;-greedy action selection, for the case of two actions and \u0026pound; = 0.5, what is the probability that the greedy action is selected?\nExercise 2.2: Bandit example Consider a multi-armed bandit problem with k = 4 actions, denoted 1, 2, 3, and 4. Consider applying to this problem a bandit algorithm using \u0026pound;-greedy action selection, sample-average action-value estimates, and initial estimates of Qi(a) = 0, Va. Suppose the initial sequence of actions and rewards is Ai = 1, Ri = 1, A2= 2, R2= 1, A3= 2, R3= 2, A4= 2, R4= 2, A5= 3, R5= 0. On some of these time steps the \u0026pound; case may have occurred, causing an action to be selected at random. On which time steps did this definitely occur? On which time steps could this possibly have occurred?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n2.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The 10-armed Testbed\nTo roughly assess the relative effectiveness of the greedy and \u0026pound;-greedy methods, we compared them numerically on a suite of test problems. This was a set of 2000 randomly generated k-armed bandit problems with k = 10. For each bandit problem, such as that shown in Figure 2.1, the action values, q^(a), a = 1,..., 10, were selected according to a normal (Gaussian) distribution with mean 0 and variance 1. Then, when a learning method applied to that problem selected action At at time t, the actual reward Rt was selected from a normal distribution with mean q^(At) and variance 1. It is these distributions which are shown as gray in Figure 2.1. We call this suite of test tasks the 10-armed testbed. For any learning method, we can measure its performance and behavior as it improves with experience over 1000steps interacting with one of the bandit problem. This makes up one run. Repeating this for 2000independent runs with a different bandit problem, we obtained measures of the learning algorithm\\A1\\AFs average behavior.\n   -2\n        -3\n        q*(10)\n        5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 6\n        10\n        Figure 2.1: An exemplary bandit problem from the 10-armed testbed. The true value q\\B1\\BE(a) of each of the ten actions was selected according to a normal distribution around zero with unit variance, and then the actual rewards were selected around q\\B1\\BE(a)with unit variance, as suggested by these gray distributions.\n        1\n        0\n        2\n        3\n        4\n        7\n        8\n        9\n        Reward\ndistribution\n        Action\n     Figure 2.2 compares a greedy method with two ^-greedy methods (s = 0.01 and e = 0.1), as described above, on the 10-armed testbed. Both methods formed their action-value estimates using the sample-average technique. The upper graph shows the increase in expected reward with experience. The greedy method improved slightly faster than the other methods at the very beginning, but then leveled off at a lower level. It achieved a reward per step of only about 1, compared with the best possible of about 1.55 on this testbed. The greedy method performs significantly worse in the long run because it often gets stuck performing suboptimal actions. The lower graph shows that the greedy method found the optimal action in only approximately one-third of the tasks. In the other two-thirds, its initial samples of the optimal action were disappointing, and it never returned to it. The e-greedy methods eventually perform better because they continue to explore and to improve their chances of recognizing the optimal action. The e = 0.1 method explores more, and usually finds the optimal action earlier, but never selects it more than 91% of the time. The e = 0.01 method improves more slowly, but eventually would perform better than the e = 0.1 method on both performance measures. It is also possible to reduce e over time to try to get the best of both high and low values.\nThe advantage of e-greedy over greedy methods depends on the task. For example, suppose the reward variance had been larger, say 10 instead of 1. With noisier\n \nr = 0.01\n \n\u0026nbsp;\n \n   \\A3\\BA0 (greedy)\n     Average\n\\A1\\B86wa\\A1\\B8d\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n \n0\n \n   500\nSteps\n        Steps\n        250\n        1000\n        750\n        Figure 2.2: Average performance of e-greedy action-value methods on the 10-armed testbed. These data are averages over 2000 runs with different bandit problem. All methods used sample averages as their action-value estimates.\n        % Optimal\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n rewards it takes more exploration to find the optimal action, and e-greedy methods should fare even better relative to the greedy method. On the other hand, if the reward variances were zero, then the greedy method would know the true value of each action after trying it once. In this case the greedy method might actually perform best because it would soon find the optimal action and then never explore. But even in the deterministic case, there is a large advantage to exploring if we weaken some of the other assumptions. For example, suppose the bandit task were nonstationary, that is, that the true values of the actions changed over time. In this case exploration is needed even in the deterministic case to make sure one of the nongreedy actions has not changed to become better than the greedy one. As we will see in the next few chapters, effective nonstationarity is the case most commonly encountered in reinforcement learning. Even if the underlying task is stationary and deterministic, the learner faces a set of banditlike decision tasks each of which changes over time as learning proceeds and the agent\\A1\\AFs policy changes. Reinforcement learning requires a balance between exploration and exploitation.\nExercise 2.3 In the comparison shown in Figure 2.2, which method will perform best in the long run in terms of cumulative reward and cumulative probability of selecting the best action? How much better will it be? Express your answer quantitatively. \\A1\\F5\n \n2.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Incremental Implementation\nThe action-value methods we have discussed so far all estimate action values as sample averages of observed rewards. We now turn to the question of how these averages can be computed in a computationally efficient manner, in particular, with constant memory and per-time-step computation.\nTo simplify notation we concentrate on a single action. Let Ri now denote the reward received after the ith selection of this action, and let Qn denote the estimate of its action value after it has been selected n \\A1\\AA 1times, which we can now write simply as\nRi+ R2+ ... + Rn\\A1\\AA 1\nQn\nn\\A1\\AA1\nThe obvious implementation would be to maintain a record of all the rewards and then perform this computation whenever the estimated value was needed. However, in this case the memory and computational requirements would grow over time as more rewards are seen. Each additional reward would require more memory to store it and more computation to compute the sum in the numerator.\nAs you might suspect, this is not really necessary. It is easy to devise incremental formulas for updating averages with small, constant computation required to process each new reward. Given Qn and the nth reward, Rn, the new average of all n rewards can be computed by\n \n   1\n        n\n        Qn+1\n        Ri\n     \u0026nbsp;\n    1\n     ni\n \n\u0026nbsp;\n \nn\n \n   n-1\u0026nbsp;\u0026nbsp; \\A1\\A2\nRi\n        1\n        \\A1\\AA Rn+ (n \\A1\\AA 1)һ\nnn\n        1\n     \u0026nbsp;\n \n   (2.3)\n        1\n        n 1\nn\nQn +--- \nn\n        + (n \\A1\\AA 1)Qnj\n+ nQn\\A1\\AA Qn\n        Rn\\A1\\AA Qn\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n which holds even for n = 1, obtaining Q2= Ri for arbitrary Qi. This implementa\u0026shy;tion requires memory only for Qn and n, and only the small computation (2.3) for each new reward. Pseudocode for a complete bandit algorithm using incrementally computed sample averages and \u0026pound;-greedy action selection is shown in the box. The function bandit(a) is assumed to take an action and return a corresponding reward.\n   (2.4)\n     The update rule (2.3) is of a form that occurs frequently throughout this book. The general form is\nNewEstimate OldEstimate+ StepSize Target\\A1\\AA OldEstimate\nA simple bandit algorithm\nInitialize, for a = 1to k:\nQ(a) ^ 0 N(a) ^ 0\nRepeat forever:\narg maxa Q(a) with probability 1 \\A1\\AA e (breaking ties randomly) a random action with probability e\nR ^bandit (A)\nN(A) ^ N(A)ʮ1\nQ(A) ^ Q(A)ʮnA) [r \\A1\\AA Q(A)]\nThe expression [Target \\A1\\AA OldEstimat^ is an error in the estimate. It is reduced by taking a step toward the \\A1\\B0Target.\\A1\\B1 The target is presumed to indicate a desirable direction in which to move, though it may be noisy. In the case above, for example, the target is the nth reward.\nNote that the step-size parameter (StepSize) used in the incremental method described above changes from time step to time step. In processing the nth reward for action a, that method uses a step-size parameter of n. In this book we denote the step-size parameter by the symbol a or, more generally, by at (a). We sometimes use the informal shorthand a = n to refer to this case, leaving the dependence of n on the action implicit, just as we have in this section.\n2.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Tracking a Nonstationary Problem\nThe averaging methods discussed so far are appropriate in a stationary environment, but not if the bandit is changing over time. As noted earlier, we often encounter reinforcement learning problems that are effectively nonstationary. In such cases it makes sense to weight recent rewards more heavily than long-past ones. One of the most popular ways of doing this is to use a constant step-size parameter. For example, the incremental update rule (2.3) for updating an average Qn of the n \\A1\\AA 1 past rewards is modified to be\nQn+1= Qn ʮa Rn\\A1\\AA Qn ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (2.5)\nwhere the step-size parameter a E (0,1][1]is constant. This results in Qn+ i being a weighted average of past rewards and the initial estimate Q :\nQn+ 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; =\u0026nbsp;\u0026nbsp;\u0026nbsp; Qn + a Rn \\A1\\AA Qn\n=aRn+ (1\\A1\\AA a)Qn\n=aRn+ (1\\A1\\AA a)[aRn- 1+ (1\\A1\\AA a)Qn- 1]\n=aRn\u0026nbsp;\u0026nbsp;\u0026nbsp; +(1\\A1\\AA a)aRn- 1+ (1 \\A1\\AA a)[2]Qn- 1\n=aRn\u0026nbsp;\u0026nbsp;\u0026nbsp; +(1\\A1\\AA a)aRn- 1+ (1\\A1\\AA a)2aRn-2+\n\u0026#8226;\u0026#8226;\u0026#8226; + (1\\A1\\AA a)n-1aR1+ (1\\A1\\AA a)nQ1\nn\n=(1\\A1\\AA a)nQ1+ J] a(1\\A1\\AA a)n-iRi.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (2.6)\ni=1\nWe call this a weighted average because the sum of the weights is (1\\A1\\AAa)n+En=1a(1 \\A1\\AA a)n-i = 1, as you can check for yourself. Note that the weight, a(1 \\A1\\AA a)n-i, given to the reward Ri depends on how many rewards ago, n \\A1\\AA i, it was observed. The quantity 1\\A1\\AAa is less than 1, and thus the weight given to Ri decreases as the number of intervening rewards increases. In fact, the weight decays exponentially according to the exponent\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; on 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\AA\u0026nbsp;\u0026nbsp;\u0026nbsp; a.\u0026nbsp;\u0026nbsp;\u0026nbsp; (If 1 \\A1\\AA a = 0, then all the weight\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; goesonthe\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; very last\nreward,\u0026nbsp;\u0026nbsp; Rn,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; because of\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; the convention that 00= 1.) Accordingly,\u0026nbsp;\u0026nbsp; this\u0026nbsp; is\u0026nbsp;\u0026nbsp;\u0026nbsp; sometimes\ncalled an exponential, recency-weighted average.\nSometimes it is convenient to vary the step-size parameter from step to step. Let an (a) denote the step-size parameter used to process the reward received after the nth selection of action a. As we have noted, the choice an (a) = n1 results in the sample-average method, which is guaranteed to converge to the true action values by the law of large numbers. But of course convergence is not guaranteed for all choices of the sequence {an(a)}. A well-known result in stochastic approximation theory gives us the conditions required to assure convergence with probability 1:\nan(a) = oo and\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^ an (a) \u0026lt; \\A2\\C6.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (2.7)\nn=1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n=1\nThe first condition is required to guarantee that the steps are large enough to even\u0026shy;tually overcome any initial conditions or random fluctuations. The second condition guarantees that eventually the steps become small enough to assure convergence.\nNote that both convergence conditions are met for the sample-average case, an (a)= \\A1\\F8, but not for the case of constant step-size parameter, an (a) = a. In the latter case, the second condition is not met, indicating that the estimates never completely con\u0026shy;verge but continue to vary in response to the most recently received rewards. As we mentioned above, this is actually desirable in a nonstationary environment, and problems that are effectively nonstationary are the norm in reinforcement learn\u0026shy;ing. In addition, sequences of step-size parameters that meet the conditions (2.7) often converge very slowly or need considerable tuning in order to obtain a satisfac\u0026shy;tory convergence rate. Although sequences of step-size parameters that meet these convergence conditions are often used in theoretical work, they are seldom used in applications and empirical research.\nExercise 2.4 If the step-size parameters, an, are not constant, then the estimate Qn is a weighted average of previously received rewards with a weighting different from that given by (2.6). What is the weighting on each prior reward for the general case, analogous to (2.6), in terms of the sequence of step-size parameters?\\A1\\F5\nExercise 2.5 (programming) Design and conduct an experiment to demonstrate the difficulties that sample-average methods have for nonstationary problems. Use a modified version of the 10-armed testbed in which all the q^(a) start out equal and then take independent random walks (say by adding a normally distributed increment with mean zero and standard deviation 0.01 to all the q^(a) on each step). Prepare plots like Figure 2.2 for an action-value method using sample averages, incrementally computed, and another action-value method using a constant step-size parameter, a = 0.1. Use \u0026pound; = 0.1 and longer runs, say of 10,000 steps.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n2.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimistic Initial Values\nAll the methods we have discussed so far are dependent to some extent on the initial action-value estimates, Qi(a). In the language of statistics, these methods are biased by their initial estimates. For the sample-average methods, the bias disappears once all actions have been selected at least once, but for methods with constant a, the bias is permanent, though decreasing over time as given by (2.6). In practice, this kind of bias is usually not a problem and can sometimes be very helpful. The downside is that the initial estimates become, in effect, a set of parameters that must be picked by the user, if only to set them all to zero. The upside is that they provide an easy way to supply some prior knowledge about what level of rewards can be expected.\nInitial action values can also be used as a simple way of encouraging exploration. Suppose that instead of setting the initial action values to zero, as we did in the 10-armed testbed, we set them all to +5. Recall that the q^(a) in this problem are selected from a normal distribution with mean 0and variance 1. An initial estimate of +5 is thus wildly optimistic. But this optimism encourages action-value methods to explore. Whichever actions are initially selected, the reward is less than the starting estimates; the learner switches to other actions, being \\A1\\B0disappointed\\A1\\B1 with the rewards it is receiving. The result is that all actions are tried several times before the value estimates converge. The system does a fair amount of exploration even if greedy actions are selected all the time.\nFigure 2.3 shows the performance on the 10-armed bandit testbed of a greedy method using Qi(a) = +5, for all a. For comparison, also shown is an \u0026pound;-greedy method with Qi(a) = 0. Initially, the optimistic method performs worse because it explores more, but eventually it performs better because its exploration decreases with time. We call this technique for encouraging exploration optimistic initial val-\n \n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n %\nOptimal\naction\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Steps\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 2.3: The effect of optimistic initial action-value estimates on the 10-armed testbed. Both methods used a constant step-size parameter, a = 0.1.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nues. We regard it as a simple trick that can be quite effective on stationary problems, but it is far from being a generally useful approach to encouraging exploration. For example, it is not well suited to nonstationary problems because its drive for ex\u0026shy;ploration is inherently temporary. If the task changes, creating a renewed need for exploration, this method cannot help. Indeed, any method that focuses on the initial state in any special way is unlikely to help with the general nonstationary case. The beginning of time occurs only once, and thus we should not focus on it too much. This criticism applies as well to the sample-average methods, which also treat the beginning of time as a special event, averaging all subsequent rewards with equal weights. Nevertheless, all of these methods are very simple, and one of them or some simple combination of them is often adequate in practice. In the rest of this book we make frequent use of several of these simple exploration techniques.\nExercise 2.6: Mysterious Spikes The results shown in Figure 2.3 should be quite reliable because they are averages over 2000individual, randomly chosen 10-armed bandit tasks. Why, then, are there oscillations and spikes in the early part of the curve for the optimistic method? In other words, what might make this method perform particularly better or worse, on average, on particular early steps?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n2.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Upper-Confidence-Bound Action Selection\nExploration is needed because the estimates of the action values are uncertain. The greedy actions are those that look best at present, but some of the other actions may actually be better. e-greedy action selection forces the non-greedy actions to be tried, but indiscriminately, with no preference for those that are nearly greedy or particularly uncertain. It would be better to select among the non-greedy actions according to their potential for actually being optimal, taking into account both how close their estimates are to being maximal and the uncertainties in those estimates.\nOne effective way of doing this is to select actions as\n   Ilog t Nt(a)\n        (2.8)\n     Qt(a) + c\nAt == argmax\na\nwhere log t denotes the natural logarithm of t (the number that e ^ 2.71828 would have to be raised to in order to equal t), Nt(a) denotes the number of times that action a has been selected prior to time t (the denominator in (2.1)), and the number c \u0026gt; 0 controls the degree of exploration. If Nt(a) = 0, then a is considered to be a maximizing action.\nThe idea of this upper confidence bound (UCB) action selection is that the square- root term is a measure of the uncertainty or variance in the estimate of a\\A1\\AFs value. The quantity being max\\A1\\AFed over is thus a sort of upper bound on the possible true value of action a, with the c parameter determining the confidence level. Each time a is selected the uncertainty is presumably reduced; Nt(a) is incremented and, as it appears in the denominator of the uncertainty term, the term is decreased. On the other hand, each time an action other than a is selected t is increased but Nt(a) is not; as t appears in the numerator the uncertainty estimate is increased. The use of the natural logarithm means that the increase gets smaller over time, but is unbounded; all actions will eventually be selected, but as time goes by it will be a longer wait, and thus a lower selection frequency, for actions with a lower value estimate or that have already been selected more times.\nResults with UCB on the 10-armed testbed are shown in Figure 2.4. UCB will often perform well, as shown here, but is more difficult than \u0026pound;-greedy to extend beyond bandits to the more general reinforcement learning settings considered in the rest of this book. One difficulty is in dealing with nonstationary problems; something more complex than the methods presented in Section 2.4 would be needed. Another difficulty is dealing with large state spaces, particularly function approximation as\n \nSteps\nFigure 2.4: Average performance of UCB action selection on the 10-armed testbed. As shown, UCB generally performs better than \u0026pound;-greedy action selection, except in the first k steps, when it selects randomly among the as-yet-untried actions.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\ndeveloped in Part II of this book. In these more advanced settings there is currently no known practical way of utilizing the idea of UCB action selection.\n2.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Gradient Bandit Algorithms\nSo far in this chapter we have considered methods that estimate action values and use those estimates to select actions. This is often a good approach, but it is not the only one possible. In this section we consider learning a numerical preference Hi (a) for each action a. The larger the preference, the more often that action is taken, but the preference has no interpretation in terms of reward. Only the relative preference of one action over another is important; if we add 1000to all the preferences there is no effect on the action probabilities, which are determined according to a soft-max distribution (i.e., Gibbs or Boltzmann distribution) as follows:\neHt(a)\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z Pr{Ai = a} =\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; eH\u0026pound;(b) = ni(a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (2.9)\nwhere here we have also introduced a useful new notation ni(a) for the probability of taking action a at time t. Initially all preferences are the same (e.g., H1(a) = 0, Va) so that all actions have an equal probability of being selected.\nExercise 2.7 Show that in the case of two actions, the soft-max distribution is the same as that given by the logistic, or sigmoid, function often used in statistics and artificial neural networks.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nThere is a natural learning algorithm for this setting based on the idea of stochastic gradient ascent. On each step, after selecting the action Ai and receiving the reward Ri, the preferences are updated by:\nHi+1(Ai) = Hi(Ai) + (a(Ri \\A1\\AA ^Ri)(1\\A1\\AA ni(Ai)); and\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (\\A1\\A3\\B9\\A4\\A1\\A3\\A3\\A9\nHi+1(a) = Hi (a) \\A1\\AA a(Ri \\A1\\AA ^i)ni(a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Va = Ai,\nwhere a \u0026gt; 0 is a step-size parameter, and R^ E R is the average of all the rewards up through and including time t, which can be computed incrementally as described in Section 2.3 (or Section 2.4 if the problem is nonstationary). The Ri term serves as a baseline with which the reward is compared. If the reward is higher than the baseline, then the probability of taking Ai in the future is increased, and if the reward is below baseline, then probability is decreased. The non-selected actions move in the opposite direction.\nFigure 2.5 shows results with the gradient bandit algorithm on a variant of the 10-armed testbed in which the true expected rewards were selected according to a normal distribution with a mean of +4 instead of zero (and with unit variance as before). This shifting up of all the rewards has absolutely no effect on the gradient bandit algorithm because of the reward baseline term, which instantaneously adapts to the new level. But if the baseline were omitted (that is, if Ri was taken to be constant zero in (2.10)), then performance would be significantly degraded, as shown in the figure.\n   a= 0.1\n        a= 0.4\n        250\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 500\nSteps\n        750\n        Figure 2.5: Average performance of the gradient bandit algorithm with and without a reward baseline on the 10-armed testbed when the q^(a) are chosen to be near ʮ4 rather than near zero.\n        1\n        1000\n        \u0026nbsp;\n 100%\n  \u0026nbsp;\n 80%\n  %\n 60%\n  Optimal\n \u0026nbsp;\n  action\n 40%\n  \u0026nbsp;\n 20%\n  \u0026nbsp;\n 0%\n    \u0026nbsp;\n     The Bandit Gradient Algorithm as Stochastic Gradient Ascent\nOne can gain a deeper insight into the gradient bandit algorithm by under\u0026shy;standing it as a stochastic approximation to gradient ascent. In exact gradient ascent, each preference Ht(a) would be incrementing proportional to the in\u0026shy;crement\\A1\\AFs effect on performance:\nHt+i(a) ^ Ht(a)ʮadHR,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (2.11)\nwhere the measure of performance here is the expected reward:\nE[Rt] == ^nt(b)q*(b), b\nand the measure of the increment\\A1\\AFs effect is the partial derivative of this per\u0026shy;formance measure with respect to the preference. Of course, it is not possible to implement gradient ascent exactly in our case because by assumption we do not know the q^(b), but in fact the updates of our algorithm (2.10) are equal to (2.11) in expected value, making the algorithm an instance of stochastic gra\u0026shy;dient ascent. The calculations showing this require only beginning calculus, but take several steps. First we take a closer look at the exact performance gradient:\ndE[Rt]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (b) (b)\nmardHt^i ?\\C7\\C9\\E1t\n=?\\B8\\B1\\BF\\97\n=^ (\\B8\\B1-\\BD\\D0m,\nwhere Xt can be any scalar that does not depend on b. We can include it here because the gradient sums to zero over all the actions, Eb \\D2淺)=0.As Ht(a) is changed, some actions\\A1\\AF probabilities go up and some down, but the sum of the changes must be zero because the sum of the probabilities must remain one.\n^ nt(b) (q*(b) \\A1\\AA Xt) IHH/nt(b)\nThe equation is now in the form of an expectation, summing over all possible values b of the random variable At, then multiplying by the probability of taking those values. Thus:\n   E\nE\n     (q*(At) \\A1\\AA Xt) dHt(a) /nt(At)\n(Rt - Rt)\\E8F\\CB\\FD\\A3\\A9\nwhere here we have chosen Xt = Rt and substituted Rt for q^(At), which is permitted because E[Rt|At] = q^(At) and because the Rt (given At) is uncorrelated with anything else. Shortly we will establish that \\C4\\FA\\C9\\CF))= nt(b) (1a=b \\A1\\AA nt(a), where 1a=b is defined to be 1 if a = b, else 0. Assuming that for now, we have\n=E[(Rt \\A1\\AA ^Rt)nt(At)(1a=A\u0026pound; \\A1\\AA 7Tt(a))/nt(At)]\n=E [(Rt \\A1\\AA Rt)(ia=At \\A1\\AAأt\\A2\\C8)]\u0026#8226;\nRecall that our plan has been to write the performance gradient as an expecta\u0026shy;tion of something that we can sample on each step, as we have just done, and then update on each step proportional to the sample. Substituting a sample of the expectation above for the performance gradient in (2.11) yields:\nHt+i(a) = Ht(a) + a(Rt \\A1\\AA Rt) (1a=At \\A1\\AA ^t(a)), Va,\nwhich you will recognize as being equivalent to our original algorithm (2.10).\nThus it remains only to show that \\D2\\E6(0) = nt(b)( 1a=b \\A1\\AA nt(a)), as we assumed. Recall the standard quotient rule for derivatives:\n\n\n\u0026nbsp;SHAPE \u0026nbsp;\\* MERGEFORMAT    \u0026nbsp;\n      \u0026nbsp;\n \n   f(x)g(x)_\n        d_\ndx\n     dfg(x) \\A1\\AA f (x)\\BE\\AF\ng(x)2\nUsing this, we can write\n \n   dni(b)\ndHi(a)\n        d\n        ni(b)\n        dHi(a)\nd [ e\\EAP dHi(a) Vfc_1eHt(c)\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n deHt \\A2\\C8Vk\u0026nbsp;\u0026nbsp; pHt(c) _ eHt(b) d Eh eHt(c)\ndHt(a)\\D2\\D2c=1e\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\AA\u0026nbsp; e ~SHt(a)~\n \n\u0026nbsp;\n \n   2\n        eH t(c)\n     (Ek=1\n \n\u0026nbsp;\n \n(by the quotient rule)\n \n\u0026nbsp;\n \n   (because\n        ex)\n     1a=6e^t(a^ k=1eHt(c)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\AA\u0026nbsp;\u0026nbsp; eHt(b)eHt(a)\n(Ek=1e \\BA\\FBѾ\n1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a=fceHt(b)eHt(b)eHt(a)\n \n\u0026nbsp;\n \n   2\n     Ek=1eHt(c)(^k=1eHt(c)\\A1\\A2\n   Q.E.D.\n     1a=bV(i(6) \\A1\\AA ni(b)ni(a) ni (b)( 1a=b \\A1\\AA W(a)).\n \n\u0026nbsp;\n \nWe have just shown that the expected update of the gradient bandit algo\u0026shy;rithm is equal to the gradient of expected reward, and thus that the algorithm is an instance of stochastic gradient ascent. This assures us that the algorithm has robust convergence properties.\nNote that we did not require any properties of the reward baseline other than that it does not depend on the selected action. For example, we could have set it to zero, or to 1000, and the algorithm would still be an instance of stochastic gradient ascent. The choice of the baseline does not affect the expected update of the algorithm, but it does affect the variance of the update and thus the rate of convergence (as shown, e.g., in Figure 2.5). Choosing it as the average of the rewards may not be the very best, but it is simple and works well in practice.\n2.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Associative Search (Contextual Bandits)\nSo far in this chapter we have considered only nonassociative tasks, in which there is no need to associate different actions with different situations. In these tasks the learner either tries to find a single best action when the task is stationary, or tries to track the best action as it changes over time when the task is nonstationary. However, in a general reinforcement learning task there is more than one situation, and the goal is to learn a policy: a mapping from situations to the actions that are best in those situations. To set the stage for the full problem, we briefly discuss the \n \nsimplest way in which nonassociative tasks extend to the associative setting.\nAs an example, suppose there are several different k-armed bandit tasks, and that on each step you confront one of these chosen at random. Thus, the bandit task changes randomly from step to step. This would appear to you as a single, nonstationary k-armed bandit task whose true action values change randomly from step to step. You could try using one of the methods described in this chapter that can handle nonstationarity, but unless the true action values change slowly, these methods will not work very well. Now suppose, however, that when a bandit task is selected for you, you are given some distinctive clue about its identity (but not its action values). Maybe you are facing an actual slot machine that changes the color of its display as it changes its action values. Now you can learn a policy associating each task, signaled by the color you see, with the best action to take when facing that task\\A1\\AAfor instance, if red, select arm 1; if green, select arm 2. With the right policy you can usually do much better than you could in the absence of any information distinguishing one bandit task from another.\nThis is an example of an associative search task, so called because it involves both trial-and-error learning in the form of search for the best actions and association of these actions with the situations in which they are best.[3]Associative search tasks are intermediate between the k-armed bandit problem and the full reinforcement learning problem. They are like the full reinforcement learning problem in that they involve learning a policy, but like our version of the k-armed bandit problem in that each action affects only the immediate reward. If actions are allowed to affect the next situation as well as the reward, then we have the full reinforcement learning problem. We present this problem in the next chapter and consider its ramifications throughout the rest of the book.\n2.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nWe have presented in this chapter several simple ways of balancing exploration and exploitation. The e-greedy methods choose randomly a small fraction of the time, whereas UCB methods choose deterministically but achieve exploration by subtly favoring at each step the actions that have so far received fewer samples. Gradient bandit algorithms estimate not action values, but action preferences, and favor the more preferred actions in a graded, probabilistic manner using a soft-max distribu\u0026shy;tion. The simple expedient of initializing estimates optimistically causes even greedy methods to explore significantly.\n   Average r6ward over first 1000 steps\n        Figure 2.6: A parameter study of the various bandit algorithms presented in this chapter. Each point is the average reward obtained over 1000steps with a particular algorithm at a particular setting of its parameter.\n        / a / c / Q0\n     It is natural to ask which of these methods is best. Although this is a difficult question to answer in general, we can certainly run them all on the 10-armed testbed that we have used throughout this chapter and compare their performances. A complication is that they all have a parameter; to get a meaningful comparison we will have to consider their performance as a function of their parameter. Our graphs so far have shown the course of learning over time for each algorithm and parametersetting, but it would be too visually confusing to show such a learning curve for each algorithm and parameter value. Instead we summarize a complete learning curve by its average value over the 1000steps; this value is proportional to the area under the learning curves we have shown up to now. Figure 2.6 shows this measure for the various bandit algorithms from this chapter, each as a function of its own parameter shown on a single scale on the x-axis. Note that the parameter values are varied by factors of two and presented on a log scale. Note also the characteristic inverted- U shapes of each algorithm\\A1\\AFs performance; all the algorithms perform best at an intermediate value of their parameter, neither too large nor too small. In assessing a method, we should attend not just to how well it does at its best parameter setting, but also to how sensitive it is to its parameter value. All of these algorithms are fairly insensitive, performing well over a range of parameter values varying by about an order of magnitude. Overall, on this problem, UCB seems to perform best.\nDespite their simplicity, in our opinion the methods presented in this chapter can fairly be considered the state of the art. There are more sophisticated methods, but their complexity and assumptions make them impractical for the full reinforcement learning problem that is our real focus. Starting in Chapter 5 we present learning methods for solving the full reinforcement learning problem that use in part the simple methods explored in this chapter.\nAlthough the simple methods explored in this chapter may be the best we can do at present, they are far from a fully satisfactory solution to the problem of balancing exploration and exploitation.\nThe classical solution to balancing exploration and exploitation in k-armed bandit problems is to compute special functions called Gittins indices. These provide an optimal solution to a certain kind of bandit problem more general than that con\u0026shy;sidered here but that assumes the prior distribution of possible problems is known. Unfortunately, neither the theory nor the computational tractability of this method appear to generalize to the full reinforcement learning problem that we consider in the rest of the book.\nBayesianmethods assume a known initial distribution over the action values and then updates the distribution exactly after each step (assuming that the true action values are stationary). In general, the update computations can be very complex, but for certain special distributions (called conjugate priors) they are easy. One possibility is to then select actions at each step according to their posterior proba\u0026shy;bility of being the best action. This method, sometimes called posterior sampling or Thompson sampling, often performs similarly to the best of the distribution-free methods we have presented in this chapter.\nIn the Bayesian setting it is even conceivable to compute the optimal balance be\u0026shy;tween exploration and exploitation. Clearly, for any possible action we can compute the probability of each possible immediate reward and the resultant posterior distri\u0026shy;butions over action values. This evolving distribution becomes the information state of the problem. Given a horizon, say of 1000 steps, one can consider all possible actions, all possible resulting rewards, all possible next actions, all next rewards, and so on for all 1000 steps. Given the assumptions, the rewards and probabilities of each possible chain of events can be determined, and one need only pick the best. But the tree of possibilities grows extremely rapidly; even if there are only two ac\u0026shy;tions and two rewards, the tree will have 22000leaves. It is generally not feasible to perform this immense computation exactly, but perhaps it could be approximated efficiently. This approach would effectively turn the bandit problem into an instance of the full reinforcement learning problem; it is beyond the current state of the art, but someday it may be possible to use reinforcement learning methods such as those presented in Part II of this book to approximate this optimal solution.\nExercise 2.8 (programming) Make a figure analogous to Figure 2.6 for the non-stationary case outlined in Exercise 2.5. Include the constant-step-size e-greedy algorithm with a = 0.1. Use runs of 200,000 steps and, as a performance measure for each algorithm and parameter setting, use the average reward over the last 100,000 steps.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nBibliographical and Historical Remarks\n2.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Bandit problems have been studied in statistics, engineering, and psychology. In statistics, bandit problems fall under the heading \\A1\\B0sequential design of ex\u0026shy;periments,\\A1\\B1 introduced by Thompson (1933, 1934) and Robbins (1952), and studied by Bellman (1956). Berry and Fristedt (1985) provide an extensive treatment of bandit problems from the perspective of statistics. Narendra and Thathachar (1989) treat bandit problems from the engineering perspec\u0026shy;tive, providing a good discussion of the various theoretical traditions that have focused on them. In psychology, bandit problems have played roles in statistical learning theory (e.g., Bush and Mosteller, 1955; Estes, 1950).\nThe term greedy is often used in the heuristic search literature (e.g., Pearl,\n \n1984). The conflict between exploration and exploitation is known in control engineering as the conflict between identification (or estimation) and control (e.g., Witten, 1976). Feldbaum (1965) called it the dual control problem, referring to the need to solve the two problems of identification and con\u0026shy;trol simultaneously when trying to control a system under uncertainty. In discussing aspects of genetic algorithms, Holland (1975) emphasized the im\u0026shy;portance of this conflict, referring to it as the conflict between the need to exploit and the need for new information.\n   2.2\n2.3-4\n2.5\n2.6\n2.7\n2.8\n     Action-value methods for our k-armed bandit problem were first proposed by Thathachar and Sastry (1985). These are often called estimator algorithms in the learning automata literature. The term action value is due to Watkins (1989). The first to use \u0026pound;-greedy methods may also have been Watkins (1989, p. 187), but the idea is so simple that some earlier use seems likely.\nThis material falls under the general heading of stochastic iterative algo\u0026shy;rithms, which is well covered by Bertsekas and Tsitsiklis (1996).\nOptimistic initialization was used in reinforcement learning by Sutton (1996).\nEarly work on using estimates of the upper confidence bound to select actions was done by Lai and Robbins (1985), Kaelbling (1993b), and Agrawal (1995). The UCB algorithm we present here is called UCB1 in the literature and was first developed by Auer, Cesa-Bianchi and Fischer (2002).\nGradient bandit algorithms are a special case of the gradient-based rein\u0026shy;forcement learning algorithms introduced by Williams (1992), and that later developed into the actor-critic and policy-gradient algorithms that we treat later in this book. Our development here was influenced by that by Balara- man Ravindran. Further discussion of the choice of baseline is provided there and by Greensmith, Bartlett, and Baxter (2001, 2004) and Dick (2015).\nThe term softmax for the action selection rule (2.9) is due to Bridle (1990). This rule appears to have been first proposed by Luce (1959).\nThe term associative search and the corresponding problem were introduced by Barto, Sutton, and Brouwer (1981). The term associative reinforcement learning has also been used for associative search (Barto and Anandan, 1985), but we prefer to reserve that term as a synonym for the full reinforcement learning problem (as in Sutton, 1984). (And, as we noted, the modern litera\u0026shy;ture also uses the term \\A1\\B0contextual bandits\\A1\\B1 for this problem.) We note that Thorndike\\A1\\AFs Law of Effect (quoted in Chapter 1) describes associative search by referring to the formation of associative links between situations (states) and actions. According to the terminology of operant, or instrumental, con\u0026shy;ditioning (e.g., Skinner, 1938), a discriminative stimulus is a stimulus that signals the presence of a particular reinforcement contingency. In our terms, different discriminative stimuli correspond to different states.\n   2.9\n     The Gittins index approach is due to Gittins and Jones (1974). Duff (1995) showed how it is possible to learn Gittins indices for bandit problems through reinforcement learning. Bellman (1956) was the first to show how dynamic programming could be used to compute the optimal balance between explo\u0026shy;ration and exploitation within a Bayesian formulation of the problem. The survey by Kumar (1985) provides a good discussion of Bayesian and non- Bayesian approaches to these problems. The term information state comes from the literature on partially observable MDPs; see, e.g., Lovejoy (1991).\n \n48\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; MULTI-ARMED\u0026nbsp;\u0026nbsp; BANDITS\n \nChapter 3\nFinite Markov Decision Processes\nIn this chapter we introduce the problem that we try to solve in the rest of the book. This problem could be considered to define the field of reinforcement learning: any method that is suited to solving this problem we consider to be a reinforcement learning method.\nOur objective in this chapter is to describe the reinforcement learning problem in a broad sense. We try to convey the wide range of possible applications that can be framed as reinforcement learning tasks. We also describe mathematically idealized forms of the reinforcement learning problem for which precise theoretical statements can be made. We introduce key elements of the problem\\A1\\AFs mathematical structure, such as value functions and Bellman equations. As in all of artificial intelligence, there is a tension between breadth of applicability and mathematical tractability. In this chapter we introduce this tension and discuss some of the trade-offs and challenges that it implies.\n3.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Agent-Environment Interface\nThe reinforcement learning problem is meant to be a straightforward framing of the problem of learning from interaction to achieve a goal. The learner and decision\u0026shy;maker is called the agent. The thing it interacts with, comprising everything outside the agent, is called the environment. These interact continually, the agent selecting actions and the environment responding to those actions and presenting new situa\u0026shy;tions to the agent.[4]The environment also gives rise to rewards, special numerical values that the agent tries to maximize over time. A complete specification of an environment, including how rewards are determined, defines a task , one instance of the reinforcement learning problem.\n\u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n r\u0026quot;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n Agent\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  state\n \u0026nbsp;\n reward\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n action\n  St\n \u0026nbsp;\n Rt\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n i . Rt+1\n r\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \\ t St+l\n Environment\n M------- \n \u0026nbsp;\n    \u0026nbsp;\nFigure 3.1: The agent-environment interaction in reinforcement learning.\nMore specifically, the agent and environment interact at each of a sequence of discrete time steps, t = 0, 1, 2, 3, . . .. [5]At each time step t, the agent receives some representation of the environment\\A1\\AFs state, StG S, where S is the set of possible states, and on that basis selects an action, At G A(St), where A(St) is the set of actions available in state St. One time step later, in part as a consequence of its action, the agent receives a numerical reward, Rt+i G R C R, and finds itself in a new state, St+i.[6]Figure 3.1 diagrams the agent-environment interaction.\nAt each time step, the agent implements a mapping from states to probabilities of selecting each possible action. This mapping is called the agent\\A1\\AFs policy and is denoted nt, where nt(a|s) is the probability that At = a if St= s. Reinforcement learning methods specify how the agent changes its policy as a result of its experience. The agent\\A1\\AFs goal, roughly speaking, is to maximize the total amount of reward it receives over the long run.\nThis framework is abstract and flexible and can be applied to many different problems in many different ways. For example, the time steps need not refer to fixed intervals of real time; they can refer to arbitrary successive stages of decision-making and acting. The actions can be low-level controls, such as the voltages applied to the motors of a robot arm, or high-level decisions, such as whether or not to have lunch or to go to graduate school. Similarly, the states can take a wide variety of forms. They can be completely determined by low-level sensations, such as direct sensor readings, or they can be more high-level and abstract, such as symbolic descriptions of objects in a room. Some of what makes up a state could be based on memory of past sensations or even be entirely mental or subjective. For example, an agent could be in the state of not being sure where an object is, or of having just been surprised in some clearly defined sense. Similarly, some actions might be totally mental or computational. For example, some actions might control what an agent chooses to think about, or where it focuses its attention. In general, actions can be any decisions we want to learn how to make, and the states can be anything we can know that might be useful in making them.\nIn particular, the boundary between agent and environment is not often the same as the physical boundary of a robot\\A1\\AFs or animal\\A1\\AFs body. Usually, the boundary is drawn closer to the agent than that. For example, the motors and mechanical linkages of a robot and its sensing hardware should usually be considered parts of the environment rather than parts of the agent. Similarly, if we apply the framework to a person or animal, the muscles, skeleton, and sensory organs should be considered part of the environment. Rewards, too, presumably are computed inside the physical bodies of natural and artificial learning systems, but are considered external to the agent.\nThe general rule we follow is that anything that cannot be changed arbitrarily by the agent is considered to be outside of it and thus part of its environment. We do not assume that everything in the environment is unknown to the agent. For example, the agent often knows quite a bit about how its rewards are computed as a function of its actions and the states in which they are taken. But we always consider the reward computation to be external to the agent because it defines the task facing the agent and thus must be beyond its ability to change arbitrarily. In fact, in some cases the agent may know everything about how its environment works and still face a difficult reinforcement learning task, just as we may know exactly how a puzzle like Rubik\\A1\\AFs cube works, but still be unable to solve it. The agent-environment boundary represents the limit of the agent\\A1\\AFs absolute control, not of its knowledge.\nThe agent-environment boundary can be located at different places for different purposes. In a complicated robot, many different agents may be operating at once, each with its own boundary. For example, one agent may make high-level decisions which form part of the states faced by a lower-level agent that implements the high- level decisions. In practice, the agent-environment boundary is determined once one has selected particular states, actions, and rewards, and thus has identified a specific decision-making task of interest.\nThe reinforcement learning framework is a considerable abstraction of the problem of goal-directed learning from interaction. It proposes that whatever the details of the sensory, memory, and control apparatus, and whatever objective one is trying to achieve, any problem of learning goal-directed behavior can be reduced to three signals passing back and forth between an agent and its environment: one signal to represent the choices made by the agent (the actions), one signal to represent the basis on which the choices are made (the states), and one signal to define the agent\\A1\\AFs goal (the rewards). This framework may not be sufficient to represent all decision- learning problems usefully, but it has proved to be widely useful and applicable.\nOf course, the particular states and actions vary greatly from task to task, and how they are represented can strongly affect performance. In reinforcement learning, as in other kinds of learning, such representational choices are at present more art than science. In this book we offer some advice and examples regarding good ways of representing states and actions, but our primary focus is on general principles for learning how to behave once the representations have been selected.\nExample 3.1: Bioreactor Suppose reinforcement learning is being applied to determine moment-by-moment temperatures and stirring rates for a bioreactor (a large vat of nutrients and bacteria used to produce useful chemicals). The actions in such an application might be target temperatures and target stirring rates that are passed to lower-level control systems that, in turn, directly activate heating elements and motors to attain the targets. The states are likely to be thermocouple and other sensory readings, perhaps filtered and delayed, plus symbolic inputs representing the ingredients in the vat and the target chemical. The rewards might be moment- by-moment measures of the rate at which the useful chemical is produced by the bioreactor. Notice that here each state is a list, or vector, of sensor readings and symbolic inputs, and each action is a vector consisting of a target temperature and a stirring rate. It is typical of reinforcement learning tasks to have states and actions with such structured representations. Rewards, on the other hand, are always single numbers.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExample 3.2: Pick-and-Place Robot Consider using reinforcement learning to control the motion of a robot arm in a repetitive pick-and-place task. If we want to learn movements that are fast and smooth, the learning agent will have to control the motors directly and have low-latency information about the current positions and velocities of the mechanical linkages. The actions in this case might be the voltages applied to each motor at each joint, and the states might be the latest readings of joint angles and velocities. The reward might be +1 for each object successfully picked up and placed. To encourage smooth movements, on each time step a small, negative reward can be given as a function of the moment-to-moment \\A1\\B0jerkiness\\A1\\B1 of the motion.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExample 3.3: Recycling Robot A mobile robot has the job of collecting empty soda cans in an office environment. It has sensors for detecting cans, and an arm and gripper that can pick them up and place them in an onboard bin; it runs on a rechargeable battery. The robot\\A1\\AFs control system has components for interpreting sensory information, for navigating, and for controlling the arm and gripper. High- level decisions about how to search for cans are made by a reinforcement learning agent based on the current charge level of the battery. This agent has to decide whether the robot should (1) actively search for a can for a certain period of time, (2) remain stationary and wait for someone to bring it a can, or (3) head back to its home base to recharge its battery. This decision has to be made either periodically or whenever certain events occur, such as finding an empty can. The agent therefore has three actions, and its state is determined by the state of the battery. The rewards might be zero most of the time, but then become positive when the robot secures an empty can, or large and negative if the battery runs all the way down. In this example, the reinforcement learning agent is not the entire robot. The states it monitors describe conditions within the robot itself, not conditions of the robot\\A1\\AFs external environment. The agent\\A1\\AFs environment therefore includes the rest of the robot, which might contain other complex decision-making systems, as well as the robot\\A1\\AFs external environment.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n\n\nExercise 3.1 Devise three example tasks of your own that fit into the reinforcement learning framework, identifying for each its states, actions, and rewards. Make the three examples as different from each other as possible. The framework is abstract and flexible and can be applied in many different ways. Stretch its limits in some way in at least one of your examples.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.2 Is the reinforcement learning framework adequate to usefully represent all goal-directed learning tasks? Can you think of any clear exceptions?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.3 Consider the problem of driving. You could define the actions in terms of the accelerator, steering wheel, and brake, that is, where your body meets the machine. Or you could define them farther out\\A1\\AAsay, where the rubber meets the road, considering your actions to be tire torques. Or you could define them farther in\\A1\\AAsay, where your brain meets your body, the actions being muscle twitches to control your limbs. Or you could go to a really high level and say that your actions are your choices of where to drive. What is the right level, the right place to draw the line between agent and environment? On what basis is one location of the line to be preferred over another? Is there any fundamental reason for preferring one location over another, or is it a free choice?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n3.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Goals and Rewards\nIn reinforcement learning, the purpose or goal of the agent is formalized in terms of a special reward signal passing from the environment to the agent. At each time step, the reward is a simple number, Rt G R. Informally, the agent\\A1\\AFs goal is to maximize the total amount of reward it receives. This means maximizing not immediate reward, but cumulative reward in the long run. We can clearly state this informal idea as the reward hypothesis:\nThat all of what we mean by goals and purposes can be well thought of as the maximization of the expected value of the cumulative sum of a received scalar signal (called reward).\nThe use of a reward signal to formalize the idea of a goal is one of the most distinctive features of reinforcement learning.\nAlthough formulating goals in terms of reward signals might at first appear limit\u0026shy;ing, in practice it has proved to be flexible and widely applicable. The best way to see this is to consider examples of how it has been, or could be, used. For example, to make a robot learn to walk, researchers have provided reward on each time step proportional to the robot\\A1\\AFs forward motion. In making a robot learn how to escape from a maze, the reward is often \\A1\\AA1for every time step that passes prior to escape; this encourages the agent to escape as quickly as possible. To make a robot learn to find and collect empty soda cans for recycling, one might give it a reward of zero most of the time, and then a reward of ʮ1for each can collected. One might also want to give the robot negative rewards when it bumps into things or when somebody yells at it. For an agent to learn to play checkers or chess, the natural rewards are +1 for winning, \\A1\\AA1for losing, and 0for drawing and for all nonterminal positions.\nYou can see what is happening in all of these examples. The agent always learns to maximize its reward. If we want it to do something for us, we must provide rewards to it in such a way that in maximizing them the agent will also achieve our goals. It is thus critical that the rewards we set up truly indicate what we want accomplished. In particular, the reward signal is not the place to impart to the agent prior knowledge about how to achieve what we want it to do.[7]For example, a chess-playing agent should be rewarded only for actually winning, not for achieving subgoals such as taking its opponent\\A1\\AFs pieces or gaining control of the center of the board. If achieving these sorts of subgoals were rewarded, then the agent might find a way to achieve them without achieving the real goal. For example, it might find a way to take the opponent\\A1\\AFs pieces even at the cost of losing the game. The reward signal is your way of communicating to the robot what you want it to achieve, not how you want it achieved.\nNewcomers to reinforcement learning are sometimes surprised that the rewards\\A1\\AA which define of the goal of learning\\A1\\AAare computed in the environment rather than in the agent. Certainly most ultimate goals for animals are recognized by computations occurring inside their bodies, for example, by sensors for recognizing food, hunger, pain, and pleasure. Nevertheless, as we discussed in the previous section, one can redraw the agent-environment interface in such a way that these parts of the body are considered to be outside of the agent (and thus part of the agent\\A1\\AFs environment). For example, if the goal concerns a robot\\A1\\AFs internal energy reservoirs, then these are considered to be part of the environment; if the goal concerns the positions of the robot\\A1\\AFs limbs, then these too are considered to be part of the environment\\A1\\AA that is, the agent\\A1\\AFs boundary is drawn at the interface between the limbs and their control systems. These things are considered internal to the robot but external to the learning agent. For our purposes, it is convenient to place the boundary of the learning agent not at the limit of its physical body, but at the limit of its control.\nThe reason we do this is that the agent\\A1\\AFs ultimate goal should be something over which it has imperfect control: it should not be able, for example, to simply decree that the reward has been received in the same way that it might arbitrarily change its actions. Therefore, we place the reward source outside of the agent. This does not preclude the agent from defining for itself a kind of internal reward, or a sequence of internal rewards. Indeed, this is exactly what many reinforcement learning methods do.\n3.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Returns\nSo far we have discussed the objective of learning informally. We have said that the agent\\A1\\AFs goal is to maximize the cumulative reward it receives in the long run. Howmight this be defined formally? If the sequence of rewards received after time step t is denoted Rt+i, Rt+2, Rt+3, \u0026#8226; \u0026#8226; \u0026#8226;, then what precise aspect of this sequence do we wish to maximize? In general, we seek to maximize the expected return, where the return Gt is defined as some specific function of the reward sequence. In the simplest case the return is the sum of the rewards:\n   (3.1)\n     Gt= Rt+i ʮRt+2ʮRt+3 ʮ\\A1\\F6\\A1\\F6\\A1\\F6ʮRt,\nwhere T is a final time step. This approach makes sense in applications in which there is a natural notion of final time step, that is, when the agent-environment interaction breaks naturally into subsequences, which we call episodes,[8] such as plays of a game, trips through a maze, or any sort of repeated interactions. Each episode ends in a special state called the terminal state, followed by a reset to a standard starting state or to a sample from a standard distribution of starting states. Even if you think of episodes as ending in different ways, such as winning and losing a game, the next episode begins independently of how the previous one ended. Thus the episodes can all be considered to end in the same terminal state, with different rewards for the different outcomes. Tasks with episodes of this kind are called episodic tasks. In episodic tasks we sometimes need to distinguish the set of all nonterminal states, denoted S, from the set of all states plus the terminal state, denoted S+.\nOn the other hand, in many cases the agent-environment interaction does not break naturally into identifiable episodes, but goes on continually without limit. For example, this would be the natural way to formulate a continual process-control task, or an application to a robot with a long life span. We call these continuing tasks. The return formulation (3.1) is problematic for continuing tasks because the final time step would be T = oo, and the return, which is what we are trying to maximize, could itself easily be infinite. (For example, suppose the agent receives a reward of ʮ1 at each time step.) Thus, in this book we usually use a definition of return that is slightly more complex conceptually but much simpler mathematically.\nThe additional concept that we need is that of discounting. According to this approach, the agent tries to select actions so that the sum of the discounted rewards it receives over the future is maximized. In particular, it chooses At to maximize the expected discounted return:\n   (3.2)\n     GtʿRt+i ʮYRt+2 ʮY2Rt+3 ʮ=\\B7\\A6\\A1\\B3YkRt+fc+i,\nwhere 7is a parameter, 0\u0026lt; 7\u0026lt; 1, called the discount rate.\nThe discount rate determines the present value of future rewards: a reward received k time steps in the future is worth only 7k-1times what it would be worth if it were received immediately. If 7\u0026lt; 1, the infinite sum has a finite value as long as the reward sequence {Rk} is bounded. If 7= 0, the agent is \\A1\\B0myopic\\A1\\B1 in being concerned only with maximizing immediate rewards: its objective in this case is to learn how to choose At so as to maximize only Rt+i. If each of the agent\\A1\\AFs actions happenedto influence only the immediate reward, not future rewards as well, then a myopic agent could maximize (3.2) by separately maximizing each immediate reward. But in general, acting to maximize immediate reward can reduce access to future rewards so that the return may actually be reduced. As 7approaches 1, the objective takes future rewards into account more strongly: the agent becomes more farsighted.\nExample 3.4: Pole-Balancing Figure 3.2 shows a task that served as an early illustration of reinforcement learning. The objective here is to apply forces to a cart moving along a track so as to keep a pole hinged to the cart from falling over. A failure is said to occur if the pole falls past a given angle from vertical or if the cart runs off the track. The pole is reset to vertical after each failure. This task could be treated as episodic, where the natural episodes are the repeated attempts to balance the pole. The reward in this case could be +1 for every time step on which failure did not occur, so that the return at each time would be the number of steps until failure. Alternatively, we could treat pole-balancing as a continuing task, using discounting. In this case the reward would be \\A1\\AA1 on each failure and zero at all other times. The return at each time would then be related to \\A1\\AA7K, where K is the number of time steps before failure. In either case, the return is maximized by keeping the pole balanced for as long as possible.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 3.4 Suppose you treated pole-balancing as an episodic task but also used discounting, with all rewards zero except for \\A1\\AA1 upon failure. What then would the return be at each time? How does this return differ from that in the discounted, continuing formulation of this task?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.5 Imagine that you are designing a robot to run a maze. You decide to give it a reward of +1for escaping from the maze and a reward of zero at all other times. The task seems to break down naturally into episodes\\A1\\AAthe successive runs through the maze\\A1\\AAso you decide to treat it as an episodic task, where the goal is to maximize expected total reward (3.1). After running the learning agent for a while, you find that it is showing no improvement in escaping from the maze. What is going wrong? Have you effectively communicated to the agent what you want it to achieve?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nFigure 3.2: The pole-balancing task.\n \nThe returns at successive times are related to each other in a way that is important for the theory and algorithms of reinforcement learning:\nGt = Rt+i+ Y Rt+2 + Y2Rt+3+ Y 3Rt+4 +----- \n=Rt+i + Y(Rt+2+ YRt+3 + y 2Rt+4+\\A1\\AA)\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z =Rt+i + YGt+i\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.3)\nNote that this works for all time steps t \u0026lt; T, even if termination occurs at t + 1, if we define Gt = 0. This often makes it easy to compute returns from reward sequences.\nExercise 3.6 Suppose y = 0.5 and the following sequence of rewards is received Ri = \\A1\\AA1, R2= 2, R3= 6, R4= 3, and R5= 2, with T = 5. What are Go, Gi,..., G5? Hint: Work backwards.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nNote that although the return (3.2) is a sum of an infinite number of terms, it is still finite if the reward is nonzero and constant. For example, if the reward is a constant +1, then the return is\nGt= E Y = i^ \u0026#8226;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.4)\nk=01\nExercise 3.7 Suppose Y = 0.9 and the reward sequence is Ri = 2 followed by an infinite sequence of 7s. What are Gi and Go?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n3.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Unified Notation for Episodic and Continuing Tasks\nIn the preceding section we described two kinds of reinforcement learning tasks, one in which the agent-environment interaction naturally breaks down into a sequence of separate episodes (episodic tasks), and one in which it does not (continuing tasks). The former case is mathematically easier because each action affects only the finite number of rewards subsequently received during the episode. In this book we consider sometimes one kind of problem and sometimes the other, but often both. It is therefore useful to establish one notation that enables us to talk precisely about both cases simultaneously.\nTo be precise about episodic tasks requires some additional notation. Rather than one long sequence of time steps, we need to consider a series of episodes, each of which consists of a finite sequence of time steps. We number the time steps of each episode starting anew from zero. Therefore, we have to refer not just to St, the state representation at time t, but to St,i, the state representation at time t of episode i (and similarly for At,i, Rt,i, nt,i, Ti, etc.). However, it turns out that, when we discuss episodic tasks we will almost never have to distinguish between different episodes. We will almost always be considering a particular single episode, or stating something that is true for all episodes. Accordingly, in practice we will almost always abuse notation slightly by dropping the explicit reference to episode number. That is, we will write St to refer to St,i, and so on.\nWe need one other convention to obtain a single notation that covers both episodic and continuing tasks. We have defined the return as a sum over a finite number of terms in one case (3.1) and as a sum over an infinite number of terms in the other (3.2). These can be unified by considering episode termination to be the entering of a special absorbing state that transitions only to itself and that generates only rewards of zero. For example, consider the state transition diagram\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nHere the solid square represents the special absorbing state corresponding to the end\nof an episode. Starting from So, we get the reward sequence +1, +1, +1, 0, 0, 0,_____ \nSumming these, we get the same return whether we sum over the first T rewards (here T = 3) or over the full infinite sequence. This remains true even if we introduce discounting. Thus, we can define the return, in general, according to (3.2), using the convention of omitting episode numbers when they are not needed, and including the possibility that 7= 1if the sum remains defined (e.g., because all episodes terminate). Alternatively, we can also write the return as\nT-i-1\n(3.5)\nincluding the possibility that T = 00or 7= 1 (but not both). We use these con\u0026shy;ventions throughout the rest of the book to simplify notation and to express the close parallels between episodic and continuing tasks. (Later, in Chapter 10, we will introduce a formulation that is both continuing and undiscounted.)\n3.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *The Markov Property\nIn the reinforcement learning framework, the agent makes its decisions as a function of a signal from the environment called the environment\\A1\\AFs state. In this section we discuss what is required of the state signal, and what kind of information we should and should not expect it to provide. In particular, we formally define a property of environments and their state signals that is of particular interest, called the Markov property.\nIn this book, by \\A1\\B0the state\\A1\\B1 we mean whatever information is available to the agent. We assume that the state is given by some preprocessing system that is nominally part of the environment. We do not address the issues of constructing, changing, or learning the state signal in this book. We take this approach not because we consider state representation to be unimportant, but in order to focus fully on the decision-making issues. In other words, our main concern is not with designing the state signal, but with deciding what action to take as a function of whatever statesignal is available. By convention, the reward signal is not part of the state, but a copy of it certainly could be.\nCertainly the state signal should include immediate sensations such as sensory measurements, but it can contain much more than that. State representations can be highly processed versions of original sensations, or they can be complex structures built up over time from the sequence of sensations. For example, we can move our eyes over a scene, with only a tiny spot corresponding to the fovea visible in detail at any one time, yet build up a rich and detailed representation of a scene. Or, more obviously, we can look at an object, then look away, and know that it is still there. We can hear the word \\A1\\B0yes\\A1\\B1 and consider ourselves to be in totally different states depending on the question that came before and which is no longer audible. At a more mundane level, a control system can measure position at two different times to produce a state representation including information about velocity. In all of these cases the state is constructed and maintained on the basis of immediate sensations together with the previous state or some other memory of past sensations. In this book, we do not explore how that is done, but certainly it can be and has been done. There is no reason to restrict the state representation to immediate sensations; in typical applications we should expect the state representation to be able to inform the agent of more than that.\nOn the other hand, the state signal should not be expected to inform the agent of everything about the environment, or even everything that would be useful to it in making decisions. If the agent is playing blackjack, we should not expect it to know what the next card in the deck is. If the agent is answering the phone, we should not expect it to know in advance who the caller is. If the agent is a paramedic called to a road accident, we should not expect it to know immediately the internal injuries of an unconscious victim. In all of these cases there is hidden state information in the environment, and that information would be useful if the agent knew it, but the agent cannot know it because it has never received any relevant sensations. In short, we don\\A1\\AFt fault an agent for not knowing something that matters, but only for having known something and then forgotten it!\nWhat we would like, ideally, is a state signal that summarizes past sensations compactly, yet in such a way that all relevant information is retained. This normally requires more than the immediate sensations, but never more than the complete history of all past sensations. A state signal that succeeds in retaining all relevant information is said to be Markov, or to have the Markov property (we define this formally below). For example, a checkers position\\A1\\AAthe current configuration of all the pieces on the board\\A1\\AAwould serve as a Markov state because it summarizes everything important about the complete sequence of positions that led to it. Much of the information about the sequence is lost, but all that really matters for the future of the game is retained. Similarly, the current position and velocity of a cannonball is all that matters for its future flight. It doesn\\A1\\AFt matter how that position and velocity came about. This is sometimes also referred to as an \\A1\\B0independence of path\\A1\\B1 property because all that matters is in the current state signal; its meaning is independent of the \\A1\\B0path,\\A1\\B1 or history, of signals that have led up to it.\nWe now formally define the Markov property for the reinforcement learning prob\u0026shy;lem. To keep the mathematics simple, we assume here that there are a finite number of states and reward values. This enables us to work in terms of sums and proba\u0026shy;bilities rather than integrals and probability densities, but the argument can easily be extended to include continuous states and rewards (or infinite discrete spaces). Consider how a general environment might respond at time t+ 1 to the action taken at time t. In the most general, causal case, this response may depend on every\u0026shy;thing that has happened earlier. In this case the dynamics can be defined only by specifying the complete joint probability distribution:\nPr{St+i = sf, Rt+i = r | So, Ao, Ri,\\A1\\AD\\A3\\ACSt-i,At-i, Rt, St, At},\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.6)\nfor all r, sf, and all possible values of the past events: So, Ao, Ri,\\A1\\AD\\A3\\ACSt_i, At-1, Rt, St, At. If the state signal has the Markov property, on the other hand, then the environment\\A1\\AFs response at t+1depends only on the state and action representations at t, in which case the environment\\A1\\AFs dynamics can be defined by specifying only\np(s',r|s,a) == Pr{St+i = s!, Rt+i = r | St = s, At = a},\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.7)\nfor all r, s', s, and a. In other words, a state signal has the Markov property, and is a Markov state, if and only if (3.6) is equal to p(s', r|St, At) for all s', r, and histories, So, Ao, Ri,\\A1\\AD\\A3\\ACSt_i, At-i, Rt, St, At. In this case, the environment and task as a whole are also said to have the Markov property.\nIf an environment has the Markov property, then its one-step dynamics (3.7) enable us to predict the next state and expected next reward given the current state and action. One can show that, by iterating this equation, one can predict all future states and expected rewards from knowledge only of the current state as well as would be possible given the complete history up to the current time. It also follows that Markov states provide the best possible basis for choosing actions. That is, the best policy for choosing actions as a function of a Markov state is just as good as the best policy for choosing actions as a function of complete histories.\nEven when the state signal is non-Markov, it is still appropriate to think of the state in reinforcement learning as an approximation to a Markov state. In particular, we always want the state to be a good basis for predicting future rewards and for selecting actions. In cases in which a model of the environment is learned (see Chapter 8), we also want the state to be a good basis for predicting subsequent states. Markov states provide an unsurpassed basis for doing all of these things. To the extent that the state approaches the ability of Markov states in these ways, one will obtain better performance from reinforcement learning systems. For all of these reasons, it is useful to think of the state at each time step as an approximation to a Markov state, although one should remember that it may not fully satisfy the Markov property.\nThe Markov property is important in reinforcement learning because decisions and values are assumed to be a function only of the current state. In order for these to be effective and informative, the state representation must be informative. All of the theory presented in this book assumes Markov state signals. This means that not all the theory strictly applies to cases in which the Markov property does not strictly apply. However, the theory developed for the Markov case still helps us to understand the behavior of the algorithms, and the algorithms can be successfully applied to many tasks with states that are not strictly Markov. A full understanding of the theory of the Markov case is an essential foundation for extending it to the more complex and realistic non-Markov case. Finally, we note that the assumption of Markov state representations is not unique to reinforcement learning but is also present in most if not all other approaches to artificial intelligence.\nExample 3.5: Pole-Balancing State In the pole-balancing task introduced earlier, a state signal would be Markov if it specified exactly, or made it possible to reconstruct exactly, the position and velocity of the cart along the track, the angle between the cart and the pole, and the rate at which this angle is changing (the angular velocity). In an idealized cart-pole system, this information would be sufficient to exactly predict the future behavior of the cart and pole, given the actions taken by the controller. In practice, however, it is never possible to know this information exactly because any real sensor would introduce some distortion and delay in its measurements. Furthermore, in any real cart-pole system there are always other effects, such as the bending of the pole, the temperatures of the wheel and pole bearings, and various forms of backlash, that slightly affect the behavior of the system. These factors would cause violations of the Markov property if the state signal were only the positions and velocities of the cart and the pole.\nHowever, often the positions and velocities serve quite well as states. Some early studies of learning to solve the pole-balancing task used a coarse state signal that divided cart positions into three regions: right, left, and middle (and similar rough quantizations of the other three intrinsic state variables). This distinctly non-Markov state was sufficient to allow the task to be solved easily by reinforcement learning methods. In fact, this coarse representation may have facilitated rapid learning by forcing the learning agent to ignore fine distinctions that would not have been useful in solving the task.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExample 3.6: Draw Poker In draw poker, each player is dealt a hand of five cards. There is a round of betting, in which each player exchanges some of his cards for new ones, and then there is a final round of betting. At each round, each player must match or exceed the highest bets of the other players, or else drop out (fold). After the second round of betting, the player with the best hand who has not folded is the winner and collects all the bets.\nThe state signal in draw poker is different for each player. Each player knows the cards in his own hand, but can only guess at those in the other players\\A1\\AF hands. A common mistake is to think that a Markov state signal should include the contents of all the players\\A1\\AF hands and the cards remaining in the deck. In a fair game, however, we assume that the players are in principle unable to determine these things from their past observations. If a player did know them, then she could predict some future events (such as the cards one could exchange for) better than by remembering all past observations.\nIn addition to knowledge of one\\A1\\AFs own cards, the state in draw poker should include the bets and the numbers of cards drawn by the other players. For example, if one of the other players drew three new cards, you may suspect he retained a pair and adjust your guess of the strength of his hand accordingly. The players\\A1\\AF bets also influence your assessment of their hands. In fact, much of your past history with these particular players is part of the Markov state. Does Ellen like to bluff, or does she play conservatively? Does her face or demeanor provide clues to the strength of her hand? How does Joe\\A1\\AFs play change when it is late at night, or when he has already won a lot of money?\nAlthough everything ever observed about the other players may have an effect on the probabilities that they are holding various kinds of hands, in practice this is far too much to remember and analyze, and most of it will have no clear effect on one\\A1\\AFs predictions and decisions. Very good poker players are adept at remembering just the key clues, and at sizing up new players quickly, but no one remembers everything that is relevant. As a result, the state representations people use to make their poker decisions are undoubtedly non-Markov, and the decisions themselves are presumably imperfect. Nevertheless, people still make very good decisions in such tasks. We conclude that the inability to have access to a perfect Markov state representation is probably not a severe problem for a reinforcement learning agent.\n\\A1\\F6\nExercise 3.8: Broken Vision System Imagine that you are a vision system. When you are first turned on for the day, an image floods into your camera. You can see lots of things, but not all things. You can\\A1\\AFt see objects that are occluded, and of course you can\\A1\\AFt see objects that are behind you. After seeing that first scene, do you have access to the Markov state of the environment? Suppose your camera was broken that day and you received no images at all, all day. Would you have access to the Markov state then?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n3.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Markov Decision Processes\nA reinforcement learning task that satisfies the Markov property is called a Markov decision process, or MDP. If the state and action spaces are finite, then it is called a finite Markov decision process (finite MDP). Finite MDPs are particularly important to the theory of reinforcement learning. We treat them extensively throughout this book; they are all you need to understand 90% of modern reinforcement learning.\nA particular finite MDP is defined by its state and action sets and by the one-step dynamics of the environment. Given any state and action s and a, the probability of each possible pair of next state and reward, s;, r, is denoted\np(s',r|s,a) ʿPr{St+i = s;, Rt+i = r | St = s, At = a}.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.8)\nThese quantities completely specify the dynamics of a finite MDP. Most of the theory we present in the rest of this book implicitly assumes the environment is a finite MDP.\n\n\nGiven the dynamics as specified by (3.8), one can compute anything else one might want to know about the environment, such as the expected rewards for state-action pairs,\nr(s,a) = E[Ri+1| Si = s, Ai = a] = [ r\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; r|s, a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.9)\nreR s;es\nthe state-transition probabilities,\np(s'|s,a) = Pr{Si+1= s' | Si = s, Ai = a} = ^^p(s\\A3\\BB,r|s,a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.10)\nreR\nand the expected rewards for state-action-next-state triples,\nr(s,a,s') ^ E[Ri+1| Si = s, Ai = a,Si+1= s'] = [ep(\\C1\\CB(^ :\\A3\\ACa).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.11)\nIn the first edition of this book, the dynamics were expressed exclusively in terms of the latter two quantities, which were denoted PL, and R:, respectively. One weakness of that notation is that it still did not fully characterize the dynamics of the rewards, giving only their expectations. Another weakness is the excess of subscripts and superscripts. In this edition we will predominantly use the explicit notation of (3.8), while sometimes referring directly to the transition probabilities (3.10).\nExercise 3.9 If the current state is Si, and actions are selected according to stochas\u0026shy;tic policy n, then what is the expectation of Ri+1in terms of the four-argument function p (3.8)?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExample 3.7: Recycling Robot MDP The recycling robot (Example 3.3) can be turned into a simple example of an MDP by simplifying it and providing some more details. (Our aim is to produce a simple example, not a particularly realistic one.) Recall that the agent makes a decision at times determined by external events (or by other parts of the robot\\A1\\AFs control system). At each such time the robot decides whether it should (1) actively search for a can, (2) remain stationary and wait for someone to bring it a can, or (3) go back to home base to recharge its battery. Suppose the environment works as follows. The best way to find cans is to actively search for them, but this runs down the robot\\A1\\AFs battery, whereas waiting does not. Whenever the robot is searching, the possibility exists that its battery will become depleted. In this case the robot must shut down and wait to be rescued (producing a low reward).\nThe agent makes its decisions solely as a function of the energy level of the battery. It can distinguish two levels, high and low, so that the state set is S = {high, low}. Let us call the possible decisions\\A1\\AAthe agent\\A1\\AFs actions\\A1\\AAwait, search, and recharge. When the energy level is high, recharging would always be foolish, so we do not include it in the action set for this state. The agent\\A1\\AFs action sets are\nA(high)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; =\u0026nbsp;\u0026nbsp;\u0026nbsp; {search,wait}\nA(low)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; =\u0026nbsp;\u0026nbsp;\u0026nbsp; {search, wait, recharge}.\nIf the energy level is high, then a period of active search can always be completed without risk of depleting the battery. A period of searching that begins with a high energy level leaves the energy level high with probability a and reduces it to low with probability 1 \\A1\\AA a. On the other hand, a period of searching undertaken when the energy level is low leaves it low with probability ¬and depletes the battery with probability 1\\A1\\AA¬.In the latter case, the robot must be rescued, and the battery is then recharged back to high. Each can collected by the robot counts as a unit reward, whereas a reward of \\A1\\AA3 results whenever the robot has to be rescued. Let rsearch and rWait, with rsearch \u0026gt; rWait, respectively denote the expected number of cans the robot will collect (and hence the expected reward) while searching and while waiting. Finally, to keep things simple, suppose that no cans can be collected during a run home for recharging, and that no cans can be collected on a step in which the battery is depleted. This system is then a finite MDP, and we can write down the transition probabilities and the expected rewards, as in Table 3.1.\ns\n a\n s!\n p(s\n |s,a)\n r(s, a, s7)\n  high\n search\n high\n a\n \u0026nbsp;\n rsearch\n  high\n search\n low\n 1\\A1\\AA\n a\n rsearch\n  low\n search\n high\n 1\\A1\\AA\n 13\n \\A1\\AA3\n  low\n search\n low\n ¬\n \u0026nbsp;\n rsearch\n  high\n wait\n high\n 1\n \u0026nbsp;\n rwait\n  high\n wait\n low\n 0\n \u0026nbsp;\n rwait\n  low\n wait\n high\n 0\n \u0026nbsp;\n rwait\n  low\n wait\n low\n 1\n \u0026nbsp;\n rwait\n  low\n recharge\n high\n 1\n \u0026nbsp;\n 0\n  low\n recharge\n low\n 0\n \u0026nbsp;\n 0.\n     Table 3.1: Transition probabilities and expected rewards for the finite MDP of the recycling robot example. There is a row for each possible combination of current state, s, next state, s7, and action possible in the current state, a G A(s).\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n \nFigure 3.3: Transition graph for the recycling robot example.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\\A1\\F6\nA transition graph is a useful way to summarize the dynamics of a finite MDP. Figure 3.3 shows the transition graph for the recycling robot example. There are two kinds of nodes: state nodes and action nodes. There is a state node for each possible state (a large open circle labeled by the name of the state), and an action node for each state-action pair (a small solid circle labeled by the name of the action and connected by a line to the state node). Starting in state s and taking action a moves you along the line from state node s to action node (s, a). Then the environment responds with a transition to the next state\\A1\\AFs node via one of the arrows leaving action node (s, a). Each arrow corresponds to a triple (s, s;, a), where sf is the next state, and we label the arrow with the transition probability, p(s;|s, a), and the expected reward for that transition, r(s, a, s;). Note that the transition probabilities labeling the arrows leaving an action node always sum to 1.\nExercise 3.10 Give a table analogous to to Table 3.1, but for p(s;, r|s, a). It should have columns for s, a, s' r, and p(s;, r|s, a), and a row for every 4-tuple for which p(s;, r|s, a) \u0026gt; 0.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n3.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Value Functions\nAlmost all reinforcement learning algorithms involve estimating value functions\\A1\\AA functions of states (or of state-action pairs) that estimate how good it is for the agent to be in a given state (or how good it is to perform a given action in a given state). The notion of \\A1\\B0how good\\A1\\B1 here is defined in terms of future rewards that can be expected, or, to be precise, in terms of expected return. Of course the rewards the agent can expect to receive in the future depend on what actions it will take. Accordingly, value functions are defined with respect to particular policies.\nRecall that a policy, n, is a mapping from each state, s G S, and action, a G A(s), to the probability n(a|s) of taking action a when in state s. Informally, the value of a state s under a policy n, denoted Vn(s), is the expected return when starting in s and following n thereafter. For MDPs, we can define v^(s) formally as\n\n\n   (3.12)\n        Ey\u0026quot;Rt+k+i\n        St= s\n        Vn(s) == En[Gt | St= s] = En\n     \u0026nbsp;\n .k=0\nwhere E^[-] denotes the expected value of a random variable given that the agent follows policy n, and t is any time step. Note that the value of the terminal state, if any, is always zero. We call the function vn the state-value function for policy n.\nSimilarly, we define the value of taking action a in state s under a policy n, denoted qn(s, a), as the expected return starting from s, taking the action a, and thereafter following policy n:\n \n   (3.13)\n        Eyk Rt+k+i\n        St \\A1\\AA s, At \\A1\\AA a\n        qn(s, a) \\A1\\AA En[Gt | St \\A1\\AA s, At \\A1\\AA a] \\A1\\AA En\n     \u0026nbsp;\n .k=0\n \nWe call qn the action-value function for policyn.\nThe value functions and can be estimated from experience. For example, if an agent follows policy n and maintains an average, for each state encountered, of the actual returns that have followed that state, then the average will converge to the state\\A1\\AFs value, (s), as the number of times that state is encountered approaches infinity. If separate averages are kept for each action taken in a state, then these aver\u0026shy;ages will similarly converge to the action values, q^(s, a). We call estimation methods of this kind Monte Carlo methods because they involve averaging over many random samples of actual returns. These kinds of methods are presented in Chapter 5. Of course, if there are very many states, then it may not be practical to keep separate averages for each state individually. Instead, the agent would have to maintain v^ and qn as parameterized functions (with fewer parameters than states) and adjust the parameters to better match the observed returns. This can also produce accu\u0026shy;rate estimates, although much depends on the nature of the parameterized function approximator. These possibilities are discussed in the second part of the book.\nA fundamental property of value functions used throughout reinforcement learning and dynamic programming is that they satisfy particular recursive relationships. For any policy n and any state s, the following consistency condition holds between the value of s and the value of its possible successor states:\nV\u0026nbsp;\u0026nbsp;\u0026nbsp; n(s) == En[Gi | Si = s]\n   (by (3.3)) (3.14)\n     =En[Ri+1+ YGi+1| Si = s]\n=[أ(a|s)[[p(s',r|s,a) r + 7Enơʮ1ӽʮ1= s\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s!r\n=^ n(a|s^ ^p(s',r|s,a) r + YVn(s') , Vs G S,\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s,\\A3\\ACr\nwhere it is implicit that the actions, a, are taken from the set A(s), the next states, s', are taken from the set S (or from Sʮin the case of an episodic problem), and the rewards, r, are taken from the set R. Note also how in the last equation we have merged the two sums, one over all the values of s' and the other over all values of r, into one sum over all possible values of both. We will use this kind of merged sum often to simplify formulas. Note how the final expression can be read very easily as an expected value. It is really a sum over all values of the three variables, a, s', and r. For each triple, we compute its probability, n(a|s)p(s', r|s, a), weight the quantity in brackets by that probability, then sum over all possibilities to get an expected value.\nEquation (3.14) is the Bellman equation for Vn. It expresses a relationship between the value of a state and the values of its successor states. Think of looking ahead from one state to its possible successor states, as suggested by Figure 3.4 (left). Each open circle represents a state and each solid circle represents a state-action pair. Starting from state s, the root node at the top, the agent could take any of some set of actions\\A1\\AAthree are shown in Figure 3.4 (left). From each of these, the environment could respond with one of several next states, s', along with a reward,\n \nFigure 3.4: Backup diagrams for v^ and q^.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nr. The Bellman equation (3.14) averages over all the possibilities, weighting each by its probability of occurring. It states that the value of the start state must equal the (discounted) value of the expected next state, plus the reward expected along the way.\nThe value function Vn is the unique solution to its Bellman equation. We show in subsequent chapters how this Bellman equation forms the basis of a number of ways to compute, approximate, and learn v[ We call diagrams like those shown in Figure 3.4 backup diagrams because they diagram relationships that form the basis of the update or backup operations that are at the heart of reinforcement learning methods. These operations transfer value information back to a state (or a state\\A1\\AA action pair) from its successor stares (or state\\A1\\AAaction pairs). We use backup diagrams throughout the book to provide graphical summaries of the algorithms we discuss. (Note that unlike transition graphs, the state nodes of backup diagrams do not necessarily represent distinct rtates; for example, a state might be its own successor. We also omit explicit arrowheads because time always flows downward in a backup diagram.)\n   \u0026nbsp;\n A\n \u0026nbsp;\n B\\A1\\A2\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \\\n +5\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n +1C\n B)\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n N\\C7\\D8\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        3.3\n 8.8\n 4.4\n 5.3\n 1.5\n  1.5\n 3.0\n 2.3\n 1.9\n 0.5\n  0.1\n 0.7\n 0.7\n 0.4\n -0.4\n  -1.0\n -0.4\n -0.4\n -0.6\n -1.2\n  -1.9\n -1.3\n -1.2\n -1.4\n -2.0\n    \u0026nbsp;\n        Actions\n        Figure 3.5: Gridworld example: exceptional reward dynamics (left) and state-value function for the equiprobable random policy (right).\n     Example 3.8, Gridworld Figure 3.5 (left) shows a rectangular gridworld repre\u0026shy;sentation of a simple finite MDP. The cells of the grid correspond to the states of the environment. At each cell, four actions are possible: north, soutli\\A3\\ACeast\\A3\\ACand west, sehich deterministically cause the agent to move one cell fn the respective di\u0026shy;rection one the grid. Actions that would take the agent off the grid leave its location unchanged, but also result in a reward of \\A1\\AA1. Other actions result in ee reward of 0, except those that move the agent cut of the special states A and B. From st ate A, all four aetions yield a reward of ʮ10 and take the ageng to A' From state B, all actions yield a reward of ʮ5 and take the agent to B;.\nSuppose the agent selects all four actions with equal probability in all states. Figure 3.5 (right) shows the value function, Vn, for this policy, for the discounted reward case with Y = 0.9. This value function was computed by solving the system of linear equations (3.14). Notice the negative values near the lower edge; these are the result of the high probability of hitting the edge of the grid there under the random policy. State A is the best state to be in under this policy, but its expected return is less than 10, its immediate reward, because from A the agent is taken to A', from which it is likely to run into the edge of the grid. State B, on the other hand, is valued more than 5, its immediate reward, because from B the agent is taken to B', which has a positive value. From B' the expected penalty (negative reward) for possibly running into an edge is more than compensated for by the expected gain for possibly stumbling onto A or B.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n   V-\n        putt\n        Figure 3.6: A golf example: the state-value function for putting (above) and the optimal action-value function for using the driver (below).\n        -2\n     Example 3.9: Golf To formulate playing a hole of golf as a reinforcement learning task, we count a penalty (negative reward) of \\A1\\AA1for each stroke until we hit the ball into the hole. The state is the location of the ball. The value of a state is the negative of the number of strokes to the hole from that location. Our actions are how we aim and swing at the ball, of course, and which club we select. Let us take\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\nthe former as given and consider just the choice of club, which we assume is either a putter or a driver. The upper part of Figure 3.6 shows a possible state-value function,\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; putt(s), for the policy that always uses the putter. The terminal state in-the-hole has a value of 0. From anywhere on the green we assume we can make a putt; these states have value \\A1\\AA1. Off the green we cannot reach the hole by putting, and the value is greater. If we can reach the green from a state by putting, then that state must have value one less than the green\\A1\\AFs value, that is, \\A1\\AA2. For simplicity, let us assume we can putt very precisely and deterministically, but with a limited range. This gives us the sharp contour line labeled \\A1\\AA2 in the figure; all locations between that line and the green require exactly two strokes to complete the hole. Similarly, any location within putting range of the \\A1\\AA2 contour line must have a value of \\A1\\AA3, and so on to get all the contour lines shown in the figure. Putting doesn\\A1\\AFt get us out of sand traps, so they have a value of \\A1\\AA0. Overall, it takes us six strokes to get from the tee to the hole by putting.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 3.11 What is the Bellman equation for action values, that is, for q^? It must give the action value q^(s, a) in terms of the action values, q^(s', a'), of possible successors to the state-action pair (s, a). As a hint, the backup diagram corresponding to this equation is given in Figure 3.4 (right). Show the sequence of equations analogous to (3.14), but for action values.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.12 The Bellman equation (3.14) must hold for each state for the value function Vn shown in Figure 3.5 (right). As an example, show numerically that this equation holds for the center state, valued at +0.7, with respect to its four neighboring states, valued at +2.3, +0.4, \\A1\\AA0.4, and +0.7. (These numbers are accurate only to one decimal place.)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.13 In the gridworld example, rewards are positive for goals, negative for running into the edge of the world, and zero the rest of the time. Are the signs of these rewards important, or only the intervals between them? Prove, using (3.2), that adding a constant c to all the rewards adds a constant, vc, to the values of all states, and thus does not affect the relative values of any states under any policies. What is vc in terms of c and 7?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.14 Now consider adding a constant c to all the rewards in an episodic task, such as maze running. Would this have any effect, or would it leave the task unchanged as in the continuing task above? Why or why not? Give an example. \\A1\\F5\nExercise 3.15 The value of a state depends on the values of the actions possible in that state and on how likely each action is to be taken under the current policy. We can think of this in terms of a small backup diagram rooted at the state and considering each possible action:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\ntaken wit^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; _\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; A .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; V\\A2\\C8\nprobability ^(ajs)\n-q-K(s,a)\nGive the equation corresponding to this intuition and diagram for the value at the root node, Vn(s), in terms of the value at the expected leaf node, q^(s, a), given\n\n\nSt = s. This equation should include an expectation conditioned on following the policy, n. Then give a second equation in which the expected value is written out explicitly in terms of n(a|s) such that no expected value notation appears in the equation.\n   JT-------------- Qn(s,a)\n     Exercise 3.16 The value of an action, q^(s, a), depends on the expected next reward and the expected sum of the remaining rewards. Again we can think of this in terms of a small backup diagram, this one rooted at an action (state-action pair) and branching to the possible next states:\nexpected\n   vأ(s)\n     rewards-\nGive the equation corresponding to this intuition and diagram for the action value, qn(s, a), in terms of the expected next reward, Riʮ1, and the expected next state value, Vn (Siʮ1), given that Si = s and Ai = a. This equation should include an expectation but not one conditioned conditioned on following the policy. Then give a second equation, writing out the expected value explicitly in terms of p(s', r|s, a) defined by (3.8), such that no expected value notation appears in the equation. \\A1\\F5\n3.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimal Value Functions\nSolving a reinforcement learning task means, roughly, finding a policy that achieves a lot of reward over the long run. For finite MDPs, we can precisely define an optimal policy in the following way. Value functions define a partial ordering over policies. A policy n is defined to be better than or equal to a policy n' if its expected return is greater than or equal to that of n' for all states. In other words, n \u0026gt; n' if and only if Vn(s) \u0026gt; Vn, (s) for all s G S. There is always at least one policy that is better than or equal to all other policies. This is an optimal policy. Although there may be more than one, we denote all the optimal policies by n^. They share the same state-value function, called the optimal state-value function, denoted V^, and defined as\nV^(s) == max Vn (s),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.15)\nآ\nfor all s G S.\nOptimal policies also share the same optimal action-value function, denoted q^, and defined as\nq*(s, a) == maxq^(s, a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.16)\nآ\nfor all s G S and a G A(s). For the state-action pair (s, a), this function gives the expected return for taking action a in state s and thereafter following an optimal policy. Thus, we can write q\\B1\\BEin terms of Vľas follows:\n   (3.17)\n     \\81\\96(s,a)= E[Ri+1+\\A3\\AC*\\B5\\C4ʮ1) | Si = s, Ai = a]\nExample 3.10: Optimal Value Functions for Golf The lower part of Figure 3.6 shows the contours of a possible optimal action-value function q^(s, driver). These are the values of each state if we first play a stroke with the driver and afterward select either the driver or the putter, whichever is better. The driver enables us to hit the ball farther, but with less accuracy. We can reach the hole in one shot using the driver only if we are already very close; thus the \\A1\\AA1contour for \\81\\96(s, driver) covers only a small portion of the green. If we have two strokes, however, then we can reach the hole from much farther away, as shown by the \\A1\\AA2 contour. In this case we don\\A1\\AFt have to drive all the way to within the small \\A1\\AA1contour, but only to anywhere on the green; from there we can use the putter. The optimal action-value function gives the values after committing to a particular first action, in this case, to the driver, but afterward using whichever actions are best. The \\A1\\AA3 contour is still farther out and includes the starting tee. From the tee, the best sequence of actions is two drives and one putt, sinking the ball in three strokes.\n\\A1\\F6\nBecause vľis the value function for a policy, it must satisfy the self-consistency condition given by the Bellman equation for state values (3.14). Because it is the optimal value function, however, v^\\A1\\AFs consistency condition can be written in a special form without reference to any specific policy. This is the Bellman equation for v*, or the\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Bellman optimality equation. Intuitively,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; the\u0026nbsp;\u0026nbsp; Bellmanoptimality\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; equation\nexpressesthe\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; fact that the value of a state under\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; an optimal policymust\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; equal the\nexpected return for the best action from that state:\nv*(s) = max qn (s, a)\na\u0026pound;A(s)\n\\A1\\AAmax[Gt| St \\A1\\AA s, At \\A1\\AA a] a\n=maxEn,[Rt+i + YGt+i | St = s, At = a]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (by (3.3))\na\n=maxE[Rt+i + Yv*(St+i) | St = s, At = a]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.18)\na\n=max Ep(s', r|s, a) [r + yv*(s')] .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (3.19)\naGA (s)\ns' ,r\nThe last two equations are two forms of the Bellman optimality equation for v*. The Bellman optimality equation for q* is\n \n   q*(s,a)\n        St = s, At = a\n        E\n        Rt+i + Y maxq*(St+i, a')\na'\n     \u0026nbsp;\n p(s',r|s,a) r + y max q*(s', a')\nL\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a'\ns',r\nThe backup diagrams in Figure 3.7 show graphically the spans of future states and actions considered in the Bellman optimality equations for v* and q*. These are the same as the backup diagrams for v^ and q^ except that arcs have been added at the agent\\A1\\AFs choice points to represent that the maximum over that choice is taken rather than the expected value given some policy. Figure 3.7 (left) graphically represents the Bellman optimality equation (3.19).\n \nA\n   s\n        r\n        (v*)\n     \\A1\\A2sf\n\\A9\\96\\A9\\96\\A9\\96\\A9\\96\\A9\\96\\A9\\96#\u0026#8226;\u0026#8226; \u0026#8226;\u0026#8226;()!\nFigure 3.7: Backup diagrams for v^ and q*\n \n\u0026nbsp;\n \nFor finite MDPs, the Bellman optimality equation (3.19) has a unique solution independent of the policy. The Bellman optimality equation is actually a system of equations, one for each state, so if there are N states, then there are N equations in N unknowns. If the dynamics of the environment are known (p(s', r|s, a)), then in principle one can solve this system of equations for v* using any one of a variety of methods for solving systems of nonlinear equations. One can solve a related set of equations for q*.\nOnce one has v*, it is relatively easy to determine an optimal policy. For each state s, there will be one or more actions at which the maximum is obtained in the Bellman optimality equation. Any policy that assigns nonzero probability only to these actions is an optimal policy. You can think of this as a one-step search. If you have the optimal value function, v*, then the actions that appear best after a one-step search will be optimal actions. Another way of saying this is that any policy that is greedy with respect to the optimal evaluation function v* is an opti\u0026shy;mal policy. The term greedy is used in computer science to describe any search or decision procedure that selects alternatives based only on local or immediate con\u0026shy;siderations, without considering the possibility that such a selection may prevent future access to even better alternatives. Consequently, it describes policies that select actions based only on their short-term consequences. The beauty of v* is that if one uses it to evaluate the short-term consequences of actions\\A1\\AAspecifically, the one-step consequences\\A1\\AAthen a greedy policy is actually optimal in the long-term sense in which we are interested because v* already takes into account the reward consequences of all possible future behavior. By means of v*, the optimal expected long-term return is turned into a quantity that is locally and immediately available for each state. Hence, a one-step-ahead search yields the long-term optimal actions.\nHaving q* makes choosing optimal actions still easier. With q*, the agent does not even have to do a one-step-ahead search: for any state s, it can simply find any action that maximizes q*(s, a). The action-value function effectively caches the results of all one-step-ahead searches. It provides the optimal expected long-term return as a value that is locally and immediately available for each state-action pair. Hence, at the cost of representing a function of state-action pairs, instead of just of states, the optimal action-value function allows optimal actions to be selected without having to know anything about possible successor states and their values, that is, without having to know anything about the environment\\A1\\AFs dynamics.\nExample 3.11: Bellman Optimality Equations for the Recycling Robot Us\u0026shy;ing (3.19), we can explicitly give the Bellman optimality equation for the recycling robot example. To make things more compact, we abbreviate the states high and low, and the actions search, wait, and recharge respectively by h, l, s, w, and re. Since there are only two states, the Bellman optimality equation consists of two equations. The equation for Vľ(h) can be written as follows:\n \n   V*(h)\n        P(h|h, s)[r(h, s, h) + 7V*(h)] + p(l|h, s)[r(h, s, l) + 7V*(l)], P(h|h, w)[r(h, w, h) + 7V*(h)] + p(l|h, w)[r(h, w, l) + YV*(l)]\na[rs + YV*(h)] + (1 \\A1\\AA a)[rs + YV*(l)], 1 1[rH + YV*(h)] + 0[rH + YV*(l)]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; J\n(s + Y[aV*(h) + (1\\A1\\AA a)V*(l)]^\nrH + YV*(h)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; J\u0026nbsp; .\n        max\nmax\nmax\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Following the same procedure for V* (l) yields the equation\n(¬(s \\A1\\AA 3(1 \\A1\\AA¬\\A3\\A9+ Y[(1 \\A1\\AA ^)V*(h) + ^V*(l)]\nV\u0026nbsp;\u0026nbsp;\u0026nbsp; *(l) = max \u0026lt; rH + YV*(l),\n{YV*(h)\nFor any choice of (s, rw, a, P, and 7, with 0 \u0026lt; 7\u0026lt; 1, 0 \u0026lt; a, ^ \u0026lt; 1, there is exactly one pair of numbers, V*(h) and V*(l), that simultaneously satisfy these two nonlinear equations.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n   \u0026nbsp;\n A\\A1\\A2\n \u0026nbsp;\n B\\A1\\A2\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \\\n +5\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n +1C\n B)\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n /\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        7T,\n     Example 3.12: Solving the Gridworld Suppose we solve the Bellman equa\u0026shy;tion for V* for the simple grid task introduced in Example 3.8 and shown again in Figure 3.8 (left). Recall that state A is followed by a reward of +10 and transition to state A', while state B is followed by a reward of +5 and transition to state B'. Figure 3.8 (middle) shows the optimal value function, and Figure 3.8 (right) shows the corresponding optimal policies. Where there are multiple arrows in a cell, any of the corresponding actions is optimal.\n22.C\n 24.4\n 22.C\n 19.4\n 17.5\n \u0026nbsp;\n ~\u0026#9658;\n +\n 4~\n \u0026nbsp;\n \u0026lt;~\n  19.8\n 22.C\n 19.8\n 17.8\n 16.0\n \u0026nbsp;\n U\n t\n \u0026nbsp;\n 4\\A1\\AA\\A1\\AA\n 4\\A1\\AA\n  17.8\n 19.8\n 17.8\n 16.0\n 14.4\n \u0026nbsp;\n u\n t\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  16.C\n 17.8\n 16.C\n 14.4\n 13.0\n \u0026nbsp;\n u\n \\B8\\F6\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  14.4\n 16.C\n 14.4\n 13.0\n 11.7\n \u0026nbsp;\n u\n t\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\nGridworld\nFigure 3.8: Optimal solutions to the gridworld example.\n\\A1\\F6\nExplicitly solving the Bellman optimality equation provides one route to finding an optimal policy, and thus to solving the reinforcement learning problem. However,this solution is rarely directly useful. It is akin to an exhaustive search, looking ahead at all possibilities, computing their probabilities of occurrence and their desirabili\u0026shy;ties in terms of expected rewards. This solution relies on at least three assumptions that are rarely true in practice: (1) we accurately know the dynamics of the envi\u0026shy;ronment; (2) we have enough computational resources to complete the computation of the solution; and (3) the Markov property. For the kinds of tasks in which we are interested, one is generally not able to implement this solution exactly because various combinations of these assumptions are violated. For example, although the first and third assumptions present no problems for the game of backgammon, the second is a major impediment. Since the game has about 1020states, it would take thousands of years on today\\A1\\AFs fastest computers to solve the Bellman equation for v^, and the same is true for finding q^. In reinforcement learning one typically has to settle for approximate solutions.\nMany different decision-making methods can be viewed as ways of approximately solving the Bellman optimality equation. For example, heuristic search methods can be viewed as expanding the right-hand side of (3.19) several times, up to some depth, forming a \\A1\\B0tree\\A1\\B1 of possibilities, and then using a heuristic evaluation function to approximate vľat the \\A1\\B0leaf\\A1\\B1 nodes. (Heuristic search methods such as A* are almost always based on the episodic case.) The methods of dynamic programming can be related even more closely to the Bellman optimality equation. Many reinforcement learning methods can be clearly understood as approximately solving the Bellman optimality equation, using actual experienced transitions in place of knowledge of the expected transitions. We consider a variety of such methods in the following chapters.\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z Exercise 3.17 Draw or describe the optimal state-value function for the golf ex\u0026shy;ample.\\A1\\F5\nExercise 3.18 Draw or describe the contours of the optimal action-value function for putting, q*(s,putter), for the golf example.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.19 Give the Bellman equation for q* for the recycling robot.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.20 Figure 3.8 gives the optimal value of the best state of the gridworld as 24.4, to one decimal place. Use your knowledge of the optimal policy and (3.2) to express this value symbolically, and then to compute it to three decimal places. \\A1\\F5\nExercise 3.21 Consider the continuing MDP shown on to the right. The only decision to be made is that in the top state, where two actions are available, left and right. The numbers show the rewards that are received deterministically after each action. There are exactly two deter\u0026shy;ministic policies, nieft and bright. What policy is optimal if y \\A1\\AA 0? If y \\A1\\AA 0.9? If y \\A1\\AA 0.5?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.22 Give an equation for v* in terms of q*.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.23 Give an equation for q* in terms of v* and the world\\A1\\AFs dynamics,\n\n\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z p(s', r|s, a).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.24 Give an equation for n* in terms of q*.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 3.25 Give an equation for n* in terms of v* and the world\\A1\\AFs dynamics, p(s', r|s, a).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n3.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimality and Approximation\nWe have defined optimal value functions and optimal policies. Clearly, an agent that learns an optimal policy has done very well, but in practice this rarely happens. For the kinds of tasks in which we are interested, optimal policies can be generated only with extreme computational cost. A well-defined notion of optimality organizes the approach to learning we describe in this book and provides a way to understand the theoretical properties of various learning algorithms, but it is an ideal that agents can only approximate to varying degrees. As we discussed above, even if we have a complete and accurate model of the environment\\A1\\AFs dynamics, it is usually not possible to simply compute an optimal policy by solving the Bellman optimality equation. For example, board games such as chess are a tiny fraction of human experience, yet large, custom-designed computers still cannot compute the optimal moves. A critical aspect of the problem facing the agent is always the computational power available to it, in particular, the amount of computation it can perform in a single time step.\nThe memory available is also an important constraint. A large amount of memory is often required\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; to\u0026nbsp;\u0026nbsp;\u0026nbsp; build up approximationsof value\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; functions,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; policies,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; and\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; models.\nIn tasks with small,finite state sets, it is possible\u0026nbsp;\u0026nbsp; toform theseapproximations using\narrays or tables with one entry for each state (or state-action pair). This we call the tabular case, and the corresponding methods we call tabular methods. In many cases of practical interest, however, there are far more states than could possibly be entries in a table. In these cases the functions must be approximated, using some sort of more compact parameterized function representation.\nOur framing of the reinforcement learning problem forces us to settle for approxi\u0026shy;mations. However, it also presents us with some unique opportunities for achieving useful approximations. For example, in approximating optimal behavior, there may be many states that the agent faces with such a low probability that selecting subop- timal actions for them has little impact on the amount of reward the agent receives. Tesauro\\A1\\AFs backgammon player, for example, plays with exceptional skill even though it might make very bad decisions on board configurations that never occur in games against experts. In fact, it is possible that TD-Gammon makes bad decisions for a large fraction of the game\\A1\\AFs state set. The on-line nature of reinforcement learning makes it possible to approximate optimal policies in ways that put more effort into learning to make good decisions for frequently encountered states, at the expense of less effort for infrequently encountered states. This is one key property that dis\u0026shy;tinguishes reinforcement learning from other approaches to approximately solving MDPs.\n3.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nLet us summarize the elements of the reinforcement learning problem that we have presented in this chapter. Reinforcement learning is about learning from interaction how to behave in order to achieve a goal. The reinforcement learning agent and its environment interact over a sequence of discrete time steps. The specification of their interface defines a particular task: the actions are the choices made by the agent; the states are the basis for making the choices; and the rewards are the basis for evaluating the choices. Everything inside the agent is completely known and controllable by the agent; everything outside is incompletely controllable but may or may not be completely known. A policy is a stochastic rule by which the agent selects actions as a function of states. The agent\\A1\\AFs objective is to maximize the amount of reward it receives over time.\nThe return is the function of future rewards that the agent seeks to maximize. It has several different definitions depending upon the nature of the task and whether one wishes to discount delayed reward. The undiscounted formulation is appropriate for episodic tasks, in which the agent\\A1\\AAenvironment interaction breaks naturally into episodes; the discounted formulation is appropriate for continuing tasks, in which the interaction does not naturally break into episodes but continues without limit.\nAn environment satisfies the Markov property if its state signal compactly sum\u0026shy;marizes the past without degrading the ability to predict the future. This is rarely exactly true, but often nearly so; the state signal should be chosen or constructed so that the Markov property holds as nearly as possible. In this book we assume that this has already been done and focus on the decision-making problem: how to decide what to do as a function of whatever state signal is available. If the Markov property does hold, then the environment is called a Markov decision process (MDP). A finite MDP is an MDP with finite state and action sets. Most of the current theory of reinforcement learning is restricted to finite MDPs, but the methods and ideas apply more generally.\nA policy\\A1\\AFs value functions assign to each state, or state\\A1\\AAaction pair, the expected return from that state, or state\\A1\\AAaction pair, given that the agent uses the policy. The optimal value functions assign to each state, or state\\A1\\AAaction pair, the largest expected return achievable by any policy. A policy whose value functions are optimal is an optimal policy. Whereas the optimal value functions for states and state\\A1\\AAaction pairs are unique for a given MDP, there can be many optimal policies. Any policy that is greedy with respect to the optimal value functions must be an optimal policy. The Bellman optimality equations are special consistency conditions that the optimal value functions must satisfy and that can, in principle, be solved for the optimal value functions, from which an optimal policy can be determined with relative ease.\nA reinforcement learning problem can be posed in a variety of different ways de\u0026shy;pending on assumptions about the level of knowledge initially available to the agent. In problems of complete knowledge, the agent has a complete and accurate model of the environment\\A1\\AFs dynamics. If the environment is an MDP, then such a model consists of the one-step transition probabilities and expected rewards for all states and their allowable actions. In problems of incomplete knowledge, a complete and perfect model of the environment is not available.\nEven if the agent has a complete and accurate environment model, the agent is typically unable to perform enough computation per time step to fully use it. The memory available is also an important constraint. Memory may be required to build up accurate approximations of value functions, policies, and models. In most cases of practical interest there are far more states than could possibly be entries in a table, and approximations must be made.\nA well-defined notion of optimality organizes the approach to learning we describe in this book and provides a way to understand the theoretical properties of various learning algorithms, but it is an ideal that reinforcement learning agents can only ap\u0026shy;proximate to varying degrees. In reinforcement learning we are very much concerned with cases in which optimal solutions cannot be found but must be approximated in some way.\nBibliographical and Historical Remarks\nThe reinforcement learning problem is deeply indebted to the idea of Markov decision processes (MDPs) from the field of optimal control. These historical influences and other major influences from psychology are described in the brief history given in Chapter 1. Reinforcement learning adds to MDPs a focus on approximation and incomplete information for realistically large problems. MDPs and the reinforcement learning problem are only weakly linked to traditional learning and decision-making problems in artificial intelligence. However, artificial intelligence is now vigorously exploring MDP formulations for planning and decision-making from a variety of perspectives. MDPs are more general than previous formulations used in artificial intelligence in that they permit more general kinds of goals and uncertainty.\nOur presentation of the reinforcement learning problem was influenced by Watkins (1989).\n3.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The bioreactor example is based on the work of Ungar (1990) and Miller and Williams (1992). The recycling robot example was inspired by the can- collecting robot built by Jonathan Connell (1989).\n3.3-4 The terminology of episodic and continuing tasks is different from that usu\u0026shy;ally used in the MDP literature. In that literature it is common to distinguish three types of tasks: (1) finite-horizon tasks, in which interaction terminates after a particular fixed number of time steps; (2) indefinite-horizon tasks, in which interaction can last arbitrarily long but must eventually terminate; and (3) infinite-horizon tasks, in which interaction does not terminate. Our episodic and continuing tasks are similar to indefinite-horizon and infinite- horizon tasks, respectively, but we prefer to emphasize the difference in the nature of the interaction. This difference seems more fundamental than the difference in the objective functions emphasized by the usual terms. Often episodic tasks use an indefinite-horizon objective function and continuing tasks an infinite-horizon objective function, but we see this as a common coincidence rather than a fundamental difference.\nThe pole-balancing example is from Michie and Chambers (1968) and Barto, Sutton, and Anderson (1983).\n3.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; For further discussion of the concept of state, see Minsky (1967).\n3.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The theory of MDPs is treated by, e.g., Bertsekas (2005), Ross (1983), White (1969), and Whittle (1982, 1983). This theory is also studied under the head\u0026shy;ing of stochastic optimal control, where adaptive optimal control methods are most closely related to reinforcement learning (e.g., Kumar, 1985; Kumar and Varaiya, 1986).\nThe theory of MDPs evolved from efforts to understand the problem of mak\u0026shy;ing sequences of decisions under uncertainty, where each decision can depend on the previous decisions and their outcomes. It is sometimes called the theory of multistage decision processes, or sequential decision processes, and has roots in the statistical literature on sequential sampling beginning with the papers by Thompson (1933, 1934) and Robbins (1952) that we cited in Chapter 2 in connection with bandit problems (which are prototypical MDPs if formulated as multiple-situation problems).\nThe earliest instance of which we are aware in which reinforcement learning was discussed using the MDP formalism is Andreae\\A1\\AFs (1969b) description of a unified view of learning machines. Witten and Corbin (1973) experimented with a reinforcement learning system later analyzed by Witten (1977) using the MDP formalism. Although he did not explicitly mention MDPs, Werbos (1977) suggested approximate solution methods for stochastic optimal control problems that are related to modern reinforcement learning methods (see also Werbos, 1982, 1987, 1988, 1989, 1992). Although Werbos\\A1\\AFs ideas were not widely recognized at the time, they were prescient in emphasizing the importance of approximately solving optimal control problems in a variety of domains, including artificial intelligence. The most influential integration of reinforcement learning and MDPs is due to Watkins (1989). His treatment of reinforcement learning using the MDP formalism has been widely adopted.\nOur characterization of the dynamics of an MDP in terms of p(s\\A1\\A2r|s,a) is slightly unusual. It is more common in the MDP literature to describe the dynamics in terms of the state transition probabilities p(s;|s, a) and ex\u0026shy;pected next rewards r(s, a). In reinforcement learning, however, we more often have to refer to individual actual or sample rewards (rather than just their expected values). Our notation also makes it plainer that St and Rt are in general jointly determined, and thus must have the same time index. In teaching reinforcement learning, we have found our notation to be more straightforward conceptually and easier to understand.\n3.7-8 Assigning value on the basis of what is good or bad in the long run has ancient roots. In control theory, mapping states to numerical values representing the long-term consequences of control decisions is a key part of optimal control theory, which was developed in the 1950s by extending nineteenth century state-function theories of classical mechanics (see, e.g., Schultz and Melsa, 1967). In describing how a computer could be programmed to play chess, Shannon (1950) suggested using an evaluation function that took into account the long-term advantages and disadvantages of chess positions.\nWatkins\\A1\\AFs (1989) Q-learning algorithm for estimating q* (Chapter 6) made action-value functions an important part of reinforcement learning, and con\u0026shy;sequently these functions are often called Q-functions. But the idea of an action-value function is much older than this. Shannon (1950) suggested that a function h(P, M) could be used by a chess-playing program to decide whether a move M in position P is worth exploring. Michie\\A1\\AFs (1961, 1963) MENACE system and Michie and Chambers\\A1\\AFs (1968) BOXES system can be understood as estimating action-value functions. In classical physics, Hamil\u0026shy;ton\\A1\\AFs principal function is an action-value function; Newtonian dynamics are greedy with respect to this function (e.g., Goldstein, 1957). Action-value functions also played a central role in Denardo\\A1\\AFs (1967) theoretical treatment of DP in terms of contraction mappings.\nWhat we call the Bellman equation for v* was first introduced by Richard Bellman (1957a), who called it the \\A1\\B0basic functional equation.\\A1\\B1 The coun\u0026shy;terpart of the Bellman optimality equation for continuous time and state problems is known as the Hamilton-Jacobi-Bellman equation (or often just the Hamilton-Jacobi equation), indicating its roots in classical physics (e.g., Schultz and Melsa, 1967).\nThe golf example was suggested by Chris Watkins.\n \n80\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER3.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; FINITE\u0026nbsp;\u0026nbsp; MARKOV\u0026nbsp;\u0026nbsp; DECISION\u0026nbsp;\u0026nbsp; PROCESSES\nChapter 4\nDynamic Programming\nThe term dynamic programming (DP) refers to a collection of algorithms that can be used to compute optimal policies given a perfect model of the environment as a Markov decision process (MDP). Classical DP algorithms are of limited utility in reinforcement learning both because of their assumption of a perfect model and because of their great computational expense, but they are still important theoret\u0026shy;ically. DP provides an essential foundation for the understanding of the methods presented in the rest of this book. In fact, all of these methods can be viewed as attempts to achieve much the same effect as DP, only with less computation and without assuming a perfect model of the environment.\nStarting with this chapter, we usually assume that the environment is a finite MDP. That is, we assume that its state, action, and reward sets, S, A(s), and R, for s G S, are finite, and that its dynamics are given by a set of probabilities p(s;, r|s, a), for all s G S, a G A(s), r G R, and sf G S+ (S+ is S plus a terminal state if the problem is episodic). Although DP ideas can be applied to problems with continuous state and action spaces, exact solutions are possible only in special cases. A common way of obtaining approximate solutions for tasks with continuous states and actions is to quantize the state and action spaces and then apply finite-state DP methods. The methods we explore in Chapter 9 are applicable to continuous problems and are a significant extension of that approach.\nThe key idea of DP, and of reinforcement learning generally, is the use of value functions to organize and structure the search for good policies. In this chapter we show how DP can be used to compute the value functions defined in Chapter 3. As discussed there, we can easily obtain optimal policies once we have found the optimal value functions, v* or q*, which satisfy the Bellman optimality equations:\nv*(s)\u0026nbsp;\u0026nbsp; \\A1\\AA\u0026nbsp;\u0026nbsp;\u0026nbsp; maxE[Rt+i ʮYv*(St+i) | St \\A1\\AA s, At \\A1\\AA a]\na\n\\A1\\AAma^7p(s\u0026#12316;r|s,a) r ʮ?v*(s;)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (4.1)\na\ns; ,r\n \nor\n \n   q*(s,a)\n        St= s, At = a\n        E\n        Rt+i + Y max q*(St+i,a')\n        a'\n     \u0026nbsp;\n    (4.2)\n     ^p(s', r|s, a) r + y m^xq*(s', a')\ns',r\nfor all s G S, a G A(s), and s' G S+. As we shall see, DP algorithms are obtained by turning Bellman equations such as these into assignments, that is, into update rules for improving approximations of the desired value functions.\n4.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Evaluation\nFirst we consider how to compute the state-value function v^ for an arbitrary policy n. This is called policy evaluation in the DP literature. We also refer to it as the prediction problem. Recall from Chapter 3 that, for all s G S,\nv(s) = En[Gt | St = s]\n   (from (3.3))\n(4.3)\n(4.4)\n     =En[Rt+i + YGt+i | St = s]\n=En[Rt+1+ Yvn(St+i) | St = s]\n=^ أ(a|s)^p(s',r|s,a) r + yv^(s')\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s',r\nwhere n(a|s) is the probability of taking action a in state s under policy n, and the expectations are subscripted by n to indicate that they are conditional on n being followed. The existence and uniqueness of v^ are guaranteed as long as either y \u0026lt; 1 or eventual termination is guaranteed from all states under the policy n.\n   vfc+i(s)\n        (4.5)\n        En[Rt+1+(St+i)| St = s] ^^(a|s)^p(s',r|s,a) r + m(s')\n        s',r\nfor all s G S. Clearly, vk = v^ is a fixed point for this update rule because the Bellman equation for v^ assures us of equality in this case. Indeed, the sequence {vk} can be shown in general to converge to v^ as k^ under the same conditions that guarantee the existence of v^. This algorithm is called iterative policy evaluation.\n     If the environment\\A1\\AFs dynamics are completely known, then (4.4) is a system of |S| simultaneous linear equations in |S| unknowns (the v^(s), s G S). In principle, its solution is a straightforward, if tedious, computation. For our purposes, itera\u0026shy;tive solution methods are most suitable. Consider a sequence of approximate value functions vo, vi, v2,..., each mapping S+ to R (the real numbers). The initial ap\u0026shy;proximation, vo, is chosen arbitrarily (except that the terminal state, if any, must be given value 0), and each successive approximation is obtained by using the Bellman equation for v^ (3.14) as an update rule:\n \nTo produce each successive approximation, Vkʮ1from Vk, iterative policy evalua\u0026shy;tion applies the same operation to each state s: it replaces the old value of s with a new value obtained from the old values of the successor states of s, and the expected immediate rewards, along all the one-step transitions possible under the policy being evaluated. We call this kind of operation a full backup. Each iteration of iterative policy evaluation backs up the value of every state once to produce the new approxi\u0026shy;mate value function Vkʮ1. There are several different kinds of full backups, depending on whether a state (as here) or a state-action pair is being backed up, and depending on the precise way the estimated values of the successor states are combined. All the backups done in DP algorithms are called full backups because they are based on all possible next states rather than on a sample next state. The nature of a backup can be expressed in an equation, as above, or in a backup diagram like those introduced in Chapter 3. For example, Figure 3.4 (left) is the backup diagram corresponding to the full backup used in iterative policy evaluation.\nTo write a sequential computer program to implement iterative policy evaluation, as given by (4.5), you would have to use two arrays, one for the old values, Vk(s), and one for the new values, Vkʮ1(s). This way, the new values can be computed one by one from the old values without the old values being changed. Of course it is easier to use one array and update the values \\A1\\B0in place,\\A1\\B1 that is, with each new backed-up value immediately overwriting the old one. Then, depending on the order in which the states are backed up, sometimes new values are used instead of old ones on the right-hand side of (4.5). This slightly different algorithm also converges to Vn; in fact, it usually converges faster than the two-array version, as you might expect, since it uses new data as soon as they are available. We think of the backups as being done in a sweep through the state space. For the in-place algorithm, the order in which states are backed up during the sweep has a significant influence on the rate of convergence. We usually have the in-place version in mind when we think of DP algorithms.\nAnother implementation point concerns the termination of the algorithm. For\u0026shy;mally, iterative policy evaluation converges only in the limit, but in practice it must\nIterative policy evaluation\nInput n, the policy to be evaluated Initialize an array V(s) = 0, for all s G Sʮ Repeat A ^ 0\nFor each s G S:\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; V(s)\nV(s) \\A1\\AAEa n(a|s) Es,\\A3\\ACrp(s',r|s,a) [r + 7V(s')] A \\A8D max(A, |v \\A1\\AA V(s)|) until A \u0026lt; Q (a small positive number)\nOutput V Vnbe halted short of this. A typical stopping condition for iterative policy evaluation is to test the quantity maxs^S |v^+i(s) \\A1\\AA v^ (s)| after each sweep and stop when it is sufficiently small. The box shows a complete algorithm with this stopping criterion.\nExample 4.1 Consider the 4x4 gridworld shown below.\n \n   \u0026nbsp;\n 1\n 2\n 3\n  4\n 5\n 6\n 7\n  8\n 9\n 10\n 11\n  12\n 13\n 14\n \u0026nbsp;\n    \u0026nbsp;\n        R =-1\non all transitions\n        \nactions\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n The nonterminal states are S \\A1\\AA {1, 2,..., 14}. There are four actions possible in each state, A \\A1\\AA {up, down, right, left}, which deterministically cause the corresponding state transitions, except that actions that would take the agent off the grid in fact leave the state unchanged. Thus, for instance, p(6, \\A1\\AA1 | 5, right) \\A1\\AA 1, p(7, \\A1\\AA1 | 7, right) \\A1\\AA 1, and p(10, r | 5, right) \\A1\\AA 0 for all r G R. This is an undiscounted, episodic task. The reward is \\A1\\AA1 on all transitions until the terminal state is reached. The terminal state is shaded in the figure (although it is shown in two places, it is formally one state). The expected reward function is thus r(s, a, s;) \\A1\\AA \\A1\\AA1 for all states s, sf and actions a. Suppose the agent follows the equiprobable random policy (all actions equally likely). The left side of Figure 4.1 shows the sequence of value functions {v^} computed by iterative policy evaluation. The final estimate is in fact vn, which in this case gives for each state the negation of the expected number of steps from that state until termination.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 4.1 In Example 4.1, if n is the equiprobable random policy, what is qn(11, down)? What is q^(7, down)?\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 4.2 In Example 4.1, suppose a new state 15 is added to the gridworld just below state 13, and its actions, left, up, right, and down, take the agent to states 12, 13, 14, and 15, respectively. Assume that the transitions from the original states are unchanged. What, then, is v^(15) for the equiprobable random policy? Now suppose the dynamics of state 13are\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; also changed,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; suchthat\u0026nbsp;\u0026nbsp;\u0026nbsp; action downfrom\nstate 13 takes the agent to the new\u0026nbsp;\u0026nbsp; state\u0026nbsp;\u0026nbsp; 15.\u0026nbsp;\u0026nbsp; What\u0026nbsp; is\u0026nbsp; v^(15)\u0026nbsp; forthe equiprobable\nrandom policy in this case?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 4.3 What are the equations analogous to (4.3), (4.4), and (4.5) for the action-value function q^ and its successive approximation by a sequence of functions qo,qi,q2, \u0026#8226; \u0026#8226; \u0026#8226; ?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n \n   Vkfor the Random Policy\n        random\npolicy\n        k =2\n        optimal\npolicy\n        0.0\n 0.0\n 0.0\n 0.0\n  0.0\n 0.0\n 0.0\n 0.0\n  0.0\n 0.0\n 0.0\n 0.0\n  0.0\n 0.0\n 0.0\n 0.0\n    \u0026nbsp;\n        0.0\n -1.0\n -1.0\n -1.0\n  -1.0\n -1.0\n -1.0\n -1.0\n  -1.0\n -1.0\n -1.0\n -1.0\n  -1.0\n -1.0\n -1.0\n 0.0\n    \u0026nbsp;\n        0.0\n -1.7\n -2.0\n -2.0\n  -1.7\n -2.0\n -2.0\n -2.0\n  -2.0\n -2.0\n -2.0\n -1.7\n  -2.0\n -2.0\n -1.7\n 0.0\n    \u0026nbsp;\n        0.0\n -2.4\n -2.9\n -3.0\n  -2.4\n -2.9\n -3.0\n -2.9\n  -2.9\n -3.0\n -2.9\n -2.4\n  -3.0\n -2.9\n -2.4\n 0.0\n    \u0026nbsp;\n        0.0\n -6.1\n -8.4\n -9.0\n  -6.1\n -7.7\n -8.4\n -8.4\n  -8.4\n -8.4\n -7.7\n -6.1\n  -9.0\n -8.4\n -6.1\n 0.0\n    \u0026nbsp;\n        0.0\n -14.\n -20.\n -22.\n  -14.\n -18.\n -20.\n -20.\n  -20.\n -20.\n -18.\n -14.\n  -22.\n -20.\n -14.\n 0.0\n    \u0026nbsp;\n        \u0026nbsp;\n \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n  \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n  \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n  \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026lt;\\A1\\AA\n \\E5\\F8\n \\E5\\F8\n  t\n \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n  \\E5\\F8\n \\E5\\F8\n \\E5\\F8\n i\n  \\E5\\F8\n \\E5\\F8\n \\A1\\AA\u0026gt;\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026lt;\\A1\\AA\n \u0026lt;\\A1\\AA\n \\E5\\F8\n  t\n \u0026nbsp;\n \\E5\\F8\n i\n  t\n \\E5\\F8\n \\B9\\E3\n 1\n  \\E5\\F8\n \\A1\\AA\u0026raquo;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026lt;\\A1\\AA\n \u0026lt;\\A1\\AA\n \u0026nbsp;\n  t\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  t\n u\n \u0026nbsp;\n 1\n  u\n \u0026nbsp;\n \\A1\\AA\u0026gt;\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026lt;\\A1\\AA\n \u0026lt;\\A1\\AA\n \u0026nbsp;\n  t\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  t\n u\n r\n \u0026nbsp;\n  u\n \\A1\\AA\u0026gt;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026lt;\\A1\\AA\n \u0026lt;\\A1\\AA\n \u0026nbsp;\n  t\n \u0026nbsp;\n \u0026nbsp;\n i\n  t\n u\n \\B9\\E3\n 1\n  u\n \u0026nbsp;\n \\A1\\AA\u0026gt;\n \u0026nbsp;\n    \u0026nbsp;\n        k =10\n        k =3\n        k =0\n        Greedy Policy w.r.t. Vk\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 4.1: Convergence of iterative policy evaluation on a small gridworld. The left column is the sequence of approximations of the state-value function for the random policy (all actions equal). The right column is the sequence of greedy policies corresponding to the value function estimates (arrows are shown for all actions achieving the maximum). The last policy is guaranteed only to be an improvement over the random policy, but in this case it, and all policies after the third iteration, are optimal.\n4.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Improvement\nOur reason for computing the value function for a policy is to help find better policies. Suppose we have determined the value function v^ for an arbitrary deterministic policy n. For some state s we would like to know whether or not we should change the policy to deterministically choose an action a = n(s). We know how good it is to follow the current policy from s\\A1\\AAthat is v^(s)\\A1\\AAbut would it be better or worse to change to the new policy? One way to answer this question is to consider selecting a in s and thereafter following the existing policy, n. The value of this way of behaving is\nqn(s,a) = En[Rt+i + Yv^(St+i) | St = s, At = a]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (4.6)\n=\\B6\\FEp(s', r|s, a) r + yv^(s').\ns',r\nThe key criterion is whether this is greater than or less than v^(s). If it is greater\\A1\\AA that is, if it is better to select a once in s and thereafter follow n than it would be to follow n all the time\\A1\\AAthen one would expect it to be better still to select a every time s is encountered, and that the new policy would in fact be a better one overall.\nThat this is true is a special case of a general result called the policy improvement theorem. Let n and n' be any pair of deterministic policies such that, for all s G S,\n   (4.7)\n     qn(s,n'(s)) \u0026gt; vn(s).\nThen the policy n' must be as good as, or better than, n. That is, it must obtain greater or equal expected return from all states s G S:\n   (4.8)\n     vn'(s) \u0026gt; vn(s).\nMoreover, if there is strict inequality of (4.7) at any state, then there must be strict inequality of (4.8) at at least one state. This result applies in particular to the two policies that we considered in the previous paragraph, an original deterministic policy, n, and a changed policy, n', that is identical to n except that n'(s) = a = n(s). Obviously, (4.7) holds at all states other than s. Thus, if q^(s, a) \u0026gt; v^(s), then the changed policy is indeed better than n.\nThe idea behind the proof of the policy improvement theorem is easy to under\u0026shy;stand. Starting from (4.7), we keep expanding the q^ side and reapplying (4.7) until\n \nwe get vy(s):\nv(s) \u0026lt; qn (s,n;(s))\n \n\u0026nbsp;\n \nEn^[Rt+i ʮYvn(St+i) | St \\A1\\AA s]\n   \u0026lt;\u0026nbsp;\n\u0026lt;\u0026nbsp;\n     Ef[Rt+i ʮYqn(St+i,n;(St+i)) I St \\A1\\AA s]\nEf[Rt+i ʮYEn^[Rt+2ʮYvn(St+2)] | St \\A1\\AA s] Ef[Rt+i ʮYRt+2ʮY2vn(St+2) 1St \\A1\\AA s]\nEn;[Rt+i ʮYRt+2ʮ72Rt+3 ʮY3vn(St+3) | St \\A1\\AA s]\n \n\u0026nbsp;\n\u0026nbsp;\n \n\u0026lt; Ef [Rt+i ʮYRt+2ʮY2Rt+3ʮY3Rt+4ʮ\\A1\\F6 \\A1\\F6 \\A1\\F6 1St \\A1\\AA s]\n\\A1\\AAvn;(s).\nSo far we have seen how, given a policy and its value function, we can easily evaluate a change in the policy at a single state to a particular action. It is a natural extension to consider changes at all states and to all possible actions, selecting at each state the action that appears best according to q^(s, a). In other words, to consider the new greedy policy, n;, given by\nn;(s)\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\AA\u0026nbsp;\u0026nbsp; argmaxq^ (s, a)\na\n   (4.9)\n     \\A1\\AAargmax E[Rt+i ʮyv^(St+i) | St \\A1\\AA s, At \\A1\\AA a]\na\narg max ^ p(s;, r|s, a) r ʮyv^ (s')\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s,,r\nwhere arg maxa denotes the value of a at which the expression that follows is max\u0026shy;imized (with ties broken arbitrarily). The greedy policy takes the action that looks best in the short term\\A1\\AAafter one step of lookahead\\A1\\AAaccording to v^. By construc\u0026shy;tion, the greedy policy meets the conditions of the policy improvement theorem (4.7), so we know that it is as good as, or better than, the original policy. The process of making a new policy that improves on an original policy, by making it greedy with respect to the value function of the original policy, is called policy improvement.\nSuppose the new greedy policy, n', is as good as, but not better than, the old policy n. Then v^ \\A1\\AA v#, and from (4.9) it follows that for all s G S:\n(s)\u0026nbsp; \\A1\\AA\u0026nbsp;\u0026nbsp;\u0026nbsp; maxE[Rt+i ʮ(St+i) | St \\A1\\AA s, At \\A1\\AA a]\na\n\\A1\\AAma^\u0026gt; p(s', r|s, a) r ʮn(s')\na\ns7,r\nBut this is the same as the Bellman optimality equation (4.1), and therefore, v^^ must be v*, and both n and n' must be optimal policies. Policy improvement thus must give us a strictly better policy except when the original policy is already optimal.\nSo far in this section we have considered the special case of deterministic policies. In the general case, a stochastic policy n specifies probabilities, n(a|s), for takingeach action, a, in each state, s. We will not go through the details, but in fact all the ideas of this section extend easily to stochastic policies. In particular, the policy improvement theorem carries through as stated for the stochastic case. In addition, if there are ties in policy improvement steps such as (4.9)\\A1\\AAthat is, if there are several actions at which the maximum is achieved\\A1\\AAthen in the stochastic case we need not select a single action from among them. Instead, each maximizing action can be given a portion of the probability of being selected in the new greedy policy. Any apportioning scheme is allowed as long as all submaximal actions are given zero probability.\nThe last row of Figure 4.1 shows an example of policy improvement for stochastic policies. Here the original policy, n, is the equiprobable random policy, and the new policy, n', is greedy with respect to v^. The value function v^ is shown in the bottom-left diagram and the set of possible n' is shown in the bottom-right diagram. The states with multiple arrows in the n' diagram are those in which several actions achieve the maximum in (4.9); any apportionment of probability among these actions is permitted. The value function of any such policy, v^'(s), can be seen by inspection to be either \\A1\\AA1, -2, or \\A1\\AA3 at all states, s G S, whereas v^(s) is at most \\A1\\AA14. Thus, vآ'(s) \u0026gt; vآ(s), for all s G S, illustrating policy improvement. Although in this case the new policy n' happens to be optimal, in general only an improvement is guaranteed.\n4.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Iteration\nOnce a policy, n, has been improved using v^ to yield a better policy, n', we can then compute v^' and improve it again to yield an even better n''. We can thus obtain a sequence of monotonically improving policies and value functions:\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nwhere \\A1\\AA^ denotes a policy evaluation and denotes a policy improvement. Each policy is guaranteed to be a strict improvement over the previous one (unless it is already optimal). Because a finite MDP has only a finite number of policies, this process must converge to an optimal policy and optimal value function in a finite number of iterations.\nThis way of finding an optimal policy is called policy iteration. A complete al\u0026shy;gorithm is given in the box on the next page.[9]Note that each policy evaluation, itself an iterative computation, is started with the value function for the previous policy. This typically results in a great increase in the speed of convergence of policy evaluation (presumably because the value function changes little from one policy to the next).\nPolicy iteration (using iterative policy evaluation)\n1.\u0026nbsp; Initialization\nV(s) G R and n(s) G A(s) arbitrarily for all s G S\n2.\u0026nbsp; Policy Evaluation Repeat\nA ^ 0\nFor each s G S: vV(s)\nV(s) \\A8D Es\\A1\\A2rp(s', r|s, n(s)) [r ʮyV(s')]\nA \\A8D max(A, |v \\A1\\AA V(s)|) until A \u0026lt; Q (a small positive number)\n3.\u0026nbsp; Policy Improvement policy-stable \\A8D true For each s G S:\nold-action\\A8D n(s)\nn(s) \\A8D argmaxa Es\\A1\\A2rP(s', r|s, a) [r ʮyV (s')]\nIf old-action \\A1\\AA n(s), then policy-stable \\A8D false If policy-stable, then stop and return V c v* and n c n*; else go to 2\n\n\n   \u0026quot;3\n        \u0026quot;4\n\n        V,\n\n        \u0026quot;2\n\n        \\C1\\EDUOCBOOI JSJIM\\A1\\AAһcc3JCC0# 0\n              \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 4.2: The sequence of policies found by policy iteration on Jack\\A1\\AFs car rental problem, and the final state-value function. The first five diagrams show, for each number of cars at each location at the end of the day, the number of cars to be moved from the first location to the second (negative numbers indicate transfers from the second location to the first). Each successive policy is a strict improvement over the previous policy, and the last policy is optimal.\nbe moved from one location to the other in one night. We take the discount rate to be Y = 0.9 and formulate this as a continuing finite MDP, where the time steps are days, the state is the number of cars at each location at the end of the day, and the actions are the net numbers of cars moved between the two locations overnight. Figure 4.2 shows the sequence of policies found by policy iteration starting from the policy that never moves any cars.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 4.4 (programming) Write a program for policy iteration and re-solve Jack\\A1\\AFs car rental problem with the following changes. One of Jack\\A1\\AFs employees at the first location rides a bus home each night and lives near the second location. She is happy to shuttle one car to the second location for free. Each additional car still costs $2, as do all cars moved in the other direction. In addition, Jack has limited parking space at each location. If more than 10 cars are kept overnight at a location (after any moving of cars), then an additional cost of $4 must be incurred to use a second parking lot (independent of how many cars are kept there). These sorts of nonlinearities and arbitrary dynamics often occur in real problems and cannot easily be handled by optimization methods other than dynamic programming. To check your program, first replicate the results given for the original problem. If your computer is too slow for the full problem, cut all the numbers of cars in half. \\A1\\F5\n \nExercise 4.5 How would policy iteration be defined for action values? Give a complete algorithm for computing q*, analogous to that on page 89 for computing\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *. Please pay special attention to this exercise, because the ideas involved will be used throughout the rest of the book.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 4.6 Suppose you are restricted to considering only policies that are e-soft, meaning that the probability of selecting each action in each state, s, is at least e/|A(s)|. Describe qualitatively the changes that would be required in each of the steps 3, 2, and 1, in that order, of the policy iteration algorithm for V* (page 89). \\A1\\F5\n4.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Value Iteration\nOne drawback to policy iteration is that each of its iterations involves policy eval\u0026shy;uation, which may itself be a protracted iterative computation requiring multiple sweeps through the state set. If policy evaluation is done iteratively, then conver\u0026shy;gence exactly to Vn occurs only in the limit. Must we wait for exact convergence, or can we stop short of that? The example in Figure 4.1 certainly suggests that it may be possible to truncate policy evaluation. In that example, policy evaluation iterations beyond the first three have no effect on the corresponding greedy policy.\nIn fact, the policy evaluation step of policy iteration can be truncated in several ways without losing the convergence guarantees of policy iteration. One important special case is when policy evaluation is stopped after just one sweep (one backup of each state). This algorithm is called value iteration. It can be written as a particularly simple backup operation that combines the policy improvement and truncated policy evaluation steps:\nVkʮ1(s)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; = maxE[Ri+1+ 7%(Sw) | Si = s, Ai = a]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (4.10)\na\n=ma^7p(s', r|s, a) r + 7Vk(s'),\na\ns,\\A3\\ACr\nfor all s G S. For arbitrary Vo, the sequence {Vk} can be shown to converge to V* under the same conditions that guarantee the existence of V*.\nAnother way of understanding value iteration is by reference to the Bellman op\u0026shy;timality equation (4.1). Note that value iteration is obtained simply by turning the Bellman optimality equation into an update rule. Also note how the value iteration backup is identical to the policy evaluation backup (4.5) except that it requires the maximum to be taken over all actions. Another way of seeing this close relationship is to compare the backup diagrams for these algorithms: Figure 3.4 (left) shows the backup diagram for policy evaluation and Figure 3.7 (left) shows the backup diagram for value iteration. These two are the natural backup operations for computing Vn and V*.\nFinally, let us consider how value iteration terminates. Like policy evaluation, value iteration formally requires an infinite number of iterations to converge exactly to V*. In practice, we stop once the value function changes by only a small amount\nValue iteration\nInitialize array V arbitrarily (e.g., V(s) \\A1\\AA 0 for all s G S+)\nRepeat A \\A8D 0\nFor each s G S: v \\A8D V(s)\nV(s) \\A8D maxaEsV p(s',r|s,a) [r ʮyV (s')]\nA \\A8D max(A, |v \\A1\\AA V(s)|) until A \u0026lt; Q (a small positive number)\nOutput a deterministic policy, n c [*, such that n(s) \\A1\\AA argmaxa Es\\A1\\A2rP(s', r|s, a) [r ʮyV (s')]\nin a sweep. The box shows a complete algorithm with this kind of termination condition.\nValue iteration effectively combines, in each of its sweeps, one sweep of policy evaluation and one sweep of policy improvement. Faster convergence is often achieved by interposing multiple policy evaluation sweeps between each policy improvement sweep. In general, the entire class of truncated policy iteration algorithms can be thought of as sequences of sweeps, some of which use policy evaluation backups and some of which use value iteration backups. Since the max operation in (4.10) is the only difference between these backups, this just means that the max operation is added to some sweeps of policy evaluation. All of these algorithms converge to an optimal policy for discounted finite MDPs.\nExample 4.3: Gambler\\A1\\AFs Problem A gambler has the opportunity to make bets on the outcomes of a sequence of coin flips. If the coin comes up heads, he wins as many dollars as he has staked on that flip; if it is tails, he loses his stake. The game ends when the gambler wins by reaching his goal of $100, or loses by running out of money. On each flip, the gambler must decide what portion of his capital to stake, in integer numbers of dollars. This problem can be formulated as an undiscounted, episodic, finite MDP. The state is the gambler\\A1\\AFs capital, s G {1, 2,..., 99} and the actions are stakes, a G {0,1,..., min(s, 100\\A1\\AAs)}. The reward is zero on all transitions except those on which the gambler reaches his goal, when it is ʮ1. The state-value function then gives the probability of winning from each state. A policy is a mapping from levels of capital to stakes. The optimal policy maximizes the probability of reaching the goal. Let ph denote the probability of the coin coming up heads. If ph is known, then the entire problem is known and it can be solved, for instance, by value iteration. Figure 4.3 shows the change in the value function over successive sweeps of value iteration, and the final policy found, for the case of ph \\A1\\AA 0.4. This policy is optimal, but not unique. In fact, there is a whole family of optimal policies, all corresponding to ties for the argmax action selection with respect to the optimal\n\\A1\\F6\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n value function. Can you guess what the entire family looks like?\ni\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Value\nestimates\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Capital\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nFinal\n3U\npolicy (stake) 20\n10\n1\n\n\n   50\n        25\n        75\n        99\n        1\n     \u0026nbsp;\n Capital\nFigure 4.3: The solution to the gambler\\A1\\AFs problem for ph = 0.4. The upper graph shows the value function found by successive sweeps of value iteration. The lower graph shows the final policy.\nExercise 4.7 Why does the optimal policy for the gambler\\A1\\AFs problem have such a curious form? In particular, for capital of 50 it bets it all on one flip, but for capital of 51 it does not. Why is this a good policy?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 4.8 (programming) Implement value iteration for the gambler\\A1\\AFs problem and solve it for ph = 0.25 and ph = 0.55. In programming, you may find it convenient to introduce two dummy states corresponding to termination with capital of 0and 100, giving them values of 0 and 1 respectively. Show your results graphically, as in Figure 4.3. Are your results stable as Q 0?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 4.9 What is the analog of the value iteration backup (4.10) for action values, qkʮ1(s, a)?\u0026nbsp;\u0026nbsp; \\A1\\F5\n4.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Asynchronous Dynamic Programming\nA major drawback to the DP methods that we have discussed so far is that they involve operations over the entire state set of the MDP, that is, they require sweeps of the state set. If the state set is very large, then even a single sweep can be prohibitively expensive. For example, the game of backgammon has over 1020states.\nEven if we could perform the value iteration backup on a million states per second, it would take over a thousand years to complete a single sweep.\nAsynchronousDP algorithms are in-place iterative DP algorithms that are not organized in terms of systematic sweeps of the state set. These algorithms back up the values of states in any order whatsoever, using whatever values of other states happen to be available. The values of some states may be backed up several times before the values of others are backed up once. To converge correctly, however, an asynchronous algorithm must continue to backup the values of all the states: it can\\A1\\AFt ignore any state after some point in the computation. Asynchronous DP algorithms allow great flexibility in selecting states to which backup operations are applied.\nFor example, one version of asynchronous value iteration backs up the value, in place, of only one state, sk, on each step, k, using the value iteration backup (4.10). If 0 \u0026lt; y \u0026lt; 1, asymptotic convergence to v* is guaranteed given only that all states occur in the sequence {sk} an infinite number of times (the sequence could even be stochastic). (In the undiscounted episodic case, it is possible that there are some orderings of backups that do not result in convergence, but it is relatively easy to avoid these.) Similarly, it is possible to intermix policy evaluation and value iteration backups to produce a kind of asynchronous truncated policy iteration. Although the details of this and other more unusual DP algorithms are beyond the scope of this book, it is clear that a few different backups form building blocks that can be used flexibly in a wide variety of sweepless DP algorithms.\nOf course, avoiding sweeps does not necessarily mean that we can get away with less computation. It just means that an algorithm does not need to get locked into any hopelessly long sweep before it can make progress improving a policy. We can try to take advantage of this flexibility by selecting the states to which we apply backups so as to improve the algorithm\\A1\\AFs rate of progress. We can try to order the backups to let value information propagate from state to state in an efficient way. Some states may not need their values backed up as often as others. We might even try to skip backing up some states entirely if they are not relevant to optimal behavior. Some ideas for doing this are discussed in Chapter 8.\nAsynchronous algorithms also make it easier to intermix computation with real\u0026shy;time interaction. To solve a given MDP, we can run an iterative DP algorithm at the same time that an agent is actually experiencing the MDP. The agent\\A1\\AFs experience can be used to determine the states to which the DP algorithm applies its backups. At the same time, the latest value and policy information from the DP algorithm can guide the agent\\A1\\AFs decision-making. For example, we can apply backups to states as the agent visits them. This makes it possible to focus the DP algorithm\\A1\\AFs backups onto parts of the state set that are most relevant to the agent. This kind of focusing is a repeated theme in reinforcement learning.\n \n4.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Generalized Policy Iteration\nPolicy iteration consists of two simultaneous, interacting processes, one making the value function consistent with the current policy (policy evaluation), and the other making the policy greedy with respect to the current value function (policy improve\u0026shy;ment). In policy iteration, these two processes alternate, each completing before the other begins, but this is not really necessary. In value iteration, for example, only a single iteration of policy evaluation is performed in between each policy improve\u0026shy;ment. In asynchronous DP methods, the evaluation and improvement processes are interleaved at an even finer grain. In some cases a single state is updated in one process before returning to the other. As long as both processes continue to update all states, the ultimate result is typically the same\\A1\\AAconvergence to the optimal value function and an optimal policy.\nWe use the term generalized policy iteration (GPI) to refer to the general idea of letting policy evaluation and policy im\u0026shy;provement processes interact, independent of the granularity and other details of the two processes. Almost all reinforce\u0026shy;ment learning methods are well described as GPI. That is, all have identifiable policies and value functions, with the pol\u0026shy;icy always being improved with respect to the value function and the value function always being driven toward the value function for the policy, as suggested by the diagram to the right. It is easy to see that if both the evaluation process and the improvement process stabilize, that is, no longer produce changes, then the value function and policy must be optimal.\nThe value function stabilizes only when it is consistent with the current policy, and the policy stabilizes only when it is greedy with respect to the current value function. Thus, both processes stabilize only when a policy has been found that is greedy with respect to its own evaluation function. This implies that the Bellman optimality equation (4.1) holds, and thus that the policy and the value function are optimal.\nThe evaluation and improvement processes in GPI can be viewed as both compet\u0026shy;ing and cooperating. They compete in the sense that they pull in opposing directions. Making the policy greedy with respect to the value function typically makes the value function incorrect for the changed policy, and making the value function consistent with the policy typically causes that policy no longer to be greedy. In the long run, however, these two processes interact to find a single joint solution: the optimal value function and an optimal policy.\nOne might also think of the inter\u0026shy;action between the evaluation and im\u0026shy;provement processes in GPI in terms of two constraints or goals\\A1\\AAfor example, as two lines in two-dimensional space as suggested by the diagram to the right.\nAlthough the real geometry is much more complicated than this, the diagram suggests what happens in the real case.\nEach process drives the value function\nor policy toward one of the lines representing a solution to one of the two goals. The goals interact because the two lines are not orthogonal. Driving directly toward one goal causes some movement away from the other goal. Inevitably, however, the joint process is brought closer to the overall goal of optimality. The arrows in this diagram correspond to the behavior of policy iteration in that each takes the system all the way to achieving one of the two goals completely. In GPI one could also take smaller, incomplete steps toward each goal. In either case, the two processes together achieve the overall goal of optimality even though neither is attempting to achieve it directly.\n4.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Efficiency of Dynamic Programming\nDP may not be practical for very large problems, but compared with other methods for solving MDPs, DP methods are actually quite efficient. If we ignore a few tech\u0026shy;nical details, then the (worst case) time DP methods take to find an optimal policy is polynomial in the number of states and actions. If n and k denote the number of states and actions, this means that a DP method takes a number of computational operations that is less than some polynomial function of n and k. A DP method is guaranteed to find an optimal policy in polynomial time even though the total number of (deterministic) policies is kn. In this sense, DP is exponentially faster than any direct search in policy space could be, because direct search would have to exhaustively examine each policy to provide the same guarantee. Linear program\u0026shy;ming methods can also be used to solve MDPs, and in some cases their worst-case convergence guarantees are better than those of DP methods. But linear program\u0026shy;ming methods become impractical at a much smaller number of states than do DP methods (by a factor of about 100). For the largest problems, only DP methods are feasible.\nDP is sometimes thought to be of limited applicability because of the curse of dimensionality, the fact that the number of states often grows exponentially with the number of state variables. Large state sets do create difficulties, but these are inherent difficulties of the problem, not of DP as a solution method. In fact, DP is comparatively better suited to handling large state spaces than competing methods such as direct search and linear programming.\nIn practice, DP methods can be used with today\\A1\\AFs computers to solve MDPs with millions of states. Both policy iteration and value iteration are widely used, and itis not clear which, if either, is better in general. In practice, these methods usually converge much faster than their theoretical worst-case run times, particularly if they are started with good initial value functions or policies.\nOn problems with large state spaces, asynchronous DP methods are often pre\u0026shy;ferred. To complete even one sweep of a synchronous method requires computation and memory for every state. For some problems, even this much memory and compu\u0026shy;tation is impractical, yet the problem is still potentially solvable because relatively few states occur along optimal solution trajectories. Asynchronous methods and other variations of GPI can be applied in such cases and may find good or optimal policies much faster than synchronous methods can.\n4.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nIn this chapter we have become familiar with the basic ideas and algorithms of dynamic programming as they relate to solving finite MDPs. Policy evaluation refers to the (typically) iterative computation of the value functions for a given policy. Policy improvement refers to the computation of an improved policy given the value function for that policy. Putting these two computations together, we obtain policy iteration and value iteration, the two most popular DP methods. Either of these can be used to reliably compute optimal policies and value functions for finite MDPs given complete knowledge of the MDP.\nClassical DP methods operate in sweeps through the state set, performing a full backup operation on each state. Each backup updates the value of one state based on the values of all possible successor states and their probabilities of occurring. Full backups are closely related to Bellman equations: they are little more than these equations turned into assignment statements. When the backups no longer result in any changes in value, convergence has occurred to values that satisfy the corre\u0026shy;sponding Bellman equation. Just as there are four primary value functions (v^, v*, qn, and q*), there are four corresponding Bellman equations and four correspond\u0026shy;ing full backups. An intuitive view of the operation of backups is given by backup diagrams.\nInsight into DP methods and, in fact, into almost all reinforcement learning meth\u0026shy;ods, can be gained by viewing them as generalized policy iteration (GPI). GPI is the general idea of two interacting processes revolving around an approximate policy and an approximate value function. One process takes the policy as given and performs some form of policy evaluation, changing the value function to be more like the true value function for the policy. The other process takes the value function as given and performs some form of policy improvement, changing the policy to make it bet\u0026shy;ter, assuming that the value function is its value function. Although each process changes the basis for the other, overall they work together to find a joint solution: a policy and value function that are unchanged by either process and, consequently, are optimal. In some cases, GPI can be proved to converge, most notably for the classical DP methods that we have presented in this chapter. In other cases conver\u0026shy;gence has not been proved, but still the idea of GPI improves our understanding of the methods.\nIt is not necessary to perform DP methods in complete sweeps through the state set. Asynchronous DP methods are in-place iterative methods that back up states in an arbitrary order, perhaps stochastically determined and using out-of-date infor\u0026shy;mation. Many of these methods can be viewed as fine-grained forms of GPI.\nFinally, we note one last special property of DP methods. All of them update estimates of the values of states based on estimates of the values of successor states. That is, they update estimates on the basis of other estimates. We call this general idea bootstrapping. Many reinforcement learning methods perform bootstrapping, even those that do not require, as DP requires, a complete and accurate model of the environment. In the next chapter we explore reinforcement learning methods that do not require a model and do not bootstrap. In the chapter after that we explore methods that do not require a model but do bootstrap. These key features and properties are separable, yet can be mixed in interesting combinations.\nBibliographical and Historical Remarks\nThe term \\A1\\B0dynamic programming\\A1\\B1 is due to Bellman (1957a), who showed how these methods could be applied to a wide range of problems. Extensive treatments of DP can be found in many texts, including Bertsekas (2005, 2012), Bertsekas and Tsitsiklis (1996), Dreyfus and Law (1977), Ross (1983), White (1969), and Whittle (1982, 1983). Our interest in DP is restricted to its use in solving MDPs, but DP also applies to other types of problems. Kumar and Kanal (1988) provide a more general look at DP.\nTo the best of our knowledge, the first connection between DP and reinforcement learning was made by Minsky (1961) in commenting on Samuel\\A1\\AFs checkers player. In a footnote, Minsky mentioned that it is possible to apply DP to problems in which Samuel\\A1\\AFs backing-up process can be handled in closed analytic form. This remark may have misled artificial intelligence researchers into believing that DP was restricted to analytically tractable problems and therefore largely irrelevant to arti\u0026shy;ficial intelligence. Andreae (1969b) mentioned DP in the context of reinforcement learning, specifically policy iteration, although he did not make specific connections between DP and learning algorithms. Werbos (1977) suggested an approach to ap\u0026shy;proximating DP called \\A1\\B0heuristic dynamic programming\\A1\\B1 that emphasizes gradient- descent methods for continuous-state problems (Werbos, 1982, 1987, 1988, 1989, 1992). These methods are closely related to the reinforcement learning algorithms that we discuss in this book. Watkins (1989) was explicit in connecting reinforce\u0026shy;ment learning to DP, characterizing a class of reinforcement learning methods as \\A1\\B0incremental dynamic programming.\\A1\\B1\n4.1-4 These sections describe well-established DP algorithms that are covered in any of the general DP references cited above. The policy improvement the\u0026shy;orem and the policy iteration algorithm are due to Bellman (1957a) and\n \nHoward (1960). Our presentation was influenced by the local view of policy improvement taken by Watkins (1989). Our discussion of value iteration as a form of truncated policy iteration is based on the approach of Puterman and Shin (1978), who presented a class of algorithms called modified policy itera\u0026shy;tion, which includes policy iteration and value iteration as special cases. An analysis showing how value iteration can be made to find an optimal policy in finite time is given by Bertsekas (1987).\nIterative policy evaluation is an example of a classical successive approxima\u0026shy;tion algorithm for solving a system of linear equations. The version of the algorithm that uses two arrays, one holding the old values while the other is updated, is often called a Jacobi-style algorithm, after Jacobi\\A1\\AFs classical use of this method. It is also sometimes called a synchronous algorithm be\u0026shy;cause it can be performed in parallel, with separate processors simultaneously updating the values of individual states using input from other processors. The second array is needed to simulate this parallel computation sequentially. The in-place version of the algorithm is often called a Gauss-Seidel-style algo\u0026shy;rithm after the classical Gauss-Seidel algorithm for solving systems of linear equations. In addition to iterative policy evaluation, other DP algorithms can be implemented in these different versions. Bertsekas and Tsitsiklis (1989) provide excellent coverage of these variations and their performance differ\u0026shy;ences.\n4.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Asynchronous DP algorithms are due to Bertsekas (1982, 1983), who also called them distributed DP algorithms. The original motivation for asyn\u0026shy;chronous DP was its implementation on a multiprocessor system with com\u0026shy;munication delays between processors and no global synchronizing clock. These algorithms are extensively discussed by Bertsekas and Tsitsiklis (1989). Jacobi-style and Gauss-Seidel-style DP algorithms are special cases of the asynchronous version. Williams and Baird (1990) presented DP algorithms that are asynchronous at a finer grain than the ones we have discussed: the backup operations themselves are broken into steps that can be performed asynchronously.\n4.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; This section, written with the help of Michael Littman, is based on Littman, Dean, and Kaelbling (1995). The phrase \\A1\\B0curse of dimensionality\\A1\\B1 is due to Bellman (1957).\n100\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER4.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; DYNAMIC\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; PROGRAMMING\n \nChapter 5\nMonte Carlo Methods\nIn this chapter we consider our first learning methods for estimating value functions and discovering optimal policies. Unlike the previous chapter, here we do not as\u0026shy;sume complete knowledge of the environment. Monte Carlo methods require only experience\\A1\\AAsample sequences of states, actions, and rewards from actual or simu\u0026shy;lated interaction with an environment. Learning from actual experience is striking because it requires no prior knowledge of the environment\\A1\\AFs dynamics, yet can still attain optimal behavior. Learning from simulated experience is also powerful. Al\u0026shy;though a model is required, the model need only generate sample transitions, not the complete probability distributions of all possible transitions that is required for dynamic programming (DP). In surprisingly many cases it is easy to generate expe\u0026shy;rience sampled according to the desired probability distributions, but infeasible to obtain the distributions in explicit form.\nMonte Carlo methods are ways of solving the reinforcement learning problem based on averaging sample returns. To ensure that well-defined returns are available, here we define Monte Carlo methods only for episodic tasks. That is, we assume experience is divided into episodes, and that all episodes eventually terminate no matter what actions are selected. Only on the completion of an episode are value estimates and policies changed. Monte Carlo methods can thus be incremental in an episode-by- episode sense, but not in a step-by-step (online) sense. The term \\A1\\B0Monte Carlo\\A1\\B1 is often used more broadly for any estimation method whose operation involves a significant random component. Here we use it specifically for methods based on averaging complete returns (as opposed to methods that learn from partial returns, considered in the next chapter).\nMonte Carlo methods sample and average returns for each state-action pair much like the bandit methods we explored in Chapter 2 sample and average rewards for each action. The main difference is that now there are multiple states, each acting like a different bandit problem (like an associative-search or contextual bandit) and that the different bandit problems are interrelated. That is, the return after taking an action in one state depends on the actions taken in later states in the same episode. Because all the action selections are undergoing learning, the problem becomes nonstationary from the point of view of the earlier state.\n \nTo handle the nonstationarity, we adapt the idea of general policy iteration (GPI) developed in Chapter 4 for DP. Whereas there we computedvalue functions from knowledge of the MDP, here we learnvalue functions from sample returns with the MDP. The value functions and corresponding policies still interact to attain optimality in essentially the same way (GPI). As in the DP chapter, first we consider the prediction problem (the computation of Vn and q^ for a fixed arbitrary policy n) then policy improvement, and, finally, the control problem and its solution by GPI. Each of these ideas taken from DP is extended to the Monte Carlo case in which only sample experience is available.\n5.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Prediction\nWe begin by considering Monte Carlo methods for learning the state-value function for a given policy. Recall that the value of a state is the expected return\\A1\\AAexpected cumulative future discounted reward\\A1\\AAstarting from that state. An obvious way to estimate it from experience, then, is simply to average the returns observed after visits to that state. As more returns are observed, the average should converge to the expected value. This idea underlies all Monte Carlo methods.\nIn particular, suppose we wish to estimate Vn(s), the value of a state s under policy n, given a set of episodes obtained by following n and passing through s. Each occurrence of state s in an episode is called a visitto s. Of course, s may be visited multiple times in the same episode; let us call the first time it is visited in an episode the first visitto s. The first-visit MC methodestimates Vآ(s) as the average of the returns following first visits to s, whereas the every-visit MC method averages the returns following all visits to s. These two Monte Carlo (MC) methods are very similar but have slightly different theoretical properties. First-visit MC has been most widely studied, dating back to the 1940s, and is the one we focus on in this chapter. Every-visit MC extends more naturally to function approximation and eligibility traces, as discussed in Chapters 9 and 12. First-visit MC is shown in procedural form in the box.\nFirst-visit MC prediction, for estimating V \\B0\\D1\nInitialize:\nn \\A8D policy to be evaluated V \\A8D an arbitrary state-value function Returns(s) \\A8D an empty list, for all s G \\B8\\F7\nRepeat forever:\nGenerate an episode using n\nFor each state s appearing in the episode:\nG\\A8D return following the first occurrence of s Append G to Returns(s)\nV(s) \\A8D average(Returns(s))\nBoth first-visit MC and every-visit MC converge to v^(s) as the number of visits (or first visits) to s goes to infinity. This is easy to see for the case of first-visit MC. In this case each return is an independent, identically distributed estimate of vn (s) with finite variance. By the law of large numbers the sequence of averages of these estimates converges to their expected value. Each average is itself an unbiased estimate, and the standard deviation of its error falls as 1/y/n, where n is the number of returns averaged (i.e., the estimate is said to converge quadratically). Every-visit MC is less straightforward, but its estimates also converge quadratically to v^(s) (Singh and Sutton, 1996).\nThe use of Monte Carlo methods is best illustrated through an example.\nExample 5.1: Blackjack The object of the popular casino card game of blackjack is to obtain cards the sum of whose numerical values is as great as possible without exceeding 21. All face cards count as 10, and an ace can count either as 1or as 11. We consider the version in which each player competes independently against the dealer. The game begins with two cards dealt to both dealer and player. One of the dealer\\A1\\AFs cards is face up and the other is face down. If the player has 21 immediately (an ace and a 10-card), it is called a natural. He then wins unless the dealer also has a natural, in which case the game is a draw. If the player does not have a natural, then he can request additional cards, one by one (hits), until he either stops (sticks) or exceeds 21 (goes bust). If he goes bust, he loses; if he sticks, then it becomes the dealer\\A1\\AFs turn. The dealer hits or sticks according to a fixed strategy without choice: he sticks on any sum of 17 or greater, and hits otherwise. If the dealer goes bust, then the player wins; otherwise, the outcome\\A1\\AAwin, lose, or draw\\A1\\AAis determined by whose final sum is closer to 21.\nPlaying blackjack is naturally formulated as an episodic finite MDP. Each game of blackjack is an episode. Rewards of +1, \\A1\\AA1, and 0 are given for winning, losing, and drawing, respectively. All rewards within a game are zero, and we do not discount (Y = 1); therefore these terminal rewards are also the returns. The player\\A1\\AFs actions are to hit or to stick. The states depend on the player\\A1\\AFs cards and the dealer\\A1\\AFs showing card. We assume that cards are dealt from an infinite deck (i.e., with replacement) so that there is no advantage to keeping track of the cards already dealt. If the player holds an ace that he could count as 11without going bust, then the ace is said to be usable. In this case it is always counted as 11 because counting it as 1 would make the sum 11or less, in which case there is no decision to be made because, obviously, the player should always hit. Thus, the player makes decisions on the basis of three variables: his current sum (12-21), the dealer\\A1\\AFs one showing card (ace-10), and whether or not he holds a usable ace. This makes for a total of 200 states.\nConsider the policy that sticks if the player\\A1\\AFs sum is 20 or 21, and otherwise hits. To find the state-value function for this policy by a Monte Carlo approach, one simulates many blackjack games using the policy and averages the returns following each state. Note that in this task the same state never recurs within one episode, so there is no difference between first-visit and every-visit MC methods. In this way, we obtained the estimates of the state-value function shown in Figure 5.1. The estimates for states with a usable ace are less certain and less regular because these\n \n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Usable\nace\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n   After 500,000 episodes\n        +1\n        \nTO\n     \n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n No\nusable\nace\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\n\u0026nbsp;\n\u0026nbsp;\n \nFigure 5.1: Approximate state-value functions for the blackjack policy that sticks only on 20 or 21, computed by Monte Carlo policy evaluation.\nstates are less common. In any event, after 500,000 games the value function is very well approximated.\nAlthough we have complete knowledge of the environment in this task, it would not be easy to apply DP methods to compute the value function. DP methods require the distribution of next eventsһin particular, they require the quantities p(s', r|s, a)\\A1\\AAand it is not easy to determine these for blackjack. For example, suppose the player\\A1\\AFs sum is 14 and he chooses to stick. What is his expected reward as a function of the dealer\\A1\\AFs showing card? All of these expected rewards and transition probabilities must be computed before DP can be applied, and such computations are often complex and error-prone. In contrast, generating the sample games required by Monte Carlo methods is easy. This is the case surprisingly often; the ability of Monte Carlo methods to work with sample episodes alone can be a significant advantage even when one has complete knowledge of the environment\\A1\\AFs dynamics.\nCan we generalize the idea of backup diagrams to Monte Carlo algorithms? The general idea of a backup diagram is to show at the top the root node to be updated and to show below all the transitions and leaf nodes whose rewards and estimated values contribute to the update. For Monte Carlo estimation of v^, the root is a state node, and below it is the entire trajectory of transitions along a particular single episode, ending at the terminal state, as in Figure 5.2. Whereas the DP diagram (Figure 3.4-left) shows all possible transitions, the Monte Carlo diagram shows only those sampled on the one episode. Whereas the DP diagram includes only one-step transitions, the Monte Carlo diagram goes all the way to the end of the episode. These differences in the diagrams accurately reflect the fundamental differences between the algorithms.\nFigure 5.2: The backup diagram for Monte Carlo estimation of Vn.\nAn important fact about Monte Carlo methods is that the estimates for each state are independent. The estimate for one state does not build upon the estimate of any other state, as is the case in DP. In other words, Monte Carlo methods do not bootstrap as we defined it in the previous chapter.\nIn particular, note that the computational expense of estimating the value of a single state is independent of the number of states. This can make Monte Carlo methods particularly attractive when one requires the value of only one or a subset of states. One can generate many sample episodes starting from the states of interest, averaging returns from only these states ignoring all others. This is a third advantage Monte Carlo methods can have over DP methods (after the ability to learn from actual experience and from simulated experience).\n   \nA bubble on a wire loop\n     Example 5.2: Soap Bubble\nSuppose a wire frame forming a closed loop is dunked in soapy water to form a soap surface or bubble conforming at its edges to the wire frame. If the geometry of the wire frame is irregular but known, how can you compute the shape of the surface? The shape has the property that the total force on each point exerted by neighboring points is zero (or else the shape would change). This means that the surface\\A1\\AFs height at any point is the aver\u0026shy;age of its heights at points in a small circle around that point. In addition, the surface must meet at its boundaries with the wire frame. The usual approach to problems of this kind is to put a grid over the area covered by the surface and solve for its height at the grid points by an iterative computation. Grid points at the boundary areforced\u0026nbsp;\u0026nbsp;\u0026nbsp; to\u0026nbsp;\u0026nbsp;\u0026nbsp; the\u0026nbsp;\u0026nbsp;\u0026nbsp; wire\u0026nbsp; frame,and\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; all\nothers are adjusted toward the average of the heightsof their four nearest neighbors.\n \nThis process then iterates, much like DP\\A1\\AFs iterative policy evaluation, and ultimately converges to a close approximation to the desired surface.\nThis is similar to the kind of problem for which Monte Carlo methods were origi\u0026shy;nally designed. Instead of the iterative computation described above, imagine stand\u0026shy;ing on the surface and taking a random walk, stepping randomly from grid point to neighboring grid point, with equal probability, until you reach the boundary. It turns out that the expected value of the height at the boundary is a close approximation to the height of the desired surface at the starting point (in fact, it is exactly the value computed by the iterative method described above). Thus, one can closely approximate the height of the surface at a point by simply averaging the bound\u0026shy;ary heights of many walks started at the point. If one is interested in only the value at one point, or any fixed small set of points, then this Monte Carlo method can be far more efficient than the iterative method based on local consistency.\n\\A1\\F6\nExercise 5.1 Consider the diagrams on the right in Figure 5.1. Why does the estimated value function jump up for the last two rows in the rear? Why does it drop off for the whole last row on the left? Why are the frontmost values higher in the upper diagrams than in the lower?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n5.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Estimation of Action Values\nIf a model is not available, then it is particularly useful to estimate action values (the values of state-action pairs) rather than state values. With a model, state values alone are sufficient to determine a policy; one simply looks ahead one step and chooses whichever action leads to the best combination of reward and next state, as we did in the chapter on DP. Without a model, however, state values alone are not sufficient. One must explicitly estimate the value of each action in order for the values to be useful in suggesting a policy. Thus, one of our primary goals for Monte Carlo methods is to estimate q*. To achieve this, we first consider the policy evaluation problem for action values.\nThe policy evaluation problem for action values is to estimate q^(s, a), the expected return when starting in state s, taking action a, and thereafter following policy n. The Monte Carlo methods for this are essentially the same as just presented for state values, except now we talk about visits to a state-action pair rather than to a state. A state-action pair s, a is said to be visited in an episode if ever the state s is visited and action a is taken in it. The every-visit MC method estimates the value of a state-action pair as the average of the returns that have followed all the visits to it. The first-visit MC method averages the returns following the first time in each episode that the state was visited and the action was selected. These methods converge quadratically, as before, to the true expected values as the number of visits to each state-action pair approaches infinity.\nThe only complication is that many state-action pairs may never be visited. If n is a deterministic policy, then in following n one will observe returns only for\n \n   one of the actions from each state. With no returns to average, the Monte Carlo estimates of the other actions will not improve with experience. This is a serious problem because the purpose of learning action values is to help in choosing among the actions available in each state. To compare alternatives we need to estimate the value of allthe actions from each state, not just the one we currently favor.\nThis is the general problem of maintaining exploration, as discussed in the context of the k-armed bandit problem in Chapter 2. For policy evaluation to work for action values, we must assure continual exploration. One way to do this is by specifying that the episodes start in a state-action pair, and that every pair has a nonzero probability of being selected as the start. This guarantees that all state-action pairs will be visited an infinite number of times in the limit of an infinite number of episodes. We call this the assumption of exploring starts.\nThe assumption of exploring starts is sometimes useful, but of course it cannot be relied upon in general, particularly when learning directly from actual interaction with an environment. In that case the starting conditions are unlikely to be so helpful. The most common alternative approach to assuring that all state-action pairs are encountered is to consider only policies that are stochastic with a nonzero probability of selecting all actions in each state. We discuss two important variants of this approach in later sections. For now, we retain the assumption of exploring starts and complete the presentation of a full Monte Carlo control method.\nExercise 5.2 What is the backup diagram for Monte Carlo estimation of \\BF\\DB\\A3\\BF\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n        5.3 Monte Carlo Control\nWe are now ready to consider how Monte Carlo estimation can be used in control, that is, to approximate optimal poli\u0026shy;cies. The overall idea is to proceed according to the same pattern as in the DP chapter, that is, according to the idea of generalized policy iteration (GPI). In GPI one maintains both an approximate policy and an approximate value func\u0026shy;tion. The value function is repeatedly altered to more closely approximate the value function for the current policy, and the policy is repeatedly improved with respect to the current value function, as suggested by the diagram to the right. These two kinds of changes work against each other to some extent, as each creates a mov\u0026shy;ing target for the other, but together they cause both policy and value function to approach optimality.\nTo begin, let us consider a Monte Carlo version of classical policy iteration. In this method, we perform alternating complete steps of policy evaluation and policy improvement, beginning with an arbitrary policy no and ending with the optimal policy and optimal action-value function:\n        evaluation\n        ^\\^^greedy(Q)/\n        Q\n        آ\n        improvement\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TP\n   q*,\n        no\n     -- \\A1\\A2qno - \\A1\\A2آ1\\A1\\A2Qni- \\A1\\A2n2-- \\A1\\A2' ' '\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\A2n* \u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\A2\n \nwhere \\A1\\AA^ denotes a complete policy evaluation and \\A1\\AA^ denotes a complete pol\u0026shy;icy improvement. Policy evaluation is done exactly as described in the preceding section. Many episodes are experienced, with the approximate action-value func\u0026shy;tion approaching the true function asymptotically. For the moment, let us assume that we do indeed observe an infinite number of episodes and that, in addition, the episodes are generated with exploring starts. Under these assumptions, the Monte Carlo methods will compute each q^fc exactly, for arbitrary nk.\nPolicy improvement is done by making the policy greedy with respect to the current value function. In this case we have an action-value function, and therefore no model is needed to construct the greedy policy. For any action-value function q, the corresponding greedy policy is the one that, for each s G S, deterministically chooses an action with maximal action-value:\nn(s) == argmaxq(s, a).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.1)\n \n\u0026nbsp;\n \nPolicy improvement then with respect to q^fc. The آk and nkʮ1because, for\nqnfc (s,أ\u0026amp;ʮ1(s))=\n\u0026gt;\u0026nbsp;\n\u0026gt;\u0026nbsp;\ncan be done by constructing each nkʮ1as the greedy policy policy improvement theorem (Section 4.2) then applies to all s G S,\nqnfc (s, argmaxq^fc (s,a))\na\nmax qnk (s, a)\na\nqnk (s, nk (s))\nVnfc(s).\n \n\u0026nbsp;\n \nAs we discussed in the previous chapter, the theorem assures us that each nkʮ1is uniformly better than nk, or just as good as nk, in which case they are both optimal policies. This in turn assures us that the overall process converges to the optimal policy and optimal value function. In this way Monte Carlo methods can be used to find optimal policies given only sample episodes and no other knowledge of the environment\\A1\\AFs dynamics.\nWe made two unlikely assumptions above in order to easily obtain this guarantee of convergence for the Monte Carlo method. One was that the episodes have exploring starts, and the other was that policy evaluation could be done with an infinite number of episodes. To obtain a practical algorithm we will have to remove both assumptions. We postpone consideration of the first assumption until later in this chapter.\nFor now we focus on the assumption that policy evaluation operates on an infinite number of episodes. This assumption is relatively easy to remove. In fact, the same issue arises even in classical DP methods such as iterative policy evaluation, which also converge only asymptotically to the true value function. In both DP and Monte Carlo cases there are two ways to solve the problem. One is to hold firm to the idea of approximating q^fc in each policy evaluation. Measurements and assumptions are made to obtain bounds on the magnitude and probability of error in the estimates, and then sufficient steps are taken during each policy evaluation to assure that these bounds are sufficiently small. This approach can probably be made \n \ncompletely satisfactory in the sense of guaranteeing correct convergence up to some level of approximation. However, it is also likely to require far too many episodes to be useful in practice on any but the smallest problems.\nThe second approach to avoiding the infinite number of episodes nominally required for policy evaluation is to forgo trying to complete policy evaluation before returning to policy improvement. On each evaluation step we move the value function toward q^fc, but we do not expect to actually get close except over many steps. We used this idea when we first introduced the idea of GPI in Section 4.6. One extreme form of the idea is value iteration, in which only one iteration of iterative policy evaluation is performed between each step of policy improvement. The in-place version of value iteration is even more extreme; there we alternate between improvement and evaluation steps for single states.\nFor Monte Carlo policy evaluation it is natural to alternate between evaluation and improvement on an episode-by-episode basis. After each episode, the observed returns are used for policy evaluation, and then the policy is improved at all the states visited in the episode. A complete simple algorithm along these lines, which we call Monte Carlo ES, for Monte Carlo with Exploring Starts, is given in the box.\nIn Monte Carlo ES, all the returns for each state-action pair are accumulated and averaged, irrespective of what policy was in force when they were observed. It is easy to see that Monte Carlo ES cannot converge to any suboptimal policy. If it did, then the value function would eventually converge to the value function for that policy, and that in turn would cause the policy to change. Stability is achieved only when both the policy and the value function are optimal. Convergence to this optimal fixed point seems inevitable as the changes to the action-value function decrease over time, but has not yet been formally proved. In our opinion, this is one of the most fundamental open theoretical questions in reinforcement learning (for a partial solution, see Tsitsiklis, 2002).\nMonte Carlo ES (Exploring Starts), for estimating n n*\nInitialize, for all s G S, a G A(s):\nQ(s, a) ^ arbitrary n(s) ^ arbitrary Returns(s, a) ^ empty list\nRepeat forever:\nChoose So G S and Ao G A(So) s.t. all pairs have probability \u0026gt; 0 Generate an episode starting from So, Ao, following n For each pair s, a appearing in the episode:\nG^ return following the first occurrence of s, a Append G to Returns(s, a)\nQ(s, a) ^ average(Returns(s, a))\nFor each s in the episode: n(s) ^ arg max a Q(s, a)\n V*\n\u0026nbsp;\n STICK :\n 21\n20\n \u0026nbsp;\n \u0026nbsp;\n  Usable\nace\n n r\n 19\n18\n \u0026nbsp;\n \u0026nbsp;\n  HIT\n 17\n16\n15\n14\n1 3\n \u0026nbsp;\n  \u0026nbsp;\n 127^4/ 11 \\l\n        \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n A23456789 10\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n \nFigure 5.3: The optimal policy and state-value function for blackjack, found by Monte Carlo ES (Figure 5.4). The state-value function shown was computed from the action-value function found by Monte Carlo ES.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nExample 5.3: Solving Blackjack It is straightforward to apply Monte Carlo ES to blackjack. Since the episodes are all simulated games, it is easy to arrange for exploring starts that include all possibilities. In this case one simply picks the dealer\\A1\\AFs cards, the player\\A1\\AFs sum, and whether or not the player has a usable ace, all at random with equal probability. As the initial policy we use the policy evaluated in the previous blackjack example, that which sticks only on 20 or 21. The initial action-value function can be zero for all state-action pairs. Figure 5.3 shows the optimal policy for blackjack found by Monte Carlo ES. This policy is the same as the \\A1\\B0basic\\A1\\B1 strategy of Thorp (1966) with the sole exception of the leftmost notch in the policy for a usable ace, which is not present in Thorp\\A1\\AFs strategy. We are uncertain of the reason for this discrepancy, but confident that what is shown here is indeed the optimal policy for the version of blackjack we have described.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n5.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Control without Exploring Starts\nHow can we avoid the unlikely assumption of exploring starts\\A3\\BFThe only general way to ensure that all actions are selected infinitely often is for the agent to continue to select them. There are two approaches to ensuring this, resulting in what we call on-policy methods and off-policy methods. On-policy methods attempt to evaluate or improve the policy that is used to make decisions, whereas off-policy methods evaluate or improve a policy different from that used to generate the data. The Monte Carlo ES method developed above is an example of an on-policy method. In this section we show how an on-policy Monte Carlo control method can be designed that does not use the unrealistic assumption of exploring starts. Off-policy methods\n\n\nare considered in the next section.\nIn on-policy control methods the policy is generally soft, meaning that n(a|s) \u0026gt; 0 for all s G S and all a G A(s), but gradually shifted closer and closer to a deterministic optimal policy. Many of the methods discussed in Chapter 2 provide mechanisms for this. The on-policy method we present in this section uses \u0026pound;-greedy policies, meaning that most of the time they choose an action that has maximal estimated action value, but with probability \u0026pound; they instead select an action at random. That is, all nongreedy actions are given the minimal probability of selection, |^)|, and the remaining bulk of the probability, 1\\A1\\AA \u0026pound; + pfsji, is given to the greedy action. The \u0026pound;-greedy policies are examples of \u0026pound;-soft policies, defined as policies for which n(a|s) \u0026gt; |a(s)|for all states and actions, for some \u0026pound; \u0026gt; 0. Among \u0026pound;-soft policies, \u0026pound;-greedy policies are in some sense those that are closest to greedy.\nThe overall idea of on-policy Monte Carlo control is still that of GPI. As in Monte Carlo ES, we use first-visit MC methods to estimate the action-value function for the current policy. Without the assumption of exploring starts, however, we cannot sim\u0026shy;ply improve the policy by making it greedy with respect to the current value function, because that would prevent further exploration of nongreedy actions. Fortunately, GPI does not require that the policy be taken all the way to a greedy policy, only that it be moved toward a greedy policy. In our on-policy method we will move it only to an \u0026pound;-greedy policy. For any \u0026pound;-soft policy, n, any \u0026pound;-greedy policy with respect to qn is guaranteed to be better than or equal to n. The complete algorithm is given in the box below.\nThat any \u0026pound;-greedy policy with respect to q^ is an improvement over any \u0026pound;-soft policy n is assured by the policy improvement theorem. Let n' be the \u0026pound;-greedy policy. The conditions of the policy improvement theorem apply because for any\ni-policy first-visit MC control (for \u0026pound;-soft policies), estimates n n*\nInitialize, for all s G S, a G A(s):\nQ(s, a) ^ arbitrary Returns(s, a) ^ empty list n(a|s) ^ an arbitrary \u0026pound;-soft policy\nRepeat forever:\n(a)Generate an episode using n\n(b)For each pair s, a appearing in the episode:\n   a\n     G ^ return following the first occurrence of . Append G to Returns(s, a)\nQ(s, a) ^ average(Returns(s, a))\n(c)For each s in the episode:\nA* ^ argmaxa Q(s, a)\nFor all a G A(s):\n   if a = A* if a = A*\n     1\\A1\\AA \u0026pound; + \u0026pound;/|A(s) |\n \nqn (s,n;(s)) = f n;(a|s)qn (s,a)\n \n\u0026nbsp;\n \n E\n       (5.2)\n        |A(s)|\n     qn (s, a) + (1- e) max q^ (s, a)\na,\n\n\n   qn (s,a)\n        \u0026gt;\u0026nbsp;\n        |A(s)|\n        XX(s,a) + (1- e)Yl\n        n(a|s) -\n     \u0026nbsp;\n (the sum is a weighted average with nonnegative weights summing to 1, and as such it must be less than or equal to the largest number averaged)\n \n\u0026nbsp;\n \n   |A(s)| vn (s).\n        |A(s)|\n     ^qn (s,a) + L n(a|s)qn (s,a)\n \n\u0026nbsp;\n\u0026nbsp;\n \nThus, by the policy improvement theorem, \u0026gt; n (i.e.,(s)\u0026gt; v^(s), for all s G S). We now prove that equality can hold only when both and n are optimal among the e-soft policies, that is, when they are better than or equal to all other e-soft policies.\nConsider a new environment that is just like the original environment, except with the requirement that policies be e-soft \\A1\\B0moved inside\\A1\\B1 the environment. The new environment has the same action and state set as the original and behaves as follows. If in state s and taking action a, then with probability 1 - e the new environment behaves exactly like the old environment. With probability e it repicks the action at random, with equal probabilities, and then behaves like the old environment with the new, random action. The best one can do in this new environment with general policies is the same as the best one could do in the original environment with e-soft policies. Let ʯ* and c[*denote the optimal value functions for the new environment. Then a policy n is optimal among e-soft policies if and only if v^ = ^*. From the definition of Tj*we know that it is the unique solution to\n   T*(s)\n     (1- e) max T*(s, a) +\n|A(s)|\n(1\\A1\\AA e) ma^ \u0026gt; p(s;, r|s, a) r + yt(s') a\u0026nbsp;\u0026nbsp; L\n   +\n     \u0026pound;WP(s',r|s,a) r + yt*(s;)\nS ,r\n|A(s)|\nWhen equality holds and the e-soft policy n is no longer improved, then we also know, from (5.2), that\nvn(s)\u0026nbsp;\u0026nbsp; =\u0026nbsp; (1\\A1\\AAe) max\\C8\\E7(s,a) + i J\\A1\\A2!\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (s,a)\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; |A(s)|V\n=(1\\A1\\AA e) ma^ 7p(s', r|s, a) r + yv^(s')\na\n \n\u0026nbsp;\n \n   +\n        |A(s)|\n     ^^p(s',r|s,a) r + yv^(s')\na\n \nHowever, this equation is the same as the previous one, except for the substitution of vn for vJ*. Since vJ* is the unique solution, it must be that v^ = ^*.\nIn essence, we have shown in the last few pages that policy iteration works for e-soft policies. Using the natural notion of greedy policy for e-soft policies, one is assured of improvement on every step, except when the best policy has been found among the e-soft policies. This analysis is independent of how the action-value functions are determined at each stage, but it does assume that they are computed exactly. This brings us to roughly the same point as in the previous section. Now we only achieve the best policy among the e-soft policies, but on the other hand, we have eliminated the assumption of exploring starts.\n5.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Prediction via Importance Sampling\nAll learning control methods face a dilemma: They seek to learn action values con\u0026shy;ditional on subsequent optimal behavior, but they need to behave non-optimally in order to explore all actions (to find the optimal actions). How can they learn about the optimal policy while behaving according to an exploratory policy\\A3\\BFThe on-policy approach in the preceding section is actually a compromise\\A1\\AAit learns action values not for the optimal policy, but for a near-optimal policy that still explores. A more straightforward approach is to use two policies, one that is learned about and that becomes the optimal policy, and one that is more exploratory and is used to gen\u0026shy;erate behavior. The policy being learned about is called the target policy, and the policy used to generate behavior is called the behavior policy. In this case we say that learning is from data \\A1\\B0off\\A1\\B1 the target policy, and the overall process is termed off-policy learning.\nThroughout the rest of this book we consider both on-policy and off-policy meth\u0026shy;ods. On-policy methods are generally simpler and are considered first. Off-policy methods require additional concepts and notation, and because the data is due to a different policy, off-policy methods are often of greater variance and are slower to converge. On the other hand, off-policy methods are more powerful and general. They include on-policy methods as the special case in which the target and behavior policies are the same. Off-policy methods also have a variety of additional uses in applications. For example, they can often be applied to learn from data generated by a conventional non-learning controller, or from a human expert. Off-policy learning is also seen by some as key to learning multi-step predictive models of the world\\A1\\AFs dynamics (Sutton, 2009, Sutton et al., 2011).\nIn this section we begin the study of off-policy methods by considering the predic\u0026shy;tion problem, in which both target and behavior policies are fixed. That is, suppose we wish to estimate v^ or , but all we have are episodes following another policy b, where b = n. In this case, n is the target policy, b is the behavior policy, and both policies are considered fixed and given.\nIn order to use episodes from b to estimate values for n, we require that every action taken under n is also taken, at least occasionally, under b. That is, we require that n(a|s) \u0026gt; 0 implies b(a|s) \u0026gt; 0. This is called the assumption of coverage. It follows from coverage that b must be stochastic in states where it is not identical to n. The target policy n, on the other hand, may be deterministic, and, in fact, this is a case of particular interest in control problems. In control, the target policy is typically the deterministic greedy policy with respect to the current action-value function estimate. This policy becomes a deterministic optimal policy while the behavior policy remains stochastic and more exploratory, for example, an \u0026pound;-greedy policy. In this section, however, we consider the prediction problem, in which n is unchanging and given.\nAlmost all off-policy methods utilize importance sampling, a general technique for estimating expected values under one distribution given samples from another. We apply importance sampling to off-policy learning by weighting returns according to the relative probability of their trajectories occurring under the target and behavior policies, called the importance-sampling ratio. Given a starting state St, the prob\u0026shy;ability of the subsequent state-action trajectory, At, Stʮ1, Atʮ1,...,St, occurring under any policy n is\nPr{At, Stʮ1, Atʮ1,...,St | St, At\\A3\\BAT-1\u0026#12316;n}\n=n(At|St)p(Stʮ1|St, At)n(At+1|St+1) \\A1\\F6 \\A1\\F6 \\A1\\F6 p(St|St-1, At-1)\nT -1\n=H n(Ak|Sk)P(Sk+1!Sk, Ak),\nk=t\nwhere p here is the state-transition probability function defined by (3.10). Thus, the relative probability of the trajectory under the target and behavior policies (the importance-sampling ratio) is\np= nT=t1n(Ak |Sk )p(Sw|Sk ,Ak) = T-1n(Ak |Sk)\n\\A1\\AAnT=t1b(Ak|Sk)p(Sk+1|Sk,Ak) \\A1\\AA knt b(Ak|Sk)'\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1' j\nAlthough the trajectory probabilities depend on the MDP\\A1\\AFs transition probabilities, which are generally unknown, they appear identically in both the numerator and denominator, and thus cancel. The importance sampling ratio ends up depending only on the two policies and the sequence, not on the MDP.\nNow we are ready to give a Monte Carlo algorithm that uses a batch of observed episodes following policy b to estimate Vn(s). It is convenient here to number time steps in a way that increases across episode boundaries. That is, if the first episode of the batch ends in a terminal state at time 100, then the next episode begins at time t = 101. This enables us to use time-step numbers to refer to particular steps in particular episodes. In particular, we can define the set of all time steps in which state s is visited, denoted T(s). This is for an every-visit method; for a first-visit method, T(s) would only include time steps that were first visits to s within their episodes. Also, let T(t) denote the first time of termination following time t, and Gt denote the return after t up through T(t). Then {Gt}te\\B6\\A1(s) are the returns that pertain to state s, and {pt:T(t)_1}te\\B6\\A1(s) are the corresponding importance-sampling ratios. To estimate v^ (s), we simply scale the returns by the ratios and average the results:\nv(s) = E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A2\\C8-lGt.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.4)\nWhen importance sampling is done as a simple average in this way it is called ordinary importance sampling.\nAn important alternative is weighted importance sampling, which uses a weighted average, defined as\nV(s)=\\C1\\A2\\C8\\C8\\E7\\A2\\C8-lGt,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.5)\n(t)-1\nor zero if the denominator is zero. To understand these two varieties of importance sampling, consider their estimates after observing a single return. In the weighted- average estimate, the ratio pt\\A3\\BAT(t)_i for the single return cancels in the numerator and denominator, so that the estimate is equal to the observed return independent of the ratio (assuming the ratio is nonzero). Given that this return was the only one observed, this is a reasonable estimate, but its expectation is v^(s) rather than vآ(s), and in this statistical sense it is biased. In contrast, the simple average (5.4) is always v^(s) in expectation (it is unbiased), but it can be extreme. Suppose the ratio were ten, indicating that the trajectory observed is ten times as likely under the target policy as under the behavior policy. In this case the ordinary importance- sampling estimate would be ten times the observed return. That is, it would be quite far from the observed return even though the episode\\A1\\AFs trajectory is considered very representative of the target policy.\nFormally, the difference between the two kinds of importance sampling is expressed in their biases and variances. The ordinary importance-sampling estimator is unbi\u0026shy;ased whereas the weighted importance-sampling estimator is biased (the bias con\u0026shy;verges asymptotically to zero). On the other hand, the variance of the ordinary importance-sampling estimator is in general unbounded because the variance of the ratios can be unbounded, whereas in the weighted estimator the largest weight on any single return is one. In fact, assuming bounded returns, the variance of the weighted importance-sampling estimator converges to zero even if the variance of the ratios themselves is infinite (Precup, Sutton, and Dasgupta 2001). In practice, the weighted estimator usually has dramatically lower variance and is strongly pre\u0026shy;ferred. Nevertheless, we will not totally abandon ordinary importance sampling as it is easier to extend to the approximate methods using function approximation that we explore in the second part of this book.\nA complete every-visit MC algorithm for off-policy policy evaluation using weighted importance sampling is given in the next section on page 120.\nExample 5.4: Off-policy Estimation of a Blackjack State Value\nWe applied both ordinary and weighted importance-sampling methods to estimate the value of a single blackjack state from off-policy data. Recall that one of the\n   Mean\nsquare\nerror\n(av6\\A1\\B8age ov6\\A1\\B8 100 runs)\n        Figure 5.4: Weighted importance sampling produces lower error estimates of the value of a single blackjack state from off-policy episodes (see Example 5.4).\n        10,000\n        Episodes (log scale)\n     advantages of Monte Carlo methods is that they can be used to evaluate a single state without forming estimates for any other states. In this example, we evaluated the state in which the dealer is showing a deuce, the sum of the player\\A1\\AFs cards is 13, and the player has a usable ace (that is, the player holds an ace and a deuce, or equivalently three aces). The data was generated by starting in this state then choosing to hit or stick at random with equal probability (the behavior policy). The target policy was to stick only on a sum of 20 or 21, as in Example 5.1. The value of this state under the target policy is approximately \\A1\\AA0.27726 (this was determined by separately generating one-hundred million episodes using the target policy and averaging their returns). Both off-policy methods closely approximated this value after 1000 off-policy episodes using the random policy. To make sure they did this reliably, we performed 100independent runs, each starting from estimates of zero and learning for 10,000 episodes. Figure 5.4 shows the resultant learning curves\\A1\\AAthe squared error of the estimates of each method as a function of number of episodes, averaged over the 100 runs. The error approaches zero for both algorithms, but the weighted importance-sampling method has much lower error at the beginning, as is typical in practice.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExample 5.5: Infinite Variance\n   110100100010,000100,0001,000,00010,000,000100,000,000\nEpisodes (log scale)\n        Figure 5.5: Ordinary importance sampling produces surprisingly unstable estimates on the one-state MDP shown inset (Example 5.5). The correct estimate here is 1 (7= 1), and, even though this is the expected value of a sample return (after importance sampling), the variance of the samples is infinite, and the estimates do not convergence to this value. These results are for off-policy first-visit MC.\n        2\nMonte-Carlo estimate of vn(s) with ordinary importance 1 sampling (ten runs)\n0\n     The estimates of ordinary importance sampling will typically have infinite variance, and thus unsatisfactory convergence properties, whenever the scaled returns have infinite variance\\A1\\AAand this can easily happen in off-policy learning when trajecto\u0026shy;ries contain loops. A simple example is shown inset in Figure 5.5. There is only one nonterminal state s and two actions, right and left. The right action causes a deterministic transition to termination, whereas the left action transitions, with probability 0.9, back to s or, with probability 0.1, on to termination. The rewards are +1 on the latter transition and otherwise zero. Consider the target policy that always selects left. All episodes under this policy consist of some number (possibly \n \nzero) of transitions back to s followed by termination with a reward and return of +1. Thus the value of s under the target policy is 1 (7= 1). Suppose we are estimating this value from off-policy data using the behavior policy that selects right and left with equal probability.\nThe lower part of Figure 5.5 shows ten independent runs of the first-visit MC algo\u0026shy;rithm using ordinary importance sampling. Even after millions of episodes, the esti\u0026shy;mates fail to converge to the correct value of 1. In contrast, the weighted importance- sampling algorithm would give an estimate of exactly 1everafter the first episode that ended with the back action. All returns not equal to 1 (that is, ending with the end action) would be inconsistent with the target policy and thus would have a Pt\\A3\\BAT(t)-1of zero and contribute neither to the numerator nor denominator of (5.5). The weighted importance-sampling algorithm produces a weighted average of only the returns consistent with the target policy, and all of these would be exactly 1.\nWe can verify that the variance of the importance-sampling-scaled returns is infi\u0026shy;nite in this example by a simple calculation. The variance of any random variable X is the expected value of the deviation from its mean \\D3\\C8\\A3\\ACwhich can be written\nVar[X ] = E [(X \\A1\\AA\\D3\\C8)2j = E[X2\\A1\\AA 2X \\D3\\C8+ \\D3\\C82] = E[X2]\\A1\\AA\\D3\\C82.\nThus, if the mean is finite, as it is in our case, the variance is infinite if and only if the expectation of the square of the random variable is infinite. Thus, we need onlyshow that the expected square of the importance-sampling-scaled return is infinite:\n2_\nn(At|St)g\\A1\\A3\n   \\A1\\A2\\CD\\F6=0\n     b(At|St)\nTo compute this expectation, we break it down into cases based on episode length and termination. First note that, for any episode ending with the end action, the importance sampling ratio is zero, because the target policy would never take this action; these episodes thus contribute nothing to the expectation (the quantity in parenthesis will be zero) and can be ignored. We need only consider episodes that involve some number (possibly zero) of back actions that transition back to the nonterminal state, followed by a back action transitioning to termination. All of these episodes have a return of 1, so the G\\A1\\A3factor can be ignored. To get the expected square we need only consider each length of episode, multiplying the probability of the episode\\A1\\AFs occurrence by the square of its importance-sampling ratio, and add these up:\n \n   (the length 1episode)\n        (the length 3 episode)\n        1\n2\n+\n+\n+\n        11 \\A1\\AA\\A1\\F6 0.9 \\A1\\F6\\A1\\AA 22\n        2\n        11 \\A1\\AA\\A1\\F6 0.9 \\A1\\F6 \\A1\\AA \\A1\\F6 0.9 22\n        1,111\\A1\\A2\n\\A1\\AA\\A1\\F6 0.1I --------------------- \n2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.5 0.5 0.5\n        0.1(\\81A\\81A'\n0.5 0.5\n        2\n        2\n        (the length 2episode)\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n \n   E\nk=0\nE\nk=0\n        0.9k\n1.8k\n        2k\u0026#8226; 2\n        0.1\n0.2\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n .\n\\A1\\F6\nExercise 5.3 What is the equation analogous to (5.5) for action values Q(s, a) instead of state values V(s), again given returns generated using b?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 5.4 In learning curves such as those shown in Figure 5.4 error generally decreases with training, as indeed happened for the ordinary importance-sampling method. But for the weighted importance-sampling method error first increased and then decreased. Why do you think this happened?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 5.5 The results with Example 5.5 and shown in Figure 5.5 used a first- visit MC method. Suppose that instead an every-visit MC method was used on the same problem. Would the variance of the estimator still be infinite? Why or why not?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n5.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Incremental Implementation\nMonte Carlo prediction methods can be implemented incrementally, on an episode- by-episode basis, using extensions of the techniques described in Chapter 2(Sec\u0026shy;tion 2.4). Whereas in Chapter 2 we averaged rewards, in Monte Carlo methods we average returns. In all other respects exactly the same methods as used in Chapter 2 can be used for on-policy Monte Carlo methods. For off-policy Monte Carlo meth\u0026shy;ods, we need to separately consider those that use ordinary importance sampling and those that use weighted importance sampling.\nIn ordinary importance sampling, the returns are scaled by the importance sam\u0026shy;pling ratio pt:T(t)_i (5.3), then simply averaged. For these methods we can again use the incremental methods of Chapter 2, but using the scaled returns in place of the rewards of that chapter. This leaves the case of off-policy methods using weighted importance sampling. Here we have to form a weighted average of the returns, and a slightly different incremental algorithm is required.\nSuppose we have a sequence of returns Gi, G2,...,Gn-i, all starting in the same state and each with a corresponding random weight Wi (e.g., Wi = Pt:r(t)_i). We wish to form the estimate\nwfcGfczn-i wfc\nand keep it up-to-date as we obtain a single additional return Gn. In addition to keeping track of Vn, we must maintain for each state the cumulative sum Cn of the weights given to the first n returns. The update rule for Vn is\n \n\u0026nbsp;\n \n   Vn+1== Vn + 7^\nCn\n        Gn \\A1\\AA\n     n \u0026gt; 1,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.7)\n \n\u0026nbsp;\n \nand\nCn+1= Cn + Wn+1,\nwhere Co == 0 (and Vi is arbitrary and thus need not be specified). The box on the next page contains a complete episode-by-episode incremental algorithm for Monte Carlo policy evaluation. The algorithm is nominally for the off-policy case, using weighted importance sampling, but applies as well to the on-policy case just by choosing the target and behavior policies as the same (in which case (n = b), W is always 1). The approximation Q converges to qn (for all encountered state-action pairs) while actions are selected according to a potentially different policy, b.\nExercise 5.6 Modify the algorithm for first-visit MC policy evaluation (Section 5.1) to use the incremental implementation for sample averages described in Section 2.4.\n\\A1\\F5\nExercise 5.7 Derive the weighted-average update rule (5.7) from (5.6). Follow the pattern of the derivation of the unweighted rule (2.3).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nOff-policy MC prediction, for estimating Q^ q^\nInput: an arbitrary target policy n\nInitialize, for all s G S, a G A(s):\nQ(s, a) ^ arbitrary C(s, a) ^ 0\nRepeat forever:\nb^ any policy with coverage of n Generate an episode using b:\nSo, Ao, R1, \u0026#8226; \u0026#8226; \u0026#8226; , ST \\A1\\AA 1, AT \\A1\\AA 1,\u0026nbsp; , ST\nG ^ 0 W ^ 1\nFor t = T \\A1\\AA 1, T \\A1\\AA 2,...downto 0:\nG ^ 7G ʮRt+i C(St,At) ^ C(St, At) + W\nQ(SUAt) ^ Q(St, At)ʮc(St,At) [G \\A1\\AA Q(St7 At)]\nW \\B2\\B7W n(At)St)\nW^ Wb(At|St)\nIf W = 0 then ExitForLoop\n5.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Monte Carlo Control\nWe are now ready to present an example of the second class of learning control methods we consider in this book: off-policy methods. Recall that the distinguishing feature of on-policy methods is that they estimate the value of a policy while using it for control. In off-policy methods these two functions are separated. The policy used to generate behavior, called the behavior policy, may in fact be unrelated to the policy that is evaluated and improved, called the target policy. An advantage of this separation is that the target policy may be deterministic (e.g., greedy), while the behavior policy can continue to sample all possible actions.\nOff-policy Monte Carlo control methods use one of the techniques presented in the preceding two sections. They follow the behavior policy while learning about and improving the target policy. These techniques require that the behavior policy has a nonzero probability of selecting all actions that might be selected by the target policy (coverage). To explore all possibilities, we require that the behavior policy be soft (i.e., that it select all actions in all states with nonzero probability).\nThe box on the next page shows an off-policy Monte Carlo method, based on GPI and weighted importance sampling, for estimating n* and q*. The target policy n \\B0\\D1n* is the greedy policy with respect to Q, which is an estimate of q^. The behavior policy b can be anything, but in order to assure convergence of n to the optimal policy, an infinite number of returns must be obtained for each pair of state and action. This can be assured by choosing b to be e-soft. The policy n converges to optimal at all encountered states even though actions are selected according to a different soft policy b, which may change between or even within episodes.\n \nOff-policy MC control, for estimating n \\B0\\D1n*\nInitialize, for all s G S, a G A(s):\nQ(s, a) ^ arbitrary C(s, a) ^ 0\nn(s) ^ argmaxaQ(St, a)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (with ties broken consistently)\nRepeat forever:\nb ^ any soft policy Generate an episode using b:\nS0, A0, R1, \u0026#8226; \u0026#8226; \u0026#8226; ,\\A1\\AA 1,\u0026nbsp; \\A1\\AA 1,\nG ^ 0 W ^ 1\nFor t = T \\A1\\AA 1, T \\A1\\AA 2\\A3\\AC... downto 0:\nG ^ yG ʮRt+i\nC(St,At) ^ C(St, At) + W\nAt) ^ Q(St, At)ʮc(St,At) [G \\A1\\AA Q(St7 At)] n(St) ^ argmaxaQ(St, a)\u0026nbsp;\u0026nbsp;\u0026nbsp; (with ties broken consistently)\nIf At =أ(St) then ExitForLoop W ^ W\\A1\\F8\nA potential problem is that this method learns only from the tails of episodes, when all of the remaining actions in the episode are greedy. If nongreedy actions are common, then learning will be slow, particularly for states appearing in the early portions of long episodes. Potentially, this could greatly slow learning. There has been insufficient experience with off-policy Monte Carlo methods to assess how seri\u0026shy;ous this problem is. If it is serious, the most important way to address it is probably by incorporating temporal-difference learning, the algorithmic idea developed in the next chapter. Alternatively, if Y is less than 1, then the idea developed in the next section may also help significantly.\nExercise 5.8: Racetrack (programming) Consider driving a race car around a turn like those shown in Figure 5.6. You want to go as fast as possible, but not so fast as to run off the track. In our simplified racetrack, the car is at one of a discrete set of grid positions, the cells in the diagram. The velocity is also discrete, a number of grid cells moved horizontally and vertically per time step. The actions are increments to the velocity components. Each may be changed by +1, \\A1\\AA1, or 0 in one step, for a total of nine actions. Both velocity components are restricted to be nonnegative and less than 5, and they cannot both be zero except at the starting line. Each episode begins in one of the randomly selected start states with both velocity components zero and ends when the car crosses the finish line. The rewards are \\A1\\AA1 for each step until the car crosses the finish line. If the car hits the track boundary, it is moved back to a random position on the starting line, both velocity components are reduced to zero, and the episode continues. Before updating the car\\A1\\AFs location at each time step, check to see if the projected path of the car intersects the track boundary. If it intersects the finish line, the episode ends; if it intersects anywhere else, the car is\n   Starting line\n        Finish\nline\n        Finish\nline\n     Starting line\nFigure 5.6: A couple of right turns for the racetrack task.\nconsidered to have hit the track boundary and is sent back to the starting line. To make the task more challenging, with probability 0.1at each time step the velocity increments are both zero, independently of the intended increments. Apply a Monte Carlo control method to this task to compute the optimal policy from each starting state. Exhibit several trajectories following the optimal policy (but turn the noise off for these trajectories).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n5.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *Discounting-aware Importance Sampling\nThe off-policy methods that we have considered so far are based on forming importance- sampling weights for returns considered as unitary wholes, without taking into ac\u0026shy;count the returns\\A1\\AF internal structures as sums of discounted rewards. We now briefly consider cutting-edge research ideas for using this structure to significantly reduce the variance of off-policy estimators.\nFor example, consider the case where episodes are long and 7is significantly less than 1. For concreteness, say that episodes last 100 steps and that 7= 0. The return from time 0will then be just Go = R1, but its importance sampling ratio will be\na product of 100factors,ū\\B6\\FEح\\9E\\E9)ū\\BC\\E01)\\A1\\F6 \\A1\\F6 \\A1\\F6ū9^9:). In ordinary importance sam\u0026shy;pling, the return will be scaled by the entire product, but it is really only necessary\nto scale by the first factor, by\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The\u0026nbsp;\u0026nbsp; other 99factorsTOST \\A1\\F6 \\A1\\F6 \\A1\\F6\nare irrelevant because after the first reward the return has already been determined. These later factors are all independent of the return and of expected value 1; they do not change the expected update, but they add enormously to its variance. In some cases they could even make the variance infinite. Let us now consider an idea for avoiding this large extraneous variance.\nThe essence of the idea is to think of discounting as determining a probability of\n \ntermination or, equivalently, a degree\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; of partial termination. Forany\u0026nbsp;\u0026nbsp; y G[0,1),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; we\ncan think of the return G0as partly\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; terminating in one step, tothedegree\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1\\A1\\AA y,\nproducing a return of just the first reward, Ri, and as partly terminating after two steps, to the degree (1\\A1\\AA y)y, producing a return of Rl + R2, and so on. The latter degree corresponds to terminating on the second step, 1\\A1\\AA y, and not having already terminated on the first step, y. The\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; degree of termination\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; onthe\u0026nbsp;\u0026nbsp;\u0026nbsp; thirdstep\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; is\u0026nbsp;\u0026nbsp;\u0026nbsp; thus\n(1\\A1\\AA y)y2,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; with the y2 reflecting that\u0026nbsp; termination\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; didnot occur\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; on\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; either\u0026nbsp;\u0026nbsp; of the\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; first\ntwo steps. The partial returns here are called flat partial returns:\nGt:h = Rt+i + Rt+2 + \\A1\\F6 \\A1\\F6 \\A1\\F6 + \\B3\\F3a,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0^ t \u0026lt; h \u0026lt; T,\nwhere \\A1\\B0flat\\A1\\B1 denotes the absence of discounting, and \\A1\\B0partial\\A1\\B1 denotes that these returns do not extend all the way to termination but instead stop at h, called the horizon(and T is the time of termination of the episode). The conventional full return Gt can be viewed as a sum of flat partial returns as suggested above as follows:\nGt = Rt+i + YRt+2 + Y2 Rt+3 + \\A1\\F6 \\A1\\F6 \\A1\\F6 + YT-t-1Rr =(1\\A1\\AAY )Rt+i\n+ (1 \\A1\\AA y)y (Rt+i + Rt+2)\n+ (1 \\A1\\AA y)y 2 (Rt+i + Rt+2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; + Rt+3)\n+ (1 \\A1\\AA y)yt-t-2(Rt+i + Rt+2+ \\A1\\F6 + Rt -i)\n+ YT-t-i(Rt+i + Rt+2+ \\A1\\F6 + Rt)\n-i\n=(1\\A1\\AAYh-t-iGGt\\A3\\BAh + YT-t-iGGt\\A3\\BAT.\nh=t+i\nNow we need to scale the flat partial returns by an importance sampling ratio that is similarly truncated. As GGt\\A3\\BAh only involves rewards up to a horizon h, we only need the ratio of the probabilities up to h. We define an ordinary importance-sampling estimator, analogous to (5.4), as\n.St\\80T(s)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ((1\u0026nbsp; \\A1\\AA Y) ES+i1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Yh-t-ipt\\A3\\BAh-i GGt\\A3\\BAh+\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 7T (t)-t-ipt\\A3\\BAT (t)-iGt\\A3\\BAT (t))\nV (s)=--------------------------------------------------------------------- ,\n(5.8)\nand a weighted importance-sampling estimator, analogous to (5.5), as\nEt\\80T(s)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ((1\\A1\\AA Y)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 7h-t-ipt\\A3\\BAh-iGt\\A3\\BAh\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 7T(t)-t-ipt\\A3\\BAT(t)-iGt\\A3\\BAT(t))\nV(s)\nEteT(s) ((1 \\A1\\AA T)ES+i1Yh-t-iPt\\A3\\BAh-i + YT(t)-t-iPt\\A3\\BAT(t)-i)\n \nWe call these two estimators discounting-aware importance sampling estimators. They take into account the discount rate but have no effect (are the same as the off-policy estimators from Section 5.5) if Y = 1.\n5.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *Per-reward Importance Sampling\nThere is one more way in which the structure of the return as a sum of rewards can be taken into account in off-policy importance sampling, a way that may be able to reduce variance even in the absence of discounting (that is, even if Y = 1). In the off-policy estimators (5.4) and (5.5), each term of the sum in the numerator is itself a sum:\nPt:T _iGt = Pt\\A3\\BAT _1 (Rt+1 + YRt+2 +------------- + YT _t-1RT)\n=Pt:T _1Rt+1 + YPt\\A3\\BAT _1Rt+2+-------------- + YT _t-1Pt:T _1RT \u0026#8226;------------------ (5.10)\nThe off-policy estimators rely on the expected values of these terms; let us see if we can write them in a simpler way. Note that each sub-term of (5.10) is a product of a random reward and a random importance-sampling ratio. For example, the first sub-term can be written, using (5.3), as\nR = n(At|St) n(At+1|St+1) n(At+2|St+2)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n(AT_1|ST_1)R\nPt:T_1t+1= b(At|St) b(At+i|St+i) b(At+2|St+2) ... b(AT_i|ST_i) t+1.\nNow notice that, of all these factors, only the first and the last (the reward) are correlated; all the other ratios are independent random variables whose expected value is one:\nn(Ak |Sfc) b(Ak |Sk)\\A1\\B9\nThus, because the expectation of the product of independent random variables is the product of their expectations, all the ratios except the first drop out in expectation, leaving just\nE[pt:T_iRt+i] = E[pt:tRtʮi].\nIf we repeat this analysis for the kth term of (5.10), we get E[pt:T_iRt+k] = E[pt:t+k_iRt+k].\nIt follows then that the expectation of our original term (5.10) can be written\n   G t\n     E[pt:T _iGt] = E where\nGt = Pt:tRt+1+ YPt:t+iRt+2+ Y 2Pt:t+2Rt+3 ++ YT_t_1Pt:T _iRt .\n \nWe call this idea per-reward importance sampling. It follows immediately that there is an alternate importance-sampling estimator, with the same unbiased expectation as the OIS estimator (5.4), using GGt:\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (s)= 5iffr,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.n)\nwhich we might expect to sometimes be of lower variance.\nIs there a per-reward version of weighted importance sampling? This is less clear. So far, all the estimators that have been proposed for this that we know of are not consistent (that is, they do not converge to the true value with infinite data).\n*Exercise 5.9 Modify the algorithm for off-policy Monte Carlo control (page 121) to use the idea of the truncated weighted-average estimator (5.9). Note that you will first need to convert this equation to action values.\\A1\\F5\n5.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Returns\nIt will turn out that a special form of return works best, producing updates of the lowest variance. One of the most insightful way of writing it is in terms of a special error called the temporal-difference (TD) error. The TD error is defined by\n5t = Rt ʮ1+ YV (St ʮ1) \\A1\\AA V (St),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.12)\nwhere V(s) is the estimate of the value of state s on this episode. Using this, the state-value off-policy return is defined by\nGp = Yk-tPt\\A3\\BAk ֪+ V (St)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (5.13)\n \n\u0026nbsp;\n \nThe corresponding Monte Carlo algorithm would be wait until the end of the episode, then go back over update\nV'(s) \\B6\\FEZteT(s) Gt\nV\u0026nbsp;\u0026nbsp;\u0026nbsp; (s)=\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; |T(s)|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,\nan off-line algorithm. It would the time steps performing the\n(5.14)\n \n\u0026nbsp;\n \n5.11\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nThe Monte Carlo methods presented in this chapter learn value functions and op\u0026shy;timal policies from experience in the form of sample episodes. This gives them at least three kinds of advantages over DP methods. First, they can be used to learn optimal behavior directly from interaction with the environment, with no model of the environment\\A1\\AFs dynamics. Second, they can be used with simulation or sample models. For surprisingly many applications it is easy to simulate sample episodes\neven though it is difficult to construct the kind of explicit model of transition proba\u0026shy;bilities required by DP methods. Third, it is easy and efficient to focusMonte Carlo methods on a small subset of the states. A region of special interest can be accurately evaluated without going to the expense of accurately evaluating the rest of the state set (we explore this further in Chapter 8).\nA fourth advantage of Monte Carlo methods, which we discuss later in the book, is that they may be less harmed by violations of the Markov property. This is because they do not update their value estimates on the basis of the value estimates of successor states. In other words, it is because they do not bootstrap.\nIn designing Monte Carlo control methods we have followed the overall schema of generalized policy iteration(GPI) introduced in Chapter 4. GPI involves interacting processes of policy evaluation and policy improvement. Monte Carlo methods provide an alternative policy evaluation process. Rather than use a model to compute the value of each state, they simply average many returns that start in the state. Because a state\\A1\\AFs value is the expected return, this average can become a good approximation to the value. In control methods we are particularly interested in approximating action-value functions, because these can be used to improve the policy without requiring a model of the environment\\A1\\AFs transition dynamics. Monte Carlo methods intermix policy evaluation and policy improvement steps on an episode-by-episode basis, and can be incrementally implemented on an episode-by-episode basis.\nMaintaining sufficient explorationis an issue in Monte Carlo control methods. It is not enough just to select the actions currently estimated to be best, because then no returns will be obtained for alternative actions, and it may never be learned that they are actually better. One approach is to ignore this problem by assuming that episodes begin with state-action pairs randomly selected to cover all possibilities. Such exploring startscan sometimes be arranged in applications with simulated episodes, but are unlikely in learning from real experience. In on-policymethods, the agent commits to always exploring and tries to find the best policy that still explores. In off-policymethods, the agent also explores, but learns a deterministic optimal policy that may be unrelated to the policy followed.\nOff-policy predictionrefers to learning the value function of a target policyfrom data generated by a different behavior policy. Such learning methods are based on some form of importance sampling, that is, on weighting returns by the ratio of the probabilities of taking the observed actions under the two policies. Ordinary im\u0026shy;portance samplinguses a simple average of the weighted returns, whereas weighted importance samplinguses a weighted average. Ordinary importance sampling pro\u0026shy;duces unbiased estimates, but has larger, possibly infinite, variance, whereas weighted importance sampling always has finite variance and is preferred in practice. Despite their conceptual simplicity, off-policy Monte Carlo methods for both prediction and control remain unsettled and are a subject of ongoing research.\nThe Monte Carlo methods treated in this chapter differ from the DP methods treated in the previous chapter in two major ways. First, they operate on sample experience, and thus can be used for direct learning without a model. Second, they do not bootstrap. That is, they do not update their value estimates on the basis of other value estimates. These two differences are not tightly linked, and can be separated. In the next chapter we consider methods that learn from experience, like Monte Carlo methods, but also bootstrap, like DP methods.\nBibliographical and Historical Remarks\nThe term \\A1\\B0Monte Carlo\\A1\\B1 dates from the 1940s, when physicists at Los Alamos de\u0026shy;vised games of chance that they could study to help understand complex physical phenomena relating to the atom bomb. Coverage of Monte Carlo methods in this sense can be found in several textbooks (e.g., Kalos and Whitlock, 1986; Rubinstein, 1981).\nAn early use of Monte Carlo methods to estimate action values in a reinforcement learning context was by Michie and Chambers (1968). In pole balancing (Example 3.4), they used averages of episode durations to assess the worth (expected balancing \\A1\\B0life\\A1\\B1) of each possible action in each state, and then used these assessments to control action selections. Their method is similar in spirit to Monte Carlo ES with every- visit MC estimates. Narendra and Wheeler (1986) studied a Monte Carlo method for ergodic finite Markov chains that used the return accumulated between successive visits to the same state as a reward for adjusting a learning automaton\\A1\\AFs action probabilities.\nBarto and Duff (1994) discussed policy evaluation in the context of classical Monte Carlo algorithms for solving systems of linear equations. They used the analysis of Curtiss (1954) to point out the computational advantages of Monte Carlo policy eval\u0026shy;uation for large problems. Singh and Sutton (1996) distinguished between every-visit and first-visit MC methods and proved results relating these methods to reinforce\u0026shy;ment learning algorithms.\nThe blackjack example is based on an example used by Widrow, Gupta, and Maitra (1973). The soap bubble example is a classical Dirichlet problem whose Monte Carlo solution was first proposed by Kakutani (1945; see Hersh and Griego, 1969; Doyle and Snell, 1984). The racetrack exercise is adapted from Barto, Bradtke, and Singh (1995), and from Gardner (1973).\nMonte Carlo ES was introduced in the 1998 edition of this book. That may have been the first explicit connection between Monte Carlo estimation and control methods based on policy iteration.\nEfficient off-policy learning has become recognized as an important challenge that arises in several fields. For example, it is closely related to the idea of \\A1\\B0interventions\\A1\\B1 and \\A1\\B0counterfactuals\\A1\\B1 in probabalistic graphical (Bayesian) models (e.g., Pearl, 1995; Balke and Pearl, 1994). Off-policy methods using importance sampling have a long history and yet still are not well understood. Weighted importance sampling, which is also sometimes called normalized importance sampling (e.g., Koller and Friedman, 2009), is discussed by Rubinstein (1981), Hesterberg (1988), Shelton (2001), and Liu (2001) among others.\nOur treatment of the idea of discounting-aware importance sampling is based on the analysis of Sutton, Mahmood, Precup, and van Hasselt (2014). It has been worked out most fully to date by Mahmood (in preparation; Mahmood, van Hasselt, and Sutton, 2014). Per-reward importance sampling was introduced by Precup, Sutton, and Singh (2000), who called it \\A1\\B0per-decision\\A1\\B1 importance sampling. These works also combine off-policy learning with temporal-difference learning, eligibility traces, and approximation methods, introducing subtle issues that we consider in later chapters.\nThe target policy in off-policy learning is sometimes referred to in the literature as the \\A1\\B0estimation\\A1\\B1 policy, as it was in the first edition of this book.\n \nChapter 6\nTemporal-Difference Learning\nIf one had to identify one idea as central and novel to reinforcement learning, it would undoubtedly be temporal-difference (TD) learning. TD learning is a combination of Monte Carlo ideas and dynamic programming (DP) ideas. Like Monte Carlo methods, TD methods can learn directly from raw experience without a model of the environment\\A1\\AFs dynamics. Like DP, TD methods update estimates based in part on other learned estimates, without waiting for a final outcome (they bootstrap). The relationship between TD, DP, and Monte Carlo methods is a recurring theme in the theory of reinforcement learning; this chapter is the beginning of our exploration of it. Before we are done, we will see that these ideas and methods blend into each other and can be combined in many ways. In particular, in Chapter 7 we introduce n-step algorithms, which provide a bridge from TD to Monte Carlo methods, and in Chapter 12 we introduce the TD(A) algorithm, which seamlessly unifies them.\nAs usual, we start by focusing on the policy evaluation or prediction problem, that of estimating the value function v^ for a given policy n. For the control problem (finding an optimal policy), DP, TD, and Monte Carlo methods all use some variation of generalized policy iteration (GPI). The differences in the methods are primarily differences in their approaches to the prediction problem.\n6.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD Prediction\nBoth TD and Monte Carlo methods use experience to solve the prediction problem. Given some experience following a policy n, both methods update their estimate V of vn for the nonterminal states St occurring in that experience. Roughly speaking, Monte Carlo methods wait until the return following the visit is known, then use that return as a target for V(St). A simple every-visit Monte Carlo method suitable for nonstationary environments is\nV(St) ^ V(St) + a[Gt \\A1\\AA V(St)],\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.1)\nwhere Gt is the actual return following time t, and a is a constant step-size parameter (c.f., Equation 2.4). Let us call this method constant-a MC. Whereas Monte Carlo methods must wait until the end of the episode to determine the increment to V(St) (only then is Gt known), TD methods need to wait only until the next time step. At time t + 1they immediately form a target and make a useful update using the observed reward Rt+i and the estimate V(St+i). The simplest TD method makes the update\nV(St) ^ V(St) + a [Rt+i + YV(St+i) \\A1\\AA V(St)]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.2)\nimmediately on transition to St+i and receiving Rt+i. In effect, the target for the Monte Carlo update is Gt, whereas the target for the TD update is Rt+i + yV(St+i). This TD method is called TD(0), or one-step TD, because it is a special case of the TD(A) and n-step TD methods developed in Chapter 12 and Chapter 7. The box below specifies TD(0) completely in procedural form.\n Tabular TD(0) for estimating v^\nInput: the policy n to be evaluated\n \u0026nbsp;\n  Initialize V (s) arbitrarily (e.g., V (s)\n =0, Vs G S+)\n  Repeat (for each episode):\n \u0026nbsp;\n  Initialize S\n \u0026nbsp;\n  Repeat (for each step of episode):\n \u0026nbsp;\n  A ^ action given by n for S\n \u0026nbsp;\n  Take action A, observe R, S7\n \u0026nbsp;\n  V(S) ^ V(S)ʮa[R ʮyV(S7)\n \\A1\\AAV (S)]\n  S ^ S7\n \u0026nbsp;\n  until S is terminal\n \u0026nbsp;\n        \u0026nbsp;\nBecause the TD(0) bases its update in part on an existing estimate, we say that it is a bootstrapping method, like DP. We know from Chapter 3 that\nvn(s) == En[Gt | St = s]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.3)\n=En[Rt+i + YGt+1| St = s]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (3.3))\n=En[Rt+1+ Yvn(St+i) | St = s].\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.4)\nRoughly speaking, Monte Carlo methods use an estimate of (6.3) as a target, whereas DP methods use an estimate of (6.4) as a target. The Monte Carlo target is an estimate because the expected value in (6.3) is not known; a sample return is used in place of the real expected return. The DP target is an estimate not because of the expected values, which are assumed to be completely provided by a model of the environment, but because v^(St+i) is not known and the current estimate, V(St+i), is used instead. The TD target is an estimate for both reasons: it samples the expected values in (6.4) and it uses the current estimate V instead of the true v^. Thus, TD methods combine the sampling of Monte Carlo with the bootstrapping of DP. As we shall see, with care and imagination this can take us a long way toward obtaining the advantages of both Monte Carlo and DP methods.\n\n\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z The diagram to the right is the backup diagram for tabular TD(0). The\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Q\nvalue estimate for the state node at the top of the backup diagram is up-\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; {\ndated on the basis of the one sample transition from it to the immediately\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; |\nfollowing state. We refer to TD and Monte Carlo updates as sample back-\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A9\\96\nupsbecause they involve looking ahead to a sample successor state (or\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD(0)\nstate-action pair), using the value of the successor and the reward along the way to compute a backed-up value, and then changing the value of the original state (or state-action pair) accordingly. Sample backups differ from the full backups of DP methods in that they are based on a single sample successor rather than on a complete distribution of all possible successors.\nFinally, note that the quantity in brackets in the TD(0) update is a sort of error, measuring the difference between the estimated value of St and the better estimate Rtʮ1+ yV(Stʮ1). This quantity, called the TD error, arises in various forms through\u0026shy;out reinforcement learning:\n5t ==Rt ʮ1+ YV (St ʮ1) \\A1\\AAV (St).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.5)\nNotice that the TD\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; error at each time is theerror in the estimate made at\u0026nbsp;\u0026nbsp; thattime.\nBecause the TD error depends on the next state and next reward, it is not actually available until one time step later. That is, \u0026amp; is the error in V(St), available at time t + 1. Also note that if the array V does not change during the episode (as it does not in Monte Carlo methods), then the Monte Carlo error can be written as a sum of TD errors:\nGt \\A1\\AA V(St) = Rt+1+ 7^+1 \\A1\\AA V(St) + 7V(St+1) \\A1\\AA7V(St+1)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (3.3))\n=^t + 7(Gt.1\\A1\\AA V( (St.1))\n=\u0026amp; + 7\u0026#12316;ʮ1 + 72(Gt.2\\A1\\AA V (Sm))\n=^t + 7\u0026amp;ʮ1+ 72\u0026amp;ʮ2\u0026nbsp; +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6 \\A1\\F6 \\A1\\F6\u0026nbsp;\u0026nbsp; +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 7T-t-1^T-1+ 7T-t (Gt \\A1\\AA V (St ))\n=^t + 7\u0026#12316;ʮ1+ 7%ʮ2\u0026nbsp; +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\\A1\\F6\\A1\\F6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 7T-t-1^T-1+ 7T-t(0\\A1\\AA 0)\nT -1\nH\u0026#8226;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.6)\nk\nThis identity is not exact if V is updated during the episode (as it is in TD(0)), but if the step size is small then it may still hold approximately. Generalizations of this identity play an important role in the theory and algorithms of temporal-difference learning.\nExercise 6.1 If V changes during the episode, then (6.6) only holds approximately; what would the difference be between the two sides? Let Vt denote the array of state values used at time t in the TD error (6.5) and in the TD update (6.2). Redo the derivation above to determine the additional amount that must be added to the sum of TD errors in order to equal the Monte Carlo error.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExample 6.1: Driving Home Each day as you drive home from work, you try to predict how long it will take to get home. When you leave your office, you note thetime, the day of week, the weather, and anything else that might be relevant. Say on this Friday you are leaving at exactly 6pm, and you estimate that it will take 30 minutes to get home. As you reach your car it is 6:05, and you notice it is starting to rain. Traffic is often slower in the rain, so you reestimate that it will take 35 minutes from then, or a total of 40 minutes. Fifteen minutes later you have completed the highway portion of your journey in good time. As you exit onto a secondary road you cut your estimate of total travel time to 35 minutes. Unfortunately, at this point you get stuck behind a slow truck, and the road is too narrow to pass. You end up having to follow the truck until you turn onto the side street where you live at 6:40. Three minutes later you are home. The sequence of states, times, and predictions is thus as follows:\nElapsed Time Predicted Predicted State(minutes)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Time\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; to\u0026nbsp;\u0026nbsp;\u0026nbsp; Go\u0026nbsp;\u0026nbsp; Total\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Time\nleaving office, friday at 6\n 0\n 30\n 30\n  reach car, raining\n 5\n 35\n 40\n  exiting highway\n 20\n 15\n 35\n  2ndary road, behind truck\n 30\n 10\n 40\n  entering home street\n 40\n 3\n 43\n  arrive home\n 43\n 0\n 43\n   \u0026nbsp;\nThe rewards in this example are the elapsed times on each leg of the journey.[10] We are not discounting (y = 1), and thus the return for each state is the actual time to go from that state. The value of each state is the expectedtime to go. The second column of numbers gives the current estimated value for each state encountered.\nA simple way to view the operation of Monte Carlo methods is to plot the predicted total time (the last column) over the sequence, as in Figure 6.1 (left). The arrows\nshow the changes in predictions recommended by the constant-a MC method (6.1), for a = 1. These are exactly the errors between the estimated value (predicted time to go) in each state and the actual return (actual time to go). For example, when you exited the highway you thought it would take only 15 minutes more to get home, but in fact it took 23 minutes. Equation 6.1 applies at this point and determines an increment in the estimate of time to go after exiting the highway. The error, Gt \\A1\\AA V(St), at this time is eight minutes. Suppose the step-size parameter, a, is 1/2. Then the predicted time to go after exiting the highway would be revised upward by four minutes as a result of this experience. This is probably too large a change in this case; the truck was probably just an unlucky break. In any event, the change can only be made off-line, that is, after you have reached home. Only at this point do you know any of the actual returns.\nIs it necessary to wait until the final outcome is known before learning can begin? Suppose on another day you again estimate when leaving your office that it will take 30 minutes to drive home, but then you become stuck in a massive traffic jam. Twenty-five minutes after leaving the office you are still bumper-to-bumper on the highway. You now estimate that it will take another 25 minutes to get home, for a total of 50 minutes. As you wait in traffic, you already know that your initial estimate of 30 minutes was too optimistic. Must you wait until you get home before increasing your estimate for the initial state? According to the Monte Carlo approach you must, because you don\\A1\\AFt yet know the true return.\nAccording to a TD approach, on the other hand, you would learn immediately, shifting your initial estimate from 30 minutes toward 50. In fact, each estimate would be shifted toward the estimate that immediately follows it. Returning to our first day of driving, Figure 6.1 (right) shows the changes in the predictions recommended by the TD rule (6.2) (these are the changes made by the rule if a = 1). Each error is proportional to the change over time of the prediction, that is, to the temporal differences in predictions.\nBesides giving you something to do while waiting in traffic, there are several com\u0026shy;putational reasons why it is advantageous to learn based on your current predictions rather than waiting until termination when you know the actual return. We briefly discuss some of these next.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n6.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Advantages of TD Prediction Methods\nTD methods learn their estimates in part on the basis of other estimates. They learn a guess from a guess\\A1\\AAthey bootstrap. Is this a good thing to do? What advantages do TD methods have over Monte Carlo and DP methods? Developing and answering such questions will take the rest of this book and more. In this section we briefly anticipate some of the answers.\nObviously, TD methods have an advantage over DP methods in that they do not require a model of the environment, of its reward and next-state probability distributions.\nThe next most obvious advantage of TD methods over Monte Carlo methods is that they are naturally implemented in an on-line, fully incremental fashion. With Monte Carlo methods one must wait until the end of an episode, because only then is the return known, whereas with TD methods one need wait only one time step. Surprisingly often this turns out to be a critical consideration. Some applications have very long episodes, so that delaying all learning until an episode\\A1\\AFs end is too slow. Other applications are continuing tasks and have no episodes at all. Finally, as we noted in the previous chapter, some Monte Carlo methods must ignore or discount episodes on which experimental actions are taken, which can greatly slow learning. TD methods are much less susceptible to these problems because they learn from each transition regardless of what subsequent actions are taken.\nBut are TD methods sound? Certainly it is convenient to learn one guess from the next, without waiting for an actual outcome, but can we still guarantee convergence to the correct answer? Happily, the answer is yes. For any fixed policy n, TD(0) has been proved to converge to Vn, in the mean for a constant step-size parameter if it is sufficiently small, and with probability 1if the step-size parameter decreases according to the usual stochastic approximation conditions (2.7). Most convergence proofs apply only to the table-based case of the algorithm presented above (6.2), but some also apply to the case of general linear function approximation. These results are discussed in a more general setting in Chapter 9.\nIf both TD and Monte Carlo methods converge asymptotically to the correct pre\u0026shy;dictions, then a natural next question is \\A1\\B0Which gets there first?\\A1\\B1 In other words, which method learns faster? Which makes the more efficient use of limited data? At the current time this is an open question in the sense that no one has been able to prove mathematically that one method converges faster than the other. In fact, it is not even clear what is the most appropriate formal way to phrase this question! In practice, however, TD methods have usually been found to converge faster than constant-a MC methods on stochastic tasks, as illustrated in Example 6.2.\nExercise 6.2 This is an exercise to help develop your intuition about why TD methods are often more efficient than Monte Carlo methods. Consider the driving home example and how it is addressed by TD and Monte Carlo methods. Can you imagine a scenario in which a TD update would be better on average than a Monte Carlo update? Give an example scenario\\A1\\AAa description of past experience and a current state\\A1\\AAin which you would expect the TD update to be better. Here\\A1\\AFs a hint: Suppose you have lots of experience driving home from work. Then you move to a new building and a new parking lot (but you still enter the highway at the same place). Now you are starting to learn predictions for the new building. Can you see why TD updates are likely to be much better, at least initially, in this case? Might the same sort of thing happen in the original task?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 6.3 From Figure 6.2 (left) it appears that the first episode results in a change in only V(A). What does this tell you about what happened on the first episode? Why was only the estimate for this one state changed? By exactly how much was it changed?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExample 6.2: Random Walk In this example we empirically compare the prediction abilities of TD(0) and constant-a MC applied to the small Markov reward process shown in the upper part of the figure below. All episodes start in the center state, C, and proceed either left or right by one state on each step, with equal probability. This behavior can be thought of as due to the combined effect of a fixed policy and an environment\\A1\\AFs state-transition probabilities, but we do not care which; we are concerned only with predicting returns however they are generated. Episodes terminate either on the extreme left or the extreme right. When an episode terminates on the right, a reward of +1 occurs; all other rewards are zero. For example, a typical epsiode might consist of the following state-and-reward sequence: C, 0, B, 0, C, 0, D, 0, E, 1. Because this task is undiscounted, the true value of each state is the probability of terminating on the right if starting from that state. Thus, the true value of the center state is v^(C) = 0.5. The true values of all the states, A through E, are 1, |, |, |, and |. The left part of Figure 6.2 shows the values learned by TD(0) approaching the true values as more episodes are experienced. Averaging over many episode sequences, the right part of the figure shows the average error in the predictions found by TD(0) and constant-a MC, for a variety of values of a, as a function of number of episodes. In all cases the approximate value function was initialized to the intermediate value V(s) = 0.5, for all s. The TD method was consistently better than the MC method on this task.\nstart\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nState\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Walks\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; /\u0026nbsp; Episodes\nFigure 6.2: Results with the 5-state random walk. Above: The small Markov reward process generating the episodes. Left: Results from a single run after various numbers of episodes. The estimate after 100 episodes is about as close as they ever get to the true values; with a constant step-size parameter (a = 0.1in this example), the values fluctuate indefinitely in response to the outcomes of the most recent episodes. Right: Learning curves for TD(0) and constant-a MC methods, for various values of a. The performance measure shown is the root mean-squared (RMS) error between the value function learned and the true value function, averaged over the five states. These data are averages over 100 different sequences of episodes.\n\\A1\\F6\nExercise 6.4 The specific results shown in Figure 6.2 (right) are dependent on the value of the step-size parameter, a. Do you think the conclusions about which algorithm is better would be affected if a wider range of a values were used? Is there a different, fixed value of a at which either algorithm would have performed significantly better than shown? Why or why not?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n*Exercise 6.5 In Figure 6.2 (right) the RMS error of the TD method seems to go down and then up again, particularly at high a\\A1\\AFs. What could have caused this? Do you think this always occurs, or might it be a function of how the approximate value function was initialized?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 6.6 Above we stated that the true values for the random walk task are 6,6,\\CA\\EE,6, and \\CA\\EE,forstates A through E. Describe at least two different ways that these could have been computed. Which would you guess we actually used? Why?\n\\A1\\F5\n6.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimality of TD(0)\nSuppose there is available only a finite amount of experience, say 10 episodes or 100 time steps. In this case, a common approach with incremental learning methods is to present the experience repeatedly until the method converges upon an answer. Given an approximate value function, V, the increments specified by (6.1) or (6.2) are computed for every time step t at which a nonterminal state is visited, but the value function is changed only once, by the sum of all the increments. Then all the available experience is processed again with the new value function to produce a new overall increment, and so on, until the value function converges. We call this batch updating because updates are made only after processing each complete batch of training data.\nUnder batch updating, TD(0) converges deterministically to a single answer in\u0026shy;dependent of the step-size parameter, a, as long as a is chosen to be sufficiently small. The constant-a MC method also converges deterministically under the same conditions, but to a different answer. Understanding these two answers will help us understand the difference between the two methods. Under normal updating the methods do not move all the way to their respective batch answers, but in some sense they take steps in these directions. Before trying to understand the two answers in general, for all possible tasks, we first look at a few examples.\nExample 6.3: Random walk under batch updating Batch-updating versions of TD(0) and constant-a MC were applied as follows to the random walk predic\u0026shy;tion example (Example 6.2). After each new episode, all episodes seen so far were treated as a batch. They were repeatedly presented to the algorithm, either TD(0) or constant-a MC, with a sufficiently small that the value function converged. The re\u0026shy;sulting value function was then compared with v^, and the average root mean-squared error across the five states (and across 100independent repetitions of the whole ex\u0026shy;periment) was plotted to obtain the learning curves shown in Figure 6.3. Note that the batch TD method was consistently better than the batch Monte Carlo method.\n\n\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n RMS error, averaged over states\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Walks / Episodes\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 6.3: Performance of TD(0) and constant-a MC under batch training on the random walk task.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nUnder batch training, constant-a MC converges to values, V(s), that are sample averages of the actual returns experienced after visiting each state s. These are optimal estimates in the sense that they minimize the mean-squared error from the actual returns in the training set. In this sense it is surprising that the batch TD method was able to perform better according to the root mean-squared error measure shown in Figure 6.3. How is it that batch TD was able to perform better than this optimal method? The answer is that the Monte Carlo method is optimal only in a limited way, and that TD is optimal in a way that is more relevant to predicting returns. But first let\\A1\\AFs develop our intuitions about different kinds of optimality through another example. Consider Example 6.4, on the next page.\nExample 6.4 illustrates a general difference between the estimates found by batch TD(0) and batch Monte Carlo methods. Batch Monte Carlo methods always find the estimates that minimize mean-squared error on the training set, whereas batch TD(0) always finds the estimates that would be exactly correct for the maximum-likelihood model of the Markov process. In general, the maximum-likelihood estimate of a parameter is the parameter value whose probability of generating the data is greatest. In this case, the maximum-likelihood estimate is the model of the Markov process formed in the obvious way from the observed episodes: the estimated transition probability from i to j is the fraction of observed transitions from i that went to j, and the associated expected reward is the average of the rewards observed on those transitions. Given this model, we can compute the estimate of the value function that would be exactly correct if the model were exactly correct. This is called the certainty-equivalence estimate because it is equivalent to assuming that the estimate of the underlying process was known with certainty rather than being approximated. In general, batch TD(0) converges to the certainty-equivalence estimate.\nThis helps explain why TD methods converge more quickly than Monte Carlo methods. In batch form, TD(0) is faster than Monte Carlo methods because it com-\nExample 6.4 You are the Predictor\nPlace yourself now in the role of the predictor of returns for an unknown Markov reward process. Suppose you observe the following eight episodes:\n\n\n   A,0,B, 0\nB,1 B, 1 B, 1\n        1110 B, B, B, B,\n              \u0026nbsp;\n\u0026nbsp;\n This means that the first episode started in state A, transitioned to B with a reward of 0, and then terminated from B with a reward of 0. The other seven episodes were even shorter, starting from B and terminating immediately. Given this batch of data, what would you say are the optimal predictions, the best values for the estimates V(A) and V(B)? Everyone would probably agree that the optimal value for V(B) is |, because six out of the eight times in state B the process terminated immediately with a return of 1, and the other two times in B the process terminated immediately with a return of 0.\nBut what is the optimal value for the estimate V(A) given this data? Here there are two reasonable answers. One is to observe that 100% of the times the process was in state A it traversed immediately to B (with a reward of 0); and since we have already decided that B has value |, therefore A must have value 4 as well. One way of viewing this answer is that it is based on first modeling the Markov process,\nin this case as shown to the right, and then computing the correct estimates given the model, which indeed in this case gives V(A) = 4. This is also the answer that batch TD(0) gives.\nThe other reasonable answer is simply to observe that we have seen A once and the return that followed it was 0; we therefore estimate V(A) as 0. This is the answer that batch Monte Carlo methods give. Notice that it is also the answer that gives minimum squared error on the training data. In fact, it gives zero error on the data. But still we expect the first answer to be better. If the process is Markov, we expect that the first answer will produce lower error on future data, even though the Monte Carlo answer is better on the existing data.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6putes the true certainty-equivalence estimate. This explains the advantage of TD(0) shown in the batch results on the random walk task (Figure 6.3). The relationship to the certainty-equivalence estimate may also explain in part the speed advantage of nonbatch TD(0) (e.g., Figure 6.2, right). Although the nonbatch methods do not achieve either the certainty-equivalence or the minimum squared-error estimates, they can be understood as moving roughly in these directions. Nonbatch TD(0) may be faster than constant-a MC because it is moving toward a better estimate, even though it is not getting all the way there. At the current time nothing more definite can be said about the relative efficiency of on-line TD and Monte Carlo methods.\nFinally, it is worth noting that although the certainty-equivalence estimate is in some sense an optimal solution, it is almost never feasible to compute it directly. If N is the number of states, then just forming the maximum-likelihood estimate of the process may require N2memory, and computing the corresponding value function requires on the order of N3computational steps if done conventionally. In these terms it is indeed striking that TD methods can approximate the same solution using memory no more than N and repeated computations over the training set. On tasks with large state spaces, TD methods may be the only feasible way of approximating the certainty-equivalence solution.\nsKExercise 6.7 Design an off-policy version of the TD(0) update that can be used with arbitrary target policy n and covering behavior policy b, using at each step t the importance sampling ratio pt\\A3\\BAt(5.3).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n6.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sarsa: On-policy TD Control\nWe turn now to the use of TD prediction methods for the control problem. As usual, we follow the pattern of generalized policy iteration (GPI), only this time using TD methods for the evaluation or prediction part. As with Monte Carlo methods, we face the need to trade off exploration and exploitation, and again approaches fall into two main classes: on-policy and off-policy. In this section we present an on-policy TD control method.\nThe first step is to learn an action-value function rather than a state-value function. In particular, for an on-policy method we must estimate (s, a) for the current behavior policy n and for all states s and actions a. This can be done using essentially the same TD method described above for learning Vn. Recall that an episode consists of an alternating sequence of states and state-action pairs:\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nIn the previous section we considered transitions from state to state and learned the values of states. Now we consider transitions from state-action pair to state-action pair, and learn the values of state-action pairs. Formally these cases are identical: they are both Markov chains with a reward process. The theorems assuring the convergence of state values under TD(0) also apply to the corresponding algorithmfor action values:\n   (6.7)\n     Q(St, At)Q(St, At) + a Rt+i + 7Q(St+i, At+i) \\A1\\AA Q(St, At)\n   Sarsa\n     This update is done after every transition from a nonterminal state St. If St+i is terminal, then Q(St+i, At+i) is defined as zero. This rule uses every element of the quintuple of events, (St, At, Rt+i, St+i, At+i), that make up a transition from one state-action pair to the next. This quintuple gives rise to the name Sarsa for the algorithm. The backup diagram for Sarsa is as shown to the right.\n\n\n\u0026nbsp;\n \nExercise 6.8Show that an action-value version of (6.6) holds for the action-value form of the TD error \u0026#12316;=Rt+i+ YQ(St+i, At+i \\A1\\AA Q(St, At), again assuming that the values don\\A1\\AFt change from step to step.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nIt is straightforward to design an on-policy control algorithm based on the Sarsa prediction method. As in all on-policy methods, we continually estimate for the behavior policy n, and at the same time change n toward greediness with respect to qn. The general form of the Sarsa control algorithm is given in the box below.\nSarsa (on-policy TD control) for estimating Q ^ q*\nInitialize Q(s, a), Vs G S, a G A(s), arbitrarily, and Q(terminal-state,\u0026#8226;) = 0 Repeat (for each episode):\nInitialize S\nChoose A from S using policy derived from Q (e.g., e-greedy)\nRepeat (for each step of episode):\nTake action A, observe R, S7\nChoose A7 from S7 using policy derived from Q (e.g., e-greedy)\nQ(S, A) ^ Q(S,A)+ a[R + 7Q(S7, A7) \\A1\\AA Q(S, A)]\nS ^ S7; A ^ A7; until S is terminal\nThe convergence properties of the Sarsa algorithm depend on the nature of the policy\\A1\\AFs dependence on Q. For example, one could use e-greedy or e-soft policies. According to Satinder Singh (personal communication), Sarsa converges with prob\u0026shy;ability 1to an optimal policy and action-value function as long as all state-action pairs are visited an infinite number of times and the policy converges in the limit to the greedy policy (which can be arranged, for example, with e-greedy policies by setting e = 1/t), but this result has not yet been published in the literature.\nExample 6.5: Windy Gridworld Shown inset in Figure 6.4 is a standard grid- world, with start and goal states, but with one difference: there is a crosswind up\u0026shy;ward through the middle of the grid. The actions are the standard four\\A1\\AAup, down, right, and left\\A1\\AAbut in the middle region the resultant next states are shifted up\u0026shy;ward by a \\A1\\B0wind,\\A1\\B1 the strength of which varies from column to column. The strength of the wind is given below each column, in number of cells shifted upward. For ex\u0026shy;ample, if you are one cell to the right of the goal, then the action left takes you to\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nTime steps\n   Figure 6.4: altered by a also shown.\n     Results of Sarsa applied to a gridworld (shown inset) in which movement is location-dependent, upward \\A1\\B0wind.\\A1\\B1 A trajectory under the optimal policy is\nthe cell just above the goal. Let us treat this as an undiscounted episodic task, with constant rewards of \\A1\\AA1until the goal state is reached.\nThe graph in Figure 6.4 shows the results of applying e-greedy Sarsa to this task, with e= 0.1, a = 0.5, and the initial values Q(s, a) = 0 for all s, a. The increasing slope of the graph shows that the goal is reached more and more quickly over time. By 8000 time steps, the greedy policy was long since optimal (a trajectory from it is shown inset); continued e-greedy exploration kept the average episode length at about 17 steps, two more than the minimum of 15. Note that Monte Carlo methods cannot easily be used on this task because termination is not guaranteed for all policies. If a policy was ever found that caused the agent to stay in the same state, then the next episode would never end. Step-by-step learning methods such as Sarsa do not have this problem because they quickly learn during the episodethat such policies are poor, and switch to something else.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 6.9: Windy Gridworld with King\\A3\\ACsMovesRe-solve the windy gridworld task assuming eight possible actions, including the diagonal moves, rather than the usual four. How much better can you do with the extra actions? Can you do even better by including a ninth action that causes no movement at all other than that caused by the wind?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 6.10: Stochastic WindRe-solve the windy gridworld task with King\\A1\\AFs moves, assuming that the effect of the wind, if there is any, is stochastic, sometimes varying by 1 from the mean values given for each column. That is, a third of the time you move exactly according to these values, as in the previous exercise, but also a third of the time you move one cell above that, and another third of the time you move one cell below that. For example, if you are one cell to the right of the goal and you move left, then one-third of the time you move one cell above the goal, one-third of the time you move two cells above the goal, and one-third of the time\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z you move to the goal.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n6.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Q-learning: Off-policy TD Control\nOne of the early breakthroughs in reinforcement learning was the development of an off-policy TD control algorithm known as Q-learning (Watkins, 1989), defined by\nQ(St, At) ^ Q(St, At) + a Rt+1+ 7maxQ(St+1,a) \\A1\\AA Q(St, At) \u0026#8226;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (6.8)\n.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; .\nIn this case, the learned action-value function, Q, directly approximates q^, the op\u0026shy;timal action-value function, independent of the policy being followed. This dramat\u0026shy;ically simplifies the analysis of the algorithm and enabled early convergence proofs. The policy still has an effect in that it determines which state-action pairs are visited and updated. However, all that is required for correct convergence is that all pairs continue to be updated. As we observed in Chapter 5, this is a minimal requirement in the sense that any method guaranteed to find optimal behavior in the general case must require it. Under this assumption and a variant of the usual stochastic approx\u0026shy;imation conditions on the sequence of step-size parameters, Q has been shown to converge with probability 1 to q^. The Q-learning algorithm is shown in procedural form in the box below.\nQ-learning (off-policy TD control) for estimating n nľ\nInitialize Q(s, a), Vs G S, a G A(s), arbitrarily, and Q(terminal-state, \\A1\\F6) = 0 Repeat (for each episode):\nInitialize S\nRepeat (for each step of episode):\nChoose A from S using policy derived from Q (e.g., e-greedy)\nTake action A, observe R, S7\nQ(S, A) ^ Q(S, A)+ a[R + 7max0Q(S7, a) \\A1\\AA Q(S, A)]\nS ^ S7until S is terminal\nWhat is the backup diagram for Q-learning? The rule (6.8) updates a state-action pair, so the top node, the root of the backup, must be a small, filled action node. The backup is also from action nodes, maximizing over all those actions possible in the next state. Thus the bottom nodes of the backup diagram should be all these action nodes. Finally, remember that we indicate taking the maximum of these \\A1\\B0next action\\A1\\B1 nodes with an arc across them (Figure 3.7-right). Can you guess now what the diagram is? If so, please do make a guess before turning to the answer in Figure 6.6on page 144.\n   R =\n        Sarsa\n        Sum of rewards during episode\n        Figure 6.5: The cliff-walking task. The results are from a single run, but smoothed by averaging the reward sums from 10successive episodes.\n        Episodes\n     Example 6.6: Cliff Walking This gridworld example compares Sarsa and Q- learning, highlighting the difference between on-policy (Sarsa) and off-policy (Q- learning) methods. Consider the gridworld shown in the upper part of Figure 6.5. This is a standard undiscounted, episodic task, with start and goal states, and the \n\n\nusual actions causing movement up, down, right, and left. Reward is \\A1\\AA1 on all transitions except those into the region marked \\A1\\B0The Cliff.\\A1\\B1 Stepping into this region incurs a reward of \\A1\\AA100and sends the agent instantly back to the start.\nThe lower part of Figure 6.5 shows the performance of the Sarsa and Q-learning methods with e-greedy action selection, e = 0.1. After an initial transient, Q-learning learns values for the optimal policy, that which travels right along the edge of the cliff. Unfortunately, this results in its occasionally falling off the cliff because of the e-greedy action selection. Sarsa, on the other hand, takes the action selection into account and learns the longer but safer path through the upper part of the grid. Although Q-learning actually learns the values of the optimal policy, its on\u0026shy;line performance is worse than that of Sarsa, which learns the roundabout policy. Of course, if e were gradually reduced, then both methods would asymptotically converge to the optimal policy.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 6.11 Why is Q-learning considered an off-policy control method? \\A1\\F5\nA\nQ-learning\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ExpectedSarsa\nFigure 6.6: The backup diagrams for Q-learning and expected Sarsa.\n6.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Expected Sarsa\nConsider the learning algorithm that is just like Q-learning except that instead of the maximum over next state-action pairs it uses the expected value, taking into account how likely each action is under the current policy. That is, consider the algorithm with the update rule\nQ(St, At)Q(St, At)+ a Rt+1+ YE[Q(St+1, At+1)| St+1] \\A1\\AA Q(St, At)\nQ(St,At)+ a Rt+i + 7n(a|St+i)Q(St+i, a) \\A1\\AAQ(St,At) , (6.9)\na\nbut that otherwise follows the schema of Q-learning. Given the next state, St+i, this algorithm moves deterministically in the same direction as Sarsa moves in expecta\u0026shy;tion, and accordingly it is called expected Sarsa. Its backup diagram is shown on the right in Figure 6.6.\nExpected Sarsa is more complex computationally than Sarsa but, in return, it eliminates the variance due to the random selection of At+i. Given the same amount of experience we might expect it to perform slightly better than Sarsa, and indeed it generally does. Figure 6.7 shows summary results on the cliff-walking task with Ex\u0026shy;pected Sarsa compared to Sarsa and Q-learning. As an on-policy method, Expected Sarsa retains the significant advantage of Sarsa over Q-learning on this problem. In addition, Expected Sarsa shows a significant improvement over Sarsa over a wide range of values for the step-size parameter a. In cliff walking the state transitions are all deterministic and all randomness comes from the policy. In such cases, Ex\u0026shy;pected Sarsa can safely set a = 1 without suffering any degradation of asymptotic performance, whereas Sarsa can only perform well in the long run at a small value of a, at which short-term performance is poor. In this and other examples there is a consistent empirical advantage of Expected Sarsa over Sarsa.\nIn these cliff walking results we have taken Expected Sarsa to be an on-policy algorithm, but in general we can use a policy different from the target policy n to generate behavior, in which case Expected Sarsa becomes an off-policy algorithm. For example, suppose n is the greedy policy while behavior is more exploratory; then Expected Sarsa is exactly Q-learning. In this sense Expected Sarsa subsumes and generalizes Q-learning while reliably improving over Sarsa. Except for the small additional computational cost, Expected Sarsa may completely dominate both of the other more-well-known TD control algorithms.\n6.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Maximization Bias and Double Learning\nAll the control algorithms that we have discussed so far involve maximization in the construction of their target policies. For example, in Q-learning the target policy is the greedy policy given the current action values, which is defined with a max, and in Sarsa the policy is often e-greedy, which also involves a maximization operation. In these algorithms, a maximum over estimated values is used implicitly as an estimate of the maximumvalue, which can lead to a significant positive bias. To see why, consider a single state s where there are many actions a whose true values, q(s, a), are all zero but whose estimated values, Q(s,a), are uncertain and thus distributed some above and some below zero. The maximum of the true values is zero, but the maximum of the estimates is positive, a positive bias. We call this maximization bias.\nExample 6.7: Maximization Bias Example The smaHl MDP ehown inset in Figure 6.8provides a simple example of how maximization bias can harm the performa nce of TD control algorithm s. The MDP has two non-termin al states A and B. Episodes always start in A with a choice between two actions, left and right. The right net ion transitions immediately to the terminal state with a reward and return of zero. The left action transitions to B, also with a reward of zero, from which there are many possible actions all of which cause immediate termination with a\n   -40\n        0.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1\nCh\n        Figure 6.7: Interim and asymptotic performance ofTDcontrol methods on the cliff-walking task as a function of a. All algorithms used an e-greedy policy with e= 0.1. Asymptotic performance is an average over 100,000episodes whereas interim performance is an average over the first 100 episodes. These data are averages of over 50,000 and 10 runs for the interim and asymptotic cases respectively. The solid circles mark the best interim performance of each method. Adapted from van Seijen et al. (2009).\n        Reward per -80 episode\n-120\n     o\n \nreward drawn from a normal distribution with mean \\A1\\AA0.1 and variance 1.0. Thus, the expected return for any trajectory starting with left is \\A1\\AA0.1, and thus taking left in state A is always a mistake. Nevertheless, our control methods may favor left because of maximization bias making B appear to have a positive value. Figure 6.8 shows that Q-learning with e-greedy action selection initially learns to strongly favor the left action on this example. Even at asymptote, Q-learning takes the left action about 5% more often than is optimal at our parameter settings (e = 0.1, a = 0.1, and y = 1).\n \n   Figure 6.8: Comparison of Q-learning and Double Q-learning on a simple episodic MDP (shown inset). Q-learning initially learns to take the left action much more often than the right action, and always takes it significantly more often than the 5% minimum probability enforced by e-greedy action selection with e = 0.1. In contrast, Double Q-learning is essentially unaffected by maximization bias. These data are averaged over 10,000 runs. The initial action-value estimates were zero. Any ties in e-greedy action selection were broken randomly.\n\\A1\\F6\n        Episodes\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Are there algorithms that avoid maximization bias? To start, consider a bandit case in which we have noisy estimates of the value of each of many actions, obtained as sample averages of the rewards received on all the plays with each action. As we discussed above, there will be a positive maximization bias if we use the maximum of the estimates as an estimate of the maximum of the true values. One way to view the problem is that it is due to using the same samples (plays) both to determine the maximizing action and to estimate its value. Suppose we divided the plays in two sets and used them to learn two independent estimates, call them Qi(a) and Q2(a), each an estimate of the true value q(a), for all a G A. We could then use one estimate, say Qi, to determine the maximizing action A* = argmaxa Qi(a), and the other, Q2, to provide the estimate of its value, Q2(A*)= Q2(argmaxa Qi(a)). This estimate will then be unbiased in the sense that E[Q2(A*)] = q(A*).We can also repeat the process with the role of the two estimates reversed to yield a second unbiased estimate Qi(argmaxaQ2(a)). This is the idea of doubled learning. Note that although we learn two estimates, only one estimate is updated on each play; doubled learning doubles the memory requirements, but is no increase at all in theamount of computation per step.\nThe idea of doubled learning extends naturally to algorithms for full MDPs. For example, the doubled learning algorithm analogous to Q-learning, called Double Q- learning, divides the time steps in two, perhaps by flipping a coin on each step. If the coin comes up heads, the update is\nQi(St, At) ^ Qi (St, At)+ a Rt+i + yQ^ St+i, argmax Qi (St+i,a)) \\A1\\AA Qi(St, At).\na\n(6.10)\nIf the coin comes up tails, then the same update is done with Qi and Q2switched, so that Q2is updated. The two approximate value functions are treated completely symmetrically. The behavior policy can use both action value estimates. For ex\u0026shy;ample, an e-greedy policy for Double Q-learning could be based on the average (or sum) of the two action-value estimates. A complete algorithm for Double Q-learning is given below. This is the algorithm used to produce the results in Figure 6.8. In that example, doubled learning seems to eliminate the harm caused by maximization bias. Of course there are also doubled versions of Sarsa and Expected Sarsa.\nDouble Q-learning\n \n\u0026nbsp;\n \nInitialize Qi(s, a) and Q2(s, a), Vs G S, a G A(s), arbitrarily Initialize Q1(terminal-state,\u0026#8226;) = Q2(terminal-state,\u0026#8226;) = 0 Repeat (for each episode):\nInitialize S\nRepeat (for each step of episode):\n   in Qi ʮQ2)\nA))\nA))\n     Choose A from S using policy derived from Qi and Q2(e.g., e-greedy Take action A, observe R, S7 With 0.5 probabilility:\nQi(S, A) ^ Qi(S, A)ʮa(ֻʮYQ2(S7, argmaxa Qi(S7, a)) \\A1\\AA Qi(S, else:\nQ2(S, A) ^ Q2(S, A)ʮa(R ʮyQi(S7, argmaxa Q2(S7, a)) \\A1\\AA Q2(S, S ^ S7 until S is terminal\n \n\u0026nbsp;\n\u0026nbsp;\n \n*Exercise 6.12 What are the update equations for Double Expected Sarsa with an e-greedy target policy?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n6.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Games, Afterstates, and Other Special Cases\nIn this book we try to present a uniform approach to a wide class of tasks, but of course there are always exceptional tasks that are better treated in a specialized way. For example, our general approach involves learning an action-value function, but in Chapter 1 we presented a TD method for learning to play tic-tac-toe that learned something much more like a state-value function. If we look closely at that example, it\nbecomes apparent that the function learned there is neither an action-value function nor a state-value function in the usual sense. A conventional state-value function evaluates states in which the agent has the option of selecting an action, but the state-value function used in tic-tac-toe evaluates board positions after the agent has made its move. Let us call these afterstates, and value functions over these, afterstate value functions. Afterstates are useful when we have knowledge of an initial part of the environment\\A1\\AFs dynamics but not necessarily of the full dynamics. For example, in games we typically know the immediate effects of our moves. We know for each possible chess move what the resulting position will be, but not how our opponent will reply. Afterstate value functions are a natural way to take advantage of this kind of knowledge and thereby produce a more efficient learning method.\nThe reason it is more efficient to design algorithms in terms of afterstates is appar\u0026shy;ent from the tic-tac-toe example. A conventional action-value function would map from positions and moves to an estimate of the value. But many position-move pairs produce the same resulting position, as in this example:\n \n   X\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n O\n +\n \u0026nbsp;\n X\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026nbsp;\n X\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n O\n X + \\A1\\AA_\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n     \u0026nbsp;\n\u0026nbsp;\n  \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nIn such cases the position-move pairs are different but produce the same \\A1\\B0afterpo\u0026shy;sition,\\A1\\B1 and thus must have the same value. A conventional action-value function would have to separately assess both pairs, whereas an afterstate value function would immediately assess both equally. Any learning about the position-move pair on the left would immediately transfer to the pair on the right.\nAfterstates arise in many tasks, not just games. For example, in queuing tasks there are actions such as assigning customers to servers, rejecting customers, or discarding information. In such cases the actions are in fact defined in terms of their immediate effects, which are completely known.\nIt is impossible to describe all the possible kinds of specialized problems and cor\u0026shy;responding specialized learning algorithms. However, the principles developed in this book should apply widely. For example, afterstate methods are still aptly de\u0026shy;scribed in terms of generalized policy iteration, with a policy and (afterstate) value function interacting in essentially the same way. In many cases one will still face the choice between on-policy and off-policy methods for managing the need for persistent exploration.\nExercise 6.13 Describe how the task of Jack\\A1\\AFs Car Rental (Example 4.2) could be reformulated in terms of afterstates. Why, in terms of this specific task, would such a reformulation be likely to speed convergence?\\A1\\F5\n6.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nIn this chapter we introduced a new kind of learning method, temporal-difference (TD) learning, and showed how it can be applied to the reinforcement learning prob\u0026shy;lem. As usual, we divided the overall problem into a prediction problem and a control problem. TD methods are alternatives to Monte Carlo methods for solving the pre\u0026shy;diction problem. In both cases, the extension to the control problem is via the idea of generalized policy iteration (GPI) that we abstracted from dynamic programming. This is the idea that approximate policy and value functions should interact in such a way that they both move toward their optimal values.\nOne of the two processes making up GPI drives the value function to accurately predict returns for the current policy; this is the prediction problem. The other process drives the policy to improve locally (e.g., to be e-greedy) with respect to the current value function. When the first process is based on experience, a complication arises concerning maintaining sufficient exploration. We can classify TD control methods according to whether they deal with this complication by using an on- policy or off-policy approach. Sarsa is an on-policy method, and Q-learning is an off-policy method. Expected Sarsa is also an off-policy method as we present it here. There is a third way in which TD methods can be extended to control which we did not include in this chapter, called actor-critic methods. These method are covered in full in Chapter 13.\nThe methods presented in this chapter are today the most widely used reinforce\u0026shy;ment learning methods. This is probably due to their great simplicity: they can be applied on-line, with a minimal amount of computation, to experience generated from interaction with an environment; they can be expressed nearly completely by single equations that can be implemented with small computer programs. In the next few chapters we extend these algorithms, making them slightly more complicated and significantly more powerful. All the new algorithms will retain the essence of those introduced here: they will be able to process experience on-line, with relatively little computation, and they will be driven by TD errors. The special cases of TD methods introduced in the present chapter should rightly be called one-step, tabular, model- free TD methods. In the next two chapters we extend them to multistep forms (a link to Monte Carlo methods) and forms that include a model of the environment (a link to planning and dynamic programming). Then, in the second part of the book we extend them to various forms of function approximation rather than tables (a link to deep learning and artificial neural networks).\nFinally, in this chapter we have discussed TD methods entirely within the context of reinforcement learning problems, but TD methods are actually more general than this. They are general methods for learning to make long-term predictions about dynamical systems. For example, TD methods may be relevant to predicting financial data, life spans, election outcomes, weather patterns, animal behavior, demands on power stations, or customer purchases. It was only when TD methods were analyzed as pure prediction methods, independent of their use in reinforcement learning, that their theoretical properties first came to be well understood. Even so, these other\npotential applications of TD learning methods have not yet been extensively explored.\nBibliographical and Historical Remarks\nAs we outlined in Chapter 1, the idea of TD learning has its early roots in ani\u0026shy;mal learning psychology and artificial intelligence, most notably the work of Samuel (1959) and Klopf (1972). Samuel\\A1\\AFs work is described as a case study in Section 16.2. Also related to TD learning are Holland\\A1\\AFs (1975, 1976) early ideas about consistency among value predictions. These influenced one of the authors (Barto), who was a graduate student from 1970 to 1975 at the University of Michigan, where Holland was teaching. Holland\\A1\\AFs ideas led to a number of TD-related systems, including the work of Booker (1982) and the bucket brigade of Holland (1986), which is related to Sarsa as discussed below.\n6.1-2 Most of the specific material from these sections is from Sutton (1988), includ\u0026shy;ing the TD(0) algorithm, the random walk example, and the term \\A1\\B0temporal- difference learning.\\A1\\B1 The characterization of the relationship to dynamic programming and Monte Carlo methods was influenced by Watkins (1989), Werbos (1987), and others. The use of backup diagrams here and in other chapters is new to this book.\nTabular TD(0) was proved to converge in the mean by Sutton (1988) and with probability 1 by Dayan (1992), based on the work of Watkins and Dayan (1992). These results were extended and strengthened by Jaakkola, Jordan, and Singh (1994) and Tsitsiklis (1994) by using extensions of the powerful existing theory of stochastic approximation. Other extensions and general\u0026shy;izations are covered in later chapters.\n6.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The optimality of the TD algorithm under batch training was established by Sutton (1988). Illuminating this result is Barnard\\A1\\AFs (1993) derivation of the TD algorithm as a combination of one step of an incremental method for learning a model of the Markov chain and one step of a method for computing predictions from the model. The term certainty equivalence is from the adaptive control literature (e.g., Goodwin and Sin, 1984).\n6.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Sarsa algorithm was introduced by Rummery and Niranjan (1994). They explored it in conjunction with neural networks and called it \\A1\\B0Modified Con- nectionist Q-learning\\A1\\B1. The name \\A1\\B0Sarsa\\A1\\B1 was introduced by Sutton (1996). The convergence of one-step tabular Sarsa (the form treated in this chapter) has been proved by Satinder Singh (personal communication). The \\A1\\B0windy gridworld\\A1\\B1 example was suggested by Tom Kalt.\nHolland\\A1\\AFs (1986) bucket brigade idea evolved into an algorithm closely related to Sarsa. The original idea of the bucket brigade involved chains of rules triggering each other; it focused on passing credit back from the current rule to the rules that triggered it. Over time, the bucket brigade came to be more \n\n\nlike TD learning in passing credit back to any temporally preceding rule, not just to the ones that triggered the current rule. The modern form of the bucket brigade, when simplified in various natural ways, is nearly identical to one-step Sarsa, as detailed by Wilson (1994).\n6.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Q-learning was introduced by Watkins (1989), whose outline of a conver\u0026shy;gence proof was made rigorous by Watkins and Dayan (1992). More general convergence results were proved by Jaakkola, Jordan, and Singh (1994) and Tsitsiklis (1994).\n6.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Expected Sarsa was first described in an exercise in the first edition of this book, then fully investigated by van Seijen, van Hasselt, Whiteson, and Weir\u0026shy;ing (2009). They established its convergence properties and conditions under which it will outperform regular Sarsa and Q-learning. Our Figure 6.7 is adapted from their results. Our presentation differs slightly from theirs in that they define \\A1\\B0Expected Sarsa\\A1\\B1 to be an on-policy method exclusively, whereas we use this name for the general algorithm in which the target and behavior policies are allowed to differ.\n6.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Maximization bias and doubled learning were introduced and extensively in\u0026shy;vestigated by Hado van Hasselt (2010, 2011). The example MDP in Figure 6.8 was adapted from that in his Figure 4.1 (van Hasselt, 2011).\n6.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The notion of an afterstate is the same as that of a \\A1\\B0post-decision state\\A1\\B1 (Van Roy et al., 1997; Powell, 2010).\n \n152\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER6.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TEMPORAL-DIFFERENCE\u0026nbsp;\u0026nbsp;\u0026nbsp; LEARNING\n \nChapter 7\nMulti-step Bootstrapping\nIn this chapter we unify the methods presented in the previous two chapters. Neither Monte Carlo methods nor the one-step TD methods presented in the previous chapter are always the best. Multi-step TD methods generalize both these methods so that one can switch from one to the other smoothly. They span a spectrum with Monte Carlo methods at one end and one-step TD methods at the other, and often the intermediate methods will perform better than either extreme method.\nAnother way of looking at the benefits of multi-step methods is that they free you from the tyranny of the time step. With one-step methods the same step determines how often the action can be changed and the time interval over which bootstrapping is done. In many applications one wants to be able to update the action very fast to take into account anything that has changed, but bootstrapping works best if it is over a length of time in which a significant and recognizable state change has occurred. With one-step methods, these time intervals are the same and so a compromise must be made. Multi-step methods enable bootstrapping to occur over longer time intervals, freeing us from the tyranny of the single time step.\nMulti-step methods are usually associated with the algorithmic idea of eligibility traces, but here we will consider the multi-step idea on its own, postponing the treatment of eligibility-trace mechanisms until later, in Chapter 12.\nAs usual, we first consider the prediction problem and then the control problem. That is, we first consider how multi-step methods can help in predicting returns as a function of state for a fixed policy (i.e., in estimating ). Then we extend the ideas to action values and control methods.\n7.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step TD Prediction\nWhat is the space of methods lying between Monte Carlo and TD methods? Consider estimating from sample episodes generated using n. Monte Carlo methods perform a backup for each state based on the entire sequence of observed rewards from that state until the end of the episode. The backup of one-step TD methods, on the other hand, is based on just the one next reward, bootstrapping from the value of thestate one step later as a proxy for the remaining rewards. One kind of intermediate method, then, would perform a backup based on an intermediate number of rewards: more than one, but less than all of them until termination. For example, a two-step backup would be based on the first two rewards and the estimated value of the state two steps later. Similarly, we could have three-step backups, four-step backups, and so on. Figure 7.1 diagrams the spectrum of n-step backupsfor Vn, with the one-step TD backup on the left and the up-until-termination Monte Carlo backup on the right.\nThe methods that use n-step backups are still TD methods because they still change an earlier estimate based on how it differs from a later estimate. Now the later estimate is not one step later, but n steps later. Methods in which the temporal difference extends over n steps are called n-step TD methods. The TD methods introduced in the previous chapter all used one-step backups, which is why we call them one-step TD methods.\nMore formally, consider the backup applied to state St as a result of the state- reward sequence, St,\\B3\\F3t+1, St+1,\\B3\\F3t+2, \u0026#8226; \u0026#8226; \u0026#8226;, Rt, St (omitting the actions for simplic\u0026shy;ity). We know that in Monte Carlo backups the estimate of Vn (St) is updated in the direction of the complete return:\nGt =\\C4\\E2ʮ1+ Y \\C4\\E2ʮ2+ 72\\C4\\E2ʮ3 + \\A1\\F6\\A1\\F6\\A1\\F6 + 7T-t-1RT,\n \n\u0026nbsp;\n\u0026nbsp;\n \n1 -step TD\nand TD(0) 2-step TD 3-step TD\nM-step TD n-step TD and Monte Carlo\n \n\u0026nbsp;\n\u0026nbsp;\n \n\\B6\\A1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\C1\\CB\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\B6\\A1\n\\A9\\96\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; o\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; o\n\\A9\\96\n\\A9\\96\n\\A9\\96\nFigure 7.1: The spectrum ranging from the one-step backups of simple TD methods to the up-until-termination backups of Monte Carlo methods. In between are the n-step back\u0026shy;ups, based on n steps of real rewards and the estimated value of the nth next state, all appropriately discounted.\nwhere T is the last time step of the episode. Let us call this quantity the target of the backup. Whereas in Monte Carlo backups the target is the return, in one-step backups the target is the first reward plus the discounted estimated value of the next state, which we call the one-step return:\nGt\\A3\\BAt+i = Rt+i + 7Vt(St+i),\nwhere Vt : S R here is an estimate at time t of v^. The subscripts on Gt\\A3\\BAt+i indicate that it is truncated return for time t using rewards up until time t + 1, and the superscript s reminds us that the missing rewards are replaced by an estimate at a subsequent state (shortly we will introduce truncated returns using estimated values at state-action pairs). In the one-step return, YVt(St+i) takes the place of\nthe other terms YRt+2+ Y2Rt+3+------ + yT-t-1Rr of the full return, as we discussed\nin the previous chapter. Our point now is that this idea makes just as much sense after two steps as it does after one. The target for a two-step backup is the two-step return:\nGt:t+2= Rt+1+ YRt+2+ 72Vt+1(St+2)\nwhere now y2Vt+i(St+2) corrects for the absence of the terms Y2Rt+3+ Y3Rt+4+ \u0026#8226; \u0026#8226; \u0026#8226; + yT-t-1Rr. Similarly, the target for an arbitrary n-step backup is the n-step return:\nGt:t+n = Rt+1+ YRt+2+ \u0026#8226; \u0026#8226; \u0026#8226; + Y n iRt+n + 7nVt+n-1(St+n),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.1)\nfor all n, t such that n \u0026gt; 1 and 0 \u0026lt; t \u0026lt; T \\A1\\AA n. All n-step returns can be considered approximations to the full return, truncated after n steps and then corrected for the remaining missing terms by Vt+n-i(St+n). If t+n \u0026gt; T (if the n-step return extends to or beyond termination), then all the missing terms are taken as zero, and the n-step return defined to be equal to the ordinary full return (Gt\\A3\\BAt+n == Gt if t + n \u0026gt; T).\nNote that n-step returns for n \u0026gt; 1 involve future rewards and states that are not available at the time of transition from t to t + 1. No real algorithm can use the n-step return until after it has seen Rt+n and computed Vt+n-i. The first time these are available is t + n. The natural algorithm state-value learning algorithm for using n-step returns is thus\nVt+n(St) == Vt+n-i(St) + a [Gt\\A3\\BAt+n \\A1\\AA Vt+n-1(St)],\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0\u0026nbsp; \u0026lt;\u0026nbsp; t \u0026lt; T,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.2)\nwhile the values of all other states remain unchanged, Vt+n(s) = Vt+n-i(s), Vs = St. We call this algorithm n-step TD. Note that no changes at all are made during the first n \\A1\\AA 1 steps of each episode. To make up for that, an equal number of addition updates are made at the end of the episode, after termination and before starting the next episode. Complete pseudocode is given in the box on the next page.\nExercise 7.1 In Chapter 6we noted that the Monte Carlo error can be written as the sum of TD errors (6.5) if the value estimates don\\A1\\AFt change from step to step (6.6). Show that the n-step error used in (7.2) can also be written as a sum TD errors (again if the value estimates don\\A1\\AFt change) generalizing the earlier result. \\A1\\F5\nn-step TD for estimating V^ Vn\nInitialize V(s) arbitrarily, s G S\nParameters: step size a G (0,1], a positive integer n\nAll store and access operations (for St and Rt) can take their index mod n\nRepeat (for each episode):\nInitialize and store So = terminal T ^\nFor t = 0,1, 2,...:\n| If t \u0026lt; T, then:\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Take an action according to n(-|St)\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Observe and store the next reward asRt+i and the next state as St+i\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If St+i is terminal, then T \\A1\\AA t + 1\n| t \\A1\\AA t \\A1\\AA n + 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (t is the time whose state\\A1\\AFs estimate is being updated)\n| If t \u0026gt; 0:\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; G \\A1\\AA ^=$1+0 Yi-T-iRi\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If t + n \u0026lt; T, then: G \\A1\\AA G + YnV(Sr+n)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (Gr\\A3\\BAr+n)\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; V(St) \\A1\\AA V(St)+ a [G \\A1\\AA V(Sr)]\nUntil t = T \\A1\\AA 1\nExercise 7.2 (programming) With an n-step method, the value estimates do change from step to step, so an algorithm that used the sum of TD errors (see previous exercise) in place of the error in (7.2) would actually be a slightly different algorithm. Would it be a better algorithm or a worse one? Devise and program a small experiment to answer this question empirically.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nThe n-step return uses the value function Vt+n-i to correct for the missing rewards beyond Rt+n. An important property of n-step returns is that their expectation is guaranteed to be a better estimate of Vn than Vt+n-i is, in a worst-state sense. That is, the worst error of the expected n-step return is guaranteed to be less than or equal to yn times the worst error under Vt+n_i:\n   max\ns\n     En[Gt\\A3\\BAt+n|St = s] \\A1\\AA Vn(s)\u0026lt;\u0026nbsp;\u0026nbsp; Y\u0026nbsp; maxVt+n-i(s)\\A1\\AA Vn(s) ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.3)\ns\nfor all n \u0026gt; 1. This is called the error reduction property of n-step returns. Because of the error reduction property, one can show formally that all n-step TD methods converge to the correct predictions under appropriate technical conditions. The n- step TD methods thus form a family of sound methods, with one-step TD methods and Monte Carlo methods as extreme members.\nExample 7.1: n-step TD Methods on the Random Walk Consider using n-step TD methods on the random walk task described in Example 6.2 and shown in Figure 6.2. Suppose the first episode progressed directly from the center state, C, to the right, through D and E, and then terminated on the right with a return of 1. Recall that the estimated values of all the states started at an intermediatevalue, V(s) = 0,5. As a result of this experience, a one-step method would change only the estimate for the last state, V(E), which would be incremented toward 1, the observed return. A two-step method, on the other hand, would increment the values of the two states preceding termination: V(D) and V(E) both would be incremented toward 1. A three-step method, or any n-step method for n \u0026gt; 2, would increment the values of all three of the visited states toward 1, all by the same amount.\nWhich value of n is better? Figure 7.2 shows the results of a simple empirical test for a larger random walk process, with 19 states (and with a \\A1\\AA1 outcome on the left, all values initialized to 0), which we use as a running example in this chapter. Results are shown for n-step TD methods with a range of values for n and a. The performance measure for each parameter setting, shown on the vertical axis, is the square-root of the average squared error between the predictions at the end of the episode for the 19 states and their true values, then averaged over the first 10 episodes and 100repetitions of the whole experiment (the same sets of walks were used for all parameter settings). Note that methods with an intermediate value of n worked best. This illustrates how the generalization of TD and Monte Carlo methods to n-step methods can potentially perform better than either of the two extreme methods.\nExercise 7.3 Why do you think a larger random walk task (19 states instead of 5) was used in the examples of this chapter? Would a smaller walk have shifted the advantage to a different value of n? How about the change in left-side outcome from 0 to \\A1\\AA1 made in the larger walk? Do you think that made any difference in the best value of n?\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n7.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Sarsa\nHow can n-step methods be used not just for prediction, but for control? In this section we show how n-step methods can be combined with Sarsa in a straightforward way to produce an on-policy TD control method. The n-step version of Sarsa we call n-step Sarsa, and the original version presented in the previous chapter we henceforth call one-step Sarsa, or Sarsa(0).\nThe main idea is to simply switch states for actions (state-action pairs) and then use an e-greedy policy. The backup diagrams for n-step Sarsa, shown in Figure 7.3 are like those of n-step TD (Figure 7.1), strings of alternating states and actions, except that the Sarsa ones all start and end with an action rather a state. We define n-step returns in terms of estimated action values:\nGt:t+n = Rt+1+YRt+2+ ^ \u0026#8226; \u0026#8226;ʮ7^ iRt+n +Y^Qt+n-1(St+n, At+n), n \u0026gt; \\B9\\A4,0\u0026lt; t \u0026lt; T\\A1\\AAn,\n(7.4)\nwith Gt\\A3\\BAt+n == Gt if t + n \u0026gt; T. The natural algorithm is then\nQt+n(St, At) == Qt+n-i(St, At) + a [Gt\\A3\\BAt+n \\A1\\AA Qt+n-1(St, At)],\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0\u0026nbsp; \u0026lt;t\u0026nbsp; \u0026lt;T,\u0026nbsp; (7.5)\nwhile the values of all other states remain unchanged, Qt+n(s, a) = Qt+n_i(s,a), for all s, a such that s = St or a = At. This is the algorithm we call n-step Sarsa.\n \n\u0026nbsp;\n \nw-step Sarsa\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step\nn-step Sarsa aka Monte Carlo Expected Sarsa\n \n\u0026nbsp;\n \nI \\B6\\A1I \\C1˶\\A1\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nFigure 7.3: The spectrum of n-step backups for state-action values. They range from the one-step backup of Sarsa(0) to the up-until-termination backup of a Monte Carlo method. In between are the n-step backups, based on n steps of real rewards and the estimated value of the nth next state-action pair, all appropriately discounted. On the far right is the backup diagram for n-step Expected Sarsa.\n\n\nn-step Sarsa for estimating Q ^ q*, or Q ^ for a given n\nInitialize Q(s, a) arbitrarily, Vs G S, a G A\nInitialize n to be e-greedy with respect to Q, or to a fixed given policy\nParameters: step size a G (0,1], small e \u0026gt; 0, a positive integer n\nAll store and access operations (for St, At, and Rt) can take their index mod n\nRepeat (for each episode):\nInitialize and store So = terminal Select and store an action Ao \u0026#12316;n(-|So)\nT \\A1\\AA ^\nFor t = 0, 1, 2, . . . :\nIf t \u0026lt; T, then:\nTake action At\nObserve and store the next reward as Rt+i and the next state as St+i If St+i is terminal, then:\nT\\A1\\AAt+1 else:\nSelect and store an action At+i \u0026#12316;n(-|St+i) t \\A1\\AA t \\A1\\AA n + 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (t is the time whose estimate is being updated)\nIf t \u0026gt; 0:\ng\\A1\\AAE\\A3\\BA=[11]n+Ti+n,T)y i-T-iRi\nIf t+ n \u0026lt; T, then G \\A1\\AA G+ YnQ(ST+n, At +n)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (Gt\\A3\\BAT +n)\nQ(St, At) \\A1\\AA Q(St, At) + a [G \\A1\\AA Q(St, A)]\nIf n is being learned, then ensure that ^(-|St) is e-greedy wrt Q Until t = T \\A1\\AA 1\n\u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n G\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n t\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    Action values increased\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Actionvalues\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; increased\nPath taken\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; byone-stepSarsa\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; by10-step Sarsa\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n   \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n r\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n 1\n \u0026nbsp;\n \u0026nbsp;\n G\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \\B1\\BE\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n -\u0026#9658;\n -\u0026#9658;\n 1\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n -\u0026#9658;\n 1\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n G\n \u0026nbsp;\n 1\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n ţ\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n     \n\n\n\u0026nbsp;\n \nFigure 7.4: Gridworld example of the speedup of policy learning due to the use of n-step methods. The first panel shows the path taken by an agent in a single episode, ending at a location of high reward, marked by the G. In this example the values were all initially 0, and all rewards were zero except for a positive reward at G. The arrows in the other two panels show which action values were strengthened as a result of this path by one-step and n-step Sarsa methods. The one-step method strengthens only the last action of the sequence of actions that led to the high reward, whereas the n-step method strengthens the last n actions of the sequence, so that much more is learned from the one episode.\n7.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Off-policy Learning by Importance Sampling\nRecall that off-policy learning is learning the value function for one policy, n, while following another policy, b. Often, n is the greedy policy for the current action- value-function estimate, and b is a more exploratory policy, perhaps e-greedy. In order to use the data from b we must take into account the difference between the two policies, using their relative probability of taking the actions that were taken (see Section 5.5). In n-step methods, returns are constructed over n steps, so we are interested in the relative probability of just those n actions. For example, to make a simple off-policy version of n-step TD, the update for time t (actually made at time t + n) can simply be weighted by pt:t+n_1:\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; t+\\A1\\B0St) == K+n-1(St) + aPt:t+n-1[Gt:t+n \\A1\\AA Vt+n-1(St)],0\u0026lt; t\u0026lt;T,(7.7)\nwhere pt:t+n_1, called the importance sampling ratio, is the relative probability under the two policies of taking the n actions from At to A_t+n_1(cf. Eq. 5.3):\nmin(h,T-1)rA,Q%\nP=\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n(Ak |Sk)\npt:h=\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; |it\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026#8226;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7)\nFor example, if any one of the actions would never be taken by n (i.e., n(A^|S^) = 0) then the n-step return should be given zero weight and be totally ignored. On the other hand, if by chance an action is taken that n would take with much greater probability than b does, then this will increase the weight that would otherwise be given to the return. This makes sense because that action is characteristic of n (and therefore we want to learn about it) but is selected rarely by b and thus rarely appears in the data. To make up for this we have to over-weight it when it doesoccur. Note that if the two policies are actually the same (the on-policy case) then the importance sampling ratio is always 1. Thus our new update (7.7) generalizes and can completely replace our earlier n-step TD update. Similarly, our previous n-step Sarsa update can be completely replaced by a simple off-policy form:\nQt+n(St, At) = Qt+n-1(St, At) + apt+1\\A3\\BAt+n-1[Gt\\A3\\BAt+n \\A1\\AA Qt+n-1(St, At)] ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.9)\nfor 0 \u0026lt; t \u0026lt; T. Note the importance sampling ratio here starts one step later than for n-step TD (above). This is because here we are updating a state-action pair. We do not have to care how likely we were to select the action; now that we have selected it we want to learn fully from what happens, with importance sampling only for subsequent actions. Pseudocode for the full algorithm is shown in the box.\nOff-policy n-step Sarsa for estimating Q^ q\\A1\\B1or Q^ for a given n\nInput: an arbitrary behavior policy b such that b(a|s) \u0026gt; 0, Vs G S, a G A Initialize Q(s, a) arbitrarily, Vs G S, a G A\nInitialize n to be e-greedy with respect to Q, or as a fixed given policy\nParameters: step size a G (0,1], small e \u0026gt; 0, a positive integer n\nAll store and access operations (for St, At, and Rt) can take their index mod n\nRepeat (for each episode):\nInitialize and store So = terminal Select and store an action Ao \u0026#12316;b(^|So)\nT ^\nFor t = 0,1, 2,...:\nIf t \u0026lt; T, then:\nTake action At\nObserve and store the next reward as Rt+i and the next state as St+i If St+i is terminal, then:\nT \\A1\\AA t + 1 else:\nSelect and store an action At+i \u0026#12316;b(^|St+i) t \\A1\\AA t \\A1\\AA n + 1(t is the time whose estimate is being updated)\nIf t \u0026gt; 0:\np, i-rmin(T +n-1,T-1) n(Ai|Si)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (p\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; )\nP\\A1\\AA\\81A\\81Ai=T+1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; b(Ai|Si)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (Pt+1\\A3\\BAt+n-i)\ng\\A1\\AAE\\A3\\BA=n+T1+n,T)y i-T-iRi\nIf t+ n \u0026lt; T, then: G \\A1\\AA G+ YnQ(ST +n,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; At+n)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (Gt\\A3\\BAt +n)\nQ(St, At) \\A1\\AA Q(St, At) + ap [G \\A1\\AA\u0026nbsp;\u0026nbsp;\u0026nbsp; Q(St,At)]\nIf n is being learned, then ensure that n(-|ST) is e-greedy wrt Q Until t = T \\A1\\AA 1\nThe off-policy version of n-step Expected Sarsa would use the same update as above for Sarsa except that the importance sampling ratio would have an additional one less factor in it. That is, the above equation would use pt+i\\A3\\BAt+n-2instead of pt+i\\A3\\BAt+n-i, and of course it would use the Expected Sarsa version of the n-step return (7.6). This is because in Expected Sarsa all possible actions are taken into account in the last state; the one actually taken has no effect and does not have to be corrected for.\n7.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *Per-reward Off-policy Methods\nThe multi-step off-policy methods presented in the previous section are very simple and conceptually clear, but are probably not the most efficient. A more sophisticated approach would use per-reward importance sampling ideas such as were introduced in Section 5.9. To understand this approach, first note that the ordinary n-step return (7.1), like all returns, can be written recursively:\nGt:h = Rt+i + lGt+i:h-\nNow consider the effect of following a behavior policy b = n that is not the same as the target policy n. All of the resulting experience, including the first reward Rt+i and the next state St+i must be weighted by the importance sampling ratio for time t, pt =ū\\C6\\EF).Onemight be tempted to simply weight the righthand side of the above equation, but one can do better. Suppose the action at time t would never be selected by n, so that pt is zero. Then a simple weighting would result in the n-step return being zero, which could result in high variance when it was used as a target. Instead, in this more sophisticated approach, one uses an alternate, off-policy definition of the n-step return, as\nGt\\A3\\BAh = pt (Rt+i + lGt+i:h) + (1\\A1\\AA pt)V(St),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; t \u0026lt; h \u0026lt; T, (7.10)\nwhere V(St) is some estimate of the value of St+i, and Gt\\A3\\BAt == V(St). (We are being a little vague about exactly with time step\\A1\\AFs estimate is used for V(St) because the choice will depend on the practicality of specific algorithms.) Now, if pt is zero, instead of the target being zero and causing the estimate to shrink, the target is the same as the estimate and causes no change. The importance sampling ratio being zero means we should ignore the sample, so leaving the estimate unchanged seems an appropriate outcome. Notice that the second, additional term does not change the expected update; the importance sampling ratio has expected value one and is uncorrelated with the estimate, so the expected value of the second term is zero. Also note that the off-policy definition (7.10) is a strict generalization of the earlier on-policy definition of the n-step return (7.1), as the two are identical in the on-policy case, in which pt is always 1.\nFor a conventional n-step method, the learning rule to use in conjunction with\n(7.10)\u0026nbsp;\u0026nbsp;\u0026nbsp; is the n-step TD update (7.2), which has no explicit importance sampling ratios other than those embedded in G. In this case, the approximate value function is that at time index h \\A1\\AA 1= t + n \\A1\\AA 1.\nExercise 7.4 Write the pseudocode for the off-policy state-value prediction algo\u0026shy;rithm described above.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n \nFor action values, the off-policy definition of the n-step return corresponds to Ex\u0026shy;pected Sarsa (there does not seem to be one that corresponds to ordinary Sarsa). It is a little different because the first action does not play a role in the importance sampling. We are learning the value of that action and it does not matter if it was unlikely or even impossible under the target policy. It has been taken and now full unit weight must be given to the reward and state that follows it. Importance sam\u0026shy;pling will apply only to the actions that follow it. The off-policy recursive definition of the n-step return for action values is\nGt\\A3\\BAh = Rt+i + Y (pt+iGt+i\\A3\\BAh + (1\\A1\\AA pt-i)^Qt+i) ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.11)\nfor t, h such that t \u0026lt; h \u0026lt; T, with Gt\\A3\\BAt == (Qt == Ean(a|St)Qt-i(St, a). A complete n- step off-policy action-value prediction method would combine (7.11) and (7.5) using the estimate for time step h \\A1\\AA 1= t + n \\A1\\AA 1.\nExercise 7.5 Write the pseudocode for the off-policy action-value prediction algo\u0026shy;rithm described immediately above.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 7.6 Show that the general (off-policy) version of the n-step return (7.10) can still be written exactly and compactly as the sum of state-based TD errors (6.5) if the approximate state value function does not change.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 7.7 Repeat the above exercise for the action version of the off-policy n-step return (7.11) and the Expected Sarsa TD error (the quantity in brackets in Equation 6.9).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 7.8 (programming) Devise a small off-policy prediction problem and use it to show that the off-policy learning algorithm using (7.10) and (7.2) is more data efficient than the simpler algorithm using (7.1) and (7.7).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nThe importance sampling that we have used in this section, the previous section, and in Chapter 5 enables off-policy learning, but at the cost of increasing the variance of the updates. The high variance forces us to use a small step-size parameter, resulting in slow learning. It is probably inevitable that off-policy training is slower than on-policy training\\A1\\AAafter all, the data is less relevant to what you are trying to learn. However, it is probably also true that the methods we have presented here can be improved on. One possibility is to rapidly adapt the step sizes to the observed variance, as in the Autostep method (Mahmood et al, 2012). Another promising approach is the invariant updates of Karampatziakis and Langford (2010) as extended to TD by Tian (2017). The usage technique of Mahmood (2017; Mahmood and Sutton, 2015) is probably also part of the solution. In the next section we consider an off-policy learning method that does not use importance sampling.\n7.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Learning Without Importance Sampling:\nThe n-step Tree Backup Algorithm\nIs off-policy learning possible without importance sampling? Q-learning and Ex\u0026shy;pected Sarsa from Chapter 6do this for the one-step case, but is there a correspond\u0026shy;\n \ning multi-step algorithm? In this section we present just such an n-step method, called the tree-backup algorithm.\n   SuAt\nRt+i\n     The idea of the algorithm is suggested by the 3-step tree-backup diagram shown to the right. Down the central spine and labeled in the figure are three sample states and rewards, and two sample actions.\n   \nthe 3-step tree backup\n     These are the random variables representing the events occurring after the initial state-action pair St, At. Hanging off to the sides of each state are the actions that were not selected. (For the last state, all the actions are considered to have not (yet) been selected.) Because we have no sample data for the unselected actions, we bootstrap and use the estimates of their values in forming the target for the update. This slightly extends the idea of a backup diagram. So far we have always updated the estimated value of the node at the top of the diagram toward a target combining the rewards along the way (appropriately discounted) and the estimated values of the nodes at the bottom. In the tree backup, the target includes all these things plus the estimated values of the dangling action nodes hanging off the sides, at all levels.\nThis is why it is called a tree backup; it is a backup from the entire tree of of estimated action values.\nMore precisely, the backup is from the estimated action values of the leaf nodes of the tree. The action nodes in the interior, corresponding to the actual action taken, do not participate. Each leaf node is meant to contribute to the target with a weight in proportion to its probability of occurring under the target policy n. Thus a first-level action a contributes with a weight of n(a|St+1), except that that the action actually taken,\\D2\\E6t+1, does not contribute at all. Its probability, n(\\D2\\E6t+1|Stʮ1), is used to weight all the second-level action values. Thus, each non-selected second-level action dcontributes with weight n(At+1|StʮJnCa'ISt+a). Each third-level action contributes with weight n(At+1|Stʮ1)n(At+2|St+2)n(a\u0026quot;|St+3), and so on. It is as if each arrow to an action node in the diagram is weighted by its probability of that action being selected under the target policy, and that weight applies not only to that action but to the whole tree below it.\nWe can think of the tree backup as an alternating sequence of sample transitions (from each action to the subsequent state) and full backups (from each state we consider all the possible actions with their probability of occuring). The sample transitions also have various probabilities of occurring, but these need not be taken into account because they are given the action selection and thus indepedent of the policy; they will introduce variance, but not bias.\nThe one-step return (target) of the tree-backup algorithm is the same as that of Expected Sarsa. It can be written\nGt:t+1= Rt+1+ 7 I^(alSt+1)Qt(St+1, a)\na\n=^t + Qt-1(St, At),\n \nn-step Tree Backup for estimating Q^ q^, or Q^ q^ for a given n\nInitialize Q(s, a) arbitrarily, Vs G S, a G A\nInitialize n to be e-greedy with respect to Q, or as a fixed given policy Parameters: step size a G (0,1], small e \u0026gt; 0, a positive integer n All store and access operations can take their index mod n\nRepeat (for each episode):\nInitialize and store So = terminal Select and store an action Ao \u0026#12316;n(^|So)\nStore Q(So, Ao) as Qo T \\A1\\AA ^\nFor t = 0, 1, 2, . . . :\nIf t \u0026lt; T:\nTake action At\nObserve the next reward R; observe and store the next state as St+i If St+i is terminal:\nT \\A1\\AA t + 1 Store R \\A1\\AA Qt as \u0026amp; else:\nStore R + yJ2a n(a|St+i)Q(St+i, a) \\A1\\AA Qt as ^t Select arbitrarily and store an action as At+i Store Q(St+i, At+i) as Qt+i Store n(At+i|St+i) as nt+i t \\A1\\AA t \\A1\\AA n + 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (t is the time whose estimate is being updated)\nIf t \u0026gt; 0: e\\A1\\AA1 G \\A1\\AA Qt\nFor k = t, ...,min(T + n \\A1\\AA 1, T \\A1\\AA 1):\nG \\A1\\AA G + e ֪ e \\A1\\AA Yenk+i Q(St, At) \\A1\\AA Q(St, At) + a [G \\A1\\AA Q(St, A)]\nIf n is being learned, then ensure that n(a|ST) is e-greedy wrt Q(St, \u0026#8226;) Until t = T \\A1\\AA 1\n \nwhere ^t is a modified form of the TD error from Expected Sarsa:\n^t =˽ʮ1+ 7\\B7\\A6\u0026gt;(\\A1\\A3|\\C3\\F1ʮ1\\CB\\C6(\\C3\\F1ʮ1,4 \\A1\\AA Qt_1(St, At).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.12)\na\nWith these, the general n-step returns of the tree-backup algorithm can be defined recursively, and then as a sum of TD errors:\nGt:t+n = Rt+1+ 7أ(a|St+1)Qt(St+1, a)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; + 7أ(At+1(St+1)Gt+1:t+n (7.13)\n=\\BA\\CD+ Qt-1(St, At) \\A1\\AA 7أ(At+1|St+1)Qt(St+1, At+1) + 7أ(At+1|St+1)Gt+1:t+n =Qt-1(St, At)+ ^t + 7n(At+1|St+1) (Gt+1:t+n \\A1\\AAQt(St+1, At+1)) =Qt-1(St, At)+ ^t + 7أ(At+1|Sft+1)Jt+1+ 72أ(At+1|St+1)n(At+2|St+2)Jt+2+\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z min(t+n-1,T \\A1\\AA 1)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\n=Qt\\A1\\AA1(St,At)+\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; E \\A1\\B6n 7n(Ai|Si),\nk=t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=i+1\nunder the usual convention that a product of zero factors is 1. This target is then used with the usual action-value update rule from n-step Sarsa:\nQt+n(St, At) = Qt+n\\A1\\AA1(St, At) + a [Gt:t+n \\A1\\AA Qt+n\\A1\\AA1(St, At)],\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.5)\nwhile the values of all other state-action pairs remain unchanged, Qt+n(s, a)=\nQt+n\\A1\\AA1(s,a), Vs, a such that s = St or a = At. Pseudocode for this algorithm is shown in the box on the previous page.\n7.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; *A Unifying Algorithm: n-step Q(a)\nSo far in this chapter we have considered three different action-value backups, cor\u0026shy;responding to the first three backup diagrams shown in Figure 7.5. n-step Sarsa has all sampled transitions, the tree-backup algorithm has all state-to-action transitions fully branched without sampling, and the n-step Expected Sarsa backup has all sam\u0026shy;ple transitions except for the last state-to-action ones, which are fully branched with an expected value. To what extent can these algorithms be unified?\nOne idea for unification is suggested by the fourth backup diagram in Figure 7.5. This is the idea that one might decide on a step-by-step basis whether one wanted to take the action as a sample, as in Sarsa, or consider the expectation over all actions instead, as in the tree backup. Then, if one chose always to sample, one would obtain Sarsa, whereas if one chose never to sample, one would get the tree-backup algorithm. Expected Sarsa would be the case where one chose to sample for all steps except the last one. And of course there would be many other possibilities, as suggested by the last diagram in the figure. To increase the possibilities even further we can consider a continuous variation between sampling and expectation. Let at G [0,1] denote the degree of sampling on step t, with a= 1denoting full sampling and a= 0denoting a pure expectation with no sampling. The random variable at might be set as a\n \nFigure 7.5: The three kinds of n-step action-value backups considered so far in this chapter (4-step case) plus a fourth kind of backup that unifies them all. The \\A1\\AEp\\A1\\AFs indicate half transitions on which importance sampling is required in the off-policy case. The fourth kind of backup unifies all the others by choosing on a state-by-state basis whether to sample (at = 1) or not (at = 0).\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nfunction of the state, action, or state-action pair at time t. We call this proposed new algorithm n-step Q(a).\nNow let us develop the equations of n-step Q(a). First note that the n-step return of Sarsa (7.4) can be written in terms of its own pure-sample-based TD error:\nmin(t+n-i,T -1)\nGt\\A3\\BAt+n = Qt-i(St, At)+\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Y^ t [Rk+i + lQk(Sk+i, Ak+i) \\A1\\AAQfc-i(Sfc, Ak)]\nk=t\nThis suggests that we may be able to cover both cases if we generalize the TD error to slide with at from its expectation to its sampling form:\n^t = Rt+i + 7[at+iQt(St+i, At+i) + (1\\A1\\AA at+it+i]\\A1\\AAQt-i(St, At),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.14)\nwith\n   (7.15)\n     Qt == ^n(a|St)Qt-i(St,a),\n\n\nas usual. Using these we can define the n-step returns of Q(a) as:\nGt\\A3\\BAt+i = Rt+i + 7[at+iQt(St+i, At+i) + (1 \\A1\\AA ^t+i)^Qt+i]\n=A + Qt-i(St, At),\nGt\\A3\\BAt+2 = Rt+i + 7[at+iQt(St+i, At+i) + (1 \\A1\\AA ^t+i)^Qt+i]\n\\A1\\AAY (1 \\A1\\AA^t+i)n(At+i|St+i)Qt (St+i, At+i)\n+ Y(1 \\A1\\AA ^t+1)n(At+1|St+1) [Rt+2 + Y[^t+2Qt(St+2, At+2) + (1 \\A1\\AA Ct+2)01+2]] \\A1\\AA7at+1Qt(St+1, At+1)\n+ Y^t+1 [Rt+2 + 7[at+2Qt(St+2, At+2) + (1 \\A1\\AA ^t+2)^Qt+2]]\n=Qt-i(St, At) + ^t\n+ Y (1\\A1\\AA ^t+i)n(At+i|St+i)5t+i\n+ Y^t+i^t+i\n=Qt-i(St, At) + ^t + Y[(1 \\A1\\AA ^t+i)n(At+i|St+i) + ^t+i]^t+i\nmin(t+n-1,T -1)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\nGt\\A3\\BAt+n = Qt-1(St,At) +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^\u0026quot;^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^\u0026nbsp;\u0026nbsp; IT\u0026nbsp;\u0026nbsp; Y [(1 \\A1\\AA ai)n(Ai|Si) + ] \u0026#8226; (7.16)\nk=t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+1\nUnder on-policy training, this return is ready to be used in an update such as that for n-step Sarsa (7.5). For the off-policy case we need to take ainto account in the importance sampling ratio, which we redefine more generally as\n \n\u0026nbsp;\n \nmin(h,T-1)/ r A \\q \\\n   (7.17)\n        pt\\A3\\BAh\n     n\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; fak SAM + 1 \\A1\\AA ak\nb(Ak|Sk)\nk=t\n \n\u0026nbsp;\n \nAfter this we can then use the usual general (off-policy) update for n-step Sarsa (7.9). A complete algorithm is given in the box on the next page.\n \nOff-policy n-step Q(a) for estimating Q^ q^, or Q^ q^ for a given n\nInput: an arbitrary behavior policy b such that b(a|s) \u0026gt; 0, Vs G S, a G A Initialize Q(s, a) arbitrarily, Vs G S, a G A\nInitialize n to be e-greedy with respect to Q, or as a fixed given policy Parameters: step size a G (0,1], small e \u0026gt; 0, a positive integer n All store and access operations can take their index mod n\nRepeat (for each episode):\nInitialize and store So = terminal Select and store an action Ao \u0026#12316;b(^|So)\nStore Q(So, Ao) as Qo T \\A1\\AA ^\nFor t = 0, 1, 2, . . . :\nIf t \u0026lt; T:\nTake action At\nObserve the next reward R; observe and store the next state as St+i If St+i is terminal:\nT\\A1\\AAt+1 Store (^t \\A1\\AA~ R \\A1\\AA Qt else:\nSelect and store an action At+i\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; b(^|St+i)\nSelect and store at+i Store Q(St+i, At+i) as Qt+i\nStore R + Yat+iQt+i + Y(1 \\A1\\AA at+i) Ean(a|St+i)Q(St+i, a) \\A1\\AA Qt as \u0026amp; Store n(At+i|St+i) as nt+i\nStore^1))asPt+i\nt \\A1\\AA t \\A1\\AA n + 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (t is the time whose estimate is being updated)\nIf t \u0026gt; 0:\nP \\A1\\AA 1 e\\A1\\AA1 G \\A1\\AA Qt\nFor k = t, ...,min(T + n \\A1\\AA 1, T \\A1\\AA 1):\nG \\A1\\AA G + e^k e \\A1\\AA Ye[(1\\A1\\AA ak+1)nk+1+ ak+i] p \\A1\\AA p(1\\A1\\AA ak + ak pk)\nQ(St, At) \\A1\\AA Q(St, At) + ap [G \\A1\\AA Q(St, At)]\nIf n is being learned, then ensure that n(a|ST) is e-greedy wrt Q(St, \u0026#8226;) Until t = T \\A1\\AA 1\n7.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nIn this chapter we have developed a range of temporal-difference learning methods that lie in-between the one-step TD methods of the previous chapter and the Monte Carlo methods of the chapter before. Methods that involve an intermediate amount of bootstrapping are important because they will typically perform better than either extreme.\nOur focus in this chapter has been on n-step methods, which look ahead to the next n rewards, states, and actions.\nThe two 4-step backup diagrams to the right together summa\u0026shy;rize most of the methods introduced. The state-value backup shown is for n-step TD with importance sampling, and the action-value backup is for n-step Q(a), which generalizes Ex\u0026shy;pected Sarsa and Q-learning. All n-step methods involve a delay of n time steps before updating, as only then are all the required future events known. A further drawback is that they involve more computation per time step than previous methods. Compared to one-step methods, n-step methods also require more memory to record the states, actions, re\u0026shy;wards, and sometimes other variables over the last n time steps. Eventually, in Chapter 12, we will see how multi-step TD methods can be implemented with minimal memory and computational complexity using eligibility traces, but there will always be some additional computation beyond one-step methods. Such costs can be well worth paying to escape the tyranny of the single time step.\nAlthough n-step methods are more complex than those us\u0026shy;ing eligibility traces, they have the great benefit of being conceptually clear. We have sought to take advantage of this by developing two approaches to off-policy learning in the n-step case. One, based on importance sampling is conceptually simple but can be of high variance. If the target and behavior policies are very different it prob\u0026shy;ably needs some new algorithmic ideas before it can be efficient and practical. The other, based on tree backups, is the natural extension of Q-learning to the multi-step case with stochastic target policies. It involves no importance sampling but, again if the target and behavior policies are substantially different, the bootstrapping may span only a few steps even if n is large.\nBibliographical and Historical Remarks\n7.1-2 The notion of n-step returns is due to Watkins (1989), who also first discussed their error reduction property. n-step algorithms were explored in the first edition of this book, in which they were treated as of conceptual interest, but not feasible in practice. The work of Cichosz (1995) and particularly van Seijen (2016) showed that they are actually completely practical algorithms. Given this, and their conceptual clarity and simplicity, we have chosen to highlight them here in the second edition. In particular, we now postpone all discussion of the backward view and of eligibility traces until Chapter 12.\nThe results in the random walk examples were made for this text based on work of Sutton (1988) and Singh and Sutton (1996). The use of backup diagrams to describe these and other algorithms in this chapter is new.\n7.3-5 The developments in these sections are based on the work of Precup, Sut\u0026shy;ton, and Singh (2000), Precup, Sutton, and Dasgupta (2001), and Sutton, Mahmood, Precup, and van Hasselt (2014).\nThe tree-backup algorithm is due to Precup, Sutton, and Singh (2000), but the presentation of it here is new.\n7.6 The Q(a) algorithm is new to this text, but has been explored further by De Asis, Hernandez-Garcia, Holland, and Sutton (2017).\n \n172\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER\u0026nbsp; 7.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; MULTI-STEP\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; BOOTSTRAPPING\nChapter 8\nPlanning and Learning with Tabular Methods\nIn this chapter we develop a unified view of reinforcement learning methods that require a model of the environment, such as dynamic programming and heuristic search, and methods that can be used without a model, such as Monte Carlo and temporal-difference methods. These are respectively called model-based and model- fee reinforcement learning methods. Model-based methods rely on planning as their primary component, while model-free methods primarily rely on learning. Although there are real differences between these two kinds of methods, there are also great sim\u0026shy;ilarities. In particular, the heart of both kinds of methods is the computation of value functions. Moreover, all the methods are based on looking ahead to future events, computing a backed-up value, and then using it to update an approximate value func\u0026shy;tion. Earlier in this book we presented Monte Carlo and temporal-difference methods as distinct alternatives, then showed how they can be unified by n-step methods (and we will do this again more thoroughly with eligibility traces in Chapter 12). Our goal in this chapter is a similar integration of model-based and model-free methods. Having established these as distinct in earlier chapters, we now explore the extent to which they can be intermixed.\n8.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Models and Planning\nBy a model of the environment we mean anything that an agent can use to predict how the environment will respond to its actions. Given a state and an action, a model produces a prediction of the resultant next state and next reward. If the model is stochastic, then there are several possible next states and next rewards, each with some probability of occurring. Some models produce a description of all possibilities and their probabilities; these we call distribution models. Other models produce just one of the possibilities, sampled according to the probabilities; these we call sample models. For example, consider modeling the sum of a dozen dice. A distribution model would produce all possible sums and their probabilities of occurring, whereas a sample model would produce an individual sum drawn according to this probability distribution. The kind of model assumed in dynamic programmingһestimates of the MDP\\A1\\AFs dynamics, p(s;, r|s, a)һis a distribution model. The kind of model used in the blackjack example in Chapter 5 is a sample model. Distribution models are stronger than sample models in that they can always be used to produce samples. However, in many applications it is much easier to obtain sample models than distribution models. The dozen dice are a simple example of this. It would be easy to write a computer program to simulate the dice rolls and return the sum, but harder and more error-prone to figure out all the possible sums and their probabilities.\nModels can be used to mimic or simulate experience. Given a starting state and action, a sample model produces a possible transition, and a distribution model generates all possible transitions weighted by their probabilities of occurring. Given a starting state and a policy, a sample model could produce an entire episode, and a distribution model could generate all possible episodes and their probabilities. In either case, we say the model is used to simulate the environment and produce simulated experience.\nThe word planning is used in several different ways in different fields. We use the term to refer to any computational process that takes a model as input and produces or improves a policy for interacting with the modeled environment:\nmodel \\A1\\AA\\A8D\\BD\\D0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026gt; policy\nIn artificial intelligence, there are two distinct approaches to planning according to our definition. State-space planning, which includes the approach we take in this book, is viewed primarily as a search through the state space for an optimal policy or an optimal path to a goal. Actions cause transitions from state to state, and value functions are computed over states. In what we call plan-space planning, planning is instead a search through the space of plans. Operators transform one plan into another, and value functions, if any, are defined over the space of plans. Plan-space planning includes evolutionary methods and \\A1\\B0partial-order planning,\\A1\\B1 a common kind of planning in artificial intelligence in which the ordering of steps is not completely determined at all stages of planning. Plan-space methods are difficult to apply efficiently to the stochastic sequential decision problems that are the focus in reinforcement learning, and we do not consider them further (but see, e.g., Russell and Norvig, 2010).\nThe unified view we present in this chapter is that all state-space planning methods share a common structure, a structure that is also present in the learning methods presented in this book. It takes the rest of the chapter to develop this view, but there are two basic ideas: (1) all state-space planning methods involve computing value functions as a key intermediate step toward improving the policy, and (2) they compute value functions by backup operations applied to simulated experience. This common structure can be diagrammed as follows:\ni ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; simulated backups\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; r\nmodel ---------- \u0026#9658;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026#8226;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ----------------------- \u0026#9658; values \u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026#9658; policy\nexperience\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; r\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; J\n \nDynamic programming methods clearly fit this structure: they make sweeps through the space of states, generating for each state the distribution of possible transitions. Each distribution is then used to compute a backed-up value and update the state\\A1\\AFs estimated value. In this chapter we argue that various other state-space planning methods also fit this structure, with individual methods differing only in the kinds of backups they do, the order in which they do them, and in how long the backed-up information is retained.\nViewing planning methods in this way emphasizes their relationship to the learning methods that we have described in this book. The heart of both learning and planning methods is the estimation of value functions by backup operations. The difference is that whereas planning uses simulated experience generated by a model, learning methods use real experience generated by the environment. Of course this difference leads to a number of other differences, for example, in how performance is assessed and in how flexibly experience can be generated. But the common structure means that many ideas and algorithms can be transferred between planning and learning. In particular, in many cases a learning algorithm can be substituted for the key backup step of a planning method. Learning methods require only experience as input, and in many cases they can be applied to simulated experience just as well as to real experience. The box below shows a simple example of a planning method based on one-step tabular Q-learning and on random samples from a sample model. This method, which we call random-sample one-step tabular Q-planning, converges to the optimal policy for the model under the same conditions that one-step tabular Q- learning converges to the optimal policy for the real environment (each state-action pair must be selected an infinite number of times in Step 1, and a must decrease appropriately over time).\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nIn addition to the unified view of planning and learning methods, a second theme in this chapter is the benefits of planning in small, incremental steps. This enables planning to be interrupted or redirected at any time with little wasted computation, which appears to be a key requirement for efficiently intermixing planning with acting and with learning of the model. Planning in very small steps may be the most efficient approach even on pure planning problems if the problem is too large to be solved exactly.\n8.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Dyna: Integrating Planning, Acting, and Learning\nWhen planning is done on-line, while interacting with the environment, a number of interesting issues arise. New information gained from the interaction may change the model and thereby interact with planning. It may be desirable to customize the planning process in some way to the states or decisions currently under consideration, or expected in the near future. If decision-making and model-learning are both computation-intensive processes, then the available computational resources may need to be divided between them. To begin exploring these issues, in this section we present Dyna-Q, a simple architecture integrating the major functions needed in an on-line planning agent. Each function appears in Dyna-Q in a simple, almost trivial, form. In subsequent sections we elaborate some of the alternate ways of achieving each function and the trade-offs between them. For now, we seek merely to illustrate the ideas and stimulate your intuition.\nWithin a planning agent, there are at least two roles for real experience: it can be used to improve the model (to make it more accurately match the real environment) and it can be used to directly improve the value function and policy using the kinds of reinforcement learning methods we have discussed in previous chapters. The former we call model-learning, and the latter we call direct reinforcement learning (direct RL). The possible relationships between experience, model, values, and policy are summarized in Figure 8.1. Each arrow shows a relationship of influence and presumed improvement. Note how experience can improve value functions and policies either directly or indirectly via the model. It is the latter, which is sometimes called indirect reinforcement learning, that is involved in planning.\nBoth direct and indirect methods have advantages and disadvantages. Indirect methods often make fuller use of a limited amount of experience and thus achieve a better policy with fewer environmental interactions. On the other hand, direct methods are much simpler and are not affected by biases in the design of the model. Some have argued that indirect methods are always superior to direct ones, while others have argued that direct methods are responsible for most human and animal\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nmodel\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; experience\n \nmodel\nlearning\nFigure 8.1: Relationships among learning, planning, and acting.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\nlearning. Related debates in psychology and artificial intelligence concern the relative importance of cognition as opposed to trial-and-error learning, and of deliberative planning as opposed to reactive decision-making (see Chapter 14 for discussion of some of these issues from the perspective of psychology). Our view is that the contrast between the alternatives in all these debates has been exaggerated, that more insight can be gained by recognizing the similarities between these two sides than by opposing them. For example, in this book we have emphasized the deep similarities between dynamic programming and temporal-difference methods, even though one was designed for planning and the other for model-free learning.\nDyna-Q includes all of the processes shown in Figure 8.1\\A1\\AAplanning, acting, model- learning, and direct RL\\A1\\AAall occurring continuously. The planning method is the random-sample one-step tabular Q-planning method given in Figure 8.1. The di\u0026shy;rect RL method is one-step tabular Q-learning. The model-learning method is also table-based and assumes the environment is deterministic. After each transition St, At Rt+1, St+1, the model records in its table entry for St, At the prediction that Rt+1, St+1will deterministically follow. Thus, if the model is queried with a state-action pair that has been experienced before, it simply returns the last-observed next state and next reward as its prediction. During planning, the Q-planning al\u0026shy;gorithm randomly samples only from state-action pairs that have previously been experienced (in Step 1), so the model is never queried with a pair about which it has no information.\nThe overall architecture of Dyna agents, of which the Dyna-Q algorithm is one example, is shown in Figure 8.2. The central column represents the basic interaction between agent and environment, giving rise to a trajectory of real experience. The arrow on the left of the figure represents direct reinforcement learning operating\n \nFigure 8.2: The general Dyna Architecture. Real experience, passing back and forth between the environment and the policy, affects policy and value functions in much the same way as does simulated experience generated by the model of the environment.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\non real experience to improve the value function and the policy. On the right are model-based processes. The model is learned from real experience and gives rise to simulated experience. We use the term search control to refer to the process that selects the starting states and actions for the simulated experiences generated by the model. Finally, planning is achieved by applying reinforcement learning methods to the simulated experiences just as if they had really happened. Typically, as in Dyna-Q, the same reinforcement learning method is used both for learning from real experience and for planning from simulated experience. The reinforcement learning method is thus the \\A1\\B0final common path\\A1\\B1 for both learning and planning. Learning and planning are deeply integrated in the sense that they share almost all the same machinery, differing only in the source of their experience.\nConceptually, planning, acting, model-learning, and direct RL occur simultane\u0026shy;ously and in parallel in Dyna agents. For concreteness and implementation on a serial computer, however, we fully specify the order in which they occur within a time step. In Dyna-Q, the acting, model-learning, and direct RL processes require little computation, and we assume they consume just a fraction of the time. The remaining time in each step can be devoted to the planning process, which is in\u0026shy;herently computation-intensive. Let us assume that there is time in each step, after acting, model-learning, and direct RL, to complete n iterations (Steps 1-3) of the Q-planning algorithm. In the pseudocode algorithm for Dyna-Q in the box below, Model(s, a) denotes the contents of the (predicted next state and reward) for state- action pair (s, a). Direct reinforcement learning, model-learning, and planning are implemented by steps (d), (e), and (f), respectively. If (e) and (f) were omitted, the remaining algorithm would be one-step tabular Q-learning.\n \nInitialize Q(s, a) and Model(s, a) for all s G S and a G A(s)\nDo forever:\n(a)\u0026nbsp;\u0026nbsp; S \\A1\\AA current (nonterminal) state\n(b)\u0026nbsp;\u0026nbsp; A \\A1\\AA e-greedy(S, Q)\n(c)\u0026nbsp;\u0026nbsp; Execute action A; observe resultant reward, R, and state, S'\n(d)\u0026nbsp;\u0026nbsp; Q(S,A) \\A1\\AA Q(S,A)+ a[R ʮ7max0 Q(S,,a) \\A1\\AA Q(S,A)]\n(e)\u0026nbsp;\u0026nbsp; Model(S, A) \\A1\\AA R, S7 (assuming deterministic environment)\n(f)\u0026nbsp;\u0026nbsp;\u0026nbsp; Repeat n times:\nS \\A1\\AA random previously observed state A \\A1\\AA random action previously taken in S R, S7 \\A1\\AA Model(S,A)\nQ(S, A) \\A1\\AA Q(S, A)ʮa[R ʮ7 max0 Q(S7, a) \\A1\\AA Q(S, A)]\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nExample 8.1: Dyna Maze Consider the simple maze shown inset in Figure 8.3. In each of the 47 states there are four actions, up, down, right, and left, which take the agent deterministically to the corresponding neighboring states, except when movement is blocked by an obstacle or the edge of the maze, in which case the agent remains where it is. Reward is zero on all transitions, except those into the goal state, on which it is +1. After reaching the goal state (G), the agent returns to\n\n\n   800-\n        600-\n        \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n G\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  S\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \\A1\\F6\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        actions\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n    0 planning steps (direct RL only)\n        5 planning steps\n        50 planning steps\n        ~i------- 1------ 1~\n10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 20\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 30\n        40\n     Steps\nper\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 400H\nepisode\n200-\n   50\n     14-\n \n\u0026nbsp;\n\u0026nbsp;\n \nEpisodes\nFigure 8.3: A simple maze (inset) and the average learning curves for Dyna-Q agents varying in their number of planning steps (n) per real step. The task is to travel from S to G as quickly as possible.\nthe start state (S) to begin a new episode. This is a discounted, episodic task with\nY\u0026nbsp; = 0.95.\nThe main part of Figure 8.3 shows average learning curves from an experiment in which Dyna-Q agents were applied to the maze task. The initial action values were zero, the step-size parameter was a= 0.1, and the exploration parameter was e = 0.1. When selecting greedily among actions, ties were broken randomly. The agents varied in the number of planning steps, n, they performed per real step. For each n, the curves show the number of steps taken by the agent to reach the goal in each episode, averaged over 30 repetitions of the experiment. In each repetition, the initial seed for the random number generator was held constant across algorithms. Because of this, the first episode was exactly the same (about 1700 steps) for all values of n, and its data are not shown in the figure. After the first episode, performance improved for all values of n, but much more rapidly for larger values. Recall that the n = 0 agent is a nonplanning agent, using only direct reinforcement learning (one- step tabular Q-learning). This was by far the slowest agent on this problem, despite the fact that the parameter values (a and e)were optimized for it. The nonplanning agent took about 25 episodes to reach (e-)optimal performance, whereas the n = 5 agent took about five episodes, and the n = 50 agent took only three episodes.\nFigure 8.4 shows why the planning agents found the solution so much faster than the nonplanning agent. Shown are the policies found by the n = 0 and n = 50 agents halfway through the second episode. Without planning (n = 0), each episode adds only one additional step to the policy, and so only one step (the last) has been\n180 CHAPTER 8. PLANNING AND LEARNING WITH TABULAR METHODS WITHOUT PLANNING (n=0)WITH PLANNING (n=50)\n\u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \\A1\\F6\n \u0026nbsp;\n \u0026nbsp;\n G\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n ţ\n  S\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\nFigure 8.4: Policies found by planning and nonplanning Dyna-Q agents halfway through the second episode. The arrows indicate the greedy action in each state; if no arrow is shown for a state, then all of its action values were equal. The black square indicates the location of the agent.\nlearned so far. With planning, again only one step is learned during the first episode, but here during the second episode an extensive policy has been developed that by the episode\\A1\\AFs end will reach almost back to the start state. This policy is built by the planning process while the agent is still wandering near the start state. By the end of the third episode a complete optimal policy will have been found and perfect performance attained.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nIn Dyna-Q, learning and planning are accomplished by exactly the same algorithm, operating on real experience for learning and on simulated experience for planning. Because planning proceeds incrementally, it is trivial to intermix planning and act\u0026shy;ing. Both proceed as fast as they can. The agent is always reactive and always deliberative, responding instantly to the latest sensory information and yet always planning in the background. Also ongoing in the background is the model-learning process. As new information is gained, the model is updated to better match real\u0026shy;ity. As the model changes, the ongoing planning process will gradually compute a different way of behaving to match the new model.\nExercise 8.1 The nonplanning method looks particularly poor in Figure 8.4 because it is a one-step method; a method using multi-step bootstrapping would do better. Do you think one of the multi-step bootstrapping methods from Chapter 7 could do as well as the Dyna method? Explain why or why not.\n8.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; When the Model Is Wrong\nIn the maze example presented in the previous section, the changes in the model were relatively modest. The model started out empty, and was then filled only with exactly correct information. In general, we cannot expect to be so fortunate. Models may be incorrect because the environment is stochastic and only a limited number of samples have been observed, or because the model was learned using function approximation that has generalized imperfectly, or simply because the environment has changed and its new behavior has not yet been observed. When the model is incorrect, the planning process is likely to compute a suboptimal policy.\n\n\nIn some cases, the suboptimal policy computed by planning quickly leads to the discovery and correction of the modeling error. This tends to happen when the model is optimistic in the sense of predicting greater reward or better state transitions than are actually possible. The planned policy attempts to exploit these opportunities and in doing so discovers that they do not exist.\n   wandering around behind the barrier. the new opening and the new optimal\n     Example 8.2: Blocking Maze A maze example illustrating this relatively minor kind of modeling error and recovery from it is shown in Figure 8.5. Initially, there is a short path from start to goal, to the right of the barrier, as shown in the upper left of the figure. After 1000 time steps, the short path is \\A1\\B0blocked,\\A1\\B1 and a longer path is opened up along the left-hand side of the barrier, as shown in upper right of the figure. The graph shows average cumulative reward for a Dyna-Q agent and an enhanced Dyna-Q+ agent to be described shortly. The first part of the graph shows that both Dyna agents found the short path within 1000 steps. When the environment changed, the graphs become flat, indicating a period during which the agents obtained no reward because they were After a while, however, they were able to find behavior.\n \n   \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n G\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n S\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n        Figure 8.5: Average performance of Dyna agents on a blocking task. The left environment was used for the first 1000 steps, the right environment for the rest. Dyna-Q+ is Dyna-Q with an exploration bonus that encourages exploration.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n        Time steps\n        \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n G\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \\A1\\AA\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n S\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Greater difficulties arise when the environment changes to become better than it was before, and yet the formerly correct policy does not reveal the improvement. In these cases the modeling error may not be detected for a long time, if ever, as we see in the next example.\nExample 8.3: Shortcut Maze The problem caused by this kind of environmental change is illustrated by the maze example shown in Figure 8.6. Initially, the optimal path is to go around the left side of the barrier (upper left). After 3000 steps, however, a shorter path is opened up along the right side, without disturbing the longer path (upper right). The graph shows that the regular Dyna-Q agent never switched to the shortcut. In fact, it never realized that it existed. Its model said that there was no shortcut, so the more it planned, the less likely it was to step to the right and discover it. Even with an e-greedy policy, it is very unlikely that an agent will take so many exploratory actions as to discover the shortcut.\n \nTime steps\nFigure 8.6: Average performance of Dyna agents on a shortcut task. The left environment was used for the first 3000 steps, the right environment for the rest.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nThe general problem here is another version of the conflict between exploration and exploitation. In a planning context, exploration means trying actions that improve the model, whereas exploitation means behaving in the optimal way given the current model. We want the agent to explore to find changes in the environment, but not so much that performance is greatly degraded. As in the earlier exploration/exploitation conflict, there probably is no solution that is both perfect and practical, but simple heuristics are often effective.\nThe Dyna-Q+ agent that did solve the shortcut maze uses one such heuristic. This agent keeps track for each state-action pair of how many time steps have elapsed since the pair was last tried in a real interaction with the environment. The more time that has elapsed, the greater (we might presume) the chance that the dynamics of this pair has changed and that the model of it is incorrect. To encourage behavior that tests long-untried actions, a special \\A1\\B0bonus reward\\A1\\B1 is given on simulated experiences involving these actions. In particular, if the modeled reward for a transition is r, and the transition has not been tried in t time steps, then planning backups are done as if that transition produced a reward of r + k^/T, for some small k. This encourages the agent to keep testing all accessible state transitions and even to find long sequences of actions in order to carry out such tests.[12] Of course all this testing has its cost, but in many cases, as in the shortcut maze, this kind of computational curiosity is well worth the extra exploration.\nExercise 8.2 Why did the Dyna agent with exploration bonus, Dyna-Q+, perform better in the first phase as well as in the second phase of the blocking and shortcut experiments?\nExercise 8.3 Careful inspection of Figure 8.6reveals that the difference between Dyna-Q+ and Dyna-Q narrowed slightly over the first part of the experiment. What is the reason for this?\nExercise 8.4 (programming) The exploration bonus described above actually changes the estimated values of states and actions. Is this necessary? Suppose the bonus was used not in backups, but solely in action selection. That is, suppose the action selected was always that for which Q(St, a) +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (St, a) was\nmaximal. Carry out a gridworld experiment that tests and illustrates the strengths and weaknesses of this alternate approach.\n8.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Prioritized Sweeping\nIn the Dyna agents presented in the preceding sections, simulated transitions are started in state-action pairs selected uniformly at random from all previously ex\u0026shy;perienced pairs. But a uniform selection is usually not the best; planning can be much more efficient if simulated transitions and backups are focused on particular state-action pairs. For example, consider what happens during the second episode of the first maze task (Figure 8.4). At the beginning of the second episode, only the state-action pair leading directly into the goal has a positive value; the values of all other pairs are still zero. This means that it is pointless to back up along almost all transitions, because they take the agent from one zero-valued state to another, and thus the backups would have no effect. Only a backup along a transition into the state just prior to the goal, or from it, will change any values. If simulated transitions are generated uniformly, then many wasteful backups will be made before stumbling onto one of these useful ones. As planning progresses, the region of useful back\u0026shy;ups grows, but planning is still far less efficient than it would be if focused where it would do the most good. In the much larger problems that are our real objective, the number of states is so large that an unfocused search would be extremely inefficient.\nThis example suggests that search might be usefully focused by working backward from goal states. Of course, we do not really want to use any methods specific to the idea of \\A1\\B0goal state.\\A1\\B1 We want methods that work for general reward functions. Goal states are just a special case, convenient for stimulating intuition. In general, we want to work back not just from goal states but from any state whose value has changed. Suppose that the values are initially correct given the model, as they were in the maze example prior to discovering the goal. Suppose now that the agent discovers a change in the environment and changes its estimated value of one state, either up or down. Typically, this will imply that the values of many other states should also be changed, but the only useful one-step backups are those of actions that lead directly into the one state whose value has been changed. If the values of these actions are updated, then the values of the predecessor states may change in turn. If so, then actions leading into them need to be backed up, and then their predecessor states may have changed. In this way one can work backward from arbitrary states that have changed in value, either performing useful backups or terminating the propagation. This general idea might be termed backward focusing of planning computations.\nAs the frontier of useful backups propagates backward, it often grows rapidly, producing many state-action pairs that could usefully be backed up. But not all of these will be equally useful. The values of some states may have changed a lot, whereas others may have changed little. The predecessor pairs of those that have changed a lot are more likely to also change a lot. In a stochastic environment, variations in estimated transition probabilities also contribute to variations in the sizes of changes and in the urgency with which pairs need to be backed up. It is natural to prioritize the backups according to a measure of their urgency, and perform them in order of priority. This is the idea behind prioritized sweeping. A queue is maintained of every state-action pair whose estimated value would change nontrivially if backed up, prioritized by the size of the change. When the top pair in the queue is backed up, the effect on each of its predecessor pairs is computed.\nPrioritized sweeping for a deterministic environment\nInitialize Q(s, a), Model(s, a), for all s, a, and PQueue to empty Do forever:\n(a)\u0026nbsp; S \\A1\\AA current (nonterminal) state\n(b)\u0026nbsp; A \\A1\\AA policy(S, Q)\n(c)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;Execute action A; observe resultant reward, R, and state, S'\n(d)\u0026nbsp; Model(S, A) \\A1\\AA R, Sf\n(e)\u0026nbsp; P\\A1\\AA |R + y maxa Q(S',a) \\A1\\AA Q(S, A)|.\n(f)\u0026nbsp;\u0026nbsp; if P \u0026gt; 0, then insert S, A into PQueue with priority P\n(g)\u0026nbsp; Repeat n times, while PQueue is not empty:\nS, A \\A1\\AA first(PQueue)\nR,S' \\A1\\AA Model (S, A)\nQ(S, A) \\A1\\AA Q(S, A) + a[R + 7maxa Q(S ',a) \\A1\\AA Q(S, A)] Repeat, for all S A predicted to lead to S:\nR \\A1\\AA predicted reward for S, A, S\nP \\A1\\AA |R + Ymaxa Q(S, a) \\A1\\AA Q(\\BC\\B0,Z)|.\nif P \u0026gt; 0 then insert S, jA into PQueue with priority P\n\n\nIf the effect is greater than some small threshold, then the pair is inserted in the queue with the new priority (if there is a previous entry of the pair in the queue, then insertion results in only the higher priority entry remaining in the queue). In this way the effects of changes are efficiently propagated backward until quiescence. The full algorithm for the case of deterministic environments is given in the box.\nExample 8.4: Prioritized Sweeping on Mazes Prioritized sweeping has been found to dramatically increase the speed at which optimal solutions are found in maze tasks, often by a factor of 5 to 10. A typical example is shown in Figure 8.7. These data are for a sequence of maze tasks of exactly the same structure as the one shown in Figure 8.3, except that they vary in the grid resolution. Prioritized sweeping maintained a decisive advantage over unprioritized Dyna-Q. Both systems made at most n = 5 backups per environmental interaction.\n \n   Figure 8.7: Prioritized sweeping significantly shortens learning time on the Dyna maze task for a wide range of grid resolutions. Reprinted from Peng and Williams (1993).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n        Gridworld size (#states)\n        Backups\nuntil\noptimal\nsolution\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Example 8.5: Rod Maneuvering The objective in this task is to maneuver a rod around some awkwardly placed obstacles within a limited rectangular work space to a goal position in the fewest number of steps (see Figure 8.8). The rod can be translated along its long axis or perpendicular to that axis, or it can be rotated in either direction around its center. The distance of each movement is approximately 1/20 of the work space, and the rotation increment is 10 degrees. Translations are deterministic and quantized to one of 20 x 20 positions. The figure shows the obstacles and the shortest solution from start to goal, found by prioritized sweeping. This problem is still deterministic, but has four actions and 14,400 potential states (some of these are unreachable because of the obstacles). This problem is probably too large to be solved with unprioritized methods.\n \nFigure 8.8: A rod-maneuvering task and its solution by prioritized sweeping. Reprinted from Moore and Atkeson (1993).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nExtensions of prioritized sweeping to stochastic environments are straightforward. The model is maintained by keeping counts of the number of times each state-action pair has been experienced and of what the next states were. It is natural then to backup each pair not with a sample backup, as we have been using so far, but with a full backup, taking into account all possible next states and their probabilities of occurring.\nPrioritized sweeping is just one way of distributing computations to improve plan\u0026shy;ning efficiency, and probably not the best way. One of prioritized sweeping\\A1\\AFs limita\u0026shy;tions is that it uses full backups, which in stochastic environments may waste lots of computation on low-probability transitions. As we show in the following section, sample backups can in many cases get closer to the true value function with less computation despite the variance introduced by sampling. Sample backups can win because they break the overall backing-up computation into smaller pieces\\A1\\AAthose corresponding to individual transitions\\A1\\AAwhich then enables it to be focused more narrowly on the pieces that will have the largest impact. This idea was taken to what may be its logical limit in the \\A1\\B0small backups\\A1\\B1 introduced by van Seijen and Sutton (2013). These are backups along a single transition, like a sample backup, but based on the probability of the transition without sampling, as in a full backup. By selecting the order in which small backups are done it is possible to greatly improve planning efficiency beyond that possible with prioritized sweeping.\nWe have suggested in this chapter that all kinds of state-space planning can be viewed as sequences of backups, varying only in the type of backup, full or sample, large or small, and in the order in which the backups are done. In this section we have emphasized backward focusing, but this is just one strategy. For example, another would be to focus on states according to how easily they can be reached from the states that are visited frequently under the current policy, which might be called forward focusing. Peng and Williams (1993) and Barto, Bradtke and Singh (1995) have explored versions of forward focusing, and the methods introduced in the next few sections take it to an extreme form.\n8.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Full vs. Sample Backups\nThe examples in the previous sections give some idea of the range of possibilities for combining methods of learning and planning. In the rest of this chapter, we analyze some of the component ideas involved, starting with the relative advantages of full and sample backups.\nMuch of this book has been about different kinds of backups, and we have con\u0026shy;sidered a great many varieties. Focusing for the moment on one-step backups, they vary primarily along three binary dimensions. The first two dimensions are whether they back up state values or action values and whether they estimate the value for the optimal policy or for an arbitrary given policy. These two dimensions give rise to four classes of backups for approximating the four value functions, q^, v^,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; , and .\nThe other binary dimension is whether the backups are full backups, considering all possible events that might happen, or sample backups, considering a single sample of what might happen. These three binary dimensions give rise to eight cases, seven of which correspond to specific algorithms, as shown in Figure 8.9. (The eighth case does not seem to correspond to any useful backup.) Any of these one-step backups can be used in planning methods. The Dyna-Q agents discussed earlier use q^ sample backups, but they could just as well use \\81\\96full backups, or either full or sample \\C8\\E7 backups. The Dyna-AC system uses v^ sample backups together with a learning policy structure. For stochastic problems, prioritized sweeping is always done using one of the full backups.\nWhen we introduced one-step sample backups in Chapter 6, we presented them as substitutes for full backups. In the absence of a distribution model, full backups are not possible, but sample backups can be done using sample transitions from the environment or a sample model. Implicit in that point of view is that full backups, if possible, are preferable to sample backups. But are they? Full backups certainly yield a better estimate because they are uncorrupted by sampling error, but they also require more computation, and computation is often the limiting resource in planning. To properly assess the relative merits of full and sample backups for planning we must control for their different computational requirements.\nFor concreteness, consider the full and sample backups for approximating q^, and the special case of discrete states and actions, a table-lookup representation of the approximate value function, Q, and a model in the form of estimated dynamics, p(s\\A1\\A2r|s, a). The full backup for a state-action pair, s, a, is:\nQ(s, a)p(s\u0026#12316;r|s,a) r + 7m^xQ(s;, a;) .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (8.1)\n\n\n6U|UJB9|-D\n   U0IJBJ9J! 0n|BA-D\n\n     P\\J\n   {s^fb\n     ɽ\nSO\nN\nv's\n \n\u0026nbsp;\n\u0026nbsp;\n \n   uo!ien|BA9 Ao||od-o\n\n     BSJBS\n   (yv)ub\n     ,yt\n^0 i\nv\\A1\\AEs\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n \n   U0\\A3\\BB1BJ@1! 9n|BA\n\n        uo!jen|EAe Aonod\n     (d\n(s)uA\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n \n(Cl \\81Adajs-auo)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (da)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; pajBiujisa\nsdn\u0026gt;)0Bq a|diues\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; sdnqoeq ||nj\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 9n|e\\B0\\CB\nSQ0H13H yvmavi H1IM DMIMUV31 QMV DMIMMVld f8 midVHD88T\n \nThe corresponding sample backup for s, a, given a sample next state and reward, S' and R (from the model), is the Q-learning-like update:\nQ(s, a) \\A1\\AA Q(s, a) + a R + 7maxQ(S', a') \\A1\\AA Q(s, a) ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (8.2)\nL\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a'\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\B9\nwhere a is the usual positive step-size parameter.\nThe difference between these full and sample backups is significant to the extent that the environment is stochastic, specifically, to the extent that, given a state and action, many possible next states may occur with various probabilities.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If\u0026nbsp; only one\nnext state is possible, then the full and sample backups given\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; above\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; are\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; identical\n(taking a = 1). If there are many possible next states, then there may be significant differences. In favor of the full backup is that it is an exact computation, resulting in a new Q(s, a) whose correctness is limited only by the correctness of the Q(s', a') at successor states. The sample backup is in addition affected by sampling error. On the other hand, the sample backup is cheaper computationally because it considers only one next state, not all possible next states. In practice, the computation required by backup operations is usually dominated by the number of state-action pairs at which Q is evaluated. For a particular starting pair, s, a, let b be the branching factor (i.e., the number of possible next states, s', for which p(s'|s,a) \u0026gt; 0). Then a full backup of this pair requires roughly b times as much computation as a sample backup.\nIf there is enough time to complete a full backup, then the resulting estimate is generally better than that of b sample backups because of the absence of sampling error. But if there is insufficient time to complete a full backup, then sample backups are always preferable because they at least make some improvement in the value estimate with fewer than b backups. In a large problem with many state-action pairs, we are often in the latter situation. With so many state-action pairs, full backups of all of them would take a very long time. Before that we may be much better off with a few sample backups at many state-action pairs than with full backups at a few pairs. Given a unit of computational effort, is it better devoted to a few full backups or to b times as many sample backups?\nFigure 8.10 shows the results of an analysis that suggests an answer to this ques\u0026shy;tion. It shows the estimation error as a function of computation time for full and sample backups for a variety of branching factors, b. The case considered is that in which all b successor states are equally likely and in which the error in the initial estimate is 1. The values at the next states are assumed correct, so the full backup reduces the error to zero upon its completion. In this case, sample backups reduce\nthe error according to\\A1\\A2/ where t is the number of sample backups that have been\n~bT\nperformed (assuming sample averages, i.e., a = 1/t). The key observation is that for moderately large b the error falls dramatically with a tiny fraction of b backups. For these cases, many state-action pairs could have their values improved dramatically, to within a few percent of the effect of a full backup, in the same time that one state-action pair could be backed up fully.\n   Figure 8.10: Comparison of efficiency of full and sample backups.\n        Number of max Q(sf, a!) computations\na0\n     The advantage of sample backups shown in Figure 8.10 is probably an underesti\u0026shy;mate of the real effect. In a real problem, the values of the successor states wouldthemselves be estimates updated by backups. By causing estimates to be more accu\u0026shy;rate sooner, sample backups will have a second advantage in that the values backed up from the successor states will be more accurate. These results suggest that sample backups are likely to be superior to full backups on problems with large stochastic branching factors and too many states to be solved exactly.\n8.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Trajectory Sampling\nIn this section we compare two ways of distributing backups. The classical approach, from dynamic programming, is to perform sweeps through the entire state (or state- action) space, backing up each state (or state-action pair) once per sweep. This is problematic on large tasks because there may not be time to complete even one sweep. In many tasks the vast majority of the states are irrelevant because they are visited only under very poor policies or with very low probability. Exhaustive sweeps implicitly devote equal time to all parts of the state space rather than focusing where it is needed. As we discussed in Chapter 4, exhaustive sweeps and the equal treatment of all states that they imply are not necessary properties of dynamic programming. In principle, backups can be distributed any way one likes (to assure convergence, all states or state-action pairs must be visited in the limit an infinite number of times; although an exception to this is discussed in Section 8.7 below), but in practice exhaustive sweeps are often used.\nThe second approach is to sample from the state or state-action space according to some distribution. One could sample uniformly, as in the Dyna-Q agent, but this would suffer from some of the same problems as exhaustive sweeps. More appealing is to distribute backups according to the on-policy distribution, that is, according to the distribution observed when following the current policy. One advantage of this distribution is that it is easily generated; one simply interacts with the model, following the current policy. In an episodic task, one starts in a start state (or according to the starting-state distribution) and simulates until the terminal state. In a continuing task, one starts anywhere and just keeps simulating. In either case, sample state transitions and rewards are given by the model, and sample actions are given by the current policy. In other words, one simulates explicit individual trajectories and performs backups at the state or state-action pairs encountered along the way. We call this way of generating experience and backups trajectory sampling.\nIt is hard to imagine any efficient way of distributing backups according to the on-policy distribution other than by trajectory sampling. If one had an explicit rep\u0026shy;resentation of the on-policy distribution, then one could sweep through all states, weighting the backup of each according to the on-policy distribution, but this leaves us again with all the computational costs of exhaustive sweeps. Possibly one could sample and update individual state-action pairs from the distribution, but even if this could be done efficiently, what benefit would this provide over simulating trajec\u0026shy;tories? Even knowing the on-policy distribution in an explicit form is unlikely. The distribution changes whenever the policy changes, and computing the distribution requires computation comparable to a complete policy evaluation. Consideration of such other possibilities makes trajectory sampling seem both efficient and elegant.\nIs the on-policy distribution of backups a good one? Intuitively it seems like a good choice, at least better than the uniform distribution. For example, if you are learning to play chess, you study positions that might arise in real games, not random positions of chess pieces. The latter may be valid states, but to be able to accurately value them is a different skill from evaluating positions in real games. We will also see in Chapter 9 that the on-policy distribution has significant advantages when function approximation is used. Whether or not function approximation is used, one might expect on-policy focusing to significantly improve the speed of planning.\nFocusing on the on-policy distribution could be beneficial because it causes vast, uninteresting parts of the space to be ignored, or it could be detrimental because it causes the same old parts of the space to be backed up over and over. We conducted a small experiment to assess the effect empirically. To isolate the effect of the backup distribution, we used entirely one-step full tabular backups, as defined by (8.1). In the uniform case, we cycled through all state-action pairs, backing up each in place, and in the on-policy case we simulated episodes, all starting in the same state, backing up each state-action pair that occurred under the current e-greedy policy (e = 0.1). The tasks were undiscounted episodic tasks, generated randomly as follows. From each of the |S| states, two actions were possible, each of which resulted in one of b next states, all equally likely, with a different random selection of b states for each state-action pair. The branching factor, b, was the same for all state-action pairs. In addition, on all transitions there was a 0.1probability of transition to the terminal state, ending the episode. We used episodic tasks to get a clear measure of the quality of the current policy. At any point in the planning process one can stop and exhaustively compute vn(so), the true value of the start state under the greedy\n \nValue of start state under greedy policy\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n \nComputation time, in full backups\n \n   Figure 8.11: Relative efficiency of backups distributed uniformly across the state space versus focused on simulated on-policy trajectories, each starting in the same state. Results are for randomly generated tasks of two sizes and various branching factors, b.\n        Computation time, in full backups\n        Value of start state under greedy policy\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n policy,\\D8\\C1\\A3\\ACgiven the current action-value function Q, as an indication of how well the agent would do on a new episode on which it acted greedily (all the while assuming the model is correct).\nThe upper part of Figure 8.11 shows results averaged over 200 sample tasks with 1000 states and branching factors of 1, 3, and 10. The quality of the policies found is plotted as a function of the number of full backups completed. In all cases, sam\u0026shy;pling according to the on-policy distribution resulted in faster planning initially and retarded planning in the long run. The effect was stronger, and the initial period of faster planning was longer, at smaller branching factors. In other experiments, we found that these effects also became stronger as the number of states increased. For example, the lower part of Figure 8.11 shows results for a branching factor of 1 for tasks with 10,000 states. In this case the advantage of on-policy focusing is large and long-lasting.\nAll of these results make sense. In the short term, sampling according to the on-policy distribution helps by focusing on states that are near descendants of the start state. If there are many states and a small branching factor, this effect will be large and long-lasting. In the long run, focusing on the on-policy distribution may hurt because the commonly occurring states all already have their correct values. Sampling them is useless, whereas sampling other states may actually perform some useful work. This presumably is why the exhaustive, unfocused approach does better in the long run, at least for small problems. These results are not conclusive because they are only for problems generated in a particular, random way, but they do suggest that sampling according to the on-policy distribution can be a great advantage for large problems, in particular for problems in which a small subset of the state-action space is visited under the on-policy distribution.\n8.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Real-time Dynamic Programming\nReal-time dynamic programming, or RTDP, is an on-policy trajectory-sampling ver\u0026shy;sion of DP\\A1\\AFs value-iteration algorithm. Because it is closely related to conventional sweep-based policy iteration, RTDP illustrates in a particularly clear way some of the advantages that on-policy trajectory sampling can provide. RTDP backs up the values of states visited in actual or simulated trajectories by means of full tabu\u0026shy;lar value-iteration backups as defined by (4.10). It is basically the algorithm that produced the on-policy results shown in Figure 8.11.\nThe close connection between RTDP and conventional DP makes it possible to derive some theoretical results by adapting existing theory. RTDP is an example of an asynchronous DP algorithm as described in Section 4.5. Asynchronous DP algorithms are not organized in terms of systematic sweeps of the state set; they back up state values in any order whatsoever, using whatever values of other states happen to be available. In RTDP, the backup order is dictated by the order states are visited in real or simulated trajectories.\nIf trajectories can start only from a designated set of start states, and if you areinterested in the prediction problem for a given policy, then on-policy trajectory sampling allows the algorithm to completely skip states that cannot be reached by the given policy from any of the start states: unreachable states are irrelevant to the prediction problem. For a control problem, where the goal is to find an optimal policy instead of evaluating a given policy, there might well be states that cannot be reached by any optimal policy from any of the start states, and there is no need to specify optimal actions for these irrelevant states. What is needed is an optimal partial policy, meaning a policy that is optimal for the relevant states but can specify arbitrary actions, or even be undefined, for the irrelevant states (see the illustration below).\nBut finding such an opti\u0026shy;mal partial policy with an on-\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; irrelevant\u0026nbsp; States\\A3\\BA\npolicy trajectory-sampling con-\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; unreachable from any start state\nunder any optimal policy\ntrol method, such as Sarsa\n(Section 6.4), in general Start States requires visiting all state-\naction pairs\\A1\\AAeven those that will turn out to be irrelevant\\A1\\AA an infinite number of times.\nThis can be done, for exam\u0026shy;ple, by using exploring starts (Section 5.3). This is true for RTDP as well: for episodic tasks with exploring starts, RTDP is an asynchronous value-iteration algorithm that converges to optimal polices for discounted finite MDPs (and for the undiscounted case under certain conditions). Unlike the situ\u0026shy;ation for a prediction problem, it is generally not possible to stop backing up any state or state-action pair if convergence to an optimal policy is important.\nThe most interesting result for RTDP is that for certain types of problems sat\u0026shy;isfying reasonable conditions, RTDP is guaranteed to find a policy that is optimal on the relevant states without visiting every state infinitely often, or even without visiting some states at all. Indeed, in some problems, only a small fraction of the states need to be visited. This can be a great advantage for problems with very large state sets, where even a single sweep may not be feasible.\nThe tasks for which this result holds are undiscounted episodic tasks for MDPs with absorbing goal states that generate zero rewards, as described in Section 3.4. At every step of a real or simulated trajectory, RTDP selects a greedy action (breaking ties randomly) and applies the full value-iteration backup operation to the current state. It can also backup the values of an arbitrary collection of other states at each step; for example, it can backup the values of states visited in a limited-horizon look-ahead search from the current state.\nFor these problems, with each episode beginning in a state randomly chosen from the set of start states, and ending at a goal state, RTDP converges (with probability one) to a policy that is optimal for all the relevant states[13]provided the following \n \nconditions are satisfied: 1) the initial value of every goal state is zero, 2) there exists at least one policy that guarantees that a goal state will be reached with probability one from any start state, 3) all rewards for transitions from non-goal states are strictly negative, and 4) all the initial values are equal to, or greater than, their optimal values (which can be satisfied by simply setting the initial values of all states to zero). This result was proved by Barto, Bradtke, and Singh (1995) by combining results for asynchronous DP with results about a heuristic search algorithm known as learning real-time A*due to Korf (1990).\nTasks having these properties are examples of stochastic optimal path problems, which are usually stated in terms of cost minimization instead as reward maximiza\u0026shy;tion, as we do here. Maximizing the negative returns in our version is equivalent to minimizing the costs of paths from a start state to a goal state. Examples of this kind of task are minimum-time control tasks, where each time step required to reach a goal produces a reward of \\A1\\AA1, or problems like the Golf example in Section 3.7, whose objective is to hit the hole with the fewest strokes.\nExample 8.6: RTDP on the Racetrack The racetrack problem of Exercise 5.7 in Section 5.7 is a stochastic optimal path problem. Comparing RTDP and the con\u0026shy;ventional DP value iteration algorithm on an example racetrack problem illustrates some of the advantages of on-policy trajectory sampling.\nRecall from the exercise that an agent has to learn how to drive a car around a turn like those shown in Figure 5.6 and cross the finish line as quickly as possible while staying on the track. Start states are all the zero-speed states on the starting line; the goal states are all the states that can be reached in one time step by crossing the finish line from inside the track. Unlike Exercise 5.7, here there is no limit on the car\\A1\\AFs speed, so the state set is potentially infinite. However, the set of states that can be reached from the set of start states via any policy is finite and can be considered to be the state set of the problem. Each episode begins in a randomly selected start state and ends when the car crosses the finish line. The rewards are \\A1\\AA1 for each step until the car crosses the finish line. If the car hits the track boundary, it is moved back to a random start state, and the episode continues.\nA racetrack similar to the small racetrack on the left of Figure 5.6 has 9,115 states reachable from start states by any policy, only 599 of which are relevant, meaning that they are reachable from some start state via some optimal policy. (The number of relevant states was estimated by counting the states visited while executing optimal actions for 107episodes.)\nThe table below compares solving this task by conventional DP and by RTDP. These results are averages over 25 runs, each begun with a different random number seed. Conventional DP in this case is value iteration using exhaustive sweeps of the state set, with values backed up one state at a time in place, meaning that the update for each state uses the most recent values of the other states (This is the Gauss-Seidel version of value iteration, which was found to be approximately twice as fast as the Jacobi version on this problem. See Section 4.8.) No special attention was paid to\ngreedy actions.\nthe ordering of the updates; other orderings could have produced faster convergence. Initial values were all zero for each run of both methods. DP was judged to have converged when the maximum change in a state value over a sweep was less than 10-4, and RTDP was judged to have converged when the average time to cross the finish line over 20episodes appeared to stabilize at an asymptotic number of steps. This version of RTDP backed up only the value of the current state on each step.\n\u0026nbsp;\n DP\n RTDP\n  Average computation to convergence\n 28 sweeps\n 4000 episodes\n  Average number of backups to convergence\n 252,784\n 127,600\n  Average number of backups per episode\n һ\n 31.9\n  % of states backed up \u0026lt; 100times\n һ\n 98.45\n  % of states backed up \u0026lt; 10times\n һ\n 80.51\n  % of states backed up 0times\n һ\n 3.18\n    \u0026nbsp;\nBoth methods produced policies averaging between 14 and 15 steps to cross the finish line, but RTDP required only roughly half of the backups that DP did. This is the result of RTDP\\A1\\AFs on-policy trajectory sampling. Whereas the value of every state was backed up in each sweep of DP, RTDP focused backups on fewer states. In an average run, RTDP backed up the costs of %98.45 of the states no more than 100 times and %80.51 of the states no more than 10 times; the values of about 290 states were not backed up at all in an average run.\nAnother advantage of RTDP over conventional value iteration is that with RTDP as the value function approaches the optimal value function, V*, the policy used by the agent to generate trajectories approaches an optimal policy because it is always greedy with respect to the current value function. This is in contrast to the situation in conventional value iteration. In practice, value iteration terminates when the value function changes by only a small amount in a sweep, which is how we terminated it to obain the results in the table above. At this point, the value function closely approximates V*, and a greedy policy is close to an optimal policy. However, it is possible that policies that are greedy with respect to the latest value function were optimal, or nearly so, long before value iteration terminates. (Recall from Chapter 4 that optimal policies can be greedy with respect to many different value functions, not just V*.) Checking for the emergence of an optimal policy before value iteration converges is not a part of the conventional DP algorithm and requires a considerable amount of extra computation.\nIn the racetrack example, by running many test episodes after each DP sweep, with actions selected greedily according to the result of that sweep, it was possible to estimate the earliest point in the DP computation at which the approximated optimal evaluation function was good enough so that the corresponding greedy policy was nearly optimal. For this racetrack, a close-to-optimal policy emerged after 15 sweeps of value iteration, or after 136,725 value iteration backups. This is considerably less than the 252,784 backups DP needed to converge to V*, but sill more than the 127,600 backups RTDP required.\nAlthough these simulations are certainly not definitive comparisons of the RTDP with conventional sweep-based value iteration, they illustrate some of advantages of on-policy trajectory sampling. Whereas conventional value iteration continued to back up the value of all the states, RTDP strongly focused on subsets of the states that were relevant to the problem\\A1\\AFs objective. This focus became increasingly narrow as learning continued. Because the convergence theorem for RTDP applies to the simulations, we know that RTDP eventually would have focused only on relevant states, i.e., on states making up optimal paths. RTDP achieved nearly optimal control with about 50% of the computation required by sweep-based value iteration.\n8.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Planning at Decision Time\nPlanning can be used in at least two ways. The one we have considered so far in this chapter, typified by dynamic programming and Dyna, is to use planning to gradually improve a policy or value function on the basis of simulated experience obtained from a model (either a sample or a distribution model). Selecting actions is then a matter of comparing the current state\\A1\\AFs action values obtained from a table in the tabular case we have thus far considered, or by evaluating a mathematical expression in the approximate methods we consider in Part II below. Well before an action is selected for any current state St, planning has played a part in improving the table entries, or the mathematical expression, needed to select the action for many states, including St. Used this way, planning is not focussed on the current state. We call planning used in this way background planning.\nThe other way to use planning is to begin and complete it after encountering each new state St, as a computation whose output is the selection of a single action At\\A3\\BB on the next step planning begins anew with St+i to produce At+i, and so on. The simplest, and almost degenerate, example of this use of planning is when only state values are available, and an action is selected by comparing the values of model- predicted next states for each action (or by comparing the values of afterstates as in the tic-tac-toe example in Chapter 1). More generally, planning used in this way can look much deeper than one-step-ahead and evaluate action choices leading to many different predicted state and reward trajectories. Unlike the first use of planning, here planning focusses on a particular state. We call this decision-time planning.\nThese two ways of thinking about planning\\A1\\AAusing simulated experience to grad\u0026shy;ually improve a policy or value function, or using simulated experience to select an action for the current state\\A1\\AAcan blend together in natural and interesting ways, but they have tended to be studied separately, and that is a good way to first understand them. Let us now take a closer look at decision-time planning.\nEven when planning is only done at decision time, we can still view it, as we did in Section 8.1, as proceeding from simulated experience to backups and values, and ultimately to a policy. It is just that now the values and policy are specific to the current state and the action choices available there, so much so that the values and policy created by the planning process are typically discarded after being used to select the current action. In many applications this is not a great loss because there are very many states and we are unlikely to return to the same state for a long time. In general, one may want to do a mix of both: focus planning on the current state and store the results of planning so as to be that much farther along should one return to the same state later. Decision-time planning is most useful in applications in which fast responses are not required. In chess playing programs, for example, one may be permitted seconds or minutes of computation for each move, and strong programs may plan dozens of moves ahead within this time. On the other hand, if low latency action selection is the priority, then one is generally better off doing planning in the background to compute a policy that can then be rapidly applied to each newly encountered state.\n8.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Heuristic Search\nThe classical state-space planning methods in artificial intelligence are decision-time planning methods collectively known as heuristic search. In heuristic search, for each state encountered, a large tree of possible continuations is considered. The approximate value function is applied to the leaf nodes and then backed up toward the current state at the root. The backing up within the search tree is just the same as in the full backups with maxes (those for vľand q^) discussed throughout this book. The backing up stops at the state-action nodes for the current state. Once the backed-up values of these nodes are computed, the best of them is chosen as the current action, and then all backed-up values are discarded.\nIn conventional heuristic search no effort is made to save the backed-up values by changing the approximate value function. In fact, the value function is generally designed by people and never changed as a result of search. However, it is natural to consider allowing the value function to be improved over time, using either the backed-up values computed during heuristic search or any of the other methods presented throughout this book. In a sense we have taken this approach all along. Our greedy, e-greedy, and UCB (Section 2.7) action-selection methods are not unlike heuristic search, albeit on a smaller scale. For example, to compute the greedy action given a model and a state-value function, we must look ahead from each possible action to each possible next state, backup the rewards and estimated values, and then pick the best action. Just as in conventional heuristic search, this process computes backed-up values of the possible actions, but does not attempt to save them. Thus, heuristic search can be viewed as an extension of the idea of a greedy policy beyond a single step.\nThe point of searching deeper than one step is to obtain better action selections. If one has a perfect model and an imperfect action-value function, then in fact deeper search will usually yield better policies.[14]Certainly, if the search is all the way to the end of the episode, then the effect of the imperfect value function is eliminated, and the action determined in this way must be optimal. If the search is of sufficient \n\n\ndepth k such that ʮis very small, then the actions will be correspondingly near optimal. On the other hand, the deeper the search, the more computation is required, usually resulting in a slower response time. A good example is provided by Tesauro\\A1\\AFs grandmaster-level backgammon player, TD-Gammon (Section 16.1). This system used TD learning to learn an afterstate value function through many games of self\u0026shy;play, using a form of heuristic search to make its moves. As a model, TD-Gammon used a priori knowledge of the probabilities of dice rolls and the assumption that the opponent always selected the actions that TD-Gammon rated as best for it. Tesauro found that the deeper the heuristic search, the better the moves made by TD-Gammon, but the longer it took to make each move. Backgammon has a large branching factor, yet moves must be made within a few seconds. It was only feasible to search ahead selectively a few steps, but even so the search resulted in significantly better action selections.\nWe should not overlook the most obvious way in which heuristic search focuses backups: on the current state. Much of the effectiveness of heuristic search is due to its search tree being tightly focused on the states and actions that might immediately follow the current state. You may spend more of your life playing chess than checkers, but when you play checkers, it pays to think about checkers and about your particular checkers position, your likely next moves, and successor positions. No matter how you select actions, it is these states and actions that are of highest priority for backups and where you most urgently want your approximate value function to be accurate. Not only should your computation be preferentially devoted to imminent events, but so should your limited memory resources. In chess, for example, there are far too many possible positions to store distinct value estimates for each of them, but chess programs based on heuristic search can easily store distinct estimates for the millions of positions they encounter looking ahead from a single position. This great focusing of memory and computational resources on the current decision is presumably the reason why heuristic search can be so effective.\nThe distribution of backups can be altered in similar ways to focus on the current state and its likely successors. As a limiting case we might use exactly the methods of heuristic search to construct a search tree, and then perform the individual, one-step backups from bottom up, as suggested by Figure 8.12. If the backups are ordered in this way and a tabular representation is used, then exactly the same backup would be achieved as in depth-first heuristic search. Any state-space search can be viewed in this way as the piecing together of a large number of individual one-step backups. Thus, the performance improvement observed with deeper searches is not due to the use of multistep backups as such. Instead, it is due to the focus and concentration of backups on states and actions immediately downstream from the current state. By devoting a large amount of computation specifically relevant to the candidate actions, decision-time planning can produce better decisions than can be produced by relying on unfocused backups.\n \nFigure 8.12: The deep backups of heuristic search can be implemented as a sequence of one-step backups (shown here outlined). The ordering shown is for a selective depth-first search.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n8.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Rollout Algorithms\nRollout algorithms are decision-time planning algorithms based on Monte Carlo con\u0026shy;trol applied to simulated trajectories that all begin at the current environment state. They estimate action values for a given policy by averaging the returns of many simulated trajectories that start with each possible action and then follow the given policy. When the action-value estimates are considered to be accurate enough, the action (or one of the actions) having the highest estimated value is executed, after which the process is carried out anew from the resulting next state. As explained by Tesauro and Galperin (1997), who experimented with rollout algorithms for playing backgammon, the term \\A1\\B0rollout\\A1\\B1 comes from estimating the value of a backgammon position by playing out, i.e., \\A1\\B0rolling out,\\A1\\B1 the position many times to the game\\A1\\AFs end with randomly generated sequences of dice rolls, where the moves of both players are made by some fixed policy.\nUnlike the Monte Carlo control algorithms described in Chapter 5, the goal of a rollout algorithm is not to estimate a complete optimal action-value function,\\81\\96\\A3\\ACor a complete action-value function,\\C8\\E7,fora given policy n. Instead, they produce Monte Carlo estimates of action values only for each current state and for a given policy usually called the rollout policy. As decision-time planning algorithms, rollout algorithms make immediate use of these action-value estimates, then discard them. This makes rollout algorithms relatively simple to implement because there is no need to sample outcomes for every state-action pair, and there is no need to approximate a function over either the state space or the state-action space.\nWhat then do rollout algorithms accomplish? The policy improvement theorem described in Section 4.2 tells us that given any two policies n and that are identical except that n;(s) = a = n(s) for some state s, if q^(s, a) \u0026gt; v^(s), then policy n! is as good as, or better, than n. Moreover, if the inequality is strict, then n! is in fact better than n. This applies to rollout algorithms where s is the current state and n is the rollout policy. Averaging the returns of the simulated trajectories produces estimates of (s, a') for each action a' G A(s). Then the policy that selects an action in s that maximizes these estimates and thereafter follows n is a good candidate for a policy that improves over n. The result is like one step of the policy-iteration algorithm of dynamic programming discussed in Section 4.3 (though it is more like one step of asynchronous value iteration described in Section 4.5 because it changes the action for just the current state).\nIn other words, the aim of a rollout algorithm is to improve upon the default policy; not to find an optimal policy. Experience has shown that rollout algorithms can be surprisingly effective. For example, Tesauro and Galperin (1997) were surprised by the dramatic improvements in backgammon playing ability produced by the rollout method. In some applications, a rollout algorithm can produce good performance even if the rollout policy is completely random. But clearly, the performance of the improved policy depends on the performance of the rollout policy and the accuracy of the Monte Carlo value estimates: the better the rollout policy and the more accurate the value estimates, the better the policy produced by a rollout algorithm is likely be.\nThis involves important tradeoffs because better rollout policies typically mean that more time is needed to simulate enough trajectories to obtain good value esti\u0026shy;mates. As decision-time planning methods, rollout algorithms usually have to meet strict time constraints. The computation time needed by a rollout algorithm depends on the number of actions that have to be evaluated for each decision, the number of time steps in the simulated trajectories needed to obtain useful sample returns, the time it takes the rollout policy to make decisions, and the number of simulated trajectories needed to obtain good Monte Carlo action-value estimates.\nBalancing these factors is important in any application of rollout methods, though there are several ways to ease the challenge. Because the Monte Carlo trials are independent of one another, it is possible to run many trials in parallel on separate processors. Another tact is to truncate the simulated trajectories short of complete episodes, correcting the truncated returns by means of a stored evaluation function (which brings into play all that we have said about truncated returns and backups in the preceding chapters). It is also possible, as Tesauro and Galperin (1997) suggest, to monitor the Monte Carlo simulations and prune away candidate actions that are unlikely to turn out to be the best, or whose values are close enough to that of the cur\u0026shy;rent best that choosing them instead would make no real difference (though Tesauro and Galperin point out that this would complicate a parallel implementation).\nWe do not ordinarily think of rollout algorithms as learning algorithms because they do not maintain long-term memories of values or policies. However, these algorithms take advantage of some of the features of reinforcement learning that we have emphasized in this book. As instances of Monte Carlo control, they estimate action values by averaging the returns of a collection of sample trajectories, in this case trajectories of simulated interactions with a sample model of the environment. In this way they are like reinforcement learning algorithms in avoiding the exhaustive sweeps of dynamic programming by trajectory sampling, and in avoiding the need for distribution models by relying on sample, instead of full, backups. Finally, rollout algorithms take advantage of the policy improvement property by acting greedily with respect to the estimated action values.\n8.11\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Monte Carlo Tree Search\nMonte Carlo Tree Search(MCTS) is a recent and strikingly successful example of decision-time planning. At is base, MCTS is a rollout algorithm as described above, but enhanced by the addition of a means for accumulating value estimates obtained from the Monte Carlo simulations in order to successively direct simulations toward more highly-rewarding trajectories. MCTS is largely responsible for the improvement in computer Go from a weak amateur level in 2005 to a grandmaster level (6dan or more) in 2015. Many variations of the basic algorithm have been developed, including a variant that we discuss in Section 16.7 that was critical for the stunning 2016 victories of the program AlphaGo over an 18-time world champion Go player. MCTS has proved to be effective in a wide variety of competitive settings, including general game playing (e.g., see Finnsson \u0026amp; Bjornsson, 2008; Genesereth \u0026amp; Thielscher, 2014), but it is not limited to games; it can be effective for single-agent sequential decision problems if there is an environment model simple enough for fast multistep simulation.\nMCTS is executed after encountering each new state to select the agent\\A1\\AFs action for that state; it is executed again to select the action for the next state, and so on. As in a rollout algorithm, each execution is an iterative process that simulates many trajectories starting from the current state and running to a terminal state (or until discounting makes any further reward negligible as a contribution to the return). The core idea of MCTS is to successively focus multiple simulations start\u0026shy;ing at the current state by extending the initial portions of trajectories that have received high evaluations from earlier simulations. MCTS does not have to retain approximate value functions or policies from one action selection to the next, though in many implementations it retains selected action values likely to be useful for its next execution.\nFor the most part, the actions in the simulated trajectories are generated using a simple policy, usually called a rollout policy as it is for simpler rollout algorithms. When both the rollout policy and the model do not require a lot of computation, many simulated trajectories can be generated in a short period of time. As in any tabular Monte Carlo method, the value of a state-action pair is estimated as the average of the (simulated) returns from that pair. Monte Carlo value estimates are maintained only for the subset of state-action pairs that are most likely to be reached in a few steps, which form a tree rooted at the current state, as illustrated in Figure 8.13. MCTS incrementally extends the tree by adding nodes representing states that look promising based on the results of the simulated trajectories. Any simulated trajectory will pass through the tree and then exit it at some leaf node. Outside the tree and at the leaf nodes the rollout policy is used for action selections, \n\n\nbut at the states inside the tree something better is possible. For these states we have value estimates for of at least some of the actions, so we can pick among them using an informed policy, called the tree policy, that balances exploration and exploitation. For example, the tree policy could select actions using an e-greedy or UCB selection rule (Chapter 2).\nIn more detail, each iteration of a basic version of MCTS consists of the following four steps as illustrated in Figure 8.13:\n1.\u0026nbsp;\u0026nbsp; Selection. Starting at the root node, a tree policy based on the action values attached to the edges of the tree traverses the tree to select a leaf node.\n2.\u0026nbsp;\u0026nbsp; Expansion. On some iterations (depending on details of the application), the tree is expanded from the selected leaf node by adding one or more child nodes reached from the selected node via unexplored actions.\n3.\u0026nbsp;\u0026nbsp; Simulation. From the selected node, or from one of its newly-added child nodes (if any), simulation of a complete episode is run with actions selected by the rollout policy. The result is a Monte Carlo trial with actions selected first by the tree policy and beyond the tree by the rollout policy.\n4.\u0026nbsp;\u0026nbsp; Backup. The return generated by the simulated episode is backed up to update, or to initialize, the action values attached to the edges of the tree traversed by the tree policy in this iteration of MCTS. No values are saved for the states and actions visited by the rollout policy beyond the tree. Figure 8.13 illustrates this by showing a backup from the terminal state of the simulated trajectory directly to the state-action node in the tree where the rollout policy began (though in general, the entire return over the simulated trajectory is backed up to this state-action node).\nMCTS continues executing these four steps, starting each time at the tree\\A1\\AFs root node, until no more time is left, or some other computational resource is exhausted. Then, finally, an action from the root node (which still represents the current state of the environment) is selected according to some mechanism that depends on the accumulated statistics in the tree; for example, it may be an action having the largest action value of all the actions available from the root state, or perhaps the action with the largest visit count to avoid selecting outliers. This is the action MCTS actually selects. After the environment transitions to a new state, MCTS is run again, sometimes starting with a tree of a single root node representing the new state, but often starting with a tree containing any descendants of this node left over from the tree constructed by the previous execution of MCTS; all the remaining nodes are discarded, along with the action values associated with them.\nMCTS was first proposed to select moves in programs playing two-person compet\u0026shy;itive games, such as Go. For game playing, each simulated episode is one complete play of the game in which both players select actions by the tree and rollout poli\u0026shy;cies. Section 16.7 describes an extension of MCTS used in the AlphaGo program that combines the Monte Carlo evaluations of MCTS with action values learned by a deep ANN via self-play reinforcement learning.\n \n   H\\A3\\BA\n     Repeat while time remains\n \n   Simulation\n\nRollout\nPolicy\n        Backup\n\n        \u0026#8226; Selection\n\n        Tree\nPolicy\n        Expansion\n\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 8.13: Monte Carlo Tree Search. When the environment changes to a new state, MCTS executes as many iterations as possible before an action needs to be selected, incre\u0026shy;mentally building a tree whose root node represents the current state. Each iteration consists of the four operations Selection, Expansion (though possibly skipped on some iterations), Simulation, and Backup, as explained in the text and illustrated by the bold arrows in the trees.\nRelating MCTS to the reinforcement learning principles we describe in this book provides some insight into how it achieves such impressive results. At its base, MCTS is a decision-time planning algorithm based on Monte Carlo control applied to simulations that start from the root state; that is, it is a kind of rollout algorithm as described in the previous section. It therefore benefits from online, incremental, sample-based value estimation and policy improvement. Beyond this, it saves action- value estimates attached to the tree edges and updates them using reinforcement learning\\A1\\AFs sample backups. This has the effect of focusing the Monte Carlo trials on trajectories whose initial segments are common to high-return trajectories previously simulated. Further, by incrementally expanding the tree, MCTS effectively grows a lookup table to store a partial action-value function, with memory allocated to the estimated values of state-action pairs visited in the initial segments of high-yielding sample trajectories. MCTS thus avoids the problem of globally approximating an action-value function while it retrains the benefit of using past experience to guide exploration.\nThe striking success of decision-time planning by MCTS has deeply influenced artificial intelligence, and many researchers are studying modifications and extensions of the basic procedure for use in both games and single-agent applications.\n8.12\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nPlanning requires a model of the environment. A distribution model consists of the probabilities of next states and rewards for possible actions; a sample model produces single transitions and rewards generated according to these probabilities. Dynamic programming requires a distribution model because it uses full backups, which involve computing expectations over all the possible next states and rewards. A sample model, on the other hand, is what is needed to simulate interacting with the environment during which sample backups, like those used by many reinforcement learning algorithms, can be used. Sample models are generally much easier to obtain than distribution models.\nWe have presented a perspective emphasizing the surprisingly close relationships between planning optimal behavior and learning optimal behavior. Both involve estimating the same value functions, and in both cases it is natural to update the estimates incrementally, in a long series of small backup operations. This makes it straightforward to integrate learning and planning processes simply by allowing both to update the same estimated value function. In addition, any of the learning meth\u0026shy;ods can be converted into planning methods simply by applying them to simulated (model-generated) experience rather than to real experience. In this case learning and planning become even more similar; they are possibly identical algorithms op\u0026shy;erating on two different sources of experience.\nIt is straightforward to integrate incremental planning methods with acting and model-learning. Planning, acting, and model-learning interact in a circular fashion (Figure 8.1), each producing what the other needs to improve; no other interaction among them is either required or prohibited. The most natural approach is for all processes to proceed asynchronously and in parallel. If the processes must share computational resources, then the division can be handled almost arbitrarily\\A1\\AAby whatever organization is most convenient and efficient for the task at hand.\nIn this chapter we have touched upon a number of dimensions of variation among state-space planning methods. One dimension is the variation in the size of backups. The smaller the backups, the more incremental the planning methods can be. Among the smallest backups are one-step sample backups, as in Dyna. Another important dimension is the distribution of backups, that is, of the focus of search. Prioritized sweeping focuses backward on the predecessors of states whose values have recently changed. On-policy trajectory sampling focuses on states or state-action pairs that the agent is likely to encounter when controlling its environment. This can allow computation to skip over parts of the state space that are irrelevant to the predic\u0026shy;tion or control problem. Real-time dynamic programming, an on-policy trajectory sampling version of value iteration, illustrates some of the advantages this strategy has over conventional sweep-based policy iteration.\nPlanning can also focus forward from pertinent states, such as states actually encountered during an agent-environment interaction. The most important form of this is when planning is done at decision time, that is, as part of the action-selection process. Classical heuristic search as studied in artificial intelligence is an example of\nthis. Other examples are rollout algorithms and Monte Carlo Tree Search that benefit\nfrom online, incremental, sample-based value estimation and policy improvement.\nBibliographical and Historical Remarks\n8.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The overall view of planning and learning presented here has developed grad\u0026shy;ually over a number of years, in part by the authors (Sutton, 1990, 1991a, 1991b; Barto, Bradtke, and Singh, 1991, 1995; Sutton and Pinette, 1985; Sut\u0026shy;ton and Barto, 1981b); it has been strongly influenced by Agre and Chapman (1990; Agre 1988), Bertsekas and Tsitsiklis (1989), Singh (1993), and others. The authors were also strongly influenced by psychological studies of latent learning (Tolman, 1932) and by psychological views of the nature of thought (e.g., Galanter and Gerstenhaber, 1956; Craik, 1943; Campbell, 1960; Den\u0026shy;nett, 1978). In the Part III of the book, Section 14.6 relates model-based and model-free methods to psychological theories of learning and behavior, and Section 15.11 discusses ideas about how the brain might implement these types of methods.\n8.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The terms direct and indirect, which we use to describe different kinds of re\u0026shy;inforcement learning, are from the adaptive control literature (e.g., Goodwin and Sin, 1984), where they are used to make the same kind of distinction. The term system identification is used in adaptive control for what we call model-learning (e.g., Goodwin and Sin, 1984; Ljung and Soderstrom, 1983; Young, 1984). The Dyna architecture is due to Sutton (1990), and the results in this and the next section are based on results reported there. Barto and Singh (1991) consider some of the issues in comparing direct and indirect reinforcement learning methods.\n8.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; There have been several works with model-based reinforcement learning that take the idea of exploration bonuses and optimistic initialization to its logical extreme, in which all incompletely explored choices are assumed maximally rewarding and optimal paths are computed to test them. The E3algorithm of Kearns and Singh (2002) and the R-max algorithm of Brafman and Tennen- holtz (2003) are guaranteed to find a near-optimal solution in time polynomial in the number of states and actions. This is usually too slow for practical algorithms but is probably the best that can be done in the worst case.\n8.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Prioritized sweeping was developed simultaneously and independently by Moore and Atkeson (1993) and Peng and Williams (1993). The results in Figure 8.7 are due to Peng and Williams (1993). The results in Figure 8.8 are due to Moore and Atkeson.\n8.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; This section was strongly influenced by the experiments of Singh (1993).\n \n8.6\\A1\\AA7 Trajectory sampling has implicitly been a part of reinforcement learning from the outset, but it was most explicitly emphasized by Barto, Bradtke, and Singh (1995) in their introduction of RTDP. They recognized that Korf\\A1\\AFs (1990) learning real-time A* (LRTA*) algorithm is an asynchronous DP algorithm that applies to stochastic problems as well as the deterministic problems on which Korf focused. Beyond LRTA*, RTDP includes the option of backing up the values of many states in the time intervals between the execution of actions. Barto et al. (1995) proved the convergence result de\u0026shy;scribed here by combining Korf\\A1\\AFs (1990) convergence proof for LRTA* with the result of Bertsekas (1982) (also Bertsekas and Tsitsiklis, 1989) ensuring convergence of asynchronous DP for stochastic shortest path problems in the undiscounted case. Combining model-learning with RTDP is called Adaptive RTDP, also presented by Barto et al. (1995)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; and discussed by Barto (2011).\n8.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; For further reading on heuristic search, the\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; reader is encouraged to consult\ntexts and surveys such as those by Russell and Norvig (2009) and Korf (1988). Peng and Williams (1993) explored a forward focusing of backups much as is suggested in this section.\n8.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Abramson\\A1\\AFs (1990) expected-outcome model is a rollout algorithm applied\nto two-person games in which the play of\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; both simulated players is ran\u0026shy;\ndom. He argued that even with random play, it is a \\A1\\B0powerful heuristic\\A1\\B1 that is \\A1\\B0precise, accurate, easily estimable, efficiently calculable, and domain- independent.\\A1\\B1 Tesauro and Galperin (1997) demonstrated the effectiveness of rollout algorithms for improving the play of backgammon programs, adopting the term \\A1\\B0rollout\\A1\\B1 from its use in evaluating backgammon positions by play\u0026shy;ing out positions with different randomly generating sequences of dice rolls. Bertsekas, Tsitsiklis, and Wu (1997) examine rollout algorithms applied to combinatorial optimization problems, and Bertsekas (2013) surveys their use in discrete deterministic optimization problems, remarking that they are \\A1\\B0of\u0026shy;ten surprisingly effective.\\A1\\B1\n8.11\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The central ideas of MCTS were introduced by Coulom (2006) and by Koc- sis and Szepesvari (2006). They built upon previous research with Monte Carlo planning algorithms as reviewed by these authors. Browne, Powley, Whitehouse, Lucas, Cowling, Rohlfshagen, Tavener, Perez, Samothrakis, and Colton (2012) survey MCTS methods and their applications. This section was written with the essential help of David Silver.\nPart II: Approximate Solution Methods\nIn the second part of the book we extend the tabular methods presented in Part I to apply to problems with arbitrarily large state spaces. In many of the tasks to which we would like to apply reinforcement learning the state space is combinatorial and enormous; the number of possible camera images, for example, is much larger than the number of atoms in the universe. In such cases we cannot expect to find an optimal policy or the optimal value function even in the limit of infinite time and data; our goal instead is to find a good approximate solution using limited computational resources. In this part of the book we explore such approximate solution methods.\nThe problem with large state spaces is not just the memory needed for large tables, but the time and data needed to fill them accurately. In many of our target tasks, almost every state encountered will never have been seen before. To make sensible decisions in such states it is necessary to generalize from previous encounters with different states that are in some sense similar to the current one. In other words, the key issue is that of generalization. How can experience with a limited subset of the state space be usefully generalized to produce a good approximation over a much larger subset?\nFortunately, generalization from examples has already been extensively studied, and we do not need to invent totally new methods for use in reinforcement learning. To some extent we need only combine reinforcement learning methods with existing generalization methods. The kind of generalization we require is often called func\u0026shy;tion approximation because it takes examples from a desired function (e.g., a value function) and attempts to generalize from them to construct an approximation of the entire function. Function approximation is an instance of supervised learning, the primary topic studied in machine learning, artificial neural networks, pattern recog\u0026shy;nition, and statistical curve fitting. In theory, any of the methods studied in these fields can be used in the role of function approximator within reinforcement learning algorithms, although in practice some fit more easily into this role than others.\nNevertheless, reinforcement learning with function approximation involves a num\u0026shy;ber of new issues that do not normally arise in conventional supervised learning, such as nonstationarity, bootstrapping, and delayed targets. We introduce these and other issues successively over the five chapters of this part. Initially we restrict attention to on-policy training, treating in Chapter 9 the prediction case, in which the policy is given and only its value function is approximated, and then in Chapter 10 the control case, in which an approximation to the optimal policy is found. Chapter 11 covers off-policy methods. In each of these chapters we will have to return to first principles and re-examine the objectives of the learning to take into account function\napproximation. Chapter 12 introduces and analyzes the algorithmic mechanism of eligibility traces, which dramatically improves the computational properties of multi\u0026shy;step reinforcement learning methods in many cases. The final chapter of this part explores a different approach to control, policy-gradient methods, which approximate the optimal policy directly and need never form an approximate value function (al\u0026shy;though they may be much more efficient if they do approximate a value function as well).\n \n210\n \nChapter 9\nOn-policy Prediction with Approximation\nIn this chapter, we begin our study of function approximation in reinforcement learn\u0026shy;ing by considering its use in estimating the state-value function from on-policy data, that is, in approximating from experience generated using a known policy n. The novelty in this chapter is that the approximate value function is represented not as a table but as a parameterized functional form with weight vector w G Rd. We will write v(s,w) ^ Vn(s) for the approximated value of state s given weight vector w. For example, V might be a linear function in features of the state, with w the vector of feature weights. More generally, V might be the function computed by a multi-layer artificial neural network, with w the vector of connection weights in all the layers. By adjusting the weights, any of a wide range of different functions can be implemented by the network. Or V might be the function computed by a decision tree, where w is all the numbers defining the split points and leaf values of the tree. Typically, the number of weights (the dimensionality of w) is much less than the number of states (d\\A1\\B6|S|), and changing one weight changes the estimated value of many states. Consequently, when a single state is updated, the change generalizes from that state to affect the values of many other states. Such generalization makes the learning potentially more powerful but also potentially more difficult to manage and understand.\n9.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Value-function Approximation\nAll of the prediction methods covered in this book have been described as backups, that is, as updates to an estimated value function that shift its value at particular states toward a \\A1\\B0backed-up value\\A1\\B1 for that state. Let us refer to an individual backup by the notation s ^ g, where s is the state backed up and g is the backed-up value, or target, that s\\A1\\AFs estimated value is shifted toward. For example, the Monte Carlo backup for value prediction is St ^ Gt, the TD(0) backup is St ^ Rt+i+T^(St+i,wt), and the n-step TD backup is St ^ Gt:t+n. In the DP (dynamic programming) policy-evaluation backup, s ^ En[Rt+i + Y\u0026amp;(St+i,wt) | St = s], an arbitrary state s is backed up, whereas in the other cases the state encountered in actual experience, St, is backed up.\nIt is natural to interpret each backup as specifying an example of the desired input-output behavior of the value function. In a sense, the backup s ^ g means that the estimated value for state s should be more like the number g. Up to now, the actual update implementing the backup has been trivial: the table entry for s\\A1\\AFs estimated value has simply been shifted a fraction of the way toward g, and the estimated values of all other states were left unchanged. Now we permit arbitrarily complex and sophisticated methods to implement the backup, and updating at s generalizes so that the estimated values of many other states are changed as well. Machine learning methods that learn to mimic input-output examples in this way are called supervised learning methods, and when the outputs are numbers, like g, the process is often called function approximation. Function approximation methods expect to receive examples of the desired input-output behavior of the function they are trying to approximate. We use these methods for value prediction simply by passing to them the s ^ g of each backup as a training example. We then interpret the approximate function they produce as an estimated value function.\nViewing each backup as a conventional training example in this way enables us to use any of a wide range of existing function approximation methods for value pre\u0026shy;diction. In principle, we can use any method for supervised learning from examples, including artificial neural networks, decision trees, and various kinds of multivariate regression. However, not all function approximation methods are equally well suited for use in reinforcement learning. The most sophisticated neural network and statis\u0026shy;tical methods all assume a static training set over which multiple passes are made. In reinforcement learning, however, it is important that learning be able to occur on\u0026shy;line, while interacting with the environment or with a model of the environment. To do this requires methods that are able to learn efficiently from incrementally acquired data. In addition, reinforcement learning generally requires function approximation methods able to handle nonstationary target functions (target functions that change over time). For example, in control methods based on GPI (generalized policy itera\u0026shy;tion) we often seek to learn q^ while n changes. Even if the policy remains the same, the target values of training examples are nonstationary if they are generated by bootstrapping methods (DP and TD learning). Methods that cannot easily handle such nonstationarity are less suitable for reinforcement learning.\n9.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Prediction Objective (MSVE)\nUp to now we have not specified an explicit objective for prediction. In the tabular case a continuous measure of prediction quality was not necessary because the learned value function could come to equal the true value function exactly. Moreover, the learned values at each state were decoupled\\A1\\AAan update at one state affected no other. But with genuine approximation, an update at one state affects many others, and it is not possible to get all states exactly correct. By assumption we have far \n \nmore states than weights, so making one state\\A1\\AFs estimate more accurate invariably means making others\\A1\\AF less accurate. We are obligated then to say which states we care most about. We must specify a weighting or distribution ^(s) \u0026gt; 0 representing how much we care about the error in each state s. By the error in a state s we mean the square of the difference between the approximate value v(s,w) and the true value vn(s). Weighting this over the state space by the distribution \u0026quot;\\A3\\ACwe obtain a natural objective function, the Mean Squared Value Error, or MSVE:\n^~^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\B812\nMSVE(w)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^^(s) vn(s) \\A1\\AA {)(s,w)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.1)\nThe square root of this measure, the root MSVE or RMSVE, gives a rough measure of how much the approximate values differ from the true values and is often used in plots. Typically one chooses ^(s) to be the fraction of time spent in s under the target policy n. This is called the on-policy distribution; we focus entirely on this case in this chapter. In continuing tasks, the on-policy distribution is the stationary distribution under n.\nThe on-policy distribution in episodic tasks\nIn an episodic task, the on-policy distribution is a little different in that it is not really a distribution and depends on how the initial states of episodes are chosen. Let h(s) denote the probability that an episode begins in each state s, and let the \\A1\\B0distribution\\A1\\B1 ^(s) denote the number of time steps spent, on average, in state s in a single episode. Time is spent in a state s if episodes start in it, or if transitions are made into it from a state s in which time is spent:\n\u0026quot;(s) = h(s) + ^ \u0026quot;(s) E n(a|s)p(s|s, a), Vs G S.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.2)\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\nThis system of equations can be solved for the expected number of visits \u0026quot;(s).\nThe two cases, continuing and episodic, behave similarly, but with approximation they must be treated separately in formal analyses, as we will see repeatedly in this part of the book. This completes the specification of the learning objective.\nIt is not completely clear that the MSVE is the right performance objective for reinforcement learning.[15]Remember that our ultimate purpose, the reason we are learning a value function, is to use it in finding a better policy. The best value func\u0026shy;tion for this purpose is not necessarily the best for minimizing MSVE. Nevertheless, it is not yet clear what a more useful alternative goal for value prediction might be. For now, we will focus on MSVE.\nAn ideal goal in terms of MSVE would be to find a global optimum, a weight vector w* for which MSVE(w*) \u0026lt; MSVE(w) for all possible w. Reaching this goal is some\u0026shy;times possible for simple function approximators such as linear ones, but is rarely possible for complex function approximators such as artificial neural networks and decision trees. Short of this, complex function approximators may seek to converge instead to a local optimum, a weight vector w* for which MSVE(w*) \u0026lt; MSVE(w) for all w in some neighborhood of w*. Although this guarantee is only slightly reassur\u0026shy;ing, it is typically the best that can be said for nonlinear function approximators, and often it is enough. Still, for many cases of interest in reinforcement learning there is no guaranteed of convergence to an optimum, or even to within a bounded distance of an optimum. Some methods may in fact diverge, with their MSVE approaching infinity in the limit.\nIn the last two sections we have outlined a framework for combining a wide range of reinforcement learning methods for value prediction with a wide range of function approximation methods, using the backups of the former to generate training ex\u0026shy;amples for the latter. We have also described a MSVE performance measure which these methods may aspire to minimize. The range of possible function approxima\u0026shy;tion methods is far too large to cover all, and anyway too little is known about most of them to make a reliable evaluation or recommendation. Of necessity, we consider only a few possibilities. In the rest of this chapter we focus on function approximation methods based on gradient principles, and on linear gradient-descent methods in particular. We focus on these methods in part because we consider them to be particularly promising and because they reveal key theoretical issues, but also because they are simple and our space is limited.\n9.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Stochastic-gradient and Semi-gradient Methods\nWe now develop in detail one class of learning methods for function approximation in value prediction, those based on stochastic gradient descent (SGD). SGD methods are among the most widely used of all function approximation methods and are particularly well suited to online reinforcement learning.\nIn gradient-descent methods, the weight vector is a column vector with a fixed number of real valued components, w == (wi, W2,...,w^)T,[16]and the approximate value function V(s,w) is a differentiable function of w for all s G S. We will be updating w at each of a series of discrete time steps, t = 0,1, 2, 3,..., so we will need a notation wt for the weight vector at each step. For now, let us assume that, on each step, we observe a new example St ^ Vn (St) consisting of a (possibly randomly selected) state St and its true value under the policy. These states might be successive states from an interaction with the environment, but for now we do not assume so. Even though we are given the exact, correct values, Vn(St) for each St, there is still a difficult problem because our function approximator has limited resources and thuslimited resolution. In particular, there is generally no w that gets all the states, or even all the examples, exactly correct. In addition, we must generalize to all the other states that have not appeared in examples.\nWe assume that states appear in examples with the same distribution, \u0026quot;, over which we are trying to minimize the MSVE as given by (9.1). A good strategy in this case is to try to minimize error on the observed examples. Stochastic gradient- descent (SGD) methods do this by adjusting the weight vector after each example by a small amount in the direction that would most reduce the error on that example:\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z 1r\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 12\nwtʮ1= wt - 2aVn(St) - v(St,wt)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.3)\n   Wt + a\n     Vn(St) - V(St,wt) VV(St,wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.4)\nwhere a is a positive step-size parameter, and Vf (w), for any scalar expression f (w), denotes the vector of partial derivatives with respect to the components of the weight vector:\n(w)\u0026#8226; ( df (w) df (w)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; df (w)\\T\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; f(w)^.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9)\nThis derivative vector is the gradient of f with respect to w. SGD methods are \\A1\\B0gradient descent\\A1\\B1 methods because the overall step in wt is proportional to the negative gradient of the example\\A1\\AFs squared error (9.3). This is the direction in which the error falls most rapidly. Gradient descent methods are called \\A1\\B0stochastic\\A1\\B1 when the update is done, as here, on only a single example, which might have been selected stochastically. Over many examples, making small steps, the overall effect is to minimize an average performance measure such as the MSVE.\nIt may not be immediately apparent why SGD takes only a small step in the direction of the gradient. Could we not move all the way in this direction and completely eliminate the error on the example? In many cases this could be done, but usually it is not desirable. Remember that we do not seek or expect to find a value function that has zero error for all states, but only an approximation that balances the errors in different states. If we completely corrected each example in one step, then we would not find such a balance. In fact, the convergence results for SGD methods assume that a decreases over time. If it decreases in such a way as to satisfy the standard stochastic approximation conditions (2.7), then the SGD method (9.4) is guaranteed to converge to a local optimum.\nWe turn now to the case in which the target output, here denoted Ut G R, of the tth training example, St ^ Ut, is not the true value, Vn(St), but some, possibly random, approximation to it. For example, Ut might be a noise-corrupted version of Vn(St), or it might be one of the bootstrapping targets using V mentioned in the previous section. In these cases we cannot perform the exact update (9.4) because Vn(St) is unknown, but we can approximate it by substituting Ut in place of Vn(St). This yields the following general SGD method for state-value prediction:\n   wt+1= wt + a\n     Ut - V(St,wt) VV(St,wt).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.6)\nGradient Monte Carlo Algorithm for Estimating v \\B0\\D1v^\nInput: the policy n to be evaluated\nInput: a differentiable function v : S x Rd\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; R\nInitialize value-function weights w as appropriate (e.g., w = 0) Repeat forever:\nGenerate an episode So, Ao, Ri, Si, Ai,..., Rt, St using n For t = 0,1,..., T \\A1\\AA 1:\nw t w + a [Gt \\A1\\AA v(St,w)] W(St,w)\nIf Ut is an unbiased estimate, that is, if E[Ut] = v^ (St), for each t, then wt is guaranteed to converge to a local optimum under the usual stochastic approximation conditions (2.7) for decreasing a.\nFor example, suppose the states in the examples are the states generated by in\u0026shy;teraction (or simulated interaction) with the environment using policy n. Because the true value of a state is the expected value of the return following it, the Monte Carlo target Ut == Gt is by definition an unbiased estimate of v^(St). With this choice, the general SGD method (9.6) converges to a locally optimal approximation to vn(St). Thus, the gradient-descent version of Monte Carlo state-value prediction is guaranteed to find a locally optimal solution. Pseudocode for a complete algorithm is shown in the box.\nOne does not obtain the same guarantees if a bootstrapping estimate of v^ (St) is used as the target Ut in (9.6). Bootstrapping targets such as n-step returns Gt\\A3\\BAt+n or the DP target Eas,r n(a|St)p(s;, r|St, a)[r + 7v(s;,wt)] all depend on the current value of the weight vector wt, which implies that they will be biased and that they will not produce a true gradient-descent method. One way to look at this is that the key step from (9.3) to (9.4) relies on the target being independent of wt. This step would not be valid if a bootstrapping estimate was used in place of v^(St). Bootstrapping methods are not in fact instances of true gradient descent (Barnard, 1993). They take into account the effect of changing the weight vector wt on the estimate, but ignore its effect on the target. They include only a part of the gradient and, accordingly, we call them semi-gradient methods.\nAlthough semi-gradient (bootstrapping) methods do not converge as robustly as gradient methods, they do converge reliably in important cases such as the linear case discussed in the next section. Moreover, they offer important advantages which makes them often clearly preferred. One reason for this is that they are typically significantly faster to learn, as we have seen in Chapters 6and 7. Another is that they enable learning to be continual and online, without waiting for the end of an episode. This enables them to be used on continuing problems and provides computational advantages. A prototypical semi-gradient method is semi-gradient TD(0), which uses Ut == Rt+i + Yv(St+i,w) as its target. Complete pseudocode for this method is given in the box below.\nSemi-gradient TD(0) for estimating V Vn\nInput: the policy n to be evaluated\nInput: a differentiable function V : S+ x Rd R such that V(terminal,-) = 0\nInitialize value-function weights w arbitrarily (e.g., w = 0)\nRepeat (for each episode):\nInitialize S\nRepeat (for each step of episode):\nChoose A \u0026#12316;n(-|S)\nTake action A, observe R, S' w w + a [R + yv(S;,w) \\A1\\AA V(S,w) Vf)(S,w)\nS \\A1\\AA S; until Sf is terminal\nExample 9.1: State Aggregation on the 1000-state Random Walk State aggregationis a simple form of generalizing function approximation in which states are grouped together, with one estimated value (one component of the weight vector w) for each group. The value of a state is estimated as its group\\A1\\AFs component, and when the state is updated, that component alone is updated. State aggregation is a special case of SGD (9.6) in which the gradient, VV(St,wt), is 1 for St\\A1\\AFs group\\A1\\AFs component and 0for the other components.\nConsider a 1000-state version of the random walk task (Examples 6.2 and 7.1). The states are numbered from 1 to 1000, left to right, and all episodes begin near the center, in state 500. State transitions are from the current state to one of the 100 neighboring states to its left, or to one of the 100neighboring states to its right, all with equal probability. Of course, if the current state is near an edge, then there may be fewer than 100 neighbors on that side of it. In this case, all the probability that would have gone into those missing neighbors goes into the probability of terminating on that side (thus, state 1 has a 0.5 chance of terminating on the left, and state 950 has a 0.25 chance of terminating on the right). As usual, termination on the left produces a reward of \\A1\\AA1, and termination on the right produces a reward of +1. All other transitions have a reward of zero. We use this task as a running example throughout this section.\nFigure 9.1 shows the true value function Vn for this task. It is nearly a straight line, but tilted slightly toward the horizontal and curving further in this direction for the last 100states at each end. Also shown is the final approximate value function learned by the gradient Monte-Carlo algorithm with state aggregation after 100,000 episodes with a step size of a = 2 x 10-5. For the state aggregation, the 1000 states were partitioned into 10groups of 100states each (i.e., states 1-100were one group, states 101-200 were another, and so on). The staircase effect shown in the figure is typical of state aggregation; within each group, the approximate value is constant, and it changes abruptly from one group to the next. These approximate values are\n \nTrue ____ ^\n   0.0137\n     value Vr-\n \n   1000\n        Distribution\nscale\n        0.0017\n0\n        State\n        Approximate MC value vj\n        Value\nscale\n        0\n        Figure 9.1: Function approximation by state aggregation on the 1000-state random walk task, using the gradient Monte Carlo algorithm (page 216).\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n close to the global minimum of the MSVE (9.1).\nSome of the details of the approximate values are best appreciated by reference to the state distribution \u0026quot; for this task, shown in the lower portion of the figure with a right-side scale. State 500, in the center, is the first state of every episode, but it is rarely visited again. On average, about 1.37% of the time steps are spent in the start state. The states reachable in one step from the start state are the second most visited, with about 0.17% of the time steps being spent in each of them. From there \u0026quot; falls off almost linearly, reaching about 0.0147% at the extreme states 1 and 1000. The most visible effect of the distribution is on the leftmost groups, whose values are clearly shifted higher than the unweighted average of the true values of states within the group, and on the rightmost groups, whose values are clearly shifted lower. This is due to the states in these areas having the greatest asymmetry in their weightings by \\B2\\B7For example, in the leftmost group, state 99 is weighted more than 3 times more strongly than state 0. Thus the estimate for the group is biased toward the true value of state 99, which is higher than the true value of state 0.\n9.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Linear Methods\nOne of the most important special cases of function approximation is that in which the approximate function, V(-,w),is a linear function of the weight vector, w. Corresponding to every state s, there is a real-valued vector of features x(s)== (xi(s), X2(s),...,Xd(s))T, with the same number of components as w. The features may be constructed from the states in many different ways; we cover a few possi\u0026shy;bilities in the next sections. However the features are constructed, the approximatestate-value function is given by the inner product between w and x(s)\nd\n   (9.7)\n     {)(s,w) == wTx(s)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^ WjXj(s).\nIn this case the approximate value function is said to be linear in the weights, or simply linear. The individual functions Xi : S R are called basis functions because they form a linear basis for the set of approximate functions of this form. Construct\u0026shy;ing n-dimensional feature vectors to represent states is the same as selecting a set of n basis functions.\nIt is natural to use SGD updates with linear function approximation. The gradient of the approximate value function with respect to w in this case is\nV\u0026nbsp;\u0026nbsp; 0(s,w) = x(s).\nThus, the general SGD update (9.6) reduces to a particularly simple form in the linear case.\nBecause it is so simple, the linear SGD case is one of the most favorable for mathematical analysis. Almost all useful convergence results for learning systems of all kinds are for linear (or simpler) function approximation methods.\nIn particular, in the linear case there is only one optimum (or, in degenerate cases, one set of equally good optima), and thus any method that is guaranteed to converge to or near a local optimum is automatically guaranteed to converge to or near the global optimum. For example, the gradient Monte Carlo algorithm presented in the previous section converges to the global optimum of the MSVE under linear function approximation if a is reduced over time according to the usual conditions.\nThe semi-gradient TD(0) algorithm presented in the previous section also con\u0026shy;verges under linear function approximation, but this does not follow from general results on SGD; a separate theorem is necessary. The weight vector converged to is also not the global optimum, but rather a point near the local optimum. It is useful to consider this important case in more detail, specifically for the continuing case. The update at each time t is\nwt+i ==\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.8)\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nwhere here we have used the notational shorthand xt = x(St). Once the system has reached steady state, for any given wt, the expected next weight vector can be written\n   (9.9)\n        where\n     E[wt+i|wt] = wt + a(b \\A1\\AA Awt),\nb == E[Rt+ixt] G Rdand A == E xt(xt \\A1\\AA ^xt+i)T G Rdx Rd\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.10)\nFrom (9.9) it is clear that, if the system converges, it must converge to the weight vector wtd at which\nb \\A1\\AA Awtd = 0\n   (9.11)\n     b = Awtd A-ib.\nwTD\nThis quantity is called the TD fixedpoint. In fact linear semi-gradient TD(0) con\u0026shy;verges to this point. Some of the theory proving its convergence, and the existence of the inverse above, is given in the box.\nProof of Convergence of Linear TD(0)\nWhat properties assure convergence of the linear TD(0) algorithm (9.8)? Some insight can be gained by rewriting (9.9) as\n   (9.12)\n     E[wt+i|wt] = (I \\A1\\AA aA)wt + ab.\nNote that the matrix A multiplies the weight vector wt and not b; only A is important to convergence. To develop intuition, consider the special case in which A is a diagonal matrix. If any of the diagonal elements are negative, then the corresponding diagonal element of I \\A1\\AA aA will be greater than one, and the corresponding component of wt will be amplified, which will lead to divergence if continued. On the other hand, if the diagonal elements of A are all positive, then a can be chosen smaller than one over the largest of them, such that I \\A1\\AA aA is diagonal with all diagonal elements between 0 and 1. In this case the first term of the update tends to shrink wt, and stability is assured. In general case, wt will be reduced toward zero whenever A is positive definite, meaning yTAy \u0026gt; 0 for real vector y. Positive definiteness also ensures that the inverse A-iexists.\nFor linear TD(0), in the continuing case with 7\u0026lt; 1, the A matrix (9.10) can be written\n\n\n\u0026nbsp;SHAPE \u0026nbsp;\\* MERGEFORMAT    \u0026nbsp;\n      \u0026nbsp;\n \n   A\n     J2\u0026quot;(s)Ylأ(a|s)Ep(r\\A3\\ACs/|s,a)x(s)(x(s)\\A1\\AA7x(s\\A3\\BB))\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; r, s!\n^\u0026quot;(s)^p(s/|s)x(s)(x(s) \\A1\\AAYx(s/))T\n   T\n     s\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; sf\n[\u0026quot;(s)x(s^x(s) \\A1\\AAY [ P(s/|s)x(s/)\ns1\nXtD(I \\A1\\AA Y P)X,\n \n\u0026nbsp;\n \n   the probability matrix of these on its diagonal,\n     where \u0026quot;(s) is the stationary distribution under n, p(s/|s) is of transition from s to s/under policy n, P is the |S| x |S| probabilities, D is the |S| x |S| diagonal matrix with the \u0026quot;(s)\nand X is the |S| x d matrix with x(s) as its rows. From here it is clear that\nthe inner matrix D(I - yP) is key to determining the positive definiteness of A.\nFor a key matrix of this type, positive definiteness is assured if all of its columns sum to a nonnegative number. This was shown by Sutton (1988, p. 27) based on two previously established theorems. One theorem says that any matrix M is positive definite if and only if the symmetric matrix S = M + MTis positive definite (Sutton 1988, appendix). The second theorem says that any symmetric real matrix S is positive definite if all of its diagonal entries are positive and greater than the sum of the corresponding off-diagonal entries (Varga 1962, p. 23). For our key matrix, D(I - 7P), the diagonal entries are positive and the off-diagonal entries are negative, so all we have to show is that each row sum plus the corresponding column sum is positive. The row sums are all positive because P is a stochastic matrix and 7\u0026lt; 1. Thus it only remains to show that the column sums are nonnegative. Note that the row vector of the column sums of any matrix M can be written as 1TM, where 1 is the column vector with all components equal to 1. Let fx denote the |S|-vector of the \u0026quot;(s), where x = PTX by virtue of \u0026quot; being the stationary distribution. The column sums of our key matrix, then, are:\n1tD(I - 7P) = xT(I - 7P)\n=XT- 7XTP\n=xT- 7XT\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (because x is the stationary distribution)\n=(1-7)M,\nall components of which are positive. Thus, the key matrix and its A matrix are positive definite, and on-policy TD(0) is stable. (Additional conditions and a schedule for reducing a over time are needed to prove convergence with probability one.)\nAt the TD fixedpoint, it has also been proven (in the continuing case) that the MSVE is within a bounded expansion of the lowest possible error:\nMSVE(wTD) ^ -^minMSVE(w).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.13)\n[1]- 7w\nThat is, the asymptotic error of the TD method is no more than times the small\u0026shy;est possible error, that attained in the limit by the Monte Carlo method. Because 7is often near one, this expansion factor can be quite large, so there is substantial potential loss in asymptotic performance with the TD method. On the other hand, recall that the TD methods are often of vastly reduced variance compared to Monte Carlo methods, and thus faster, as we saw in Chapters 6and 7. Which method will be best depends on the nature of the approximation and problem, and on how long learning contiunues.\nA bound analogous to (9.13) applies to other on-policy bootstrapping methods as well. For example, linear semi-gradient DP (Eq. 9.6 with Ut == Ea n(aJSt) Es, r\np(s;, r|St, a)[r + T^s'w^)]) with backups according to the on-policy distribution will also converge to the TD fixedpoint. One-step semi-gradient action-valuemethods, such as semi-gradient Sarsa(0) covered in the next chapter converge to an analogous fixedpoint and an analogous bound. For episodic tasks, there is a slightly different but related bound (see Bertsekas and Tsitsiklis, 1996). There are also a few technical conditions on the rewards, features, and decrease in the step-size parameter, which we have omitted here. The full details can be found in the original paper (Tsitsiklis and Van Roy, 1997).\nCritical to the these convergence results is that states are backed up according to the on-policy distribution. For other backup distributions, bootstrapping methods using function approximation may actually diverge to infinity. Examples of this and a discussion of possible solution methods are given in Chapter 11.\nExample 9.2: Bootstrapping on the 1000-state Random Walk State aggre\u0026shy;gation is a special case of linear function approximation, so let's return to the 1000- state random walk to illustrate some of the observations made in this chapter. The left panel of Figure 9.2 shows the final value function learned by the semi-gradient TD(0) algorithm (page 217) using the same state aggregation as in Example 9.1. We see that the near-asymptotic TD approximation is indeed farther from the true values than the Monte Carlo approximation shown in Figure 9.1.\nNevertheless, TD methods retain large potential advantages in learning rate, and generalize MC methods, as we investigated fully with the multi-step TD methods of Chapter 7. The right panel of Figure 9.2 shows results with an n-step semi\u0026shy;gradient TD method using state aggregation and the 1000-state random walk that are strikingly similar to those we obtained earlier with tabular methods and the 19-state random walk. To obtain such quantitatively similar results we switched the state aggregation to 20 groups of 50 states each. The 20 groups are then quantitatively close to the 19 states of the tabular problem. In particular, the state transitionsof at-most 100 states to the right or left, or 50 states on average, were quantitively analogous to the single-state state transitions of the tabular system. To complete the match, we use here the same performance measure\\A1\\AAan unweighted average of the RMS error over all states and over the first 10 episodes\\A1\\AArather than a MSVE objective as is otherwise more appropriate when using function approximation.\nThe semi-gradient n-step TD algorithm we used in this example is the natural extension of the tabular n-step TD algorithm presented in Chapter 7 to semi-gradient function approximation. The key equation, analogous to (7.2), is\nwt+n = wt+n-i + a [Gt\\A3\\BAt+n \\A1\\AA v(St,wt+ra-i)] W(St,wt+ra-i),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0\u0026lt; t \u0026lt; T, (9.14)\nwhere the n-step return is generalized from (7.1) to\nGt:t+n = Rt+i + YRt+2+ \\A1\\F6 \\A1\\F6 \\A1\\F6 + Yn iRt+n + YnV(St+n,wt+n-i),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0\u0026nbsp;\u0026nbsp; \u0026lt;\u0026nbsp;\u0026nbsp;\u0026nbsp; t\u0026nbsp; \u0026lt;\u0026nbsp;\u0026nbsp; T\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\AA\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.15)\nPseudocode for the complete algorithm is given in the box below.\nn-step semi-gradient TD for estimating v \\B0\\D1v^\nInput: the policy n to be evaluated\nInput: a differentiable function v : S+ x RdR such that v(terminal,-) = 0\nParameters: step size a G (0,1], a positive integer n\nAll store and access operations (St and Rt) can take their index mod n\nInitialize value-function weights w arbitrarily (e.g., w = 0)\nRepeat (for each episode):\nInitialize and store So = terminal T ^\nFor t = 0,1, 2,...:\n| If t \u0026lt; T, then:\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Take an action according to n(-|St)\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Observe and store the next reward as Rt+i and the next state as St+i\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If St+i is terminal, then T \\A1\\AA t + 1\n|\u0026nbsp; t \\A1\\AA t \\A1\\AA n + 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (t is the time whose state\\A1\\AFs estimate is being updated)\n|\u0026nbsp; If t \u0026gt; 0:\ni\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; g\\A1\\AAyi-T-iRi\n| If t + n \u0026lt; T,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; then: G \\A1\\AA G + Ynv(Sr+n,w)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (Gr\\A3\\BAr+n)\n| w \\A1\\AA w + a [G \\A1\\AA v(Sr,w)] W(Sr,w)\nUntil t = T \\A1\\AA 1\n \n9.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Feature Construction for Linear Methods\nLinear methods are interesting because of their convergence guarantees, but also because in practice they can be very efficient in terms of both data and computation. Whether or not this is so depends critically on how the states are represented in terms of the features, which we investigate in this large section. Choosing features appropriate to the task is an important way of adding prior domain knowledge to reinforcement learning systems. Intuitively, the features should correspond to the natural features of the task, those along which generalization is most appropriate. If we are valuing geometric objects, for example, we might want to have features for each possible shape, color, size, or function. If we are valuing states of a mobile robot, then we might want to have features for locations, degrees of remaining battery power, recent sonar readings, and so on.\nIn general, we also need features for combinations of these natural qualities. This is because the linear form prohibits the representation of interactions between features, such as the presence of feature i being good only in the absence of feature j. For example, in the pole-balancing task (Example 3.4), a high angular velocity may be either good or bad depending on the angular position. If the angle is high, then high angular velocity means an imminent danger of falling\\A1\\AAa bad state\\A1\\AAwhereas if the angle is low, then high angular velocity means the pole is righting itself\\A1\\AAa good state. In cases with such interactions one needs to introduce features for combinations of feature values when using linear function approximation methods. In the following subsections we consider a variety of general ways of doing this.\n9.5.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Polynomials\nFor multi-dimensional continuous state spaces, function approximation for reinforce\u0026shy;ment learning has much in common with the familiar tasks of interpolation and regression, which aim to define functions between and/or beyond given samples of function values. Various families of polynomials commonly used for these tasks can also be used in reinforcement learning. Here we discuss only the most basic polyno\u0026shy;mial family.\nSuppose a reinforcement learning problem\\A1\\AFs state space is two-dimensional so that each state is a real vector s = (si,s2)T. You might choose to represent each s with the feature vector (1, si, s2, sis2)Tin order to take the interaction of the state variables into account by weighting the product sis2in an appropriate way. Or you might choose to use feature vectors like (1, si, s2, sis2, s2, s2, sys2, sis2, s2s2)Tto take more complex interactions into account. Using these features means that functions are approximated as multi-dimensional quadratic functions\\A1\\AAeven though the approximation is still linear in the weights that have to be learned.\nThese example feature vectors are the result of selecting sets of polynomial basis functions, which are defined for any dimension and can encompass highly-complex interactions among the state variables:\nFor d state variables taking real values, every state s is a d-dimensional vec\u0026shy;tor (si, s2,..., sd)Tof real numbers. Each d-dimensional polynomial basis function Xi can be written as\nXi(s) = nd=isCi'j,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.16)\nwhere each Ci,j is an integer in the set {0,1,\\A1\\AD\\A3\\ACN} for an integer N \u0026gt; 0. These functions make up the order-N polynomial basis, which contains (N + 1)ddifferent functions.\nHigher-order polynomial bases allow for more accurate approximations of more complicated functions. But because the number of functions in an order-N poly\u0026shy;nomial basis grows exponentially with the state space dimension (for N \u0026gt; 0), it is generally necessary to select a subset of them for function approximation. This can be done using prior beliefs about the nature of the function to be approximated, and some automated selection methods developed for polynomial regression can be adapted to deal with the incremental and nonstationary nature of reinforcement learning.\nExercise 9.1 Why does (9.16) define (N + 1)d distinct functions for dimension d? \\A1\\F5\nExercise 9.2 Give N and the Ci,j defining the basis functions that produce feature vectors (1, si, s2, sis2, sg, s2, sis2, sis2, s2s2)T.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n9.5.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Fourier Basis\nAnother linear function approximation method is based on the time-honored Fourier series, which expresses periodic functions as a weighted sum of sine and cosine basis functions of different frequencies. (A function f is periodic if f (x) = f (x + T) for all x and some period T.) The Fourier series and the more general Fourier transform are widely used in applied sciences because\\A1\\AAamong many other reasons\\A1\\AAif a function to be approximated is known, then the basis function weights are given by simple formulae and, further, with enough basis functions essentially any function can be approximated as accurately as desired. In reinforcement learning, where the functions to be approximated are unknown, Fourier basis functions are of interest because they are easy to use and can perform well in a range of reinforcement learning problems. Konidaris, Osentoski, and Thomas (2011) presented the Fourier basis in a simple form suitable for reinforcement learning problems with multi-dimensional continuous state spaces and functions that do not have to be periodic.\nFirst consider the one-dimensional case. The usual Fourier series representation of a function of one dimension having period T represents the function as a linear com\u0026shy;bination of sine and cosine functions that are each periodic with periods that evenly divide T (in other words, whose frequencies are integer multiples of a fundamental frequency 1/T). But if you are interested in approximating an aperiodic function defined over a bounded interval, you can use these Fourier basis functions with Tset to the length the interval. The function of interest is then just one period of the periodic linear combination of the sine and cosine basis functions.\nFurthermore, if you set T to twice the length of the interval of interest and restrict attention to the approximation over the half interval [0,T/2], you can use just the cosine basis functions. This is possible because you can represent any even function, that is, any function that is symmetric about the origin, with just the cosine basis functions. So any function over the half-period [0, T/2] can be approximated as closely as desired with enough cosine basis functions. (Saying \\A1\\B0any function\\A1\\B1 is not exactly correct because the function has to be mathematically well-behaved, but we skip this technicality here.) Alternatively, it is possible to use just the sine basis functions, linear combinations of which are always odd functions, that is functions that are anti-symmetric about the origin. But it is generally better to keep just the cosine basis functions because \\A1\\B0half-even\\A1\\B1 functions tend to be easier to approximate than \\A1\\B0half-odd\\A1\\B1 functions since the latter are often discontinuous at the origin.\nFollowing this logic and letting T = 2 so that the functions are defined over the half-T interval [0,1], the one-dimensional order-N Fourier cosine basis consists of the N + 1 functions\nXi(s) = cos(ins), s G [0,1],\n   Figure 9.3: One-dimensional Fourier cosine basis functions\u0026nbsp;\u0026nbsp; i = 1, 2, 3, 4, for approximat\u0026shy;\ning functions over the interval [0,1]; xo is a constant function. After Konidaris et al. (2011).\nThis same reasoning applies to the Fourier cosine series approximation in the multi-dimensional case as described in the box at the top of the next page. As an example, consider the d= 2case in which s = (si,s2), where each ci = (ci, c2)T. Figure 9.4 shows a selection of six Fourier cosine basis functions, each labeled by the vector ci that defines it (si is the horizontal axis and ci is shown as a row vector with the index i omitted). Any zero in c means the function is constant along that dimension. So if c = (0, 0), the function is constant over both dimensions; if c = (ci, 0) the function is constant over the second dimension and varies over the first with frequency depending on ci; and similarly, for c = (0, c2). When c = (ci, c2) with neither cj = 0, the basis function varies along both dimensions and represents an interaction between the two state variables. The values of ci and c2determine the frequency along each dimension, and their ratio gives the direction of the interaction.\n     for i = 0,\\A1\\AD\\A3\\ACN. Figure 9.3 shows one-dimensional Fourier cosine basis functions Xi, for i = 1, 2, 3, 4; xo is a constant function.\nFor a state space that is the d-dimensional unit hypercube with the origin in one corner, states are real vectors s = (si\\A3\\AC\\A1\\AD\\A3\\ACs^)T, s^ G [0,1]. Each function in the order-N Fourier cosine basis can be written\nXi(s) = cos(nci \\A1\\F6 s),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.17)\nwhere \u0026amp; = (ci,..., cld)T, with cj G {0,..., N} for j = =1,\\A1\\AD\\A3\\ACd and i = 0,..., (N + 1)d. This defines a function for each of the (N + 1)d possible integer vectors cl. The dot-product c% \\A1\\F6 s has the effect of assigning an in\u0026shy;teger in {0,\\A1\\AD\\A3\\ACN} to each dimension. As in the one-dimensional case, this integer determines the function\\A1\\AFs frequency along that dimension. The basis functions can of course be shifted and scaled to suit the bounded state space of a particular application.\nKonidaris et al. (2011) found that when using Fourier cosine basis functions with a learning algorithm such as (9.6), semi-gradient TD(0), or semi-gradient Sarsa, it is helpful to use a different step-size parameter for each basis function. If a is the basic step-size parameter, they suggest setting the step-size parameter for basis function\n\\B6\\F8to a\u0026lt; = a/y^(ci)2+ ... + (c^)2(except when each cj =0, in which case a\u0026lt; = a).\n   \nFigure 9.4: A selection of six two-dimensional Fourier cosine basis functions, each labeled by the vector clthat defines it (s\\A3\\BBi is the horizontal axis, and clis shown as a row vector with the index i omitted). After Konidaris et al. (2011).\n     Fourier cosine basis functions with Sarsa were found to produce good performance compared to several other collections of basis functions, including polynomial and\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\nradial basis functions, on several reinforcement learning tasks. Not surprisingly, how\u0026shy;ever, Fourier basis functions have trouble with discontinuities because it is difficult to avoid \\A1\\B0ringing\\A1\\B1 around points of discontinuity unless very high frequency basis functions are included.\nAs is true for polynomial approximation, the number of basis functions in the order-N Fourier cosine basis grows exponentially with the state space dimension. This makes it necessary to select a subset of these functions if the state space has high dimension (e.g., d \u0026gt; 5). This can be done using prior beliefs about the nature of the function to be approximated, and some automated selection methods can be adapted to deal with the incremental and nonstationary nature of reinforcement learning. Advantages of Fourier basis functions in this regard are that it is easy to select functions by setting the ci vectors to account for suspected interactions among the state variables, and by limiting the values in the cj vectors so that the approximation can filter out high frequency components considered to be noise.\nFigure 9.5 shows learning curves comparing the Fourier and polynomial bases on the 1000-state random walk example. In general, we do not recommend using the polynomial basis for online learning.\n\n\n   Figure 9.5: Fourier basis vs polynomials on the 1000-state random walk. Shown are learning curves for the gradient MC method with Fourier and polynomial bases of order 5, 10, and 20. The step-size parameters were roughly optimized for each case: a = 0.0001 for the polynomial basis and a = 0.00005 for the Fourier basis.\n        Episodes\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Exercise 9.3 Why does (9.17) define (N + 1)d distinct functions for dimension d?\n\\A1\\F5\n9.5.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Coarse Coding\nConsider a task in which the state set is continuous and two-dimensional. A state in this case is a point in 2-space, a vector with two real components. One kind of feature for this case is those corresponding to circlesin state space, as shown in Figure 9.6.\n \nFigure 9.6: Coarse coding. Generalization from state sto state s!depends on the number of their features whose receptive fields (in this case, circles) overlap. These states have one feature in common, so there will be slight generalization between them.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nIf the state is inside a circle, then the corresponding feature has the value 1 and is said to be present;otherwise the feature is 0 and is said to be absent.This kind of 1-0-valued feature is called a binary feature.Given a state, which binary features are present indicate within which circles the state lies, and thus coarsely code for its location. Representing a state with features that overlap in this way (although they need not be circles or binary) is known as coarse coding.\n   \nAsymmetric generalization\n        \n\\CB\\C8road generalization\n        \nNarrow generalization\n        Figure 9.7: Generalization in linear function approximation methods is determined by the sizes and shapes of the features\\A1\\AF receptive fields. All three of these cases have roughly the same number and density of features.\n     Assuming linear gradient-descent function approximation, consider the effect of the size and density of the circles. Corresponding to each circle is a single weight (a component of w) that is affected by learning. If we train at one state, a point in the space, then the weights of all circles intersecting that state will be affected. Thus, by (9.7), the approximate value function will be affected at all states within the union of the circles, with a greater effect the more circles a point has \\A1\\B0in common\\A1\\B1 with the state, as shown in Figure 9.6. If the circles are small, then the generalization will be over a short distance, as in Figure 9.7a, whereas if they are large, it will be over a large distance, as in Figure 9.7b. Moreover, the shape of the features will determinethe nature of the generalization. For example, if they are not strictly circular, but are elongated in one direction, then generalization will be similarly affected, as in Figure 9.7c.\nFeatures with large receptive fields give broad generalization, but might also seem to limit the learned function to a coarse approximation, unable to make discrimina\u0026shy;tions much finer than the width of the receptive fields. Happily, this is not the case. Initial generalization from one point to another is indeed controlled by the size and shape of the receptive fields, but acuity, the finest discrimination ultimately possible, is controlled more by the total number of features.\nExample 9.3: Coarseness of Coarse Coding This example illustrates the effect on learning of the size of the receptive fields in coarse coding. Linear function approximation based on coarse coding and (9.6) was used to learn a one-dimensional square-wave function (shown at the top of Figure 9.8). The values of this function were used as the targets, Ut. With just one dimension, the receptive fields were intervals rather than circles. Learning was repeated with three different sizes of the intervals: narrow, medium, and broad, as shown at the bottom of the figure. All three cases had the same density of features, about 50 over the extent of the function being learned. Training examples were generated uniformly at random over this extent. The step-size parameter was a= 0.2, where m is the number of features that were present at one time. Figure 9.8 shows the functions learned in all three cases over the course of learning. Note that the width of the features had a strong effect early in learning. With broad features, the generalization tended to be broad; with narrow features, only the close neighbors of each trained point were changed, causing the function learned to be more bumpy. However, the final function learned was affected only slightly by the width of the features. Receptive field shape tends to have a strong effect on generalization but little effect on asymptotic solution quality.\n\n\n   Medium\nfeatures\n        Figure 9.8: Example of feature width\\A1\\AFs strong effect on initial generalization (first row) and weak effect on asymptotic accuracy (last row).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n        Narrow\nfeatures\n        10240\n        feature\nwidth\n        2560\n        #Examples\n10\n40\n160\n640\n        Broad\nfeatures\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n 9.5.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Tile Coding\nTile coding is a form of coarse coding for multi-dimensional continuous spaces that is flexible and computationally efficient. It may be the most practical feature repre\u0026shy;sentation for modern sequential digital computers. Open-source software is available for many kinds of tile coding.\nIn tile coding the receptive fields of the features are grouped into partitions of the input space. Each such partition is called a tiling, and each element of the partition is called a tile. For example, the simplest tiling of a two-dimensional state space is a uniform grid such as that shown on the left side of Figure 9.9. The tiles or receptive field here are squares rather than the circles in Figure 9.6. If just this single tiling were used, then the state indicated by the white spot would be represented by the single feature whose tile it falls within; generalization would be complete to all states within the same tile and nonexistent to states outside it. With just one tiling, we would not have coarse coding by just a case of state aggregation.\nTo get the strengths of coarse coding requires overlapping receptive fields, and by definition the tiles of a partition do not overlap. To get true coarse coding with tile coding, multiple tilings are used, each offset by a fraction of a tile width. A simple case with four tilings is shown on the right side of Figure 9.9. Every state, such as that indicated by the white spot, falls in exactly one tile in each of the four tilings. These four tiles correspond to four features that become active when the state occurs. Specifically, the feature vector x(s) has one component for each tile in each tiling. In this example there are 4 x 4 x 4 = 64 components, all of which will be 0 except for the four corresponding to the tiles that s falls within. Figure 9.10 shows the advantage of multiple offset tilings (coarse coding) over a single tiling on the 1000-state random walk example.\nAn immediate practical advantage of tile coding is that, because it works with partitions, the overall number of features that are active at one time is the same for any state. Exactly one feature is present in each tiling, so the total number of features present is always the same as the number of tilings. This allows the step-\n \n   һTiling 1 Tiling 2 Tiling 3\\B6\\FE Tiling 4\n        \\A1\\A2Point in state space \\A1\\AA to be represented\n        Four active\ntiles/features overlap the point and are used to represent it\n        Continuous\n        2\n        D state space\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 9.9: Multiple, overlapping grid-tilings on a limited two-dimensional space. These tilings are offset from one another by a uniform amount in each dimension.\n \n   RMSVE\naveraged over 30 runs\n        Figure 9.10: Why we use coarse coding. Shown are learning curves random walk example for the gradient MC algorithm with a single tiling tilings. The space of 1000 states was treated as a single continuous dimension, covered with tiles each 200 states wide. The multiple tilings were offset from each other by 4 states. The step-size parameter was set so that the initial learning rate in the two cases was the same, a = 0.0001 for the single tiling and a = 0.0001/50 for the 50 tilings.\n        on the 1000-state and with multiple\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n size parameter, a, to be set in an easy, intuitive way. For example, choosing a = mm, where mis the number of tilings, results in exact one-trial learning. If the example s ^ V is trained on, then whatever the prior estimate, V(s,wt), the new estimate will be V(s\\A3\\ACwt+i) = V. Usually one wishes to change more slowly than this, to allow for generalization and stochastic variation in target outputs. For example, one might choose a=\u0026nbsp;\u0026nbsp;\u0026nbsp; , in which case the estimate for the trained state would move one-\ntenth of the way to the target in one update, and neighboring states will be moved less, proportional to the number of tiles they have in common.\nTile coding also gains computational advantages from its use of binary feature vectors. Because each component is either 0 or 1, the weighted sum making up the approximate value function (9.7) is almost trivial to compute. Rather than performing n multiplications and additions, one simply computes the indices of the m\\A1\\B6n active features and then adds up the m corresponding components of the weight vector.\nGeneralization occurs to states other than the one trained if those states fall within any of the same tiles, proportional to the number of tiles in common. Even the choice of how to offset the tilings from each other affects generalization. If they are offset uniformly in each dimension, as they were in Figure 9.9, then different states can generalize in qualitatively different ways, as shown below in the upper half of Figure 9.11. Each of the eight subfigures show the pattern of generalization from a trained state to nearby points. In this example their are eight tilings, thus 64subregions within a tile that generalize distinctly, but all according to one of these eight patterns. Note how uniform offsets result in a strong effect along the diagonal in many patterns. These artifacts can be avoided if the tilings are offset asymmetrically, as shown in the lower half of the figure. These lower generalization patterns are better because they are all well centered on the trained state with no\nPossible generalizations for uniformly offset tilings\nPossible generalizations for asymmetrically\noffset tilings\nFigure 9.11: Why tile asymmetrical offsets are preferred in tile coding. Shown is the strength of generalization from a trained state, indicated by the small black plus, to nearby states, for the case of eight tilings. If the tilings are uniformly offset (above), then there are diagonal artifacts and substantial variations in the generalization, whereas with asymmetrically offset tilings the generalization is more spherical and homogeneous.\nobvious asymmetries.\nTilings in all cases are offset from each other by a fraction of a tile width in each dimension. If wdenotes the tile width and kthe number of tilings, then | is a fundamental unit. Within small squares Won a side, all states activate the same tiles, have the same feature representation, and the same approximated value. If a state is moved by fin any cartesian direction, the feature representation changes by one component/tile. Uniformly offset tilings are offset from each other by exactly this unit distance. For a two-dimensional space, we say that each tiling is offset by the displacement vector (1,1), meaning that it is offset from the previous tiling by ftimes this vector. In these terms, the asymmetrically offset tilings shown in the lower part of Figure 9.11 are offset by a displacement vector of (1, 3).\nExtensive studies have been made of the effect of different displacement vectors on the generalization of tile coding (Parks and Militzer, 1991; An, 1991; An, Miller and Parks, 1991; Miller, Glanz and Carter, 1991), assessing their homegeneity and tendency toward diagonal artifacts like those seen for the (1, 1) displacement vectors.\nBased on this work, Miller and Glanz (1996) recommend using displacement vectors consisting of the first odd integers. In particular, for a continuous space of dimension d, a good choice is to use the first odd integers (1, 3, 5, 7,..., 2d \\A1\\AA 1), with k(the number of tilings) set to an integer power of 2 greater than or equal to 4d. This is what we have done to produce the tilings in the lower half of Figure 9.11, in which d = 2, k = 23\u0026gt; 4d, and the displacement vector is (1, 3). In a three-dimensional case, the first four tilings would be offset in total from a base position by (0, 0, 0), (1, 3, 5), (2, 6,10), and (3, 9,15). Open-source software that can efficiently make tilings like this for any d is readily available.\nIn choosing a tiling strategy, one has to pick the number of the tilings and the shape of the tiles. The number of tilings, along with the size of the tiles, determines the resolution or fineness of the asymptotic approximation, as in general coarse coding and illustrated in Figure 9.8. The shape of the tiles will determine the nature of generalization as in Figure 9.7. Square tiles will generalize roughly equally in each dimension as indicated in Figure 9.11 (lower). Tiles that are elongated along one dimension, such as the stripe tilings in Figure 9.12b, will promote generalization along that dimension. The tilings in Figure 9.12b are also denser and thinner on the left, promoting discrimination along the horizonal dimension at lower values along that dimension. The diagonal stripe tiling in Figure 9.12c will promote generalization along one diagonal. In higher dimensions, axis-aligned stripes correspond to ignoring some of the dimensions in some of the tilings, that is, to hyperplanar slices. Irregular tilings such as shown in Figure 9.12a are also possible, though rare in practice and beyond the standard software.\nIn practice, it is often desirable to use different shaped tiles in different tilings. For example, one might use some vertical stripe tilings and some horizontal stripe tilings. This would encourage generalization along either dimension. However, with stripe tilings alone it is not possible to learn that a particular conjunction of horizontal and vertical coordinates has a distinctive value (whatever is learned for it will bleed into states with the same horizontal and vertical coordinates). For this one needs the conjunctive rectangular tiles such as originally shown in Figure 9.9. With multiple tilings\\A1\\AAsome horizontal, same vertical, and some conjunctive\\A1\\AAone can get every\u0026shy;thing: a preference for generalizing along each dimension, yet the ability to learn\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nLog stripes\nFigure 9.12: Tilings need not be grids. They can be arbitrarily shaped and non-uniform, while still in many cases being computationally efficient to compute.\n\n\nspecific values for conjunctions (see Section 16.3 for a case study using this). The choice of tilings determines generalization, and until this choice can be effectively automated, it is important that tile coding enables the choice to be made flexibly and in a way that makes sense to people.\nAnother useful trick for reducing memory requirements is hashing\\A1\\AAa consistent pseudo-random collapsing of a large tiling into a much smaller set of tiles. Hashing produces tiles consisting of noncontiguous, disjoint regions randomly spread throughout the state space, but that still form an exhaustive partition. For example, one tile might consist of the four subtiles shown to the right. Through hashing, memory re\u0026shy;quirements are often reduced by large factors with little loss of performance. This is possible because high resolution is needed in only a small fraction of the state space. Hashing\nfrees us from the curse of dimensionality in the sense that memory requirements need not be exponential in the number of dimensions, but need merely match the real demands of the task. Good open-source implementations of tile coding, including hashing, are widely available.\nExercise 9.4 Suppose we believe that one of two state dimensions is more likely to have an effect on the value function than is the other, that generalization should be primarily across this dimension rather than along it. What kind of tilings could be used to take advantage of this prior knowledge?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n9.5.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Radial Basis Functions\nRadial basis functions (RBFs) are the natural generalization of coarse coding to continuous-valued features. Rather than each feature being either 0 or 1, it can be anything in the interval [0,1], reflecting various degreesto which the feature is present. A typical RBF feature, i, has a Gaussian (bell-shaped) response Xi(s) dependent only on the distance between the state, s, and the feature\\A1\\AFs prototypical or center state, ci, and relative to the feature\\A1\\AFs width, %:\nXi(s) ^ exp (-l|s2^2\\A1\\BB)\u0026#8226;\nThe norm or distance metric of course can be chosen in whatever way seems most appropriate to the states and task at hand. Figure 9.13 shows a one-dimensional\n \nFigure 9.13: One-dimensional radial basis functions.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\nexample with a Euclidean distance metric.\nThe primary advantage of RBFs over binary features is that they produce approxi\u0026shy;mate functions that vary smoothly and are differentiable. Although this is appealing, in most cases it has no practical significance. Nevertheless, extensive studies have been made of graded response functions such as RBFs in the context of tile coding (An, 1991; Miller et al., 1991; An, Miller and Parks, 1991; Lane, Handelman and Gelfand, 1992). All of these methods require substantial additional computational complexity (over tile coding) and often reduce performance when there are more than two state dimensions. In high dimensions the edges of tiles are much more important, and it has proven difficult to obtain well controlled graded tile activations near the edges.\nAn RBF networkis a linear function approximator using RBFs for its features. Learning is defined by equations (9.6) and (9.7), exactly as in other linear function approximators. In addition, some learning methods for RBF networks change the centers and widths of the features as well, bringing them into the realm of nonlinear function approximators. Nonlinear methods may be able to fit target functions much more precisely. The downside to RBF networks, and to nonlinear RBF networks es\u0026shy;pecially, is greater computational complexity and, often, more manual tuning before learning is robust and efficient.\n9.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Nonlinear Function Approximation: Artificial Neu\u0026shy;ral Networks\nArtificial neural networks (ANNs) are widely used for nonlinear function approxima\u0026shy;tion. An ANN is a network of interconnected units that have some of the properties of neurons, main component of nervous systems. ANNs have a long history, with latest advances in training deeply-layered ANNs being responsible for some of the most impressive abilities of machine learning systems, including reinforcement learn\u0026shy;ing systems. In Chapter 16 we describe several stunning examples of reinforcement learning systems that use ANN function approximation.\nFigure 9.14 shows a generic feedforward ANN, meaning that there are no loops in the network, that is, there are no paths within the network by which a unit's output can influence its input. The network in the figure has an output layer consisting of two output units, an input layer with four input units, and two hidden layers: layers that are neither input nor output layers. A real-valued weight is associated with each link. A weight roughly corresponds to the efficacy of a synaptic connection in a real neural network (see Section 15.1). If an ANN has at least one loop in its connections, it is a recurrent rather than a feedforward ANN. Although both feedforward and recurrent ANNs have been used in reinforcement learning, here we look only at the simpler feedforward case.\nThe units (the circles in Figure 9.14) are typically semi-linear units, meaning that they compute a weighted sum of their input signals and then apply to the result a nonlinear function, called the activation function, to produce the unit's output, or\nFigure 9.14: A generic feedforward neural network with four input units, two output units, and two hidden layers.\nactivation. Many different activation functions are used, but they are typically S- shaped, or sigmoid, functions such as the logistic function f(x) = 1/(1+ e-x), though sometimes the rectifier nonlinearity f (x) = max(0, x) is used. A step function like f (x) = 1 if x \u0026gt; 0\\A3\\ACand 0 otherwise, results in a binary unit with threshold 0. It is often useful for units in different layers to use different activation functions.\nThe activation of each output unit of a feedforward ANN is a nonlinear function of the activation patterns over the network\\A1\\AFs input units. The functions are param\u0026shy;eterized by the network\\A1\\AFs connection weights. An ANN with no hidden layers can represent only a very small fraction of the possible input-output functions. However an ANN with a single hidden layer having a large enough finite number of sigmoid units can approximate any continuous function on a compact region of the network\\A1\\AFs input space to any degree of accuracy (Cybenko, 1989). This is also true for other nonlinear activation functions that satisfy mild conditions, but nonlinearity is essen\u0026shy;tial: if all the units in a multi-layer feedforward ANN have linear activation functions, the entire network is equivalent to a network with no hidden layers (because linear functions of linear functions are themselves linear).\nDespite this \\A1\\B0universal approximation\\A1\\B1 property of one-hidden-layer ANNs, both experience and theory show that approximating the complex functions needed for many artificial intelligence tasks is made easier\\A1\\AAindeed may require\\A1\\AAabstractions that are hierarchical compositions of many layers of lower-level abstractions, that is, abstractions produced by deep architectures such as ANNs with many hidden layers. (See Bengio, 2009, for a thorough review.) The successive layers of a deep ANN compute increasingly abstract representations of the network\\A1\\AFs \\A1\\B0raw\\A1\\B1 input, with each unit providing a feature contributing to a hierarchical representation of the overall input-output function of the network.\nCreating these kinds of hierarchical representations without relying exclusively on hand-crafted features has been an enduring challenge for artificial intelligence. This is why learning algorithms for ANNs with hidden layers have received so much attention over the years. ANNs typically learn by a stochastic gradient method (Section 9.3). Each weight is adjusted in a direction aimed at improving the network\\A1\\AFs overall performance as measured by an objective function to be either minimized or maximized. In the most common supervised learning case, the objective function is the expected error, or loss, over a set of labeled training examples. In reinforcement learning, ANNs can use TD errors to learn value functions, or they can aim to maximize expected reward as in a gradient bandit (Section 2.8) or a policy-gradient algorithm (Chapter 13). In all of these cases it is necessary to estimate how a change in each connection weight would influence the network\\A1\\AFs overall performance, in other words, to estimate the partial derivative of an objective function with respect to each weight, given the current values of all the network\\A1\\AFs weights. The gradient is the vector of these partial derivatives.\nThe most successful way to do this for ANNs with hidden layers (provided the units have differentiable activation functions) is the backpropagation algorithm, which con\u0026shy;sists of alternating forward and backward passes through the network. Each forward pass computes the activation of each unit given the current activations of the net\u0026shy;work\\A1\\AFs input units. After each forward pass, a backward pass efficiently computes a partial derivative for each weight. (As in other stochastic gradient learning algo\u0026shy;rithms, the vector of these partial derivatives is an estimate of the true gradient.) In Section 15.10 we discuss methods for training ANNs with hidden layers that use reinforcement learning principles instead of backpropagation. These methods are less efficient than the backpropagation algorithm, but they may be closer to how real neural networks learn.\nThe backpropagation algorithm can produce good results for shallow networks having 1 or 2 hidden layers, but it does not work well for deeper ANNs. In fact, training a network with k + 1hidden layers can actually result in poorer performance than training a network with k hidden layers, even though the deeper network can represent all the functions that the shallower network can (Bengio, 2009). Explaining results like these is not easy, but several factors are important. First, the large number of weights in a typical deep ANN makes it difficult to avoid the problem of overfitting, that is, the problem of failing to generalize correctly to cases on which the network has not been trained. Second, backpropagation does not work well for deep ANNs because the partial derivatives computed by its backward passes either decay rapidly toward the input side of the network, making learning by deep layers extremely slow, or the partial derivatives grow rapidly toward the input side of the network, making learning unstable. Methods for dealing with these problems are largely responsible for many impressive results achieved by systems that use deep ANNs.\nOverfitting is a problem for any function approximation method that adjusts func\u0026shy;tions with many degrees of freedom on the basis of limited training data. It is less of a problem for on-line reinforcement learning that does not rely on limited training sets, but generalizing effectively is still an important issue. Overfitting is a problem\n\n\nfor ANNs in general, but especially so for deep ANNs because they tend to have very large numbers of weights. Many methods have been developed for reducing overfitting. These include stopping training when performance begins to decrease on validation data different from the training data (cross validation), modifying the objective function to discourage complexity of the approximation (regularization), and introducing dependencies among the weights to reduce the number of degrees of freedom (e.g., weight sharing).\nA particularly effective method for reducing overfitting by deep ANNs is the dropout method introduced by Srivastava, Hinton, Krizhevsky, Sutskever, and Salakhut- dinov (2014). During training, units are randomly removed from the network (dropped out) along with their connections. This can be thought of as training a large number of \\A1\\B0thinned\\A1\\B1 networks. Combining the results of these thinned networks at test time is a way to improve generalization performance. The dropout method efficiently ap\u0026shy;proximates this combination by multiplying each outgoing weight of a unit by the probability that that unit was retained during training. Srivastava et al. found that this method significantly improves generalization performance. It encourages indi\u0026shy;vidual hidden units to learn features that work well with random collections of other features. This increases the versatility of the features formed by the hidden units so that the network does not overly specialize to rarely-occurring cases.\nHinton, Osindero, and Teh (2006) took a major step toward solving the problem of training the deep layers of a deep ANN in their work with deep belief networks, layered networks closely related to the deep ANNs discussed here. In their method, the deepest layers are trained one at a time using an unsupervised learning algorithm. Without relying on the overall objective function, unsupervised learning can extract features that capture statistical regularities of the input stream. The deepest layer is trained first, then with input provided by this trained layer, the next deepest layer is trained, and so on, until the weights in all, or many, of the network's layers are set to values that now act as initial values for supervised learning. The network is then fine-tuned by backpropagation with respect to the overall objective function. Studies show that this approach generally works much better than backpropagation with weights initialized with random values. The better performance of networks trained with weights initialized this way could be due to many factors, but one idea is that this method places the network in a region of weight space from which a gradient-based algorithm can make good progress.\nA type of deep ANN that has proven to be very successful in applications, includ\u0026shy;ing impressive reinforcement learning applications (Chapter 16) is the deep convolu\u0026shy;tional network. This type of network is specialized for processing high-dimensional data arranged in spatial arrays, such as images. It was inspired by how early visual processing works in the brain (LeCun, Bottou, Bengio and Haffner, 1998). Because of its special architecture, a deep convolutional network can be trained by backprop- agation without resorting to methods like those described above to train the deep layers.\nFigure 9.15 illustrates the architecture of a deep convolutional network. This in\u0026shy;stance, from LeCun et al. (1998), was designed to recognize hand-written characters.\n C3: f. maps 16@ 10x10\n\nConvolutions\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Subsampling Convolutions Subsampling Full connection\nFigure 9.15: Deep Convolutional Network. Republished with permission of Proceedings of the IEEE, from Gradient-based learning applied to document recognition, LeCun, Bottou, Bengio, and Haffner, volume 86, 1998; permission conveyed through Copyright Clearance Center, Inc.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nIt consists of alternating convolutional and subsampling layers, followed by several fully connected final layers. Each convolutional layer produces a number of feature maps. A feature map is a pattern of activity over an array of units, where each unit performs the same operation on data in its receptive field, which is the part of the data it \\A1\\B0sees\\A1\\B1 from the preceding layer (or from the external input in the case of the first convolutional layer). The units of a feature map are identical to one another except that their receptive fields, which are all the same size and shape, are shifted to different locations on the arrays of incoming data. Units in the same feature map share the same weights. This means that a feature map detects the same feature no matter where it is located in the input array. In the network in Figure 9.15, for example, the first convolutional layer produces 6feature maps, each consisting of 28 x 28 units. Each unit in each feature map has a 5 x 5 receptive field, and these receptive fields overlap (in this case by four columns and five rows). Consequently, each of the 6feature maps is specified by just 25 adjustable weights.\nThe subsampling layers of a deep convolutional network reduce the spatial res\u0026shy;olution of the feature maps. Each feature map in a subsampling layer consists of units that average over a receptive field of units in the feature maps of the preceding convolutional layer. For example, each unit in each of the 6feature maps in the first subsampling layer of the network of Figure 9.15 averages over a 2 x 2 non-overlapping receptive fields of a feature map produced by the first convolutional layer, resulting in six 14 x 14 feature maps. The subsampling layers reduce the network\\A1\\AFs sensitivity to the spatial locations of the features detected, that is, they help make the network\\A1\\AFs responses spatially invariant. This is useful because a feature detected at one place in an image is likely to be useful at other places as well.\nAdvances in the design and training of ANNs\\A1\\AAof which we have only mentioned a few\\A1\\AAall contribute to reinforcement learning. Although current reinforcement learning theory is mostly limited to methods using tabular or linear function approx\u0026shy;imation methods, the impressive performances of notable reinforcement learning ap\u0026shy;plications owe much of their success to nonlinear function approximation by ANNs,\nin particular, by deep ANNs. The case studies we discuss in Chapter 16 that use ANNs all use deep convolutional networks, which are well suited for the spatial arrays that represent states in these problems. Other network architectures are appropriate for other types of problems, and one of the challenges of using ANNs for function approximation is finding a network architecture that works well for the problem of interest.\n9.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Least-Squares TD\nIn Section 9.4 we established that TD(0) with linear function approximation con\u0026shy;verges asymptotically, for appropriately decreasing step sizes, to the TD fixedpoint:\nwtd = A ib,\nwhere\n   A == E\n     xt(xt \\A1\\AA Yxt+i)Tand b ==E[Rt+ixt]\nWhy, we might ask, must we compute this solution iteratively? This is wasteful of data! Could one not do better by computing estimates of A and b, and then directly computing the TD fixedpoint? The Least-Squares TD algorithm, commonly known as LSTD, does exactly this. It forms the natural estimates\ntt At =\\B7\\A6\\A1\\B3xfc(xfc\\A1\\AA Yxfc+i)T+ el and bt =\\B7\\A6\\A1\\B3Rt+ixfc\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.18)\nk=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k=0\n(where eI, for some small e \u0026gt; 0, ensures that At is always invertible) and then estimates the TD fixedpoint as\n   wt+i\n     ==Ap bt.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.19)\nThis algorithm is the most data efficient form of linear TD(0), but it is also much more expensive computationally. Recall that semi-gradient TD(0) requires memory and per-step computation that is only O(d).\nHow complex is LSTD? As it is written above the complexity seems to increase with t, but the two approximations in (9.18) could be implemented incrementally using the techniques we have covered earlier (e.g., in Chapter 2) so that they can be done in constant time per step. Even so, the update for At would involve an outer product (a column vector times a row vector) and thus would be a matrix update; its computational complexity would be O(d2), and of course the memory required to hold the At matrix would be O(d2).\nA potentially greater problem is that our final computation (9.19) uses the inverse of At, and the computational complexity of a general inverse computation is O(d3). Fortunately, an inverse of a matrix of our special form\\A1\\AAa sum of outer products\\A1\\AAcanalso be updated incrementally with only O(d2) computations, as\nA;1= (A_t-i + xt(xt - 7xt+i)T)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (9.18))\n=A-_ii -\\D3\\D6--ixt(xt - Yxt+i)TX--i,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.20)\n1+ (xt - 7xt+i)T^Vt-ixt\nwith A_i == ^I. Although the identity (9.20), known as the Sherman-Morrison formula, is superficially complicated, it involves only vector-matrix and vector-vector multiplications and thus is only O(d2). Thus we can store and maintain the inverse matrix A-it, and then use it in (9.19), all with only O(d2) memory and per-step computation. The complete algorithm is given in the box below.\nLSTD for estimating V c Vn (O(d2) version)\nInput: feature representation x(s) G Rd, Vs G S, x(terminal) == 0\nA-i^-iI\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; An d x d matrix\nb \\A1\\AA 0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; An d-dimensional vector\nRepeat (for each episode):\nInitialize S; obtain corresponding x Repeat (for each step of episode):\nChoose A \u0026#12316;n(-|S)\nTake action A, observe R, Sf;obtain corresponding xf\nT\nv \\A1\\AA A-i(x \\A1\\AA yx;)\nA-i\\A1\\AA A-i\\A1\\AA (A-ix)vT/ (1 + vTx) b \\A1\\AA b + Rx\ne\\A1\\AA a-1b\nS \\A1\\AA S;; x \\A1\\AA x! until Sf is terminal\nOf course, O(d2) is still significantly more expensive than the O(d) of semi-gradient TD. Whether the greater data efficiency of LSTD is worth this computational expense depends on how large d is, how important it is to learn quickly, and the expense of other parts of the system. The fact that LSTD requires no step-size parameter is sometimes also touted, but the advantage of this is probably overstated. LSTD does not require a step size, but it does requires e\\ if e is chosen too small the sequence of inverses can vary wildly, and if e is chosen too large then learning is slowed. In addition, LSTD's lack of a step size parameter means that it never forgets. This is sometimes desirable, but it is problematic if the target policy n changes as it does in reinforcement learning and GPI. In control applications, LSTD typically has to be combined with some other mechanism to induce forgeting, mooting any initial advantage of not requiring a step size parameter.\n\n\n9.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Memory-based Function Approximation\nSo far we have discussed the parametricapproach to approximating value functions. In this approach, a learning algorithm adjusts the parameters of a functional form intended to approximate the value function over a problem\\A1\\AFs entire state space. Each backup, s ^ g, is a training example used by the learning algorithm to change the parameters with the aim of reducing the approximation error. After the update, the training example can be discarded (although it might be saved to be used again). When an approximate value of a state (which we will call the query state)is needed, the function is simply evaluated at that state using the latest parameters produced by the learning algorithm.\nMemory-based function approximation methods are very different. They simply save training examples in memory as they arrive (or at least save a subset of the examples) without updating any parameters. Then, whenever a query state\\A1\\AFs value estimate is needed, a set of examples is retrieved from memory and used to compute a value estimate for the query state. This approach is sometimes called lazy learning because processing training examples is postponed until the system is queried to provide an output.\nMemory-based function approximation methods are prime examples of nonpara- metricmethods. Unlike parametric methods, the approximating function\\A1\\AFs form is not limited to a fixed parameterized class of functions, such as linear functions or polynomials, but is instead determined by the training examples themselves, together with some means for combining them to output estimated values for query states. As more training examples accumulate in memory, one expects nonparametric methods to produce increasingly accurate approximations of any target function.\nThere are many different memory-based methods depending on how the stored training examples are selected and how they are used to respond to a query. Here, we focus on local-learningmethods that approximate a value function only locally in the neighborhood of the current query state. These methods retrieve a set of training examples from memory whose states are judged to be the most relevant to the query state, where relevance usually depends on the distance between states: the closer a training example\\A1\\AFs state is to the query state, the more relevant it is considered to be, where distance can be defined in many different ways. After the query state is given a value, the local approximation is discarded.\nThe simplest example of the memory-based approach is the nearest neighbormethod, which simply finds the example in memory whose state is closest to the query state and returns that example\\A1\\AFs value as the approximate value of the query state. In other words, if the query state is s, and sf^ gis the example in memory in which s; is the closest state to s, then g is returned as the approximate value of s. Slightly more complicated are weighted averagemethods that retrieve a set of nearest neigh\u0026shy;bor examples and return a weighted average of their target values, where the weights generally decrease with increasing distance between their states and the query state. Locally weighted regressionis similar, but it fits a surface to the values of a set of nearest states by means of a parametric approximation method that minimizes a\nweighted error measure like (9.1), where the weights depend on distances from the query state. The value returned is the evaluation of the locally-fitted surface at the query state, after which the local approximation surface is discarded.\nBeing nonparametric, memory-based methods have the advantage over paramet\u0026shy;ric methods of not limiting approximations to pre-specified functional forms. This allows accuracy to improve as more data accumulates. Memory-based localapproxi\u0026shy;mation methods have other properties that make them well suited for reinforcement learning. Because trajectory sampling is of such importance in reinforcement learn\u0026shy;ing, as discussed in Section 8.6, memory-based local methods can focus function approximation on local neighborhoods of states (or state-action pairs) visited in real or simulated trajectories. There may be no need for global approximations because many areas of the state space will never (or almost never) be reached. In addition, memory-based methods allow an agent\\A1\\AFs experience to have a relatively immediate affect on value estimates in the neighborhood if its environment\\A1\\AFs current state, in contrast with a parametric method\\A1\\AFs need to incrementally adjust parameters of a global approximation.\nAvoiding global approximations is also a way to address the curse of dimensionality. For example, for a state space with d dimensions, a tabular method storing a global approximation requires memory exponential in d. On the other hand, in storing examples for a memory-based method, each example requires memory proportional to d, and the memory required to store, say, n examples is linear in n. Nothing is exponential in d or n. Of course, the critical remaining issue is whether a memory- based method can answer queries quickly enough to be useful to an agent. A related concern is how speed degrades as the size of the memory grows. Finding nearest neighbors in a large database can take too long to be practical in many applications.\nProponents of memory-based methods have developed ways to accelerate the near\u0026shy;est neighbor search. Using parallel computers or special purpose hardware is one approach; another is the use of special multi-dimensional data structures to store the training data. One data structure studied for this application is the k-d tree (short for k-dimensional tree), which recursively splits a k-dimensional space into regions arranged as nodes of a binary tree. Depending on the amount of data and how it is distributed over the state space, nearest-neighbor search using k-d trees can quickly eliminate large regions of the space in the search for neighbors, making the searches feasible in some problems where naive searches would take too long.\nLocally weighted regression additionally requires fast ways to do the local regres\u0026shy;sion computations which have to be repeated to answer each query. Researchers have developed many ways to address these problems, including methods for forgetting en\u0026shy;tries in order to keep the size of the database within bounds. The Bibliographic and Historical Comments section at the end of this chapter points to some of the relevant literature, including a selection of papers describing applications of memory-based learning to reinforcement learning.\n9.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Kernel-based Function Approximation\nMemory-baed methods such as the weighted average and locally weighted regression methods described above depend on assigning weights to examples sf^ g in the database depending on the distance between sfand a query states s. The function that assigns these weights is called a kernel function, or simply a kernel. In the weighted average and locally weighted regressions methods, for example, a kernel function k: R R assigns weights to distances between states. More generally, weights do not have to depend on distances; they can depend on some other measure of similarity between states. In this case, k : S x S R, so that k(s, s;) is the weight given to data about sfin its influence on answering queries about s.\nViewed slightly differently, k(s, s;) is a measure of the strength of generalization from sحto s. Kernel functions numerically express how relevantknowledge about any state is to any other state. As an example, the strengths of generalization for tile coding shown in Figure 9.11 correspond to different kernel functions resulting from uniform and asymmetrical tile offsets. Although tile coding does not explicitly use a kernel function in its operation, it generalizes according to one. In fact, as we discuss more below, the strength of generalization resulting from linear parametric function approximation can always be described by a kernel function.\nKernel regressionis the memory-based method that computes a kernel weighted average of the targets of allexamples stored in memory, assigning the result to the query state. If Dis the set of stored examples, and g(s;) denotes the target for state s; in a stored example, then kernel regression approximates the target function, in this case a value function depending on D, as\n\\D0\\C4(s,D)= E k(s, s;)g(s;).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.21)\nThe weighted average method described above is a special case in which k(s, s;) is non-zero only when s and s; are close to one another so that the sum need not be computed over all of D.\nA common kernel is the Gaussian radial basis function (RBF) used in RBF function approximation as described in Section 9.5.5. In the method described there, RBFs are features whose centers and widths are either fixed from the start, with centers presumably concentrated in areas where many examples are expected to fall, or are adjusted in some way during learning. Barring methods that adjust centers and widths, this is a linear parametric method whose parameters are the weights of each RBF, which are typically learned by stochastic gradient, or semi-gradient, descent. The form of the approximation is a linear combination of the pre-determined RBFs. Kernel regression with an RBF kernel differs from this in two ways. First, it is memory-based: the RBFs are centered on the states of the stored examples. Second, it is nonparametric: there are no parameters to learn; the response to a query is given by (9.21).\nOf course, many issues have to be addressed for practical implementation of ker\u0026shy;nel regression, issues that are beyond the scope or our brief discussion. However, it turns out that any linear parametric regression method like those we described in Sec\u0026shy;tion 9.4, with states represented by feature vectors x(s) = (xi(s), x2(s),..., xn(s))T, can be recast as kernel regression where k(s, s') is the inner product of the feature vector representations of s and s'; that is\nk(s, s') = x(s)Tx(s').\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (9.22)\nKernel regression with this kernel function produces the same approximation that a linear parametric method would if it used these feature vectors and learned with the same training data.\nWe skip the mathematical justification for this, which can be found in any modern machine learning text, such as Bishop (2006), and simply point out an important implication. Instead of constructing features for linear parametric function approx\u0026shy;imators, one can instead construct kernel functions directly without referring at all to feature vectors. Not all kernel functions can be expressed as inner products of feature vectors as in (9.22), but a kernel function that can be expressed like this can offer significant advantages over the equivalent parametric method. For many sets of feature vectors, (9.22) has a compact functional form that can be evaluated without any computation taking place in the n-dimensional feature space. In these cases, kernel regression is much less complex than directly using a linear parametric method with states represented by these feature vectors. This is the so-called \\A1\\B0kernel trick\\A1\\B1 that allows effectively working in the high-dimension of an expansive feature space while actually working only with the set of stored training examples. The ker\u0026shy;nel trick is the basis of many machine learning methods, and researchers have shown how it can sometimes benefit reinforcement learning.\nThe Bibliographic and Historical Comments section at the end of this chapter refers to a selection of publications on some of the mathematical details and on some of the kernel-based reinforcement learning methods that have been proposed.\n9.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Looking Deeper at On-policy Learning: Interest and Emphasis\nThe algorithms we have considered so far in this chapter have treated all the states encountered equally, as if they were all equally important. In some cases, however, we are more interested in some states than others. In discounted episodic problems, for example, we may be more interested in accurately valuing early states in the episode than in later states where discounting may have made the rewards much less important to the value of the start state. Or, if an action-value function is being learned, it may be less important to accurately value poor actions whose value is much less than the greedy action. Function approximation resources are always limited, and if they were used in a more targeted way, then performance could be improved.\nOne reason we have treated all states encountered equally is that then we are updating according to the on-policy distribution, for which stronger theoretical re\u0026shy;\n \nsults are available for semi-gradient methods. Recall that the on-policy distribution was defined as the distribution of states encountered in an MDP while following the target policy. Now we will generalize this concept significantly. Rather than having one on-policy distribution for the MDP, we will have many. All of them will have in common that they are a distribution of states encountered in trajectories while following the target policy, but they will vary in how the trajectories are, in a sense, initiated.\nWe now introduce some new concepts. First be introduce a non-negative scalar measure, a random variable It called interest, indicating the degree to which we are interested in accurately valuing the state (or state-action pair) at time t. If we don\\A1\\AFt care at all about the state, then the interest should be zero; if we fully care, it might be one, though it\\A1\\AFs formally allowed take any non-negative value. The interest can be set in any causal way; for example, it may depend on the trajectory up to time t or the learned parameters at time t. The distribution ^ in the MSVE (9.1) is then defined as the distribution of states encountered while following the target policy, weighted by the interest. Second, we introduce another non-negative scalar random variable, the emphasis Mt. This scalar multiplies the learning update and thus emphasizes or de-emphasizes the learning done at time t. The general n-step learning rule, replacing (9.14), is\nwt+n = wt+n-1+aMt [Gt\\A3\\BAt+n - v(St,wt+ra-i)] W(St,wt+ra-i),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0 \u0026lt; t \u0026lt; T, (9.23)\nwith the n-step return given by (9.15) and the emphasis determined recursively from the interest by:\nMt = It + YnMt-n,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0\u0026lt; t\u0026lt;T,(9.24)\nwith Mt == 0, Vt \u0026lt; 0. These equations are taken to include the Monte Carlo case, for which Gt\\A3\\BAt+n = Gt, all the updates are taken at episode\\A1\\AFs end, n = T - t, and Mt = It.\n9.11\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nReinforcement learning systems must be capable of generalization if they are to be applicable to artificial intelligence or to large engineering applications. To achieve this, any of a broad range of existing methods for supervised-learning function ap\u0026shy;proximation can be used simply by treating each backup as a training example.\nPerhaps the most suitable supervised learning methods are those using parameter\u0026shy;ized function approximation, in which the policy is parameterized by a weight vector w. Although the weight vector has many components, the state space is much larger still and we must settle for an approximate solution. We defined MSVE(w) as a measure of the error in the values (s) for a weight vector w under the on-policy distribution,\\B2\\B7The MSVE gives us a clear way to rank different value-function approximations in the on-policy case.\n \nvn= 4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; vn = 3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; v \\C8\\DF=2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; vn = 1\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n   Example of Interest and Emphasis\n        To see the potential benefits of using interest and emphasis, consider the four- state Markov reward process shown below:\n     Episodes start in the leftmost state, then transition one state to the right, with a reward of +1, on each step until the terminal state is reached. The true value of the first state is thus 4, of the second state 3, and so on as shown below each state. These are the true values; the estimated values can only approximate these because they are constrained by the parameterization. There are two components to the parameter vector w = (wi, W2)T, and the parameterization is as written inside each state. The estimated values of the first two states are given by wi alone and thus must be the same even though their true values are different. Similarly, the estimated values of the third and fourth states are given by W2alone and must be the same even though their true values are different. Suppose that we are interested in accurately valuing only the leftmost state; we assign it an interest of 1while all the other states are assigned an interest of 0, as indicated above the states.\nFirst consider applying gradient Monte Carlo algorithms to this problem. The algorithms presented earlier in this chapter that do not take into account interest and emphasis (in (9.6) and the box on page 216) will converge (for decreasing step sizes) to the parameter vector w^ = (3.5,1.5), which gives the first state\\A1\\AAthe only one we are interested in\\A1\\AAa value of 3.5 (i.e., intermediate between the true values of the first and second states). The methods presented in this section that do use interest and emphasis, on the other hand, will learn the value of the first state exactly correctly; wi will converge to 4 while w2will never be updated because the emphasis is zero in all states save the leftmost.\nNow consider applying two-step semi-gradient TD methods. The methods from earlier in this chapter without interest and emphasis (in (9.14) and (9.15) and the box on page 223) will again converge to w^ = (3.5,1.5), while the methods with interest and emphasis converge to w^ = (4, 2). The latter pro\u0026shy;duces the exactly correct values for the first state and for the third state (which the first state bootstraps from) while never making any updates corresponding to the second or fourth states.\nTo find a good weight vector, the most popular methods are variations of stochas\u0026shy;tic gradient descent(SGD). In this chapter we have focused on the on-policycase with a fixed policy,also known as policy evaluation or prediction; a natural learn\u0026shy;ing algorithm for this case is n-step semi-gradient TD,which includes gradient MC and semi-gradient TD(0) algorithms as the special cases when n = oo and n = 1 respectively. Semi-gradient TD methods are not true gradient methods. In such bootstrapping methods (including DP), the weight vector appears in the update tar\u0026shy;get, yet this is not taken into account in computing the gradientһthus they are semi-gradient methods. As such, they cannot rely on classical SGD results.\nNevertheless, good results can be obtained for semi-gradient methods in the special case of linearfunction approximation, in which the value estimates are sums of features times corresponding weights. The linear case is the most well understood theoretically and works well in practice when provided with appropriate features. Choosing the features is one of the most important ways of adding prior domain knowledge to reinforcement learning systems. They can be chosen as polynomials, but this case generalizes poorly in the online learning setting typically considered in reinforcement learning. Better is to choose features according the Fourier basis, or according to some form of coarse coding with sparse overlapping receptive fields. Tile coding is a form of coarse coding that is particularly computationally efficient and flexible. Radial basis functions are useful for one- or two-dimensional tasks in which a smoothly varying response is important. LSTD is the most data-efficient linear TD prediction method, but requires computation proportional to the square of the number of weights, whereas all the other methods are of complexity linear in the number of weights. Nonlinear methods include artificial neural networks trained by backpropagation and variations of SGD; these methods have become very popular in recent years under the name deep reinforcement learning.\nLinear semi-gradient n-step TD is guaranteed to converge under standard condi\u0026shy;tions, for all n, to a MSVE that is within a bound of the optimal error. This bound is always tighter for higher n and approaches zero as n o. However, in practice that choice results in very slow learning, and some degree of bootstrapping (1\u0026lt; n \u0026lt; co) is usually preferrable.\nBibliographical and Historical Remarks\nGeneralization and function approximation have always been an integral part of rein\u0026shy;forcement learning. Bertsekas and Tsitsiklis (1996), Bertsekas (2012), and Sugiyama et al. (2013) present the state of the art in function approximation in reinforce\u0026shy;ment learning. Some of the early work with function approximation in reinforcement learning is discussed at the end of this section.\n9.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Gradient-descent methods for minimizing mean-squared error in supervised learning are well known. Widrow and Hoff (1960) introduced the least-mean- square (LMS) algorithm, which is the prototypical incremental gradient- descent algorithm. Details of this and related algorithms are provided in many texts (e.g., Widrow and Stearns, 1985; Bishop, 1995; Duda and Hart, 1973).\nSemi-gradient TD(0) was first explored by Sutton (1984, 1988), as part of the linear TD(A) algorithm that we will treat in Chapter 12. The term \\A1\\B0semi-gradient\\A1\\B1 to describe these bootstrapping methods is new to the second edition of this book.\nThe earliest use of state aggregation in reinforcement learning may have been Michie and Chambers\\A1\\AFs BOXES system (1968). The theory of state aggre\u0026shy;gation in reinforcement learning has been developed by Singh, Jaakkola, and Jordan (1995) and Tsitsiklis and Van Roy (1996). State aggregation has been used in dynamic programming from its earliest days (e.g., Bellman, 1957a).\n9.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sutton (1988) proved convergence of linear TD(0) in the mean to the minimal MSVE solution for the case in which the feature vectors, {x(s) : s G S}, are linearly independent. Convergence with probability 1 was proved by several researchers at about the same time (Peng, 1993; Dayan and Sejnowski, 1994; Tsitsiklis, 1994; Gurvits, Lin, and Hanson, 1994). In addition, Jaakkola, Jordan, and Singh (1994) proved convergence under on-line updating. All of these results assumed linearly independent feature vectors, which implies at least as many components to wt as there are states. Convergence for the more important case of general (dependent) feature vectors was first shown by Dayan (1992). A significant generalization and strengthening of Dayan\\A1\\AFs result was proved by Tsitsiklis and Van Roy (1997). They proved the main result presented in this section, the bound on the asymptotic error of linear bootstrapping methods.\n9.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Our presentation of the range of possibilities for linear function approximation is based on that by Barto (1990).\n9.5.3\u0026nbsp;\u0026nbsp;\u0026nbsp; The term coarse codingis due to Hinton (1984), and our Figure 9.6 is based on one of his figures. Waltz and Fu (1965) provide an early example of this type of function approximation in a reinforcement learning system.\n9.5.4\u0026nbsp;\u0026nbsp;\u0026nbsp; Tile coding, including hashing, was introduced by Albus (1971, 1981). He de\u0026shy;scribed it in terms of his \\A1\\B0cerebellar model articulator controller,\\A1\\B1 or CMAC, as tile coding is sometimes known in the literature. The term \\A1\\B0tile cod\u0026shy;ing\\A1\\B1 was new to the first edition of this book, though the idea of describing CMAC in these terms is taken from Watkins (1989). Tile coding has been used in many reinforcement learning systems (e.g., Shewchuk and Dean, 1990; Lin and Kim, 1991; Miller, Scalera, and Kim, 1994; Sofge and White, 1992; Tham, 1994; Sutton, 1996; Watkins, 1989) as well as in other types of learning control systems (e.g., Kraft and Campagna, 1990; Kraft, Miller, and Dietz, 1992). This section draws heavily on the work of Miller and Glanz (1996).\n\n\n9.5.5 Function approximation using radial basis functions (RBFs) has received wide attention ever since being related to neural networks by Broomhead and Lowe (1988). Powell (1987) reviewed earlier uses of RBFs, and Poggio and Girosi (1989, 1990) extensively developed and applied this approach.\n9.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The introduction of the threshold logic unit as an abstract model neuron by McCulloch and Pitts (1943) was the beginning of artificial neural net\u0026shy;works (ANNs). The history of ANNs as learning methods for classification or regression has passed through several stages: roughly, the Perceptron (Rosen\u0026shy;blatt, 1962) and ADALINE (ADAptive LINear Element) (Widrow and Hoff, 1960) stage of learning by single-layer ANNs, the error-backpropagation stage (Werbos, 1974; LeCun, 1985; Parker, 1985; Rumelhart, Hinton, and Williams, 1986) of learning by multi-layer ANNs, and the current deep-learning stage with its emphasis on representation learning (e.g., Bengio, Courville, and Vincent, 2012; Goodfellow, Bengio, and Courville, 2016). Examples of the many books on ANNs are Haykin (1994), Bishop (1995), and Ripley (2007).\nANNs as function approximation for reinforcement learning goes back to the early neural networks of Farley and Clark (1954), who used reinforcement\u0026shy;like learning to modify the weights of linear threshold functions representing policies. Widrow, Gupta, and Maitra (1973) presented a neuron-like linear threshold unit implementing a learning process they called learning with a criticor selective bootstrap adaptation, a reinforcement-learning variant of the ADALINE algorithm. Werbos (1974, 1987, 1994) developed an approach to prediction and control that uses ANNs trained by error backpropation to learn policies and value functions using TD-like algorithms. Barto, Sutton, and Brouwer (1981) and Barto and Sutton (1981b) extended the idea of an as\u0026shy;sociative memory network (e.g., Kohonen, 1977; Anderson, Silverstein, Ritz, and Jones, 1977) to reinforcement learning. Barto, Anderson, and Sutton (1982) used a two-layer ANN to learn a nonlinear control policy, and em\u0026shy;phasized the first layer's role of learning a suitable representation. Hampson (1983, 1989) was an early proponent of multilayer ANNs for learning value functions. Barto, Sutton, and Anderson (1983) presented an actor-critic al\u0026shy;gorithm in the form of an ANN learning to balance a simulated pole (see Sections 15.7 and 15.8). Barto and Anandan (1985) introduced a stochastic version of Widrow, Gupta, and Maitra\\A1\\AFs (1973) selective bootstrap algorithm called the associative reward-penalty(Ar-p) algorithm. Barto (1985, 1986) and Barto and Jordan (1987) described multi-layer ANNs consisting of Ar-p units trained with a globally-broadcast reinforcement signal to learn classi\u0026shy;fication rules that are not linearly separable. Barto (1985) discussed this approach to ANNs and how this type of learning rule is related to others in the literature at that time. (See Section 15.10 for additional discussion of this approach to training multi-layer ANNs.) Anderson (1986, 1987, 1989) eval\u0026shy;uated numerous methods for training multilayer ANNs and showed that an actor-critic algorithm in which both the actor and critic were implemented by two-layer ANNs trained by error backpropagation outperformed single\u0026shy;layer ANNs in the pole-balancing and tower of Hanoi tasks. Williams (1988) described several ways that backpropagation and reinforcement learning can be combined for training ANNs. Gullapalli (1990) and Williams (1992) de\u0026shy;vised reinforcement learning algorithms for neuron-like units having continu\u0026shy;ous, rather than binary, outputs. Barto, Sutton, and Watkins (1990) argued that ANNs can play significant roles for approximating functions required for solving sequential decision problems. Williams (1992) related REINFORCE learning rules (Section 13.3) to the error backpropagation method for train\u0026shy;ing multi-layer ANNs. Schmidhuber (2015) reviews applications of ANNs in reinforcement learning, including applications of recurrent ANNs.\n9.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; LSTD is due to Bradtke and Barto (see Bradtke, 1993, 1994; Bradtke and Barto, 1996; Bradtke, Ydstie, and Barto, 1994), and was further developed by Boyan (1999, 2002) and Nedic and Bertsekas (2003). The incremental update of the inverse matrix has been known at least since 1949 (Sherman and Morrison, 1949). An extension of least-squares methods to control was introduced by Lagoudakis and Parr (2003).\n9.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Our discussion of memory-based function approximation is largely based on the review of locally weighted learning by Atkeson, Moore, and Schaal (1997). Atkeson (1992) discussed the use of locally weighted regression in memory- based robot learning and supplied an extensive bibliography covering the history of the idea. Stanfill and Waltz (1986) influentially argued for the importance of memory based methods in artificial intelligence, especially in light of parallel architectures then becoming available, such as the Connection Machine. Baird and Klopf (1993) introduced a novel memory-based approach and used it as the function approximation method for Q-learning applied to the pole-balancing task. Schaal and Atkeson (1994) applied locally weighted regression to a robot juggling control problem, where it was used to learn a system model. Ping (1995) used the pole-balancing task to experiment with several nearest-neighbor methods for approximating value functions, poli\u0026shy;cies, and environment models. Tadepalli and Ok (1996) obtained promising results with locally-weighted linear regression to learn a value function for a simulated automatic guided vehicle task. Bottou and Vapnik (1996) demon\u0026shy;strated surprising efficiency of several local learning algorithms compared to non-local algorithms in some pattern recognition tasks, discussing the impact of local learning on generalization.\nBentley (1975) introduced k-d trees and reported observing average running time of O(log n) for nearest neighbor search over nrecords. Friedman, Bent\u0026shy;ley, and Finkel (1977) clarified the algorithm for nearest neighbor search with k-d trees. Omohundro (1987) discussed efficiency gains possible with hierar\u0026shy;chical data structures such as k-d-trees. Moore, Schneider, and Deng (1997) introduced the use of k-d trees for efficient locally weighted regression.\n9.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The origin of kernel regression is the method of potential functionsof Aiz\u0026shy;erman, Braverman, and Rozonoer (1964). They likened the data to point electric charges of various signs and magnitudes distributed over space. The resulting electric potential over space produced by summing the potentials of the point charges corresponded to the interpolated surface. In this analogy, the kernel function is the potential of a point charge, which falls off as the reciprocal of the distance from the charge. Connell and Utgoff (1987) applied an actor-critic method to the pole-balancing task in which the critic approxi\u0026shy;mated the value function using kernel regression with inverse distance weight\u0026shy;ing given by \\A1\\B0Shepard\\A1\\AFs function.\\A1\\B1 Predating widespread interest in kernel regression in machine learning, these authors did not use the term kernel, but referred to \\A1\\B0Shepard\\A1\\AFs method\\A1\\AF (Shepard, 1968). Their system could learn to balance the pole in about 16 episodes. Other kernel-based approaches to reinforcement learning include those of Ormoneit and Sen (2002), Dietterich and Wang (2002), Xu, Xie, Hu, Nu, and Lu (2005), Taylor and Parr (2009), Barreto, Precup, and Pineau (2011), and Bhat, Farias, and Moallemi (2012).\nThe earliest example we know of in which function approximation methods were used for learning value functions was Samuel\\A1\\AFs checkers player (1959, 1967). Samuel followed Shannon\\A1\\AFs (1950) suggestion that a value function did not have to be exact to be a useful guide to selecting moves in a game and that it might be approximated by linear combination of features. In addition to linear function approximation, Samuel experimented with lookup tables and hierarchical lookup tables called signa\u0026shy;ture tables (Griffith, 1966, 1974; Page, 1977; Biermann, Fairfield, and Beres, 1982).\nAt about the same time as Samuel\\A1\\AFs work, Bellman and Dreyfus (1959) proposed using function approximation methods with DP. (It is tempting to think that Bell\u0026shy;man and Samuel had some influence on one another, but we know of no reference to the other in the work of either.) There is now a fairly extensive literature on function approximation methods and DP, such as multigrid methods and methods using splines and orthogonal polynomials (e.g., Bellman and Dreyfus, 1959; Bellman, Kalaba, and Kotkin, 1973; Daniel, 1976; Whitt, 1978; Reetz, 1977; Schweitzer and Seidmann, 1985; Chow and Tsitsiklis, 1991; Kushner and Dupuis, 1992; Rust, 1996).\nHolland\\A1\\AFs (1986) classifier system used a selective feature-match technique to gen\u0026shy;eralize evaluation information across state-action pairs. Each classifier matched a subset of states having specified values for a subset of features, with the remaining features having arbitrary values (\\A1\\B0wild cards\\A1\\B1). These subsets were then used in a conventional state-aggregation approach to function approximation. Holland\\A1\\AFs idea was to use a genetic algorithm to evolve a set of classifiers that collectively would im\u0026shy;plement a useful action-value function. Holland\\A1\\AFs ideas influenced the early research of the authors on reinforcement learning, but we focused on different approaches to function approximation. As function approximators, classifiers are limited in several ways. First, they are state-aggregation methods, with concomitant limitations in scaling and in representing smooth functions efficiently. In addition, the matching rules of classifiers can implement only aggregation boundaries that are parallel to the feature axes. Perhaps the most important limitation of conventional classifier systems is that the classifiers are learned via the genetic algorithm, an evolutionary method. As we discussed in Chapter 1, there is available during learning much more detailed information about how to learn than can be used by evolutionary methods. This perspective led us to instead adapt supervised learning methods for use in rein\u0026shy;forcement learning, specifically gradient-descent and neural network methods. These differences between Holland's approach and ours are not surprising because Holland's ideas were developed during a period when neural networks were generally regarded as being too weak in computational power to be useful, whereas our work was at the beginning of the period that saw widespread questioning of that conventional wisdom. There remain many opportunities for combining aspects of these different approaches.\nChristensen and Korf (1986) experimented with regression methods for modifying coefficients of linear value function approximations in the game of chess. Chapman and Kaelbling (1991) and Tan (1991) adapted decision-tree methods for learning value functions. Explanation-based learning methods have also been adapted for learning value functions, yielding compact representations (Yee, Saxena, Utgoff, and Barto, 1990; Dietterich and Flann, 1995).\n \nChapter 10\nOn-policy Control with Approximation\nIn this chapter we turn to the control problem with parametric approximation of the action-value function q(s, a, w) ^ \\81\\96\\A3\\A8s,a), where w G Rdis a finite-dimensional weight vector. We continue to restrict attention to the on-policy case, leaving off- policy methods to Chapter 11. The present chapter features the semi-gradient Sarsa algorithm, the natural extension of semi-gradient TD(0) (last chapter) to action values and to on-policy control. In the episodic case, the extension is straightforward, but in the continuing case we have to take a few steps backward and re-examine how we have used discounting to define an optimal policy. Surprisingly, once we have genuine function approximation we have to give up discounting and switch to a new \\A1\\B0average-reward\\A1\\B1 formulation of the control problem with new value functions.\nStarting first in the episodic case, we extend the function approximation ideas presented in the last chapter from state values to action values. Then we extend them to control following the general pattern of on-policy GPI, using e-greedy for action selection. We show results for n-step linear Sarsa on the Mountain Car problem. Then we turn to the continuing case and repeat the development of these ideas for the average-reward case with differential values.\n10.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Episodic Semi-gradient Control\nThe extension of the semi-gradient prediction methods of Chapter 9 to action values is straightforward. In this case it is the approximate action-value function, q^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,\u0026nbsp; that\nis represented as a parameterized functional form with weight vector w. Whereas before we considered random training examples of the form St ^ Ut, now we consider examples of the form St, At ^ Ut. The target Ut can be any approximation of qn (St, At), including the usual backed-up values such as the full Monte Carlo return, Gt, or any of the n-step Sarsa returns (7.4). The general gradient-descent update for action-value prediction is\nwt+i = wt + aUt - q(St, At, wt) Vq(St, At, wt).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.1)\nFor example, the update for the one-step Sarsa method is\nwt+i =wt + a Rt+i + 7q(St+i, At+i, wt) - q(St, At, wt) Vq(St, At, wt). (10.2)\nWe call this method episodic semi-gradient one-step Sarsa.For a constant policy, this method converges in the same way that TD(0) does, with the same kind of error bound (9.13).\nTo form control methods, we need to couple such action-value prediction methods with techniques for policy improvement and action selection. Suitable techniques applicable to continuous actions, or to actions from large discrete sets, are a topic of ongoing research with as yet no clear resolution. On the other hand, if the action set is discrete and not too large, then we can use the techniques already developed in pre\u0026shy;vious chapters. That is, for each possible action aavailable in the current state St, we can compute q(St, a, wt) and then find the greedy action Ajf = argmaxa q(St, a, wt). Policy improvement is then done (in the on-policy case treated in this chapter) by changing the estimation policy to a soft approximation of the greedy policy such as the e-greedy policy. Actions are selected according to this same policy. Pseudocode for the complete algorithm is given in the box.\nEpisodic Semi-gradient Sarsa for Estimating q^\nInput: a differentiable function q : S x Ax Rd R\nInitialize value-function weights w G Rd arbitrarily (e.g., w = 0) Repeat (for each episode):\nS, A \\A1\\AA initial state and action of episode (e.g., e-greedy) Repeat (for each step of episode):\nTake action A, observe R, SfIf S1is terminal:\nw \\A1\\AA w + a [R - q(S, A, w)] Vq(S, A, w)\nGo to next episode Choose A1as a function of q(S;, \\A1\\F6, w) (e.g., e-greedy) w \\A1\\AA w + a[R + Yq(S;, A1, w) - q(S, A, w)] Vq(S, A, w)\nS \\A1\\AA S1\nA\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; A1\nExample 10.1: Mountain Car Task Consider the task of driving an underpow\u0026shy;ered car up a steep mountain road, as suggested by the diagram in the upper left of Figure 10.1. The difficulty is that gravity is stronger than the car's engine, and even at full throttle the car cannot accelerate up the steep slope. The only solution is to first move away from the goal and up the opposite slope on the left. Then, by\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 10.1:\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The\u0026nbsp; Mountain\u0026nbsp; Car\u0026nbsp; task(upper\u0026nbsp; leftpanel)\u0026nbsp; and\u0026nbsp; thecost-to-gofunction\n(-maxa q(s, a, w)) learned during one run.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n   104\n     applying full throttle the car can build up enough inertia to carry it up the steep slope even though it is slowing down the whole way. This is a simple example of a continuous control task where things have to get worse in a sense (farther from the goal) before they can get better. Many control methodologies have great difficulties with tasks of this kind unless explicitly aided by a human designer.\nThe reward in this problem is -1 on all time steps until the car moves past its goal position at the top of the mountain, which ends the episode. There are three possible actions: full throttle forward (+1), full throttle reverse (-1), and zero throttle (0). The car moves according to a simplified physics. Its position, xt, and velocity, xt, are updated by\nxt+i == bound [xt + xt+i]\nXt+i == bound [xt + 0.001 \\9E\\E9-0.0025 cos(3xt)],\nwhere the bound operation enforces \\A1\\AA1.2 \u0026lt; x^+i \u0026lt; 0.5 and \\A1\\AA0.07 \u0026lt; x^+i \u0026lt; 0.07. In addition, when xt+i reached the left bound, xt+i was reset to zero. When it reached the right bound, the goal was reached and the episode was terminated. Each episode started from a random position xt G [-0.6, -0.4) and zero velocity. To convert the two continuous state variables to binary features, we used grid-tilings as in Figure 9.9. We used 8tilings, with each tile covering 1/8th of the bounded distance in each dimension, and asymmetrical offsets as described in Section 9.5.4.i\naIn particular, we used the tile-coding software, available on the web, version 3 (Python), with\nThe feature vectors x(s, a) created by tile coding were then combined linearly with the parameter vector to approximate the action-value function:\nq(s, a, w) == wTx(s, a) = ^^ w^ \u0026#8226;\\B6\\F8(s, a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.3)\ni\nfor each pair of state, s, and action, a.\nFigure 10.1shows what typically happens while learning to solve this task with this form of function approximation.[17]Shown is the negative of the value function (the cost-to-gofunction) learned on a single run. The initial action values were all zero, which was optimistic (all true values are negative in this task), causing extensive exploration to occur even though the exploration parameter, e, was 0. This can be seen in the middle-top panel of the figure, labeled \\A1\\B0Step 428\\A1\\B1. At this time not even one episode had been completed, but the car has oscillated back and forth in the valley, following circular trajectories in state space. All the states visited frequently are valued worse than unexplored states, because the actual rewards have been worse than what was (unrealistically) expected. This continually drives the agent away from wherever it has been, to explore new states, until a solution is found.\nFigure 10.2shows several learning curves for semi-gradient Sarsa on this problem, with various step sizes.\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Mountain Car\nSteps per episode log scale\naveraged over 100 runs\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 10.2: Mountain Car learning curves for the semi-gradient Sarsa method with tile- coding function approximation and e-greedy action selection.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nExercise 10.1 Why have we not considered Monte Carlo methods in this chapter?\n\\A1\\F5\n\n\n10.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Semi-gradient Sarsa\nWe can obtain an n-step version of episodic semi-gradient Sarsa by using an n- step return as the update target in the semi-gradient Sarsa update equation (10.1). The n-step return immediately generalizes from its tabular form (7.4) to a function approximation form:\nGt:t+n = Rt+i+7Rt+2+ ' ' '+7^ 1\\B3\\F3t+n+'TKA+n, At+n, wt+n-l), n ^ \\B9\\A4,0^ t \u0026lt; T-n,\n(10.4)\nwith Gt\\A3\\BAt+n == Gt if t + n \u0026gt; T, as usual. The n-step update equation is\nwt+n == wt+n-l + a [Gt\\A3\\BAt+n _ q(St, At, wt+n-l)] Vq(St, At, wt+n-l),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0\u0026lt; t \u0026lt; T.\n(10.5)\nComplete pseudocode is given in the box below.\nEpisodic semi-gradient n-step Sarsa for estimating q ^ q^, or q ^ q^\nInput: a differentiable function q : S x A x Rd R, possibly n Initialize value-function weight vector w arbitrarily (e.g., w = 0)\nParameters: step size a \u0026gt; 0, small e \u0026gt; 0, a positive integer n\nAll store and access operations (St, At, and Rt) can take their index mod n\nRepeat (for each episode):\nInitialize and store So = terminal\nSelect and store an action Ao \u0026#12316;n(-|So) or e-greedy wrt q(So, \\A1\\F6, w)\nT \\A1\\AA o\nFor t = 0, 1, 2, . . . :\n| If t \u0026lt; T, then:\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Take action At\n|Observe and store the next reward as Rt+i and the next state as St+i\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If St+i is terminal, then:\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; T \\A1\\AA t + 1\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; else:\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Select and store At+i \u0026#12316;n(-|St+i) or e-greedy wrt q(St+i, \\A1\\F6, w)\n| t \\A1\\AA t - n + 1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (t is the time whose estimate is being updated)\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If t \u0026gt; 0:\ni\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; g \\A1\\AA srn^i+o y i-T-iRi\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; If t + n \u0026lt; T, then G \\A1\\AA G + 7n(?(Sr+n, A+n, w)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (Gr\\A3\\BAr+n\n|\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; w \\A1\\AA w + a [G - q(Sr, Ar, w)] Vq(Sr, Ar, w)\nUntil t = T \\A1\\AA 1\nAs we have seen before, performance is best if an intermediate level of bootstrap\u0026shy;ping is used, corresponding to an n larger than 1. Figure 10.3 shows how this\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Mountain Car\nSteps per episode log scale\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Episode\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 10.3: One-step vs multi-step performance of n-step semi-gradient Sarsa on the Moun\u0026shy;tain Car task. Good step sizes were used: a= 0.5/8 for n = 1and a= 0.3/8 for n = 8.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n   Mountain Car\nSteps per episode\naveraged over first 50 episodes and 100 runs\n        Figure 10.4: Effect of the a and n on early performance of n-step semi-gradient Sarsa and tile-coding function approximation on the Mountain Car task. As usual, an intermediate level of bootstrapping (n = 4) performed best. These results are for selected a values, on a log scale, and then connected by straight lines. The standard errors ranged from 0.5 (less than the line width) for n = 1 to about 4 for n = 16, so the main effects are all statistically significant.\n        ^ x number of tilings (8)\n        algorithm tends to learn faster and obtain a better asymptotic performance at n = 8 than at n = 1 on the Mountain Car task. Figure 10.4 shows the results of a more detailed study of the effect of the parameters a and n on the rate of learning on this task.\nExercise 10.2Give pseudocode for semi-gradient one-step ExpectedSarsa for con\u0026shy;trol.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 10.3 Why do the results shown in Figure 10.4 have higher standard errors at large n than at low n?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n     \n\n\u0026nbsp;\n10.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Average Reward: A New Problem Setting for Con\u0026shy;tinuing Tasks\nWe now introduce a third classical settingһalongside the episodic and discounted settings\\A1\\AAfor formulating the goal in Markov decision problems (MDPs). Like the discounted setting, the average reward setting applies to continuing problems, prob\u0026shy;lems for which the interaction between agent and environment goes on and on for\u0026shy;ever without termination or start states. Unlike that setting, however, there is no discounting\\A1\\AAthe agent cares just as much about delayed rewards as it does about immediate reward. The average-reward setting is one of the major settings con\u0026shy;sidered in the classical theory of dynamic programming and, though less often, in reinforcement learning. As we discuss in the next section, the discounted setting is problematic with function approximation, and thus the average-reward setting is needed to replace it.\nIn the average-reward setting, the quality of a policy n is defined as the average rate of reward while following that policy, which we denote as r(n):\n1T\nr(n)== lim t [ E[Rt 1Ao\\A3\\BAt-i \u0026#12316;n]\n\\C1\\CB400 \\81A\u0026nbsp; ^\nt=l\n=lim E[Rt | Ao\\A3\\BAt-i \u0026#12316;n] ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.6)\nt^^\n=E \u0026#12316;(s)E n(a|s)E p(s;, r|s, a)r,\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\nwhere the expectations are conditioned on the prior actions, Ao, Ai,..., At-i, being taken according to n, and is the steady-state distribution, (s) == limt^^ Pr{St = which is assumed to exist and to be independent of So. This property is known as ergodicity. It means that where the MDP starts or any early decision made by the agent can have only a temporary effect; in the long run your expectation of being in a state depends only on the policy and the MDP transition probabilities. Ergodicity is sufficient to guarantee the existence of the limits in the equations above.\nThere are subtle distinctions that can be drawn between different kinds of optimal\u0026shy;ity in the undiscounted continuing case. Nevertheless, for most practical purposes it may be adequate simply to order policies according to their average reward per time step, in other words, according to their r(n). This quantity is essentially the average reward under n, as suggested by (10.6). In particular, we consider all policies that attain the maximal value of r(n) to be optimal.\nNote that the steady state distribution is the special distribution under which, if you select actions according to n, you remain in the same distribution. That is, for which\n(s)[ n(a|s, w)p(s'|s,a)=\\C8\\E7(s').\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.7)\nsa\nIn the average-reward setting, returns are defined in terms of differences betweenrewards and the average reward:\n   (10.8)\n     Gt = Rt+i -r(n) + Rt+2-r(n) + Rt+3-r(n) +\nThis is known as the differential return, and the corresponding value functions are known as differential value functions. They are defined in the same way and we will use the same notation for them as we have all along:\u0026nbsp; (s) == En[Gt|St = s] and\nqn(s, a) == En[Gt|St = s, At = a] (similarly for v* and \\C8\\E7).Differential value functions also have Bellman equations, just slightly different from those we have seen earlier. We simply remove all 7s and replace all rewards by the difference between the reward and the true average reward:\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n(s) = ^2n(a|s^p(s', r|s, a) r- r(n) + v^(s')\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; r\\A3\\ACs.\n\n\n\u0026nbsp;SHAPE \u0026nbsp;\\* MERGEFORMAT    \u0026nbsp;\n      \u0026nbsp;\n \n   r - r(n) + [ n(a'|s')q^(s', a')\n        , and\n     \nqn (s,a) = \\B6\\FEp(s',r|s,a) r\\A3\\ACs7v^(s) = ma^ 7p(s', r|s, a) r\\A3\\ACs7q*(s,a) = \\B6\\FEp(s',r|s,a) r\\A3\\ACs7(cf. Eqs. 3.14, 4.1, and 4.2).\na7\nr - r(n) + v*(s')\n-r(n) + max q*(s', a')\na7\n \nThere is also a differential form of the two TD errors:\n   (10.9)\n(10.10)\n     ^t == Rt+i-Rt+i + v(St+i,wt) - v(St,wt), and ^t = Rt+i-Rt+i + 3(St+i, At+i, wt) - 3(St, At, wt).\nwhere Rt is an estimate at time t of the average reward r(n). With these alternate definitions, most of our algorithms and many theoretical results carry through to the average-reward setting.\nFor example, the average reward version of semi-gradient Sarsa is defined just as in (10.2) except with the differential version of the TD error. That is, by\n   (10.11)\n     wt+i == wt + a^tVq(St, At, wt),\nwith ^t given by (10.10). The pseudocode for the complete algorithm is given on the next page.\nDifferential semi-gradient Sarsa for estimating q^\nInput: a differentiable function q : S x Ax Rd\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; R\nParameters: step sizes a, ^ \u0026gt; 0\nInitialize value-function weights w G Rd arbitrarily (e.g., w = 0) Initialize average reward estimate Rarbitrarily (e.g., R = 0) Initialize state S, and action A\nRepeat (for each step):\nTake action A, observe R, Sح\nChoose A;as a function of q(S;, \\A1\\F6, w) (e.g., e-greedy)\n5R - R + q(S;, A;, w) - q(S, A, w)\nR \\A1\\AA R + ^5\nw \\A1\\AA w + a5Vq(S, A, w)\nS \\A1\\AA Sح ^Af\nExample 10.2: An Access-Control Queuing Task This is a decision task involving access control to a set of kservers. Customers of four different priorities arrive at a single queue. If given access to a server, the customers pay a reward of 1, 2, 4, or 8to the server, depending on their priority, with higher priority customers paying more. In each time step, the customer at the head of the queue is either accepted (assigned to one of the servers) or rejected (removed from the queue, with a reward of zero). In either case, on the next time step the next customer in the queue is considered. The queue never empties, and the priorities of the customers in the queue are equally randomly distributed. Of course a customer can not be served if there is no free server; the customer is always rejected in this case. Each busy server becomes free with probability pon each time step. Although we have just described them for definiteness, let us assume the statistics of arrivals and departures are unknown. The task is to decide on each step whether to accept or reject the next customer, on the basis of his priority and the number of free servers, so as to maximize long-term reward without discounting.\nIn this example we consider a tabular solution to this problem. Although there is no generalization between states, we can still consider it in the general function approximation setting as this setting generalizes the tabular setting. Thus we have a differential action-value estimate for each pair of state (number of free servers and priority of the customer at the head of the queue) and action (accept or reject). Figure 10.5 shows the solution found by differential semi-gradient Sarsa for this task with k = 10 and p = 0.06. The algorithm parameters were a = 0.01,¬=0.01, and e = 0.1. The initial action values and R were zero.\n10.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;    Policy\n        Priority\n        RFJFCT\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  1\n 1 1 1\n ACCEPT\n11 1 1 1 1 1\n    1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 2345678910\nNumber of free servers\n        Figure 10.5: The policy and value function found by differential semi-gradient one-step Sarsa on the access-control queuing task after 2million steps. The drop on the right of the graph is probably due to insufficient data; many of these states were never experienced. The value learned for Rwas about 2.31.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n        Value\nFunction\n        Number of free servers\n     Deprecating the Discounted Setting\nThe continuing, discounted problem formulation has been very useful in the tabular case, in which the returns from each state can be separately identified and averaged. But in the approximate case it is questionable whether one should ever use this problem formulation.\nTo see why, consider an infinite sequence of returns with no beginning or end, and no clearly identified states. The states might be represented only by feature vectors, which may do little to distinguish the states from each other. As a special case, all of the feature vectors may be the same. Thus one really has only the reward sequence (and the actions), and performance has to be assessed purely from these. How could it be done? One way is by averaging the rewards over a long interval\\A1\\AAthis is the idea of the average-reward setting. How could discounting be used? Well, for each time step we could measure the discounted return. Some returns would be small and some big, so again we would have to average them over a sufficiently large time interval. In the continuing setting there are no starts and ends, and no special time steps, so there is nothing else that could be done. However, if you do this, it turns out that the average of the discounted returns is proportional to the average reward. In fact, for policy n, the average of the discounted returns is always r(n)/(1 - 7), \n \nthat is, it is essentially the average reward, r(n). In particular, the orderingof all policies in the average discounted return setting would be exactly the same as in the average-reward setting. The discount rate 7thus has no effect on the problem formulation. It could in fact be zeroand the ranking would be unchanged.\nThis surprising fact is proven in the box, but the basic idea can be seen via a symmetry argument. Each time step is exactly the same as every other. With discounting, every reward will appear exactly once in each position in some return. The tth reward will appear undiscounted in the t - 1st return, discounted once in the t - 2nd return, and discounted 999 times in the t - 1000th return. The weight on the tth reward is thus 1 + 7+ y2+ y3+ \\A1\\F6\\A1\\F6\\A1\\F6 = 1/(1 - 7). Since all states are the same, they are all weighted by this, and thus the average of the returns will be this times the average reward, or r(n)/(1- 7).\nSo in this key case, what the discounted case was invented for, discounting is not applicable. The discounted case is still pertinent, or at least possible, for the episodic case.\nThe Futility of Discounting in Continuing Problems\nPerhaps discounting can be saved by choosing an objective that sums dis\u0026shy;counted values over the distribution with which states occur under the policy:\nJ(n)= I] (s)vj(s)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (wherev? is the discounted value function)\ns\n=E \\C8\\E7(s)E أ(a|s) E y^p(s', r|s, a) [r + 7#(s')] (Bellman Eq.)\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z s\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s7r\n=r(n) + [\\C8\\E7(s)Ylأ(a|s) [ [ W, r|s, a)7vY(s') (from (10.6))\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s7r\n=r(n) + 7Evy (s')E\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (s) n(a|s)p(s |s, a)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (3.10))\ns7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; sa\n=r(n) + 7[ vY(s')^n(s')\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (10.7))\ns7\n=r(n) + 7J (n)\n=r(n) + 7r(n) + 72J (n)\n=r(n) + 7r(n) + 72r(n) + 73r(n) +---------- \n   r(n).\n     =1\n1\u0026nbsp;\u0026nbsp; -7\nThe proposed discounted objective orders policies identically to the undis\u0026shy;counted (average reward) objective. We have failed to save discounting!\n10.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Differential Semi-gradient Sarsa\nIn order to generalize to n-step bootstrapping, we need an n-step version of the TD error. We begin by generalizing the n-step return (7.4) to its differential form, with function approximation:\nGt:t+n = Rt+i --Rt+i + Rt+2-\\B3\\F3t+2+ \\A1\\F6 \\A1\\F6 \\A1\\F6 + Rt+n-\\B3\\F3t+n + ^(St+n, At+n, wt+n-i),\n(10.12)\nwhere R is an estimate of r(n), n \u0026gt; 1, and t + n \u0026lt; T. If t + n \u0026gt; T, then we define Gt\\A3\\BAt+n == Gt as usual. The n-step TD error is then\n   (10.13)\n     5t = Gt:t+n - 3(St, At, w).\nafter which we can apply our usual semi-gradient Sarsa update (10.11). Pseudocode for the complete algorithm is given in the box.\nDifferential semi-gradient n-step Sarsa for estimating q ^ q^, or q ^ q^\nInput: a differentiable function q : S x A x Rm\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; R, a policy n\nInitialize value-function weights w G Rm arbitrarily (e.g., w = 0)\nInitialize average-reward estimate R G R arbitrarily (e.g., R = 0) Parameters: step size a, ^ \u0026gt; 0, a positive integer n\nAll store and access operations (St, At, and Rt) can take their index mod n\nInitialize and store So and Ao For t = 0,1, 2,...:\nTake action At\nObserve and store the next reward as Rt+i and the next state as St+i Select and store an action At+i \u0026#12316;n(-|St+i), or e-greedy wrt q(So, \\A1\\F6, w) t \\A1\\AA t - n + 1\u0026nbsp;\u0026nbsp; (t is the time whose estimate is being updated)\nIf t \u0026gt; 0:\n5\\A1\\AA^T=+J-Vi(Ri - R) + q(ST +n, At+n, w) - q(Sr, At, w)\nR \\A1\\AA R + ^5\nw \\A1\\AA w + a5Vq(Sr, Ar, w)\n10.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nIn this chapter we have extended the ideas of parameterized function approximation and semi-gradient descent, introduced in the previous chapter, to control. The ex\u0026shy;tension is immediate for the episodic case, but for the continuing case we have to introduce a whole new problem formulation based on maximizing the average reward per time step. Surprisingly, the discounted formulation cannot be carried over to control in the presence of approximations. In the approximate case most policies cannot be represented by a value function. The arbitrary policies that remain need to be ranked, and the scalar average reward r(n) provides an effective way to do this.\nThe average reward formulation involves new differentialversions of value func\u0026shy;tions, Bellman equations, and TD errors, but all of these parallel the old ones, and the conceptual changes are small. There is also a new parallel set of differential algorithms for the average-reward case. We illustrate this by developing differential versions of semi-gradient n-step Sarsa.\nBibliographical and Historical Remarks\n10.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Semi-gradient Sarsa with function approximation was first explored by Rum- mery and Niranjan (1994). Linear semi-gradient Sarsa with e-greedy action selection does not converge in the usual sense, but does enter a bounded region near the best solution (Gordon, 1995). Precup and Perkins (2003) showed convergence in a differentiable action selection setting. See also Perkins and Pendrith (2002) and Melo, Meyn, and Ribiero (2008). The mountain-car example is based on a similar task studied by Moore (1990), but the exact form used here is from Sutton (1996).\n10.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Episodic n-step semi-gradient Sarsa is based on the forward Sarsa(\\C8\\EB)algo\u0026shy;rithm of van Seijen (2016). The empirical results shown here are new to the second edition of this text.\n10.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The average-reward formulation has been described for dynamic program\u0026shy;ming (e.g., Puterman, 1994) and from the point of view of reinforcement learning (Mahadevan, 1996; Tadepalli and Ok, 1994; Bertsekas and Tsitiklis, 1996; Tsitsiklis and Van Roy, 1999). The algorithm described here is the on- policy analog of the \\A1\\B0R-learning\\A1\\B1 algorithm introduced by Schwartz (1993). The name R-learning was probably meant to be the alphabetic successor to Q-learning, but we prefer to think of it as a reference to the learning of differ\u0026shy;ential or relativevalues. The access-control queuing example was suggested by the work of Carlstrom and Nordstrom (1997).\n10.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The recognition of the limitations of discounting as a formulation of the rein\u0026shy;forcement learning problem with function approximation became apparent to the authors shortly after the publication of the first edition of this text. The second edition of this book may be the first publication of the demonstration of the futility of discounting in the box on page 265.\n10.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The differential version of n-step semi-gradient Sarsa is new to this text and has not been significantly studied.\n \nChapter 11\nOff-policy Methods with Approximation\nThis book has treated on-policy and off-policy learning methods since Chapter 5 primarily as two alternative ways of handling the conflict between exploitation and exploration inherent in learning forms of generalized policy iteration. The two chap\u0026shy;ters preceding this have treated the on-policy case with function approximation, and in this chapter we treat the off-policy case with function approximation. The exten\u0026shy;sion to function approximation turns out to be significantly different and harder for off-policy learning than it is for on-policy learning. The tabular off-policy methods developed in Chapters 6and 7 readily extend to semi-gradient algorithms, but these algorithms do not converge nearly as robustly as they do under on-policy training. In this chapter we explore the convergence problems, take a closer look at the theory of linear function approximation, introduce a notion of learnability, and then discuss new algorithms with stronger convergence guarantees for the off-policy case.\nRecall that in off-policy learning we seek to learn a value function for a target policyn, given data due to a different behavior policyb. In the prediction case, both policies are static and given, and we seek to learn either state values v \\B0\\D1or action values q \\B0\\D1q^. In the control case, action values are learned, and both policies typically change during learning\\A1\\AAn being the greedy policy with respect to q, and b being something more exploratory such as the e-greedy policy with respect to q.\nThe challenge of off-policy learning can be divided into two parts, one that arises in the tabular case and one that arises only with function approximation. The first part of the challenge has to do with the target of the learning update, and the second part has to do with the distribution of the updates. The techniques related to importance sampling and rejection sampling developed in Chapters 6and 7 deal with the first part; these may increase variance but are needed in all successful algorithms, tabular and approximate. The extension of these techniques to function approximation are quickly dealt with in the first section of this chapter.\nSomething more is needed for the second part of the challenge of off-policy learning with function approximation because the distribution of updates in the off-policycase is not according to the on-policy distribution. The on-policy distribution is important to the stability of semi-gradient methods. Two general approaches have been explored to deal with this. One is to use importance sampling methods again, this time to warp the update distribution back to the on-policy distribution, so that semi-gradient methods are guaranteed to converge (in the linear case). The other is to develop true gradient methods that do not rely on any special distribution for stability. We present methods based on both approaches. This is a cutting- edge research area, and it is not clear which of these approaches is most effective in practice.\n11.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Semi-gradient Methods\nWe begin by describing how the methods developed in earlier chapters for the off- policy case extend readily to function approximation as semi-gradient methods. These methods address the first part of the challenge of off-policy learning but not the second part. Although these methods may diverge in some cases, and in that sense are not sound, they are still often successfully used. Remember that these methods are guaranteed stable and asymptotically unbiased for the tabular case, which corresponds to a special case of function approximation. So it may still be possible to combine them with feature selection methods in such a way that the combined system could be assured stable. In any event, these methods are simple and thus a good place to start.\nIn Chapter 7 we described a variety of tabular off-policy algorithms. To convert them to semi-gradient form, we simply replace the update to the array (V or Q) to an update to the weight vector (w), using the approximate value function (v or q)\n   and its gradient. Many of ratio:\n\\B6\\FE\\A1\\AA n(At|St)\nPt= Pt\\A3\\BAt= b(At|St).\nFor example, the one-step,\n     these algorithms use the per-step importance sampling\n(11.1)\nstate-value algorithm is semi-gradient off-policy TD(0), which is just like the corresponding on-policy algorithm (page 217) except for the addition of pt:\nwt+i = wt + apt^tVv(St ,wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.2)\nwhere 5t is defined appropriately depending on whether the problem is episodic and discounted, or continuing and undiscounted using average reward:\n^t = Rt+i + 7v(St+i,wt) - v(St,wt), or\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (episodic)\n^t = Rt+i - Rt + v(St+i,wt) - -0(St,wt).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (continuing)\nFor action values, the one-step algorithm is semi-gradient Expected Sarsa:\n   (11.3)\n     wt+i = wt + a^tVq(St, At, wt), with\n^t == Rt+i + ^^n(a|St+i)q(St+i,a, wt) - q(St, At, wt), or\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (episodic)\na\n^t = Rt+i - Rt + ^ n(a|St+i)q(St+i,a, wt) - q(St, At, wt). (continuing)\na\nNote that this algorithm does not use importance sampling. In the tabular case it is clear that this is appropriate because the only sampled action is At, and in learning its value we do not have to consider any other actions. With function approximation it is less clear because we might want to weight different state-action pairs differently once they all contribute to the same overall approximation. Proper resolution of this issue awaits a more thorough understanding of the theory of function approximation in reinforcement learning.\nIn the multi-step generalizations of these algorithms, both the state-value and action-value algorithms involve importance sampling. For example, the n-step ver\u0026shy;sion of semi-gradient Expected Sarsa is\nwt+n == wt+n-i + apt+i \u0026#8226; \u0026#8226; \u0026#8226; pt+n-i [Gt\\A3\\BAt+n - q(St, At, wt+n-i)] Vq(St, At, wt+n-i)\n(11.4)\nwith\nGt:t+n = Rt+i + \u0026#8226; \u0026#8226; \u0026#8226; + 7n iRt+n + 7nq(St+ n, At+n, wt+n-i), or (episodic)\nGt\\A3\\BAt+n = Rt+i - Rt +----- + Rt+n - Rt+n-i + q(St+n, At+n, wt+n-i), (continuing)\nwhere here we are being slightly informal in our treatment of episodes\\A1\\AF end. In the first equation, the pts for t \u0026gt; T should be taken to be 1, and Gt\\A3\\BAnshould be taken to be Gt if t + n \u0026gt; T.\nRecall that we also presented in Chapter 7 on off-policy algorithm that does not involve importance sampling at all: the n-step tree-backup algorithm. Here is its semi-gradient version:\nwt+n = wt+n-i + a [Gt\\A3\\BAt+n \\A1\\AA q(St, At, wt+n-i)] Vq(St, At, wt+n-i), with (11.5)\nt+n-i\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\nGt\\A3\\BAt+n ^ q(St, At, wt-i) + L ^ n 7n(Ai|Si),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.6)\nk=t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+i\nwith ^t as defined on the previous page for Expected Sarsa. We also defined in Chapter 7 an algorithm that unifies all action-value algorithms: n-step Q(a). We leave the semi-gradient form of that algorithm, and also of the n-step state-value algorithm, as exercises to the reader.\nExercise 11.1 Convert the equation of n-step off-policy TD (7.7) to semi-gradient form. Give accompanying definitions of the return for both the episodic and contin\u0026shy;uing cases.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n^Exercise 11.2 Convert the equations of n-step Q(a) (7.9, 7.14, 7.16, and 7.17) to semi-gradient form. Give definitions that cover both the episodic and continuing cases.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n11.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Examples of Off-policy Divergence\nIn this section we begin to discuss the second part of the challenge of off-policy learning with function approximation\\A1\\AAthat the distribution of updates does not match the on-policy distribution. We describe some instructive counterexamples to off-policy learning\\A1\\AAcases where semi-gradient and other simple algorithms are unstable and diverge.\nTo establish intuitions, it is best to consider first a very simple example. Suppose, perhaps as part of a larger MDP, there are two states whose estimated values are of the functional form w and 2w, where the parameter vector w consists of only a single component w. This occurs under linear function approximation with single\u0026shy;component feature vectors for the two states of 1 and 2 respectively. In the first state, there is only one action available, and it results deterministically in a transition to the second state with a reward of 0:\nSuppose initially w = 10. The transition will then be from a state of estimated value 10 to a state of estimated value 20. It will look like a good transition, and w will be increased to raise the first state\\A1\\AFs estimated value. If 7is nearly 1, then the TD error will be nearly 10, and, if a = 0.1, then w will be increased to nearly 11in trying to reduce the TD error. However, the second state\\A1\\AFs estimated value will also be increased, to nearly 22. If the transition occurs again, then it will be from a state of estimated value d1 to a state of estimated value f^22, for a TD error of d1\\A1\\AAlarger, not smaller than before. It will look even more like the first state is undervalued, and its value will be increased again, this time to d2.1. This looks bad, and in fact with further updates w will diverge to infinity. To see this definitively we have to look more carefully at the sequence of updates. The TD error on a transition between the two states is\n5t = Rt+i + Yv(St+i,wt) - v(St,wt) = 0+ 72wt - wt = (27- 1)wt, and the off-policy semi-gradient TD(0) update (from (11.2)) is\nwt+i = wt + apt5tVv(St,wt) = wt + a \\A1\\F6 1\\A1\\F6 (27- 1)wt \\A1\\F6 1= (1+ a(2? - 1))wt.\nNote that the importance sampling ratio, pt, is 1 on this transition because there is only one action available from the the first state, so its probabilities of being taken under the target and behavior policies must both be 1. In the final update above, the new parameter is the old parameter times a scalar constant, 1 + a(2Y - 1). If this constant is greater than 1, then the system is unstable and w will go to positive or negative infinity depending on its initial value. Here this constant is greater than 1 whenever 7\u0026gt; 0.5. Note that stability does not depend on the specific step size, as long as a \u0026gt; 0. Smaller or larger step sizes would affect the rate at which w goes to infinity, but not whether it goes there or not.\nKey to this example is that the one transition occurs repeatedly without w being updated on other transitions. This is possible under off-policy training because\n \nthe behavior policy might select actions on those other transitions which the target policy never would. For these transitions, pt would be zero and no update would be made. Under on-policy training, however, pt is always one. Each time there is a transition from the wstate to the 2w state, increasing w, there would also have to be a transition out of the 2w state. That transition would reduce w, unless is was to a state whose value was higher (because 7\u0026lt; 1) than 2w, and then that state would have to be followed by a state of even higher value, or else it would be reduced. Each state can support the one before only by creating a higher expectation. Eventually the piper must be paid. In the on-policy case the promise of future reward must be kept and the system is kept in check. But in the off-policy case, a promise can be made and then, after taking an action that the target policy never would, forgotten and forgiven.\nThis simple example communicates much of the reason why off-policy training can lead to divergence, but it is not completely convincing because it is not complete\\A1\\AAit is just a fragment of a complete MDP. Can there really be a complete system with instability? The simplest complete example of divergence is Baird's counterexample. Consider the episodic seven-state, two-action MDP shown in Figure 11.1. The dashed action takes the system to one of the six upper states with equal probability, whereas the solid action takes the system to the seventh state. The behavior policy bselects the two actions with probabilities | and \u0026#8226;, so that the next-state distribution under it is uniform (the same for all nonterminal states), which is also the starting distribution for each episode. The target policy n always takes the solid action, and so the on- policy distribution is concentrated in the seventh state. The reward is zero on all transitions. The discount rate is 7= 0.99.\n   Figure 11.1: Baird\\A1\\AFs counterexample. The approximate state-value function for this Markov process is of the form shown by the linear expressions inside each state. The solid action usually results in the seventh state, and the dashed action usually results in one of the other six states, each with equal probability. The reward is always zero.\n     Consider estimating the state-value under the linear parameterization indicated by the expression shown in each state circle. For example, the estimated value ofthe first state is 2wi + ws, where the subscript corresponds to the component of the overall weight vector w G R8; this corresponds to a feature vector for the first state being x(1) = (2, 0, 0, 0, 0, 0, 0, 1)T. The reward is zero on all transitions, so the true value function is v^ (s) = 0, for all s, which can be exactly approximated if w = 0. In fact, there are many solutions, as there are more components to the weight vector (8) than there are nonterminal states (7). Moreover, the set of feature vectors, {x(s) : s G S}, is a linearly independent set. In all these ways this task seems a favorable case for linear function approximation.\nIf we apply semi-gradient TD(0) to this problem (11.2), then the weights diverge to infinity, as shown in Figure 11.2 (left). The instability occurs for any positive step size, no matter how small. In fact, it even occurs if we do a DP-style expected backup instead of a learning backup, as shown in Figure 11.2 (right). That is, if the weight vector, wk, is updated in sweeps through the state space, performing a synchronous, semi-gradient backup at every state, s, using the DP (full backup) target:\nwk+i == wk + \\B6\\FE(E[Rt+i + 7v(St+i,wk) | St = s] - v(s,wk)) Vv(s,wk). (11.7)\nIn this case, there is no randomness and no asynchrony. Each state is updated exactly once per sweep as in a classical DP backup. The method is entirely conventional except in its use of semi-gradient function approximation. Yet still the system is unstable.\nIf we alter just the distribution of DP backups in Baird\\A1\\AFs counterexample, from the uniform distribution to the on-policy distribution (which generally requires asyn-\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nFigure 11.2: Demonstration of instability on Baird\\A1\\AFs counterexample. Shown are the evolu\u0026shy;tion of the components of the parameter vector w of the two semi-gradient algorithms. The step size was a = 0.01, and the initial weights were w = (1,1,1,1,1,1,10,1)T.\nchronous updating), then convergence is guaranteed to a solution with error bounded by (9.13). This example is striking because the TD and DP methods used are ar\u0026shy;guably the simplest and best-understood bootstrapping methods, and the linear, semi-descent method used is arguably the simplest and best-understood kind of function approximation. The example shows that even the simplest combination of bootstrapping and function approximation can be unstable if the backups are not done according to the on-policy distribution.\nThere are also counterexamples similar to Baird\\A1\\AFs showing divergence for Q-learning. This is cause for concern because otherwise Q-learning has the best convergence guarantees of all control methods. Considerable effort has gone into trying to find a remedy to this problem or to obtain some weaker, but still workable, guarantee. For example, it may be possible to guarantee convergence of Q-learning as long as the behavior policy (the policy used to select actions) is sufficiently close to the esti\u0026shy;mation policy (the policy used in GPI), for example, when it is the e-greedy policy. To the best of our knowledge, Q-learning has never been found to diverge in this case, but there has been no theoretical analysis. In the rest of this section we present several other ideas that have been explored.\nSuppose that instead of taking just a step toward the expected one-step return on each iteration, as in Baird\\A1\\AFs counterexample, we actually change the value function all the way to the best, least-squares approximation. Would this solve the instability problem? Of course it would if the feature vectors, {x(s) : sG S}, formed a linearly independent set, as they do in Baird\\A1\\AFs counterexample, because then exact approx\u0026shy;imation is possible on each iteration and the method reduces to standard tabular DP. But of course the point here is to consider the case when an exact solution is notpossible. In this case stability is not guaranteed even when forming the best approximation at each iteration, as shown by the counterexample in the box on the next page.\nAnother way to try to prevent instability is to use special methods for function approximation. In particular, stability is guaranteed for function approximation methods that do not extrapolate from the observed targets. These methods, called averagers, include nearest neighbor methods and local weighted regression, but not popular methods such as tile coding and backpropagation.\n\n\nTsitsiklis and Van Roy\\A1\\AFs Counterexample to DP policy evaluation with least- squares linear function approximation\nThe simplest full counterexample to the least-squares idea is the w-to-2w ex\u0026shy;ample (from earlier in this section) extended with a terminal state:\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n 1\\A1\\AA e\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n @\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nAs before, the estimated value of the first state is w, and the estimated value of the second state is 2w. The reward is zero on all transitions, so the true values are zero at both states, which is exactly representable with w = 0. If we set wk+i at each step so as to minimize the MSVE between the estimated value and the expected one-step return, then we have\n\n\n   2\n        E (v\nsGS\n        (s,w) - En[Rt+i + 7v(St+i,wk) I St = s]\n        arg min\nwGR\n        wk+i\n     \u0026nbsp;\n argmin (w - y2w^ + (2w - (1- e)Y2wk)2 wGR\n   (11.8)\n     6-4e\n-7wk.\n5\nThe sequence {wk} diverges when 7\u0026gt; and wo = 0.\n11.3The Deadly Triad\nOur discussion so far can be summarized by saying that the danger of instability and divergence arises whenever we combine all of the following three elements, making up what we call the deadly triad:\nFunction approximation A powerful, scalable way of generalizing from a state space much larger than the memory and computational resources (e.g., linear function approximation or artificial neural networks).\nBootstrapping Update targets that include existing estimates rather than rely\u0026shy;ing exclusively on actual rewards and complete returns (e.g., as in dynamic programming or TD learning).\nOff-policy training Training on a distribution of transitions other than that pro\u0026shy;duced by the target policy. Sweeping through the state space and updating all states uniformly, as in dynamic programming, does not respect the target policy and is an example of off-policy training.\n \nIn particular, note that the danger is notdue to control, or to generalized policy iteration. Those cases are more complex to analyze, but the instability arises in the simpler prediction case whenever it includes all three elements of the deadly triad. The danger is also notdue to learning or to the uncertainties involved in estimation, as it occurs just as strongly in planning methods, such as dynamic programming, in which the environment is completely known.\nAny two elements of the deadly triad can be present without the third without creating instability. It is natural, then, to go through the three and see if there is any one that can be given up.\nOf the three, function approximationmost clearly can not be given up. We need methods that scale to large problems and to great expressive power. We need at least linear function approximation with many features and parameters. State aggregation or non-parametric methods whose complexity grows with data are too weak or too expensive. Least-squares methods such as LSTD are of quadratic complexity and are too expensive.\nDoing without bootstrappingis possible, at the cost of computational and data efficiency. Perhaps most important are the losses in computational efficiency. Monte Carlo (non-bootstrapping) methods require memory to save everything that happens between making each prediction and obtaining the final return, and all their com\u0026shy;putation is done once the final return is obtained. The cost of these computational issues is not apparent on serial von Neumann computers, but would be on specialized hardware. With bootstrapping and eligibility traces (Chapter 12), data can be dealt with when and where it is generated, then need never be used again. The savings in communication and memory made possible by bootstrapping are great.\nThe losses in data efficiency by giving up bootstrappingare also significant. We have seen this repeatedly, such as in Chapters 7 (Figure 7.2) and 9 (Figure 9.2), where some degree of bootstrapping performed much better than Monte Carlo methods on the random-walk prediction task, and in Chapter 10 where the same was seen on the Mountain-Car control task (Figure 10.4). Many other problems show much faster learning with bootstrapping. Figure 12.14 shows a few examples on other small problems. Bootstrapping allows learning to take advantage of the state prop\u0026shy;erty, the ability to recognize a state upon returning to it. On problems where the state representation is poor and causes poor generalization, bootstrapping can impair learning. One example of this seems to be Tetris (see f^imsek, Algorta, and Kothiyal, 2016). A poor state representation can also result in bias; this in the reason for the poorer bound on the asymptotic approximation quality of bootstrapping methods (Equation 9.13). On balance, a bootstrapping ability has to be considered extremely valuable. One may sometimes choose not to use it by selecting long backups (or a large bootstrapping parameter,\\C8\\EB\\B0\\D11; see Chapter 12) but oftimes bootstrapping greatly increases efficiency. It's an ability that we would very much like to keep in our toolkit.\nFinally, there is off-policy learning; can we give it up? On-policy methods are often adequate. For model-free reinforcement learning, one can simply use Sarsa rather than Q-learning. Off-policy methods free behavior from the target policy.\nThis could be considered an appealing convenience but not a necessity. However, off-policy learning is essential to other anticipated use cases, cases that we have not yet mentioned in this book but may be important to the larger goal of creating a powerful intelligent agent.\nIn these use cases, the agent learns not just a single value function and single policy, but large numbers of them in parallel. There is extensive psychological evidence that people and animals learn to predict many different sensory events, not just rewards. We can be surprised by unusual events, and correct our predictions about them, even if they are of neutral valence. This kind of prediction presumably underlies predictive models of the world such as are used in planning. We predict what we will see after eye movements, how long it will take to walk home, the probability of making a jump shot in basketball, and the satisfaction we will get from taking on a new project. In all these cases, the events we would like to predict depend on our acting in a certain way. To learn them all, in parallel, requires learning from the one stream of experience. There are many target policies, and thus the one behavior policy can not equal all of them. Yet parallel learning is conceptually possible, because the behavior policy may overlap in part with many of the target policies. To take full advantage of this requires off-policy learning.\n11.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Linear Value-function Geometry\nTo better understand the stability challenge of off-policy learning, it is helpful to think about value function approximation more abstractly. We can imagine the space of all possible state-value functions, of all functions from states to real num\u0026shy;bers v : S R. Most of these value functions do not correspond to any policy. More important for our purposes is that most are not representable by the function approximator, which by design has far fewer parameters than there are states.\nGiven an enumeration of the state space S = {si, s2,\\A1\\AD,s|g|}, any value function v corresponds to a vector listing the value of each state in order [v(si), v(s2),\\A1\\AD,v(s|S|)]T. This vector representation of a value function has as many components as there are states. In most cases where we want to use function approximation that would be far too many to represent the vector explicitly. Nevertheless, the idea of this vector is conceptually useful. In the following, we treat a value function and its vector representation interchangably.\nTo develop intuitions, consider the case with three states S = {si, s2, s3} and two parameters w = (wi, w2)T. We can then view all value functions/vectors as points in a three-dimensional space. The parameters provide an alternative coordinate system over a two-dimensional subspace. For any pair of numbers (x, y), we can set wi = x and w2= y to produce a parameter vector\\A1\\AAa point in the two-dimensional subspace\\A1\\AAand thus a complete value function vw lying within the subspace and that assigns values to all three states. In general the subspace of representable functions could be curved and twisted, even not one-to-one, but in the case of linear value- function approximation it is a simple plane, as suggested by Figure 11.3.\n \nFigure 11.3: The geometry of linear value-function approximation. Shown as a plane is the subspace of all functions representable by the function approximator. The three-dimensional space above and below it is the much larger space of all value functions (functions from S to R). The true value function is in this larger space and projects down to its best approximation in the value error (VE) sense. The best approximators in the Bellman error (BE) and projected Bellman error (PBE) senses are different and are also shown in the lower right. (VE, BE, and PBE are all treated as the corresponding vectors in this figure.) The Bellman operator takes a value function in the plane to one outside, which can then be projected back. If you could iteratively apply the Bellman operator outside the space (shown in gray above) you would reach the true value function, as in conventional DP.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nNow consider a single fixed policy n. We assume that its true value function, Vn, is too complex to be represented exactly as an approximation. Thus v^ is not in the subspace; in the figure it is depicted as being above the planar subspace of representable functions.\nIf Vn can not be represented exactly, what representable value function is closest to it? This turns out to be a subtle question, with multiple answers. To begin, we need a measure of the distance between two value functions. Given two value functions\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i and V2, we can talk about the vector difference between them, v = Vi - V2. If v is small, then the two value functions are close to each other. But how are we to measure the size of this difference vector? The conventional Euclidean norm is not appropriate because, as discussed in Section 9.2, some states are more important than others because they occur more frequently or because we are more interested in them (Section 9.10). As in Section 9.2, let us use the weighting ^ : S R to specify the degree to which we care about different states being accurately valued (often taken to be the on-policy distribution). We can then define the distance between\n\n\nvalue functions using the norm\n \n\u0026nbsp;\n \n   I:\n        (11.9)\n     x^(s\u0026gt;\\A2\\C82\nseS\n \n\u0026nbsp;\n \nNote that the MSVE from Section 9.2 can be written simply using this norm as MSVE(w) = ||vw - VnII\\A3\\BA. For any value function v, the operation of finding its closest value function in the subspace of representable value functions is a projection operation. We define a projection operator n that takes an arbitrary value function to the representable function that is closest in our norm:\n \n\u0026nbsp;\n \n   (11.10)\n        arg min\nw\n     nv == Vw where w\n \n\u0026nbsp;\n \nThe representable value function that is closest to the true value function is thus its projection, nv^, as suggested in Figure 11.3. This is the solution asymmptotically found by Monte Carlo methods, albeit often very slowly. The projection operation is discussed more fully in the box.\nThe projection matrix\nFor a linear function approximator, the projection operation is linear, which implies that it can be represented as an | S| x | S| matrix:\ni\n   (11.11)\n     n = x(xt dx xtd\n   where Ddenotes denotes the | S| x each state s:\n     the |S| x |S| diagonal matrix with /i on the diagonal, and X dmatrix whose rows are the feature vectors x(s)T, one for\nX1) o \u0026quot;\n \u0026nbsp;\n \u0026quot;-x(1)T-_\n  M2)\n , X =\n -x(2)T-\n  _ 0 \u0026quot;(|S|)_\n \u0026nbsp;\n -x(|S|)T-_\n    D\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n(Formally, the inverse in (11.11) may not exist, in which case the pseudoinverse is substituted.) Using these matrices, the norm of a vector can be written\n\n\n\u0026nbsp;\n \n   (11.12)\n(11.13)\n     i\\B2\\B7ii\\A3\\BA=\\BB\\A6٤\\A3\\AC\nand the approximate linear value function can be written vw = Xw.\n \n\u0026nbsp;\n \nTD methods find different solutions. To understand their rationale, recall that the Bellman equation for value function is\nvn(s) = ^2n(q|s^ p(s\u0026#12316;r|s,a)[r +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (s')] ,\u0026nbsp; Vs G S.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.14)\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s,\\A3\\ACr\n \nvn is the only value function that solves this equation exactly. For any approximate value function vw, the difference between the right and left sides can be used as a measure of how far off vw is from v^, in a Bellman equation sense. We call this the Bellman errorat state s:\n   (11.15)\nso that\n(11.16)\nBellman\n     (^w(s) = I ^أ(a|s)Ep(s',r|s,a) [r + 7vw(s')] I - vw(s)\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s7\\A3\\ACr\nwhere we have subtracted the left-hand side from the right (vis. (11.14)) =E [Rt+i + 7vw(St+i) - vw (St) | St = s, At \u0026#12316;n],\nshows clearly the relationship of the Bellman error to the TD error. The error is the expectation of the TD error.\nThe vector of all the Bellman errors, at all states, ^w G R|S|, is called the Bellman error vector(shown as BE in Figure 11.3). The overall size of this vector, in the norm, is an overall measure of the error in the value function:\nMSBE(w) = pwII' .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.17)\nThis measure, or objective function, is called the Mean Squared Bellman Error (MSBE). It is not possible in general to reduce the MSBE to zero (at which point vw = vn), but for linear function approximation there is a unique value of w for which the MSBE is minimized. This point in representable value function space is shown in Figure 11.3 as different from that which minimizes the MSVE, as it gen\u0026shy;erally is. Methods that seek to minimize the MSBE are discussed in the next two sections.\nThe Bellman error vector is shown in Figure 11.3 as the result of applying the Bellman operatorBn : R|S|R|S|to the approximate value function. The Bellman operator is defined by\n(Bnv)(s)\u0026nbsp;\u0026nbsp;\u0026nbsp; y^n(a|s^\u0026nbsp;\u0026nbsp;\u0026nbsp; p(s',r|s,a)[r + 7v(s')]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,Vs\u0026nbsp;\u0026nbsp; G S, Vv: S\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; R.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.18)\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s7\\A3\\ACr\nThe Bellman error vector for v can be written ^w = Bn vw - vw.\nIf the Bellman operator is applied to a value function in the representable subspace, then, in general, it will produce a new value function that is outside the subspace, as suggested in the figure. In dynamic programming, this operator is applied repeatedly to the points outside the representable space, as suggested by the gray arrows in the top of Figure 11.3. Eventually that process converges to the true value function v^, the only fixedpoint for the Bellman operator, the only value function for which\nvn = Bn vn,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.19)\nwhich is just another way of writing the Bellman equation for n (11.14).\nWith function approximation, however, the intermediate value functions lying out\u0026shy;side the subspace cannot be represented. The gray arrows in the upper part of\nFigure 11.3 cannot be followed because after the first update (dark line) the value function must be projected back into something representable. The next iteration then begins within the subspace; the value function is again taken outside of the sub\u0026shy;space by the Bellman operator and then mapped back by the projection operator, as suggested by the lower gray arrow and line. Following these arrows is a DP-like process with approximation.\nIn this case we are interested in the projection of the Bellman error vector back into the representable space. This is the projected Bellman error vector n^w, shown in Figure 11.3 as PBE. The size of this vector, in the norm, is another measure of error in the approximate value function. For any approximate value function v, we define the Mean Square Projected Bellman Error(MSPBE) as\nMSPBE(w) = ||nlw ||\\A3\\BA.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.20)\nWith linear function approximation there always exists an approximate value func\u0026shy;tion within the subspace with zero MSPBE; this is the TD fixedpoint introduced in Section 9.4. As we have seen, this point is not always stable under semi-gradient TD methods and off-policy training. As shown in the figure, this value function is gener\u0026shy;ally different from those minimizing MSVE or MSBE. Methods that are guaranteed to converge to it are discussed in Sections 11.7 and 11.8.\n11.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Stochastic Gradient Descent in the Bellman Error\nStochastic gradient descent (SGD, Section 9.3) is a powerful and appealing approach to approximation that we would like to make full use of in reinforcement learning. Among the algorithms investigated so far in this book, only the Monte Carlo meth\u0026shy;ods are true SGD methods. These converge very robustly, under both on-policy and off-policy training as well as for general non-linear (differentiable) function ap\u0026shy;proximators, though they are often slower than semi-gradient methods with boot\u0026shy;strapping, which are not SGD methods. Semi-gradient methods may diverge under off-policy training, as we have seen earlier in this chapter, and under contrived cases of non-linear function approximation (Tsitsiklis and Van Roy, 1997). With a true SGD method these kinds of divergence are not possible.\nThe appeal of true SGD is so strong that great effort has gone into finding a prac\u0026shy;tical way of harnessing it for reinforcement learning. The starting place of all such efforts is the choice of an error or objective function to optimize. In this and the next section we explore the origins and limits of the most popular proposed objec\u0026shy;tive function, that based on the Bellman errorintroduced in the previous section. Although this has been a popular and influential approach, the conclusion that we reach here is that it is a misstep and offers no good learning algorithms. On the other hand, this approach fails in an interesting way that offers some insight into what might constitute a good approach.\nTo begin, let us consider not the Bellman error, but something more immediate and naive. Temporal difference learning is driven by the TD error. Why not take the minimization of the square of the TD error as the objective? In the general function-approximation case, the one-step TD error with discounting can be written\n^t = Rt+i + 7v(St+i,wt) - v(St,wt).\nA possible objective function then is what one might call the Mean Squared TD Error, or MSTDE:\nMSTDE(w)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^(s)E [\\BA\\C3| St = s, At \u0026#12316;n]\ns\\80S\n=^ ^(s)E [pt^t2| St=s,At \u0026#12316;b]\ns\\80S\n=Eb[pt^2.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (if ^ is the distribution encountered under b)\nThe last equation is of the form needed for SGD; it gives the objective as an expec\u0026shy;tation that can be sampled from experience (remember the experience is due to the behavior policy b. Thus, following the standard SGD approach, one can derive the per-step update based on a sample of this expected value:\nwt+i = wt - 1aV(pt^t2)\n=wt - apt^tV^t\n=wt + apt^t(Vv(St,wt) - 7V-0(St,wt)),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.21)\nwhich you will recognize as the same as the semi-gradient TD algorithm (11.2) except for the additional final term. This term completes the gradient and makes this a true SGD algorithm with excellent convergence guarantees. Let us call this algorithm the naive residual-gradientalgorithm (after Baird, 1993).\nAlthough the naive residual-gradient algorithm converges robustly, it does not always converge to a desireable place, as the A-split examplein the box on the next page shows. In this example a tabular representation is used, so the true state values can be exactly represented, yet the naive residual-gradient algorithm finds different values, and these values have lower MSTDE than do the true values. Minimizing the MSTDE is naive; by penalizes all TD errors it achieves something more like temporal smoothing than accurate prediction.\nA better idea would seem to be minimizing the Bellman error. If the exact values are learned, the Bellman error is zero everywhere. Thus, a Bellman-error-minimizing algorithm should have no trouble with the A-split example. We cannot expect to achieve zero Bellman error in general, as it would involve finding the true value function, which we presume is outside the space of representable value functions. But getting close to this ideal is a natural-seeming goal. As we have seen, the Bellman error is also closely related to the TD error. The Bellman error for a state is the expected TD error in that state. So let's repeat the derivation above with the\nEpisodes begin in state A and then \\A1\\AEsplit\\A1\\AF stochastically, half the time going to B and then invariably going on to terminate with a reward of 1, and half the time going to state C and then invariably terminating with a reward of zero. Reward for the first transition, out of A, is always zero whichever way the episode goes. As this is an episodic problem, we can take 7to be 1. We also assume on-policy training, so that pt is always 1, and tabular function approx\u0026shy;imation, so that the learning algorithms are free to give arbitrary, independent values to all three states. So it should be an easy problem.\n   A-split example, showing the naivete of the naive residual gradient algorithm\n        Consider the following three-state episodic MRP:\n     What should the values be? From A, half the time the return is 1, and half the time the return is 0; A should have value 2. From B the return is always\n1,\u0026nbsp; so its value should be 1, and similarly from C the return is always 0, so its value should be 0. These are the true values and, as this is a tabular problem, all the methods presented previously converge to them exactly.\nHowever, the naive residual-gradient algorithm finds different values for B and C. It converges with B having a value of | and C having a value of 4 (A converges correctly to 2). These are in fact the values that minimize the MSTDE.\nLet us compute the MSTDE for these values. The first transition of each episode is either up from A\\A1\\AFs 2 to B\\A1\\AFs |, a change of |, or down from A\\A1\\AFs 2 to C\\A1\\AFs i, a change of -1. Because the reward is zero on these transitions, and 7= 1, these changes arethe TD errors, and thus the squared TD error is always \\9E\\E9on the first transition. The second transition is similar; it is either up from B\\A1\\AFs | to a reward of 1 (and a terminal state of value 0), or down from C\\A1\\AFs 4to a reward of 0 (again with a terminal state of value 0). Thus, the TD error is always ʿ4, for a squared error of \\9E\\E9on the second step. Thus, for this set of values, the MSTDE on both steps is ʿ.\nNow let\\A1\\AFs compute the MSTDE for the true values (B at 1, C at 0, and A at i). In this case the first transition is either from 2 up to 1, at B, or from 2 down to 0, at C; in either case the absolute error is 2 and the squared error is 4. The second transition has zero error because the starting value, either 1 or\n0\u0026nbsp;\u0026nbsp; depending on whether the transition is from B or C, always exactly matches the immediate reward and return. Thus the squared TD error is | on the first transition and 0on the second, for a mean reward over the two transitions of 8. As 8is bigger that \\9E\\E9,this solution is worse according to the MSTDE. On this simple problem, the true values do not have the smallest MSTDE.\n \nexpected TD error (all expectations here are implicitly conditional on St):\n \n   wt+i = wt\nwt\nwt\nwt\n        (expectation here implicitly conditional on St)\n        12 2aV(En[^t]2)\n12 2aV(E6[pt^t]2)\naE6[pt^t] VE6[pt^t]\naE6[pt(Rt+i + 7^(St+i,w) - v(St,w))] E6[ptWt]\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n    wt + a\n     E6[pt(Rt+i + 7v(St+i,w)) - v(St,w) Vv(St,w) - yE6[pt\\A8\\8C\\B9\\AB(St+i,w)]\n \n\u0026nbsp;\n \nThis update and various ways of sampling it are referred to as the residual gradient algorithm. If you simply used the sample values in all the expectations, then the equation above reduces almost exactly to (11.21), the naive residual-gradient algo- rithm.[18] But this is naive, because the equation above involves the next state, St+i appearing in two expectations that are multiplied together. To get an unbiased sam\u0026shy;ple of the product, one two independent samples of the next state, but during normal interaction with an external environment only one is obtained. One can sample one expectation or the other, but not both.\nThere are two ways which the residual gradient algorithm can be made to work. One is in the case of deterministic environments. If the next state is deterministic, then the two samples will necessarily be the same, and the naive algorithm is valid. The other way is to obtain twoindependent samples of the next state St+i from St, one for the first expectation and another for the second expectation. In real interaction with an environment, this would not seem possible, but when interacting with a simulated environment, it is. One simply rolls back to the previous state and obtains an alternate next state before proceeding forward from the first next state. In either of these cases the residual gradient algorithm is guaranteed to converge to a minimum of the MSBE under the usual conditions on the step-size parameter. As a true SGD method, this convergence is robust, applying to both linear and non-linear function approximators. In the linear case, convergence is always to the uniquew that minimizes the MSBE.\nHowever, there remain at least three ways in which the convergence of the resid\u0026shy;ual gradient method is unsatisfactory. The first of these is that empirically it is slow, much slower that semi-gradient methods. Indeed, proponents of this method have proposed increasing its speed by combining it with faster semi-gradient meth\u0026shy;ods initially, then gradually switching over to residual gradient for the convergence guarantee (Baird and Moore, 1999). The second way in which the residual-gradient algorithm is unsatisfactory is that it still seems to converge to the wrong values. It must get the right values in all tabular cases, such as the A-split example, as for those an exact solution to the Bellman equation is possible. But if we examine ex\u0026shy;amples with genuine function approximation, then the residual-gradient algorithm,\nA-presplit example, a counterexample for the MSBE\nConsider the following three-state episodic MRP:\ni\\\nحkح\nEpisodes start in either A1 or A2, with equal probability. Because of function approximation, these two states look exactly the same, like a single state A whose feature representation is distinct from and unrelated to the feature representation of the other two states, B and C, which are also distinct from each other. Specifically, the parameter of the function approximator has three components, one giving the value of state B, one giving the value of state C, and one giving the value of both states A1 and A2. Other than the selection of the initial state, the system is deterministic. If it starts in A1, then it transitions to B with a reward of 0and then on to termination with a reward of 1. If it starts in A2, then it transitions to C, and then to termination, with both rewards zero.\nTo a learning algorithm, seeing only the features, the system looks identical to the A-split example. The system seems to always start in A, followed by either B or C with equal probability, and then terminating with a 1or a 0 depending deterministically on the previous state. As in the A-split example, the true values of B and C are 1 and 0, and the best shared value of A1 and A2 is 2, by symmetry.\nBecause this problem appears externally identical to the A-split example, we already know what values will be found by the algorithms. Semi-gradient TD converges to the ideal values just mentioned, while the naive residual-gradient algorithm converges to values of | and 4 for B and C respectively. All state transitions are deterministic, so the non-naive residual-gradient algorithm will also converge to these values (it is the same algorithm in this case). It follows then that this \\A1\\AEnaive\\A1\\AF solution must also be the one that minimizes the MSBE, and so it is. On a deterministic problem, the Bellman errors and TD errors are all the same, so the MSBE is always the same as the MSTDE. Optimizing the MSBE on this example gives rise to the same failure mode as with the naive residual-gradient algorithm on the A-split example.\nand indeed the MSBE, seems to find the wrong values functions. One of the most telling such examples is the variation on the A-split example shown in the box on the previous page. On the A-presplit example the residual-gradient algorithm finds the same poor solution as its naive version. This example shows intuitively that minimizing the MSBE (which the residual-gradient algorithm surely does) may not be a desirable goal.\nThe third way in which the convergence of the residual-gradient algorithm is not satisfactory is also a problem more with the MSBE than with the algorithm as such. This is explained in the next section.\n11.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Learnability of the Bellman Error\nThe concept of learnability that we introduce in this section is different from than that commonly used in machine learning. There, a hypothesis is said to be \\A1\\B0learnable\\A1\\B1 if it is efficientlylearnable, meaning that it can be learned within a polynomial rather than an exponential number of examples. Here we use the term in a more basic way, to mean learnable at all, with any amount of experience. It turns out many quantities of apparent interest in reinforcement learning can not be learned even from an infinite amount of experiential data. These quantities are well defined and can be computed given knowledge of the internal structure of the environment, but cannot be computed or estimated from the observed sequence of feature vectors, actions, and rewards.[19]We say that they are not learnable.It will turn out that the Bellman error introduced in the last two sections is not learnable in this sense. That the Bellman cannot be learned from the observable data is probably the strongest reason not to seek it as an objective.\nTo make the concept of learnability clear, let\\A1\\AFs start with some simple examples. Consider the two Markov reward processes[20](MRPs) diagrammed below:\n0\n\\A1\\A2cocy.\n2\nWhere two edges leave a state, both transitions are assumed to occur with equal probability, and the numbers indicate the reward received. All the states appear the same; they all produce the same single-component feature vector x= 1and have approximated value w. Thus, the only varying part of a data trajectory is the rewards. The left MRP stays in the same state and emits an endless stream of 0s and 2s at random, each with 50-50 probability. The right MRP, on every step, either stays in its current state or switches to the other, with 50-50 probability. The reward is deterministic in this MRP, always a 0 from one state and always a 2 from the other, but because the state is 50-50, the observable data is again an endless stream of 0s and 2s at random, identical to that produced by the left MDP. (We can assume the right MRP starts in one of two states at random with equal probability.) Thus, even given even an infinite amount of data, it would not be possible to tell which of these two MRPs was generating it. In particular, we could not tell if the MRP has one state or two, is stochastic or deterministic. These things are not learnable.\nThis pair of MRPs also illustrates that the MSVE objective (9.1) is not learnable. If 7= 0, then the true values of the three states, left to right, are 1, 0, and 2. Suppose w = 1. Then the MSVE is 0 for the left MDP and 1 for the right MRP. Because the MSVE is different in the two problems, yet the data generated has the same distribution, the MSVE cannot be learned. The MSVE is not a unique function of the data distribution. And if it cannot be learned, then how could the MSVE possibly be useful as an objective for learning?\nIf an objective cannot be learned, it does indeed draw its utility into question. In the case of the MSVE, however, there is a way out. Note that the same solution, w = 1, is optimal for both MRPs above (assuming ^ is the same for the two indistin\u0026shy;guishable states in the right MRP). Is this a coincidence, or could it be generally true that all MDPs with the same data distribution also have the same optimal parameter vector? If this is true\\A1\\AAand we will show next that it is\\A1\\AAthen the MSVE remains a usable objective. The MSVE is not learnable, but the parameter that optimizes it is!\nTo understand this, it is useful to bring in another natural objective function, this time one that is clearly learnable. One error that is always observable is that between the value estimate at each time and the return from that time. The Mean Square Return Error (MSRE) is the expectation, under \u0026quot;, of the square of this error. In the on-policy case it is not difficult that the the MSRE can be written\nMSRE(w) = E [(Gt - v(St,w))2\n=MSVE(w) + E [(Gt - vn(St))2.\nThus, the two objectives are the same except for a variance term that does not depend on the parameter vector. The two objectives must therefore have the same optimal parameter value w*. The overall relationships are summarized in Figure 11.4.\nNow let us return to the MSBE. The MSBE is like the MSVE in that it can be computed from knowledge of the MDP but is not learnable from data. But it is not like the MSVE in that its minimum solution is not learnable. The counterexample in the box (two pages ahead) gives two MRPs that generate the same data distribution but whose minimizing parameter vector is different, proving that the optimal param\u0026shy;eter vector is not a function of the data and thus cannot be learned from it. The other bootstrapping objectives that we have considered, the MSPBE and MSTDE, can be determined from data (are learnable) and determine optimal solutions that are in general different from each other and the MSBE minimums. The general case is summarize in Figure 11.5.\n \n   Data\ndistribution\n        MDP:\n        Figure 11.5: Causal relationships among the data distribution, MDPs\\A3\\ACand errors for bootstrapping objectives. Two different MDPs can produce the same data distri\u0026shy;bution ye: also produce different MSBEs andhave different minimizing parameter vectors; these are not learnable from the data distribution. The MSPBE and MSTDE objectives and their (different) minima can be directly determined from data and thus are learnable.\n        Data\ndistribution\n        \u0026#10003;\n     MSRE\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n MS\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 11.4: Causal relationships among the data distribution, MDPs, and errors for Monte-Carlo objectives. Two different MDPs can produce the same data distri\u0026shy;bution yet also produce different MSVEs, proving that the MSVE objective cannot be determined from data and is not learnable. However, all such MSVEs must have the same optimal parameter vector, w*! Moreover, this same w* can be determined from another objective, the MSRE, which isuniquely determined from the data distribution. Thus w* and the MSRE are learnable even though the MSVEs are not.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nTo show the full range of possibilities we need a slightly more complex pair of Markov reward processes (MRPs) than those considered earlier. Consider the following two MRPs:\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nWhere two edges leave a state, both transitions are assumed to occur with equal probability, and the numbers indicate the reward received. The MRP on the left has two states that are represented distinctly. The MRP on the right has three states, two of which, B and B', appear the same and must be given the same approximate value. Specifically, w has two components and the value of state A is given by the first component and the value of B and B' is given by the second. The second MRP has been designed so that equal time is spent in all three states, so we can take \u0026quot;(s) = |, Vs.\nNote that the observable data distribution is identical for the two MRPs. In both cases the agent will see single occurrences of A followed by a 0, then some number of apparent Bs, each followed by a -1 except the last, which is followed by a 1, then we start all over again with a single A and a 0, etc. All the statistical details are the same as well; in both MRPs, the probability of a string of kBs is 2-k.\nNow suppose w = 0. In the first MRP, this is an exact solution, and the MSBE is zero. In the second MRP, this solution produces a squared error in both B and B' of 1, such that MSBE = \u0026quot;(B)1+ \u0026quot;(B')1 =\\D3\\FE.These two MRPs, which generate the same data distribution, have different MSBEs; the MSBE is not learnable.\nMoreover (and unlike the earlier example for the MSVE) the minimizing value of w is different for the two MRPs. For the first MRP, w = 0 minimizes the MSBE for any 7. For the second MRP, the minimizing w is a complicated function of 7, but in the limit, as 7\u0026nbsp;\u0026nbsp; 1, it is (-2, 0)T. Thus the solution that\nminimizes MSBE cannot be estimated from data alone; knowledge of the MRP beyond what is revealed in the data is required. In this sense, it is impossible in principle to pursue the MSBE as an objective for learning.\nIt may be surprising that the MSBE-minimizing value of A is so far from zero. Recall that A has a dedicated weight and thus its value is unconstrained by function approximation. A is followed by a reward of 0 and transition to a state with a value of nearly 0, which suggests vw(A) should be 0; why is its optimal value substantially negative rather than 0? The answer is that making the value of A negative reduces the error upon arriving in A from B. The reward on this deterministic transition is 1, which implies that B should have a value 1 more than A. Because B\\A1\\AFs value is approximately zero, A\\A1\\AFs value is driven toward -1. The MSBE-minimizing value of c -1 for A is a compromise between reducing the errors on leaving and on entering A.\nThus, the MSBE is not learnable; it cannot be estimated from feature vectors and other observable data. This limits the MSBE to model-based settings. There can be no algorithm that minimizes the MSBE without access to the underlying MDP states beyond the feature vectors. The residual-gradient algorithm is only able to minimize MSBE because it is allowed to double sample from the same state\\A1\\AAnot a state that has the same feature vector, but one that is guaranteed to be the same underlying state. We can see now that there is no way around this. Minimizing the MSBE requires some such access to the nominal, underlying MDP. This is an important limitation of the MSBE beyond that identified in the A-presplit example on page 286. All this directs more attention toward the MSPBE.\n11.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Gradient-TD Methods\nWe now consider SGD methods for minimizing the MSPBE. As true SGD methods, these gradient-TD methodshave robust convergence properties even under off-policy training and non-linear function approximation. Remember that in the linear case there it is always an exact solution, the TD fixedpoint wtd , at which the MSPBE is zero. This solution could be found by least-squares methods (Section 9.7), but only by methods of quadratic O(d2) complexity in the number of parameters. We seek instead an SGD method, which should be O(d) and have robust convergence properties.\nTo derive an SGD method for the MSPBE (assuming linear function approxima\u0026shy;tion) we begin by expanding and rewriting the objective (11.20) in matrix terms:\nMSPBE(w) = ||nlw If\n=(n^w)TDn^w\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (11.12))\n=G nTDn\u0026lt;!w\n=G DX(XTDX)-lXT̎\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A3\\A811.22)\n(using (11.11) and the identity nTDn = DX (XTDX)-iXTD)\n=(XTD^w )T(XtDX)-1(Xt Dlw).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.23)\nThe gradient with respect to w is\nr\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; iT\nVMSPBE(w) = 2V XTD^w (XTDX)-l(XTD^w).\nTo turn this into an SGD method, we have to sample something on every time step that has this quantity as its expected value. Let us take \u0026quot; to be the distribution of states visited under the behavior policy. All three of the factors above can then be written in terms of expectations under this distribution. For example, the last factor can be written\nXTD^w =\\B9\\A4\u0026quot;(s)x(s)^w(s) = E[xtpt^t]\nwhich is just the expectation of the semi-gradient TD(0) update (11.2). The first factor is the transpose of the gradient of this update:\n\n\n\u0026nbsp;\n \n   PtV^TxT\n        E\n     VE[xtpt^t]\n \n   (using episodic \u0026#12316;\\A3\\A9\n        PtV(Rt+i + 7wTxt+i - wTxt)TxT\n        Pt(7xt+i - xt)xT\n        E\nE\n     \u0026nbsp;\n\u0026nbsp;\n Finally, the middle factor is the inverse of the expected outer-product matrix of the feature vectors:\nXtDX =\u0026nbsp; ^(s)x8xT = E xtxT\nSubstituting these expectations for the three factors in our expression for the gradient of the MSPBE, we get\ni\n   (11.24)\n     VMSPBE(w) = 2E pt(7xt+i - xt)xT E xtxf\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; E[xtpt^t] \u0026#8226;\nIt might not be obvious that we have made any progress by writing the gradient in this form. It is a product of three expressions and the first and last are not independent. They both depend on the next feature vector xt+i; we cannot simply sample both of these expectations and then multiply the samples. This would give us an unbiased estmate of the gradient just as in the naive residual-gradient algorithm.\nAnother idea would be to estimate the three expectations separately and then combine them to produce an unbiased estimate of the gradient. This would work, but would require a lot of computational resources, particularly to store the first two expectations, which are dx dmatrices, and to compute the inverse of the second. This idea can be improved. If two of the three expectations are estimated and stored, then the third could be sampled and used in conjunction with the two stored quantities. For example, you could store estimates of the second two quantities (using the increment inverse-updating techniques in Section 9.7) and then sample the first expression. Unfortunately, the overall algorithm would still be of quadratic complexity (of order O(d2)).\nThe idea of storing some estimates separately and then combining them with samples is a good one and is also used in gradient-TD methods. In these methods we estimate and store the productof the second two factors. These factors are an d x d matrix and an n-vector, so their product is just an n-vector, like w itself. We denote this second learned vector as v:\n \n\u0026nbsp;\n \ni\n   (11.25)\n        v % E\n     xtxT\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; E[xtPt^t].\n \n\u0026nbsp;\n \nThis form is familiar to students of linear supervised learning. It is the solution to a linear least-squares problem that tries to approximate pt^t from the features. The standard SGD method for incrementally finding the vector v that minimizes the\n \nexpected squared error (vTxt - pt\u0026amp;) is known as the Least Mean Square (LMS) rule:\nVt+l = vt + ¬pt (5t - vtTxt) xt,\nwhere ^ \u0026gt; 0 is another step-size parameter. We can use this method to effectively achieve (11.25) with O(d) storage and per-step computation.\nGiven a stored estimate vt approximating (11.25), we can update our main pa\u0026shy;rameter vector wt using SGD methods based on (11.24). The simplest such rule is\n \n   wt+i = wt - ^aVMSPBE(wt)\n        -l\n        pt(7xt+i - xt)xT E xtxT\n        wt\nwt\nwt\nwt\n        -l\n        xtxtT\n        E\nvt\n        This algorithm is called GTD2.Note that if the final inner product first, then the entire algorithm is of O(d) complexity.\nA slightly better algorithm can be derived by doing a few more analytic steps before substituting in vt. Continuing from (11.26):\n        + aE pt(xt - 7xt+i)xT + aE pt(xt - 7xt+i)xT + apt (xt - 7xt+i) xT vt\n        --- a2E\n2\n        (the general SGD rule) Efxtpt^t]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (from (11.24))\nEfxtpt^t]\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (11.26)\n(based on (11.25)) (sampling)\n(xfvt) is done\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n -l\nwt+i = wt + aE pt(xt - 7xt+i)xT E xtxf\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Efxtpt^t]\n \n   -i\n        xtxT\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Efxtpt^t]\n        wt + a (E\n        - 7E\n        E\n        ptxt+ixt\n        -l\n        wt + a QEfxtpt^t] - 7E wt + a (E[xtp0t] - 7E\n        xtxT\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Efxtpt^t]\n        E\n        ptxt+ixt\nptxt+ixt\n        vt\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n    (sampling)\n     wt + apt ^txt - 7xt+ixTvt^\nwhich again is O(d) if the final product is done first. This algorithm is known as either TD(0) with gradient correction (TDC)or, alternatively, as GTD(0).\nFigure 11.6 shows a sample and the expected behavior of TDC on Baird\\A1\\AFs coun\u0026shy;terexample. As intended, the MSPBE falls to zero, but note that the individual components of the parameter vector do not approach zero. In fact, these values are still far from an optimal solution, v(s) = 0,Vs, for which w would have to be propor\u0026shy;tional to (1,1,1,1,1,1, 4 - 2)t. After 1000 iterations we are still far from an optimal solution, as we can see from the MSVE, which remains almost 2. The system is actually converging to an optimal solution, but progress is extremely slow because the MSPBE is already so close to zero.\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nFigure 11.6: The behavior of the TDC algorithm on Baird\\A1\\AFs counterexample. On the left is shown a typical single run, and on the right is shown the expected behavior of this algorithm if the updates are done in asynchronous sweeps (analogous to (11.7), except for the two TDC parameter vectors). The step sizes were a = 0.005 and /3= 0.05.\nGTD2 and TDC both involve two learning processes, a primary one for w and a secondary one for v. The logic of the primary learning process relies on the sec\u0026shy;ondary learning process having finished, at least approximately, whereas the sec\u0026shy;ondary learning process proceeds without being influenced by the first. We call this sort of asymmetrical dependence a cascade. In cascades we often assume that the secondary learning process is proceeding faster and thus is always at its asymmptotic value, ready and accurate to assist the primary learning process. The convergence proofs for these methods often make this assumption explicitly. These are called two-time-scaleproofs. The fast time scale is that of the secondary learning process, and the slower time scale is that of the primary learning process. If a is the step size of the primary learning process, and Pis the step size of the secondary learning process, then these convergence proofs will typically be in the limit as P 0and\n\\C1\\A2^ 0 ^ ] 0.\nGradient-TD methods are currently the most well understood and widely used stable off-policy methods. There are extensions to action values and control (GQ, Maei et al., 2010), to eligibility traces (GTD(A) and GQ(A), Maei, 2011; Maei and Sutton, 2010), and to nonlinear function approximation (Maei et al., 2009). There has also been proposed hybrid algorithms midway between semi-gradient TD and gradient TD. The Hybrid TD (HTD, Hackman, 2012; White and White, 2016) al\u0026shy;gorithm behaves like GTD in states where the target and behavior policies are very different and like semi-gradient TD in states where they are the same. Finally, the gradient-TD idea has been combined with the ideas of proximal method and controlvariates to produce more efficient methods (Mahadevan et al., 2014).\n11.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Emphatic-TD Methods\nWe turn now to the second major strategy that has been extensively explored for ob\u0026shy;taining a cheap and efficient off-policy learning method with function approximation. Recall that linear semi-gradient TD methods are efficient and stable when trained under the on-policy distribution, and that we showed in Section 9.4 that this has to do with the matrix A and the match between the on-policy state distribution and the state-transition probabilities p(s|s, a) under the target policy. In off-policy learning, we reweight the state transitions using importance weighting so that they become appropriate for learning about the target policy, but the state distribution is still that of the behavior policy. There is a mismatch. A natural idea is to somehow reweight the states, emphasizing some and de-emphasizing others, so as to return the distribution of updates to the on-policy distribution. There would then be a match, and stability and convergence would follow from existing results. This is the idea of Emphatic-TD methods, first introduced, for on-policy training, in Section 9.10.\nActually, the notion of \\A1\\B0the on-policy distribution\\A1\\B1 is not quite right, as there are many on-policy distributions, and any one of these is sufficient to guarantee stability. Consider an undiscounted episodic problem. The way episodes terminate is fully determined by the transition probabilities, but there may be several different ways the episodes might begin. However the episodes start, if all state transitions are due to the target policy, then the state distribution that results is an on-policy distribution. You might start close to the terminal state and visit only a few states with high probability before ending the episode. Or you might start far away and pass through many states before terminating. Both are on-policy distributions, and training on both with a linear semi-gradient method would be guaranteed to be stable. However the process starts, an on-policy distribution results as long as all states encountered are updated up until termination.\nIf there is discounting, it can be treated as partial or probabilistic termination for these purposes. If 7= 0.9, then we can consider that with probability 0.1 the pro\u0026shy;cess terminates on every time step and then immediately restarts in the state that is transitioned to. A discounted problem is one that is continually terminating and restarting with probability 1 - 7on every step. This way of thinking about discount\u0026shy;ing is an example of a more general notion of pseudo termination\\A1\\AAtermination that does not affect the sequence of state transitions, but does affect the learning process and the quantities being learned. This kind of pseudo termination is important to off-policy learning because the restarting is optional\\A1\\AAremember we can start any way we want to\\A1\\AAand the termination relieves the need to keep including encoun\u0026shy;tered states within the on-policy distribution. That is, if we don\\A1\\AFt consider the new states as restarts, then discounting quickly give us a limited on-policy distribution.\nThe one-step emphatic-TD algorithm for learning episodic state values is defined by:\n^t = Rt+i + 7v(St+i,wt) - v(St,wt), wt+i = wt + aMtpt^t Vv(St,wt),\nMt = 7pt-iMt-i + It,\nwith It, the interest,being arbitrary and Mt, the emphasis,being initialized to Mt_i = 0. How does this algorithm perform on Baird\\A1\\AFs counterexample? Figure 11.7 shows the trajectory in expectation of the components of the parameter vector (for the case in which It = 1, Vt). There are some oscilations but eventually everything converges and the MSVE goes to zero. These trajectories are obtained by iteratively computing the expectation of the parameter vector trajectory without any of the variance due to sampling of transitions and rewards. We do not show the results of applying ETD directly because its variance on Baird\\A1\\AFs counterexample is so high that it is nigh impossible to get consistent results in computational experiments. The algorithm converges to the optimal solution in theory on this problem, but in practice it does not. We turn to the topic of reducing the variance of all these algorithms in the next section.\n \nFigure 11.7: The behavior of the ETD algorithm in expectation on Baird\\A1\\AFs counterexample. The step size was a = 0.03.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n11.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Reducing Variance\nOff-policy learning is of inherently greater variance than on-policy learning. This is not surprising; if you receive data less closely related to a policy, you should expect to learn less about the policy\\A1\\AFs values. In the extreme, one may be able to learn nothing. You can\\A1\\AFt expect to learn how to drive by cooking dinner, for example. Only if the target and behavior policies are related, if they visit similar states and \n\n\ntake similar actions, should one be able to make significant progress in off-policy training.\nOn the other hand, any policy has many neighbors, many similar policies with considerable overlap in states visited and actions chosen, and yet which are not identical. The raison d\\A1\\AFetre of off-policy learning is to enable generalization to this vast number of related-but-not-identical policies. The problem remains of how to make the best use of the experience. Now that we have some methods that are stable in expected value (if the step sizes are set right), attention naturally turns to reducing the variance of the estimates. There are many possible ideas, and we can just touch on of a few of them in this introductory text.\nWhy is controlling variance especially critical in off-policy methods based on im\u0026shy;portance sampling? As we have seen, important sampling often involves products of policy ratios. The ratios are always one in expectation, but their actual values may be much significantly higher or as low as zero. Successive ratios are uncorrelated, so their products are also always one in expected value, but can to be of great variance. Recall that these ratios multiply the step size in SGD methods, so high variance means taking steps that vary greatly in their size. This is problematic for SGD be\u0026shy;cause of the occasional very large steps. They must not be so large as to take the parameter to a part of the space with a very different gradient. SGD methods rely on averaging over multiple steps to get a good sense of the gradient, and if they make large moves from single samples they become unreliable. If the step-size parameter is set small enough to prevent this, then the expected step can end up being very small, resulting in very slow learning. The notions of momentum (Derthick, 1984), of Polyak-Ruppert averaging (Polyak, 1991; Ruppert, 1988; Polyak and Juditsky, 1992), or further extensions of these ideas may significantly help. Methods for adap\u0026shy;tively setting separate step sizes for different components of the parameter vector are also pertinent (e.g., Jacobs, 1988; Sutton, 1992), as are the \\A1\\B0importance weight aware\\A1\\B1 updates of Karampatziakis and Langford (2010).\nIn Chapter 5 we saw how weighted importance sampling is significantly better behaved, with lower variance updates, than ordinary importance sampling. However, adapting weighted importance sampling to function approximation is challenging and can probably only be done approximately with O(d) complexity (Mahmood and Sutton, 2015).\nThe Tree Backup algorithm shows that is is possible to perform some off-policy learning without using importance sampling. This idea has been extended to the off-policy case to produce stable and more efficient methods by Munos, Stepleton, Harutyunyan, and Bellemare (2016) and by Mahmood, Yu and Sutton (2017).\nAnother, complementary strategy is to allow the target policy to be determined in part by the behavior policy, in such a way that it never can be so different from it to create large importance sampling ratios. For example, the target policy can be defined by reference to the behavior policy, as in the \\A1\\B0recognizers\\A1\\B1 proposed by Precup et al. (2005).\n11.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nOff-policy learning is a tempting challenge, testing our ingenuity in designing sta\u0026shy;ble and efficient learning algorithms. Tabular Q-learning makes off-policy learning seem easy, and it has natural generalizations to Expected Sarsa and to the Tree Backup algorithm. But as we have seen in this chapter, the extension of these ideas to significant function approximation, even linear function approximation, involves new challenges and forces us to deepen our understanding of reinforcement learning algorithms.\nWhy go to such lengths? One reason to seek off-policy algorithms is to give flexibility in dealing with the tradeoff between exploration and exploitation. Another is to free behavior from learning, and avoid the tyranny of the target policy. TD learning appears to hold out the possibility of learning about multiple things in parallel, of using one stream of experience to solve many tasks simultaneously. We can certainly do this in special cases, just not in every case that we would like to or as efficiently as we would like to.\nIn this chapter we divided the challenge of off-policy learning into two parts. The first part, correcting the targets of learning for the behavior policy, is straightfor\u0026shy;wardly dealt with using the techniques devised earlier for the tabular case, albiet at the cost of increasing the variance of the updates and thereby slowing learning. High variance will probably always remains a challenge for off-policy learning.\nThe second part of the challenge of off-policy learning emerges as the instability of semi-gradient TD methods that involve bootstrapping. We seek powerful function approximation, off-policy learning, and the efficiency and flexibility of bootstrapping TD methods, but it is challenging to combine all three aspects of this deadly triad in one algorithm without introducing the potential for instability. There have been several attempts. The most popular has been to seek to perform true stochastic gradient descent (SGD) in the Bellman error (a.k.a. the Bellman residual). However, our analysis concludes that this is not an appealing goal in many cases, and that anyway it is impossible to achieve with a learning algorithm\\A1\\AAthat the gradient of the MSBE is not learnable from experience that reveals only feature vectors and not underlying states. Another approach, Gradient-TD methods, performs SGD in the projectedBellman error. The gradient of the MSPBE is learnable with O(d) complexity, but at the cost of a second parameter vector with a second step size. The newest family of methods, Emphatic-TD methods, refine an old idea for reweighting updates, emphasizing some and de-emphasizing others. In this way they restore the special properties that make on-policy learning stable with computationally simple semi-gradient methods.\nThe whole area of off-policy learning is relatively new and unsettled. Which meth\u0026shy;ods are best or even adequate is not yet clear. Are the complexities of the new methods introduced at the end of this chapter really necessary? Which of them can be combined effectively with variance reductions methods? The potential for off-policy learning remains tantalizing, the best way to achieve it still a mystery.\nBibliographical and Historical Remarks\n11.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The first semi-gradient method was linear TD(A) (Sutton, 1988). The name \\A1\\B0semi-gradient\\A1\\B1 is more recent (Sutton, 2015a). Semi-gradient off-policy TD(0) with general importance-sampling ratio may not have been explic\u0026shy;itly stated until Sutton, Mahmood, and White (2016), but the action-value forms were introduced by Precup, Sutton, and Singh (2000), who also did eligibility trace forms of these algorithms (see Chapter 12). Their continu\u0026shy;ing, undiscounted forms have not been significantly explored. The atomic multi-step forms given here are new.\n11.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The earliest w-to-2w example was given by Tsitsiklis and Van Roy (1996), who also introduced the specific counterexample in the box on page 276. Baird\\A1\\AFs counterexample is due to Baird (1995), though the version we present here is slightly modified. Averaging methods for function approximation were developed by Gordon (1995, 1996). Other examples of instability with off- policy DP methods and more complex methods of function approximation are given by Boyan and Moore (1995). Bradtke (1993) gives an example in which Q-learning using linear function approximation in a linear quadratic regulation problem converges to a destabilizing policy.\n11.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The deadly triad was first identified by Sutton (1995) and thoroughly ana\u0026shy;lyzed by Tsitsiklis and Van Roy (1997). The name \\A1\\B0deadly triad\\A1\\B1 is due to Sutton (2015a).\n11.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; This kind of linear analysis was pioneered by Tsitsiklis and Van Roy (1996; 1997), including the dynamic programming operator. Diagrams like Fig\u0026shy;ure 11.3 were introduced by Lagoudakis and Parr (2003).\n11.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The MSBE was first proposed as an objective function for dynamic program\u0026shy;ming by Schweitzer and Seidmann (1985). Baird (1995, 1999) extended it to TD learning based on stochastic gradient descent, and Engel, Mannor, and Meir (2003) extended it to least squares (O(d2)) methods known as Gaussian Process TD learning. In the literature, MSBE minimization is often referred to as Bellman residual minimization.\nThe earliest A-split example is due to Dayan (1992). The two forms given here were introduced by Sutton et al. (2009).\n11.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The contents of this section are new to this text.\n11.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Gradient-TD methods were introduced by Sutton, Szepesvari, and Maei (2009). The methods highlighted in this section were introduced by Sut\u0026shy;ton et al. (2009) and Mahmood et al. (2014). The most sensitive empirical investigations to date of gradient-TD and related methods are given by Geist and Scherrer (2014), Dann, Neumann, and Peters (2014), and White (2015).\n11.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Emphatic-TD methods were introduced by Sutton, Mahmood, and White (2016). Full convergence proofs and other theory were later established by Yu (2015a; 2015b; Yu, Mahmood, and Sutton, 2017) and Hallak, Tamar, Munos, and Mannor (2015).\n \nChapter 12\nEligibility Traces\nEligibility traces are one of the basic mechanisms of reinforcement learning. For example, in the popular TD(A) algorithm, the \\C8\\EBrefers to the use of an eligibility trace. Almost any temporal-difference (TD) method, such as Q-learning or Sarsa, can be combined with eligibility traces to obtain a more general method that may learn more efficiently.\nEligibility traces unify and generalize TD and Monte Carlo methods. When TD methods are augmented with eligibility traces, they produce a family of methods spanning a spectrum that has Monte Carlo methods at one end (A = 1) and one- step TD methods at the other (A = 0). In between are intermediate methods that are often better than either extreme method. Eligibility traces also provide a way of implementing Monte Carlo methods online and on continuing problems without episodes.\nOf course, we have already seen one way of unifying TD and Monte Carlo methods: the n-step TD methods of Chapter 7. What eligibility traces offer beyond these is an elegant algorithmic mechanism with significant computational advantages. The mechanism is a short-term memory vector, the eligibility traceet G Rd, that parallels the long-term weight vector wt G Rd. The rough idea is that when a component of wt participates in producing an estimated value, then the corresponding component of et is bumped up and then begins to fade away. Learning will then occur in that component of wt if a nonzero TD error occurs before the trace falls back to zero. The trace-decay parameter A G [0,1] determines the rate at which the trace falls.\nThe primary computational advantage of eligibility traces over n-step methods is that only a single trace vector is required rather than a store of the last n feature vectors. Learning also occurs continually and uniformly in time rather than being delayed and then catching up at the end of the episode. In addition learning can occur and affect behavior immediately after a state is encountered rather than being delayed n steps.\nEligibility traces illustrate that a learning algorithm can sometimes be imple\u0026shy;mented in a different way to obtain computational advantages. Many algorithms are most naturally formulated and understood as an update of a state\\A1\\AFs value basedon events that follow that state over multiple future time steps. For example, Monte Carlo methods (Chapter 5) update a state based on all the future rewards, and n- step TD methods (Chapter 7) update based on the next nrewards and state nsteps in the future. Such formulations, based on looking forward from the updated state, are called forward views. Forward views are always somewhat complex to imple\u0026shy;ment because the update depends on later things that are not available at the time. However, as we show in this chapter it is often possible to achieve nearly the same updates\\A1\\AAand sometimes exactlythe same updates\\A1\\AAwith an algorithm that uses the current TD error, looking backward to recently visited states using an eligibil\u0026shy;ity trace. These alternate ways of looking at and implementing learning algorithms are called backward views. Backward views, transformations between forward-views and backward-views, and equivalences between them date back to the introduction of temporal difference learning, but have become much more powerful and sophisticated since 2014. Here we present the basics of the modern view.\nAs usual, first we fully develop the ideas for state values and prediction, then extend them to action values and control. We develop them first for the on-policy case then extend them to off-policy learning. Our treatment pays special attention to the case of linear function approximation, for which the results with eligibility traces are stronger. All these results apply also to the tabular and state aggregation cases because these are special cases of linear function approximation.\n12.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The A-return\n   rewards plus the discounted (7.1). approximator, is\n     In Chapter 7 we defined an n-step return as the sum of the first n estimated value of the state reached in n steps, each appropriately The general form of that equation, for any parameterized function\nGt:t+n = Rt+i + 7Rt+2+' ' ' +7^ iRt+n + 7n6(St+n,wt+n-i), 0^ t\u0026lt; T-U.(12.1)\nWe noted in Chapter 7 that each n-step return, for n \u0026gt; 1, is a valid update target for a tabular learning update, just as it is for an approximate SGD learning update such as (9.6).\nNow we note that a valid update can be done not just toward any n-step return, but toward any averageof n-step returns. For example, an update can be done toward a target that is half of a two-step return and half of a four-step return:\n2Gt\\A3\\BAt+2+ 2 Gt:t+4. Any set of n-step returns can be averaged in this way, even an infinite set, as long as the weights on the component returns are positive and sum to 1. The composite return possesses an error reduction property similar to that of individual n-step returns (7.3) and thus can be used to construct updates with guaranteed convergence properties. Averaging produces a substantial new range of algorithms. For example, one could average one-step and infinite-step returns to obtain another way of interrelating TD and Monte Carlo methods. In principle, one could even average experience-based updates with DP updates to get a simple combination of experience-based and model-based methods (cf. Chapter 8).\nAn update that averages simpler component updates is called a com\u0026shy;pound update. The backup diagram for a compound update consists of the backup diagrams for each of the component updates with a hori\u0026shy;zontal line above them and the weighting fractions below. For example, the compound update for the case mentioned at the start of this sec\u0026shy;tion, mixing half of a two-step return and half of a four-step return, has the diagram shown to the right. A compound update can only be done when the longest of its component updates is complete. The update at the right, for example, could only be done at time t+ 4 for the estimate formed at time t. In general one would like to limit the length of the longest component backup because of the corresponding delay in the updates.\n   \\A9\\96\n 9\n  1\n I\n  2\n !\n?\n  \u0026nbsp;\n \\C1\\CB\n\\A9\\96\n  \u0026nbsp;\n i\n  \u0026nbsp;\n 2\n    \u0026nbsp;\n     The TD(A) algorithm can be understood as one particular way of averaging n-step backups. This average contains all the n-step backups, each weighted proportional to An-1, where A G [0,1], and normalized by a factor of 1 - A to ensure that the weights sum to 1 (see Figure 12.1).\nThe resulting backup is toward a return, called the X-return, defined in its state-based form by\n \n\u0026nbsp;\n \n   \\C8\\EB\n        (12.2)\n     (1- A) A^ 1Gt:t+n\n \n\u0026nbsp;\n \nFigure 12.2 further illustrates the weighting on the sequence of n-step returns in the A-return. The one-step return is given the largest weight, 1 - A; the two-step return is given the next largest weight, (1- A)A; the three-step return is given the weight (1- A)A2; and so on. The weight fades by A with each additional step. After a\nTD(A)\nSt\n \n   \\B6\\A1\n\\A9\\96 1 - A\n        \\A9\\96\n(i -\\C8\\EB)\\C8\\EB2\n        \\B6\\A14\nO St+i Rt+i\n..\\C1\\CB\u0026#12316;1\n(j) St+2 Rt + 2 \u0026#8226; At+2\n\\C1\\CB\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; -i\n\u0026#8226; . EH St Rt\nXT-\\B2\\B71\n0, then the overall backup reduces to its 1, then the overall backup reduces\n        Figure 12.1: The backup digram for TD(A). If A first component, the one-step TD backup, whereas if A to its last component, the Monte Carlo backup.\n        \\C1\\CB\n\\A9\\96\n(i һ\\C8\\EB)\\C8\\EB\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n    Figure 12.2: Weighting given in the A-return to each of the n-step returns.\n        1\n        Time\n        Weight\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n terminal state has been reached, all subsequent n-step returns are equal to Gt. If we want, we can separate these post-termination terms from the main sum, yielding\nt-t-i\nG=\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (1\u0026nbsp; -\u0026nbsp; A)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; An iGt\\A3\\BAt+n + aT\\CD\\F6iGt,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.3)\nn=i\nas indicated in the figures. This equation makes it clearer what happens when A = 1. In this case the main sum goes to zero, and the remaining term reduces to the conventional return, Gt. Thus, for A = 1, backing up according to the A-return is a Monte Carlo algorithm. On the other hand, if A = 0, then the A-return reduces to Gt\\A3\\BAt+i, the one-step return. Thus, for A = 0, backing up according to the A-return is a one-step TD method.\nExercise 12.1 Just as the return can be written recursively in terms of the first reward and itself one-step later (3.3), so can the A-return. Derive the analogous recursive relationship from (12.2) and (12.1).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 12.2 The parameter A characterizes how fast the exponential weighting in Figure 12.2 falls off, and thus how far into the future the A-return algorithm looks in determining its backup. But a rate factor such as A is sometimes an awkward way of characterizing the speed of the decay. For some purposes it is better to specify a time constant, or half-life. What is the equation relating A and the half-life, t\\A1\\F6\\C8\\EB,the time by which the weighting sequence will have fallen to half of its initial value? \\A1\\F5\nWe are now ready to define our first learning algorithm based on the A-return: the off-line X-return algorithm.As an off-line algorithm, it makes no changes to the weight vector during the episode. Then, at the end of the episode, a whole sequence of off-line updates are made according to our usual semi-gradient rule, using the A-return as the target:\nwt+i ʿwt + a G^s - v(St,wt) Vv(St,wt), t= 0,... ,T - 1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.4)\nThe A-return gives us an alternative way of moving smoothly between Monte Carlo and one-step TD methods that can be compared with the n-step TD way of\n   n-step TD methods\n(from Chapter 7)\n        RMS error at the end of the episode over the first 10 episodes\n        Off-line X-return algorithm\n     a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\nFigure 12.3: 19-state Random walk results (Example 7.1): Performance of the offline X- return algorithm alongside that of the n-step TD methods. In both case, intermediate values of the bootstrapping parameter (X or n) performed best. The results with the off-line X-return algorithm are slighly better at the best values of aand X, and at high a.\nChapter 7. There we assessed effectiveness on a 19-state random walk task (Example 7.1). Figure 12.3 shows the performance of the off-line \\C8\\EB-return algorithm on this task alongside that of the n-step methods (repeated from Figure 7.2). The experiment was just as described earlier except that for the X-return algorithm we varied X instead of n. The performance measure used is the estimated root-mean-squared error between the correct and estimated values of each state measured at the end of the episode, averaged over the first 10 episodes and the 19 states. Note that overall performance of the off-line X-return algorithms is comparable to that of the n-step algorithms. In both cases we get best performance with an intermediate value of the bootstrapping parameter, n for n-step methods and \\C8\\EBfor the offline \\C8\\EB-return algorithm.\nThe approach that we have been taking so far is what we call the theoretical, or forward, view of a learning algorithm. For each state visited, we look forward in time to all the future rewards and decide how best to combine them. We might imagine ourselves riding the stream of states, looking forward from each state to determine its update, as suggested by Figure 12.4. After looking forward from and updating\n \nFigure 12.4: The forward view. We decide how to update each state by looking forward to future rewards and states.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n\n\u0026nbsp;\n   and never have to work with the preceding state hand, are viewed and processed repeatedly, once them.\n        one state, we move on to the next again. Future states, on the other from each vantage point preceding\n     12.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD(A)\nTD(\\C8\\EB\\A3\\A9is one of the oldest and most widely used algorithms in reinforcement learning. It was the first algorithm for which a formal relationship was shown between a more theoretical forward view and a more computational congenial backward view using eligibility traces. Here we will show empirically that it approximates the off-line X-return algorithm presented in the previous section.\nTD(\\C8\\EB\\A3\\A9improves over the off-line \\C8\\EB-return algorithm in three ways. First it updates the weight vector on every step of an episode rather than only at the end, and thus its estimates may be better sooner. Second, its computations are equally distributed in time rather that all at the end of the episode. And third, it can be applied to continuing problems rather than just episodic problems. In this section we present the semi-gradient version of TD(\\C8\\EB\\A3\\A9with function approximation.\nWith function approximation, the eligibility trace is a vector et G Rd with the same number of components as the weight vector wt. Whereas the weight vector is a long-term memory, accumulating over the lifetime of the system, the eligibility trace is a short-term memory, typically lasting less time than the length of an episode. Eligibility traces assist in the learning process; their only consequence is that they affect the weight vector, and then the weight vector determines the estimated value.\nIn TD(\\C8\\EB)\\A3\\ACthe eligibility trace vector is initialized to zero at the beginning of the episode, is incremented on each time step by the value gradient, and then fades away by yX:\ne-i= 0,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12 5)\net == 7Aet-i + Vv(St,wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0 \u0026lt; t \u0026lt; T,\u0026nbsp;\u0026nbsp;\u0026nbsp; '\nwhere 7is the discount rate and \\C8\\EBis the parameter introduced in the previous section. The eligibility trace keeps track of which components of the weight vector have contributed, positively or negatively, to recent state valuations, where \\A1\\B0recent\\A1\\B1 is defined in terms 7A. The trace is said to indicate the eligibility of each component of the weight vector for undergoing learning changes should a reinforcing event occur. The reinforcing events we are concerned with are the moment-by-moment one-step TD errors. The TD error for state-value prediction is\n^t == Rt+i + 7\\D0\\C4(St+i,wt) - v(St,wt).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.6)\n   (12.7)\n     In TD(X), the weight vector is updated on each step proportional to the scalar TD error and the vector eligibility trace:\nwt+i = wt + a^t et,\n\n\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nInput: the policy n to be evaluated\nInput: a differentiable function v : S+ x Rd R such that v(terminal,-) = 0\nInitialize value-function weights w arbitrarily (e.g., w = 0)\nRepeat (for each episode):\nInitialize S\ne 0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (An n-dimensional vector)\nRepeat (for each step of episode):\n.Choose A\u0026#12316;n(-|S)\n.Takeaction A, observe R, Sf.e \\A1\\AA 7Ae + V(0(S,w)\n.8\\A1\\AA R + 7v(S;,w) - v(S,w)\n. w \\A1\\AA w + a8e\nuntil Sfis terminal\nComplete pseudocode for TD(A) is given in the box, and a picture of its operation is suggested by Figure 12.5.\nTD(A) is oriented backward in time. At each moment we look at the current TD error and assign it backward to each prior state according to how much that state contributed to the current eligibility trace at that time. We might imagine ourselves riding along the stream of states, computing TD errors, and shouting them back to the previously visited states, as suggested by Figure 12.5. Where the TD error and traces come together, we get the update given by (12.7).\nTo better understand the backward view, consider what happens at various values of A. If A = 0, then by (12.5) the trace at t is exactly the value gradient corresponding\n \nFigure 12.5: The backward or mechanistic view. Each update depends on the current TD error combined with eligibility traces of past events.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nto St. Thus the TD(A) update (12.7) reduces to the one-step semi-gradient TD update treated in Chapter 9 (and, in the tabular case, to the simple TD rule (6.2)). This is why that algorithm was called TD(0). In terms of Figure 12.5, TD(0) is the case in which only the one state preceding the current one is changed by the TD error. For larger values of A, but still A \u0026lt; 1, more of the preceding states are changed, but each more temporally distant state is changed less because the corresponding eligibility trace is smaller, as suggested by the figure. We say that the earlier states are given less creditfor the TD error.\nIf A = 1, then the credit given to earlier states falls only by 7per step. This turns out to be just the right thing to do to achieve Monte Carlo behavior. For example, remember that the TD error, \u0026amp;, includes an undiscounted term of Rt+i. In passing this back k steps it needs to be discounted, like any reward in a return, by 7k, which is just what the falling eligibility trace achieves. If A = 1 and 7=1, then the eligibility traces do not decay at all with time. In this case the method behaves like a Monte Carlo method for an undiscounted, episodic task. If A = 1, the algorithm is also known as TD(1).\nTD(1) is a way of implementing Monte Carlo algorithms that is more general than those presented earlier and that significantly increases their range of applicability. Whereas the earlier Monte Carlo methods were limited to episodic tasks, TD(1) can be applied to discounted continuing tasks as well. Moreover, TD(1) can be performed incrementally and on-line. One disadvantage of Monte Carlo methods is that they learn nothing from an episode until it is over. For example, if a Monte Carlo control method takes an action that produces a very poor reward but does not end the episode, then the agent\\A1\\AFs tendency to repeat the action will be undiminished during the episode. On-line TD(1), on the other hand, learns in an n-step TD way from the incomplete ongoing episode, where the n steps are all the way up to the current step. If something unusually good or bad happens during an episode, control methods based on TD(1) can learn immediately and alter their behavior on that same episode.\nIt is revealing to revisit the 19-state random walk example (Example 7.1) to see how well TD(A) does in approximating the off-line A-return algorithm. The results for both algorithms are shown in Figure 12.6. For each A value, if a is selected optimally for it or smaller, then the two algorithms perform virtually identically. If a is chosen larger, however, then the A-return algorithm is only a little worse whereas TD(A) is much worse and may even be unstable. This is not a terrible problem for TD(A) on this problem, as these higher parameter values are not what one would want to use anyway, but for other problems it can be a significant weakness.\n   TD(\\C8룩\n        Off-line \\C8\\EB-return algorithm\n(from the previous section)\n        0.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.6\not\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\nFigure 12.6: 19-state Random walk results (Example 7.1): Performance of TD(X) alongside that of the off-line X-return algorithm. The two algorithms performed virtually identically at low (less than optimal) a values, but TD(X) was worse at high a values.\n        0.25 _______________________________________________________________________________ _________________________________________________ \n        \u0026nbsp;\n 0.55\n  RMS error\n 0.5\n0.45\n  at the end\n \u0026nbsp;\n  of the episode\n 0.4\n  over the first\n \u0026nbsp;\n  10 episodes\n 0.35\n    \u0026nbsp;\n     Linear TD(A) has been proved to converge in the on-policy case if the step-size parameter is reduced over time according to the usual conditions (2.7). Just as discussed in Section 9.4, convergence is not to the minimum-error weight vector, but to a nearby weight vector that depends on A. The bound on solution quality presented in that section (9.13) can now be generalized to apply to any A. For thecontinuing discounted case,\n1 - 7X\n   MSVE(w^)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026lt;\n     minMSVE(w).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.8)\n1-7\n   That is, the asymptotic error is As X approaches 1, the bound\n     no more than i--^ times the smallest possible error. approaches the minimum error (and it is loosest at \\C8\\EB= 0). In practice, however,\\C8\\EB=1 is often the poorest choice, as will be illustrated later in Figure 12.14.\nExercise 12.3 Some insight into how TD(X) can closely approximate the off-line X-retum algorithm can be gained by seeing that the latter\\A1\\AFs error term (from (12.4)) can be written as the sum of TD errors (12.6) for a single fixed w. Show this, following the pattern of (6.6), and using the recursive relationship for the you obtained in Exercise 12.1.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n''Exercise 12.4 Although TD(X) only approximates the \\C8\\EB-\\B7Źϴ\\F2algorithm when done online, perhaps there\\A1\\AFs a slightly different TD method that would maintain the equivalence even in the on-line case. One idea is to define the TD error instead as ^t == Rt+i + 7Vt(St+i) - Vt-i(St). Show that in this case the modified TDC') algorithm would then achieve exactly\nAVt(St) = a[Gt\\C8\\EB-Vt-i(St)\neven in the case of on-line updating with large a. In what ways might this modified TD(X) be better or worse than the conventional one described in the text? Describe an experiment to assess the relative merits of the two algorithms.\u0026nbsp;\u0026nbsp; \\A1\\F5\n12.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; n-step Truncated A-return Methods\nThe off-line A-return algorithm is an important ideal, but it\\A1\\AFs of limited utility be\u0026shy;cause it uses the A-return (12.2), which is not known until the end of the episode. In the continuing case, the A-return is technically never known, as it depends on n- step returns for arbitrarily large n, and thus on rewards arbitrarily far in the future. However, the dependence gets weaker for long-delayed rewards, falling by 7A for each step of delay. A natural approximation then would be to truncate the sequence after some number of steps. Our existing notion of n-step returns provides a natural way to do this in which the missing rewards are replaced with estimated values.\nIn general, we define the truncatedA-returnfor time t, given data only up to some later horizon, h, as\nh-t-i\nGi\\A3\\BAh=\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (1- A)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; AiGt\\A3\\BAt+n + Ah t iGt\\A3\\BAh,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0^ t \u0026lt; h ^ T.(12.9)\nn=i\nIf you compare this equation with the A-return (12.3), it is clear that the horizon his playing the same role as was previously played by T, the time of termination. Whereas in the A-return there is a residual weighting given to the true return, here it is given to the longest available n-step return, the (h-t)-step return (Figure 12.2).\nThe truncated A-return immediately gives rise to a family of n-step A-return algo\u0026shy;rithms similar to the n-step methods of Chapter 7. In all these algorithms, updates are delayed by n steps and only take into account the first n rewards, but now all the k-step returns are included for 1\u0026lt; k \u0026lt; n (whereas the earlier n-step algorithms used only the n-step return), weighted geometrically as in Figure 12.2. In the state- value case, this family of algorithms is known as truncated TD(A), or TTD(A). The compound backup diagram, shown in Figure 12.7, is similar to that for TD(A) (Fig\u0026shy;ure 12.1) except that the longest component backup is n steps rather than all the way to the end of the episode. TTD(A) is defined by (cf. (9.14)):\nwt+n = wt+n-i + a G^\\A3\\BAt+\u0026#8222; - v(St,wt+n-i) Vv(St,wt+\u0026#8222;-i),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0 \u0026lt; t \u0026lt; T. (12.10)\nThis algorithm can be implemented efficiently so that per-step computation does not scale with n (though of course memory must). Much as in n-step TD methods, no updates are made on the first n - 1time steps, and n - 1additional updates are made upon termination. Efficient implementation relies on the fact that the k-step A-return can be written exactly as\nt+k-i\nGi\\A3\\BAt+k \\A1\\AA v(St,wt\\A1\\AA1)+ E (7A)i-t^t,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.11)\ni=t\nwhere\n   (12.12)\n     ^t = Ri+i + 7^(Si+i,wi) - v(Si,wi-i).\n\n\nn-step truncated TD(A)\n \n   St\nAt\nSt+i Rt+i At+i\nAt-i\n        \\C1\\CB\\C1\\CB\n        \\A9\\96\n(i һ\\C8\\EB)\\C8\\EB\n        C] St Rt\nXT-t-1\n        At+n-1 St+n Rt+n\n        \\A9\\96\nAn-1\n        \\A9\\96\n(1 -\\C8\\EB)\\C8\\EB2\n        if tʮn \u0026gt; T\n        \\C1\\CB\n\\A9\\96\n1-\\C8\\EB\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 12.7: The backup diagram for truncated TD(A).\nExercise 12.5 Several times in this book (often in exercises) we have established that returns can be written as sums of TD errors if the value function is held constant. Why is (12.11) another instance of this? Prove (12.11).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExercise 12.6 The parameter A characterizes how fast the exponential weighting in Figure 12.2 falls off, and thus how far into the future the A-return algorithm looks in determining its backup. But a rate factor such as A is sometimes an awkward way of characterizing the speed of the decay. For some purposes it is better to specify a time constant, or half-life. What is the equation relating A and the half-life, t\\A1\\F6\\C8\\EB,the time by which the weighting sequence will have fallen to half of its initial value? \\A1\\F5\n12.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Redoing Updates: The Online A-return Algorithm\nChoosing the truncation parameter n in Truncated TD(A) involves a tradeoff. n should be large so that the method closely approximates the off-line A-return al\u0026shy;gorithm, but it should also be small so that the updates can be made quicker and influence behavior quicker. Can we get the best of both? Well, yes, in principle we can, albeit at the cost of computational complexity.\nThe idea is that, on each time step as you gather a new increment of data, you go back and redo all the updates since the beginning of the current episode. The new updates will be better than the ones you previously made because now they can take into account the time step\\A1\\AFs new data. That is, the updates are always towards an n-step truncated A-return target, but they always use the latest horizon. In each pass over that episode you can use a slightly longer horizon and obtain slightly better\nresults. Recall that the n-step truncated A-return is defined by\nh-t-1\n \n\u0026nbsp;\n \n   (12.9)\n        Gi\\A3\\BAh\n     (1- A)XniGt\\A3\\BAt+n + Ah t iGt\\A3\\BAh\n \n\u0026nbsp;\n \nLet us step through how this target could ideally be used if computational com\u0026shy;plexity was not an issue. The episode begins with an estimate at time 0 using the weights wo from the end of the previous episode. Learning begins when the data horizon is extended to time step 1. The target for the estimate at step 0, given the data up to horizon 1, could only be the one-step return Go\\A3\\BAi,which includes Ri and bootstraps from the estimate v(Si,wo). In (12.9), this is exactly what Gq\\A3\\BAiis, taking the last part of the equation. Using this update target, we construct wi. Then, after advancing the data horizon to step 2, what do we do? We have new data in the form of R2and S2, as well as the new wi, so now we can construct a better update target Gq\\A3\\BA2for the first update from So as well as a better update target Gq\\A3\\BA2for the second update from Si. We perform both of these updates in sequence to produce w2. Now we advance the horizon to step 3 and repeat, going all the way back to produce three new updates and finally w3, and so on.\nThis conceptual algorithm involves multiple passes over the episode, one at each horizon, each generating a different sequence of weight vectors. To describe it clearly we have to distinguish between the weight vectors computed at the different horizons. Let us use wf to denote the weights used to generate the value at time t in the sequence at horizon h. The first weight vector in each sequence is that inherited from the previous episode, wh == wo, and the last weight vector in each sequence defines the ultimate weight-vector sequence of the algorithm wh == wh. At the final horizon h = T we obtain the final weights wt == wT which will be passed on to form the initial weights wo of the next episode. With these conventions, the three first sequences described in the previous paragraph can be given explicitly:\nh = 1:w]\\A3\\BB= w^ + a Gq\\A3\\BA1- v(So,wi) Vv(So,wi),\n \n   22 wi = wo + a\nw2== w2+ a\n        w^)Vv(So,w2),\nw2)\u0026quot;| Vv(Si,w2),\n        G0\\A3\\BA2- v(So G^\\A3\\BA2- v(Si\n        h=3\n        w\nw\nw3\n        w0)w0)w0)\n        Vv(So,w2),\nVV(Si,w3),\n\\A8\\8CV(S2,w3).\n        V(So\nv(Si\nV(S2\n        G0\nGo\\A3\\BA3 -\nG0\nG1\\A3\\BA3 - G0\nG2\\A3\\BA3 -\n        w0+ a w3+ a 3\nw2+ a\n        h=2\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n The general form for the update is\n \n   (12.13)\n        h+1= wh + a\n        w\n        G0\\A3\\BAh- V(St,wth) VV(St,wth), 0 \u0026lt; t\u0026lt;h \u0026lt; T.\n     \u0026nbsp;\n a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\n   On-line \\C8\\EB-return algorithm\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-line\\C8\\EB-return algorithm\n     Figure 12.8: 19-state Random walk results (Example 7.1): Performance of online and off\u0026shy;line X-return algorithms. The performance measure here is the MSVE at the end of the episode, which should be the best case for the off-line algorithm. Nevertheless, the on-line algorithm performs subtlely better. For comparison, the X = 0 line is the same for both methods.\nThis update, together with wt == w\\defines the online X-return algorithm.\nThe online X-return algorithm is fully online, determining a new weight vector wt at each step t during an episode, using only information available at time t. It\\A1\\AFs main drawback is that it is computationally complex, passing over the entire episode so far on every step. Note that it is strictly more complex than the off-line X-return algorithm, which passes through all the steps at the time of termination but does not make any updates during the episode. In return, the online algorithm can be expected to perform better than the off-line one, not only during the episode when it makes an update while the off-line algorithm makes none, but also at the end of the episode because the weight vector used in bootstrapping (in G;^) has had a greater number of informative updates. This effect can be seen if one looks carefully at Figure 12.8, which compares the two algorithms on the 19-state random walk task.\n12.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; True Online TD(A)\nThe on-line X-return algorithm just presented is currently the best performing temporal- difference algorithm. As presented, however, it is very complex. Is there a way to invert this forward-view algorithm to produce an efficient backward-view algorithm using eligibility traces? It turns out that there is indeed an exact computationally congenial implementation of the on-line X-return algorithm for the case of linear function approximation. This implementation is known as the true online TD(X) algorithm because it is \\A1\\B0truer\\A1\\B1 to the idea of the online TD(X) algorithm, truer even than the TD(X) algorithm itself.\nThe derivation of true on-line TD(X) is a little too complex to present here (see the next section and the appendix to the paper by van Seijen et al., 2016) but its\nstrategy is simple. The sequence of weight vectors produce by the on-line A-return algorithm can be arranged in a triangle:\n \n   (12.14)\n        w0\nw0\nw0\nw0\nw0\n        w\nw\nw\n        w| w\\C4\\D2\n        WT\nT3\nw\nT2\n.w\nTl\n.w\nTo\n              \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n    then we arrive at the\n     One row of this triangle is produced on each time step. Really only the weight vectors on the diagonal, the w^ need to be produced by the algorithm. The first, w0, is the input, the last, w^, is the output, and each weight vector along the way, wf, plays a role in bootstrapping in the n-step returns of the updates. In the final algorithm the diagonal weight vectors are renamed without a superscript, wt == w^. The strategy then is to find a compact, efficient way of computing each w\\from the one before. If this is done, for the linear case in which {)(s,w) = wTx(s), true online TD(A) algorithm:\n   (12.15)\n     wt+i = wt + a8tet + a (wtTxt - w^\\A1\\BExt) (et - xt),\nwhere we have used the shorthand xt == x(St), 8t is defined as in TD(A) (12.6), and et is defined by\n   et\n     yAet-i + (1- aYAe^xt) xt.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.16)\nThis algorithm has been proven to produce exactly the same sequence of weight vec\u0026shy;tors, wt, 0 \u0026lt; t \u0026lt; T, as the on-line A-return algorithm (van Siejen et al. 2016). Thus the results on the random walk task on the left of Figure 12.8 are also its results on that task. Now, however, the algorithm is much less expensive. The memory re\u0026shy;quirements of true online TD(A) are identical to those of conventional TD(A), while the per-step computation is increased by about 50% (there is one more inner prod\u0026shy;uct in the eligibility-trace update). Overall, the per-step computational complexity remains of O(d), the same as TD(A). Pseudocode for the complete algorithm is given in the box on the next page.\nThe eligibility trace (12.16) used in true online TD(A) is called a dutch traceto distinguish it from the trace (12.5) used in TD(A), which is called an accumulating trace.Earlier work often used a third kind of trace called the replacing trace, defined only for the tabular case or binary feature vectors such as are produced by tile coding. The replacing trace is defined on a component-by-component basis depending on whether the component of the feature vector was 1or 0:\n\u0026#12316;={YAei,t-i otSwi\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.17)\nNow, however, use of the replacing trace it deprecated; a dutch trace should almost always be used instead.\n \nTrue Online TD(A) for estimating wTx ^ Vn\nInput: the policy n to be evaluated\nInitialize value-function weights w arbitrarily (e.g., w = 0) Repeat (for each episode):\n   x\n(an n-dimensional vector)\n(a scalar temporary variable)\nof the next state)\n     Initialize state and obtain initial feature vector e 0\nVold\\A1\\AA 0\nRepeat (for each step of episode):\n| Choose A \u0026#12316;n\n| Take action A, observe R, x!(feature vector | V\\A1\\AA wTx |\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Vf\\A1\\AA wTx;\n|\u0026nbsp;\u0026nbsp; 5 \\A1\\AA R + 7W - V\n| e \\A1\\AA 7Ae + (1- a7A eTx) x | w \\A1\\AA w + a(5 + V - Vold)e - a(V - V\u0026gt;ld)x |\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Vold\\A1\\AA V'\n| x \\A1\\AA x'\nuntil x' = 0(signaling arrival at a terminal state)\n12.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Dutch Traces in Monte Carlo Learning\nAlthough eligibility traces are closely associated historically with TD learning, in fact they have nothing to do with it. In fact, eligibility traces arise even in Monte Carlo learning, as we show in this section. We show that the linear MC algorithm (Chapter 9), taken as a forward view, can be used to derive an equivalent yet com\u0026shy;putationally cheaper backward-view algorithm using dutch traces. This is the only equivalence of forward- and backward-views that we explicitly demonstrate in this book. It gives some of the flavor of the proof of equivalence of true online TD(A) and the on-line A-return algorithm, but is much simpler.\nThe linear version of the gradient Monte Carlo prediction algorithm (page 216) makes the following sequence of updates, one for each time step of the episode:\nwt+i == wt + a G - wfxt xt,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0 \u0026lt; t \u0026lt; T.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.18)\nTo make the example a simpler, we assume here that the return G is a single reward received at the end of the episode (this is why G is not subscripted by time) and that there is no discounting. In this case the update is also known as the least mean square (LMS) rule. As a Monte Carlo algorithm, all the updates depend on the final reward/return, so none can be made until the end of the episode. The MC algorithm is an offline algorithm and we do not seek to improve this aspect of it. Rather we seek merely an implementation of this algorithm with computational advantages. We will still update the weight vector only at episode\\A1\\AFs end, but we will do somecomputation during each step of the episode and less at its end. This will give a more equal distribution of computation\\A1\\AAO(d) per step\\A1\\AAand also remove the need to store the feature vectors at each step for use later at the end of each episode. Instead, we will introduce an additional vector memory, the eligibility trace, keeping in it a summary of all the vectors seen so far. This will be sufficient, at episode\\A1\\AFs end to efficiently recreate exactly the same overall update as the sequence of MC updates (12.18).\nwt = wt-i + a (G - wr_ixr_i) xt-i\n=wt-i + axT-i (-xj_iwr_i) + aGxT-i =(I - axT_ixj_i) wt-i + aGxT_i =Ft _iwt_i + aGxT _i\nI - axtxj is a forgetting,or fading,matrix. Now, recursing,\nwhere Ft\nFt_i (Ft_2wt_2+ aGx^_2) + Gax^_i Ft _iFt-2wt-2+ aG (Ft -ixt-2+ xt _i)\nFt_iFt-2(Ftswt-3+ aGx^-3) + aG (Ft-ixt-2+ xt_i)\nFt_iFt-2Ft_3wt-3+ aG (Ft-iFt_2xt-3+ Ft-ixt-2+ xt_i)\nt-i\nFt_iFt_2\\A1\\F6 \\A1\\F6 \\A1\\F6 Fowo + aG\u0026nbsp;\u0026nbsp; Ft_iFt-2\\A1\\F6 \\A1\\F6 \\A1\\F6 Fk+ix^\nv\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; arci\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; '\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,\neT-i\n=aT _i + aGeT _i,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.19)\nwhere aT_i and eT_i are the values at time T -1 of two auxilary memory vectors that can be updated incrementally without knowledge of G, and with O(d) complexity per time step. The et vector is in fact a dutch-style eligibility trace. It is initialized to eo =. xo and then updated according to\net ^=E FtF t-i ' ' ' Fk+ixk,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1\u0026lt; t \u0026lt; T\nk=0 t-i\n=^ FtFt-i \\A1\\F6 \\A1\\F6 \\A1\\F6 Ffc+ixfc + axt\n,t-i . . . \u0026#8226;\nk=0\nt-i\nFt ^ Ft-iFt-2\\A1\\F6 \\A1\\F6 \\A1\\F6 Ffc+ixfc+ axt fc=o Ftet-i + xt\n(I - axtxj ) et-i + xt\n=et-i - axtx;et-i + xt =et-i - a (e^xt) xt + xt =et-i + (1 - ae^xt) xt,\nwhich is the dutch trace for the case of 7A = 1 (cf. Eq. 12.16). The at auxilary vector is initialized to ao = wo and then updated according to\nat = FtFt-i \\A1\\ADFowo = Ftat-i = at-i - axtxfat-i,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1\u0026nbsp; \u0026lt;t\u0026lt;T.\u0026nbsp; (12.20)\nThe auxiliary vectors, at and et, are updated on each time step t \u0026lt; T and then, at time T when Gis observed, they are used in (12.19) to compute wt. In this way we achieve exactly the same final result as the MC/LMS algorithm with poor computational properties (12.18), but with an incremental algorithm whose time and memory complexity per step is O(d). This is surprising and intriguing because the notion of an eligibility trace (and the dutch trace in particular) has arisen in a setting without temporal-difference (TD) learning (in contrast to Van Seijen \u0026amp; Sutton 2014). It seems eligibility traces are not specific to TD learning at all; they are more fundamental than that. The need for eligibility traces seems to arise whenever one tries to learn long-term predictions in an efficient manner.\n12.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sarsa(A)\nVery few changes in the ideas already presented in this chapter are required in order to extend eligibility-traces to action-value methods. To learn approximate action values, q(s, a, w), rather than approximate state values, v(s,w), we need to use the action-value form of the n-step return, from Chapter 10:\nGt:t+n = Rt+l + ... + 7^ lRt+n + T'KSt+n, At+n, wt+n-l),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.4)\nfor all n and t such that n \u0026gt; 1 and 0 \u0026lt; t \u0026lt; T -n. Using this, we can form the action- value form of the truncated A-return, which is otherwise identical to the state-value form (12.9). The action-value form of the off-line A-return algorithm (12.4) simply uses qrather than v:\n \n\u0026nbsp;\n \n   A\n        wt+i = wt + a\n     -q(St, Atwt) Vq(St, At, wt), t = 0,\\A1\\AD\\A3\\ACT - 1,\u0026nbsp;\u0026nbsp; (12.21)\n \n\u0026nbsp;\n \nwhere G^ == G^\\A3\\BA^.The compound backup diagram for this forward view is shown in Figure 12.9. Notice the similarity to the diagram of the TD(A) algorithm (Fig\u0026shy;ure 12.1). The first backup looks ahead one full step, to the next state-action pair, the second looks ahead two steps, to the second state-action pair, and so on. A final backup is based on the complete return. The weighting of each n-step backup in the A-return is just as in TD(A) and the A-return algorithm (12.3).\n   (12.7)\n     The temporal-difference method for action values, known as Sarsa(A), approxi\u0026shy;mates this forward view. It has the same update rule as given earlier for TD(A):\nwt+i = wt + a8t et,\n \nSarsa(A)\n \n   1 - A\n     S At St+i Rt+i At+i St+2 Rt + 2 At+2\n \n\u0026nbsp;\n \n(1 -\\C8\\EB)\\C8\\EB\n \n\u0026nbsp;\n\u0026nbsp;\n \n   (i -\\C8\\EB)\\C8\\EB2\n     \\B6\\A1At-i\nI ISt Rt\nAt -\nFigure 12.9: Sarsa(A),s backup diagram. Compare with Figure 12.1.\nexcept, naturally, using the action-value form of the TD error:\n5t = Rt+i + 7q(St+i, At+i, wt) - q(St, At, wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.22)\nand the action-value form of the eligibility trace:\ne-i.=. 0,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.23)\net == 7Aet-i + Vq(St, At, wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0 \u0026lt; t \u0026lt; T\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (\\81A\\81A\\A2\\C7\\A3\\A9\n(or the alternate replacing trace given by (12.17)). Complete pseudocode for Sarsa(A) with linear function approximation, binary features, and either accumulating or re\u0026shy;place traces is given in the box. This pseudocode highlights a few optimizations possible in the special case of binary features.\nSarsaQ) with binary features and linear function approximation for estimating q^ or q^\nInput: a function F(s, a) returning the set of (indices of) active features for s, a Input: a policy n to be evaluated, if any\nInitialize parameter vector w = (wi,..., wn) arbitrarily (e.g., w = 0)\nLoop for each episode:\nInitialize S\nChoose A \u0026#12316;n(-|S) or e-greedy according to q(S, \\A1\\F6, w) e 0\nLoop for each step of episode:\nTake action A, observe R, Sf5\\A1\\AA R\nLoop for iin F(S, A):\n   (accumulating traces) (replacing traces)\n        near greedily\u0026nbsp;\u0026nbsp;\u0026nbsp; q(S;, \\A1\\F6, w)\n5 \\A1\\AA 5 + 7Wi\n     5 \\A1\\AA 5 - Wi ei \\A1\\AA ei + 1 or ei \\A1\\AA 1 If S1is terminal then: w \\A1\\AA w + a5 e Go to next episode Choose A;\u0026#12316;n(-|S;) or Loop for i in F(SA;): w \\A1\\AA w + a5 e e \\A1\\AA T^e\nS\u0026nbsp; t S;; At#\nExample 12.1: Traces in Gridworld The use of eligibility traces can substan\u0026shy;tially increase the efficiency of control algorithms over one-step method and even over n-step methods. The reason for this is illustrated by gridworld example below.\nAction values increased Action values increased Action values increased Path taken\u0026nbsp;\u0026nbsp; by\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; one-step\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sarsaby\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 10-step\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sarsaby Sarsa(!) with !=0.9\n\u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n *\n -\n \u0026nbsp;\n t\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n *\n \u0026nbsp;\n \u0026nbsp;\n +\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n -\n \u0026raquo;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n +\n \u0026nbsp;\n  \u0026nbsp;\n \u0026#8226;\n \u0026nbsp;\n '\n \u0026nbsp;\n \u0026nbsp;\n G\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n  \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n \u0026nbsp;\n    \u0026nbsp;\nThe first panel shows the path taken by an agent in a single episode. In this example the values were all originally zero, and all rewards were zero except for a positive reward at the goal location marked by the G. The arrows in the other panels show which actions would be strengthened upon reaching the goal by various algorithms. A one-step method would update only the last action, whereas an n-step method would equally update the last n actions, and an eligibility trace method would update all the actions up to the beginning of the episode to different degrees, fading with recency.\nThe fading strategy is often the best tradeoff, strongly learning how to reach the goal from the right, yet not as strongly learning the roundabout path to the goal from the left that was taken in this episode.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\nExercise 12.7 Modifiy the pseudocode for Sarsa(A) to use dutch traces (12.16) alone without the other features of a true online algorithm. Continue to assume linear function approximation and binary features.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nExample 12.2: Sarsa(A) on Mountain Car Figure 12.10 shows results with Sarsa(A) on the Mountain Car task introduced in Example 10.1. The function ap\u0026shy;proximation, action selection, and environmental details were exactly as in Chap\u0026shy;ter 10such that these results can be numerically compared with those for an n-step Sarsa. Those results varied the backup length n whereas here for Sarsa(A) we vary the trace parameter A, which plays a similar role. The fading-trace bootstrapping strategy of Sarsa(A) appears to result in more efficient learning on this problem.\n   n-step Sarsa\n     Sarsa(\\C8\\EB\\A3\\A9with replacing traces\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Mountain Car\nSteps per episode\naveraged over first 50 episodes and 100 runs\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 12.10: Early performance on the Mountain Car task of Sarsa(A) with replacing traces and n-step Sarsa (copied from Figure 10.4) as a function of the step size, a.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F6\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nThere is also an action-value version of our ideal TD method, the onlineA-return algorithm presented in Section 12.4. Everything in that section goes through without change other than to use the action-value form of the n-step return given at the beginning of this section. In the case of linear function approximation, the ideal algorithm again has an exact, efficient O(d) implementation, called True Online Sarsa(A).The analyses in Sections 12.5 and 12.6 carry through without change other than to use state-action feature vectors xt = x(St, At) instead of state feature vectors xt = x(St). The pseudocode for this algorithm given in the a box on the next page. Figure 12.11compares the performance of various versions of Sarsa(A) on the Mountain Car example.\n\n\nTrue Online Sarsa(A) for estimating wTx ^ \\BF\\DBor q^\nInput: a feature function x : S+ x ARd s.t. x(terminal, \\A1\\F6) = 0 Input: the policy n to be evaluated, if any\nInitialize parameter w arbitrarily (e.g., w = 0)\nLoop for each episode:\nInitialize S\nChoose A \u0026#12316;n(-|S) or near greedily from S using w; x \\A1\\AA x(S, A) e \\A1\\AA 0\nQoid \\A1\\AA 0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (ascalartemporary variable)\nLoop for each step of episode:\n|Take action A, observe R, Sح\n|Choose A'\u0026#12316;n(-|S;) or near greedily from Sfusing w; x; \\A1\\AA x(S\u0026#12316;A;)\n|Q\\A1\\AA wTx\n|Q' \\A1\\AA wTx'\n|8\\A1\\AA R + yQ' - Q\n|e \\A1\\AA 7Ae + (1- aYA eTx) x\n1\u0026nbsp;\u0026nbsp;\u0026nbsp; w \\A1\\AA w+ a(8+ Q - Qo1d)e - a(Q - Qo1d)x\nI\u0026nbsp;\u0026nbsp;\u0026nbsp; Qo1d \\A1\\AA Q'\n|x \\A1\\AA xZ\n|AL \\A1\\AA#\nuntil S' is terminal\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Mountain Car\nReward per episode averaged over first 20 episodes and 100 runs\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Sarsa(\\C8\\EB\\A3\\A9with replacing traces\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 12.11: Summary comparison of Sarsa(A) algorithms on the Mountain Car task. True Online Sarsa(A) performed better than regular Sarsa(A) with both accumulating and replacing traces. Also included is a version of Sarsa(A) with replacing traces in which, on each time step, the traces for the state and the actions not selected were set to zero.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n12.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Variable A and 7\nWe are starting now to reach the end of our development of fundamental TD learning algorithms. To present the final algorithms in their most general forms, it is useful to generalize the degree of bootstrapping and discounting beyond constant parameters to functions potentially dependent on the state and action. That is, each time step will have a different \\C8\\EBand 7, denoted Xt and 7t. We change notation now so that \\C8\\EB:S x A[0,1] is now a whole function from states and actions to the unit interval such that Xt == XfSt, At), and similarly, 7: S [0,1] is a function from states to the unit interval such that 7t == 7(St).\nThe latter generalization, to state-dependent discounting, is particularly significant because it changes the return, the fundamental random variable whose expectation we seek to estimate. Now the return is defined more generally as\nGt = Rt+i + 7t+iGt+i\n=Rt+i + 7t+iRt+2 + 7t+i7t+2Rt+3 + 7t+i 71+2 7t+3Rt+4 +\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z ^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\n=^ Rk+i\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 7i,\nk=t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+i\nwhere, to assure the sums are finite, we require that H^k=t 7k = 0with probability one for all t. One convenient aspect of this definition is that it allows us to dispense with episodes, start and terminal states, and T as a special cases and quantities. A terminal state just becomes a state at which 7(s) = 0 and which transitions to the start state. In that way (and by choosing 7(-) as a constant function) we can recover the classical episodic setting as a special case. State dependent discounting includes other prediction cases such as soft termination, when we seek to predict a quantity that becomes complete but does not alter the flow of the Markov process. Discounted returns themselves can be thought of as such a quantity, and state de\u0026shy;pendent discounting is a deep unification of the episodic and discounted-continuing cases. (The undiscounted-continuing case still needs some special treatment.)\nThe generalization to variable bootstrapping is not a change in the problem, like discounting, but a change in the solution strategy. The generalization affects the X-returns for states and actions. The new state-based X-return can be written recur\u0026shy;sively as\nG;s= Rt+i + 7t+i ((1- Xt+i)(\u0026amp;(St+i,wt) + Xt+iG\\A3\\BB+1) ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.24)\nwhere now we have added the \\A1\\B0s\\A1\\B1 to the superscript X to remind us that this is a return that bootstraps from state values, distinguishing it from returns that boot\u0026shy;strap from action values, which we present below with \\A1\\B0a\\A1\\B1 in the superscript. This equation says that the X-return is the first reward, undiscounted and unaffected by bootstrapping, plus possibly a second term to the extent that we are not discount\u0026shy;ing at the next state (that is, according to 7t+i\\A3\\BBrecall that this is zero if the next state is terminal). To the extent that we aren\\A1\\AFt terminating at the next state, wehave a second term which is itself divided into two cases depending on the degree of bootstrapping in the state. To the extent we are bootstrapping, this term is the estimated value at the state, whereas, to the extent that we not bootstrapping, the\nnext time step. The action-based X-return is either the\nterm is the X-return for the Sarsa form\n   (12.25)\n     G;a= Rt+i + 7t+i ((1 - Xt+i)3(St+i, At+i, wt) + Xt+iG;+i or the Expected Sarsa form,\n\n\n\u0026nbsp;SHAPE \u0026nbsp;\\* MERGEFORMAT    \u0026nbsp;\n      \u0026nbsp;\n \n   -Xt+i)Ot+i + Xt+iGj^i\n        (12.26)\n     G;a= Rt+i + 7t+i ((1\nwhere\n \n\u0026nbsp;\n \n   (12.27)\n     Qt == ^n(a|St)q(St,a, wt_i).\nExercise 12.8 Generalize the three recursive equations above to their truncated versions, defining G\\A3\\BBh and G;h.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n12.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy Eligibility Traces\nThe final step is to incorporate importance sampling. Unlike in the case of n-step methods, for full non-truncated X-returns one does not have a practical option in which the importance sampling is done outside the target return. Instead, we move directly to the bootstrapping generalization of per-reward importance sampling (Sec\u0026shy;tion 7.4). In the state case, our final definition of the X-return generalizes (12.24), after the model of (7.10), to\nG;s= pt(Rt+i + 7t+i((1 -Xt+i)v(St+i,wt) + Xt+iG\\A3\\BB+1)) +(1 -pt)v(St,wt) (12.28)\nwhere pt =ū\\C6\\EF)is the usual single-step importance sampling ratio. Much like the other returns we have seen in this book, the truncated version of this return can be approximated simply in terms of sums of the state-based TD error,\n5f = Rt+i + 7t+iV(St+i,wt) - v(St,wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.29)\nas\n^ k\nG\\A3\\BBs~ v(St,wt) + ptY^5s n 7iXiPi\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.30)\nk=t i=t+i\nwith the approximation becoming exact if the approximate value function does not change.\nExercise 12.9 Prove that (12.30) becomes exact\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; if\u0026nbsp;\u0026nbsp; thevaluefunction\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; does not\nchange. To save writing, consider the case of\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; t\u0026nbsp; =0,and\u0026nbsp; usethenotation Vk ==\nv(Sk ,w).\nExercise 12.10 The truncated version of general off-policy is denoted GAh. Guess the correct equation, based on (12.30).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nThe above form of the A-return is convenient to use in a forward-view update,\n \n\u0026nbsp;\n \n   -rAs\n        wt+i = wt + a\n     -V(St,wt)) Vv(St,wt)\n \n\u0026nbsp;\n \n~ wt + apt حE\nv k=t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; )\nwhich to the experienced eye looks like an eligibility-based TD updateһthe product is like an eligibility trace and it is multiplied by TD errors. But this is just one time step of a forward view. The relationship that we are looking for is that the forward-view update, summed over time, is approximately equal to a backward-view update, summed over time (this relationship is only approximate because again we ignore changes in the value function). The sum of the forward-view update over time is\nyi(wt+i- wt)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; apt8s Vv(St,wt^ n 7i AiPi\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z t=l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; t=l k=t\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+l\n^ k\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\n=naPtV^(St ,wt)8s n 7i AiPi\nk=lt=l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+l\n(using the summationrule: eLx ELt = ELx E*k=x) ^k\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\na8SX!ptV^(St,wt^ n 7iAiPi, k=lt=l\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+l\nwhich would be in the form of the sum of a backward-view TD update if the entire expression from the second sum left could be written and updated incrementally as an eligibility trace, which we now show can be done. That is, we show that if this expression was the trace at time k, then we could update it from its value at time k- 1 by:\nek\n^^PtW(St,wt)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; YiAiPi\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z t=l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+l\nk-1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k\n   + Pk V-0(Sk ,wk)\n7 iAiPi + Pk V-0(Sk ,wk)\n     ^ptVv(St,wt^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; YiAiPi\nt=l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+l\nk-l\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; k-l\n7 k Ak Pk[ ptV^(St,wt)n\n=t+i\nek-1\n=Pk (7k Ak ek-i + Vv(Sk ,wk)),\nwhich, changing the index from k to t, is the general accumulating trace update for state values:\n   (12.31)\n     et == pt(7tAtet-i + ViD(St,wt^,\n \nThis eligibility trace, together with the usual semi-gradient parameter-update rule for TD(A) (12.7), forms a general TD(A) algorithm that can be applied to either on-policy or off-policy data. In the on-policy case, the algorithm is exactly TD(A) because pt is alway 1 and (12.31) becomes the usual accumulating trace (12.5) (extended to variable A and 7). In the off-policy case, the algorithm often works well but, as an semi-gradient method, is not guaranteed to be stable. In the next few sections we will consider extensions of it that do guarantee stability.\nA very similar series of steps can be followed to derive the off-policy eligibility traces for action-value methods and corresponding general Sarsa(A) algorithms. One can start with either recursive form for the general action-based A-return, (12.25) or (12.26). Let's use the latter here, as it is more different than the state-based case that we have already done. We extend (12.26) to the off-policy case after the model of (7.11) to produce\n   -rAa\n     Rt+i + 7t+i ((1- At+i)6t+i + At+i (pt+iG\\A1\\E3+i + (1-Pt+i)6t+i)) (12.32)\nwhere Qt+i is as given by (12.27). Again the A-return can be written approximately as the sum of TD errors,\n   -rAa\n     ~ q(St, At, wt) + L \\9A{II 7iAiPi,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.33)\nk=t\u0026nbsp;\u0026nbsp;\u0026nbsp; i=t+1\nThis time using the expectation-based form of the TD error,\n= Rt+1+ 71+1^51+1 - q(St; At, wt).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.34)\nAs before, the approximation becomes exact if the approximate value function does not change.\nExercise 12.11 The truncated version of general off-polincy is denoted G;^. Guess the correct equation, based on (12.33).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nUsing steps entirely analogous to those for the state case, one can write a forward- view update based on (12.33), transform the sum of the updates using the summation rule, and finally derive the following form for the eligibility trace for action values:\net = 7tAtPtet-i + Vq(St, At, wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.35)\nThis eligibility trace, together with the usual semi-gradient parameter-update rule (12.7), forms a general Expected Sarsa(A) algorithm that can be applied to either on- policy or off-policy data though, in the off-policy case it is not stable unless combined with one of the methods presented in the following sections.\nExercise 12.12 Show in detail the steps outlined above for deriving (12.35) from (12.33).\\A1\\F5\nExercise 12.13 Show how similar steps can be followed starting from the Sarsa form of the action-based A-return (12.25) to derive the same eligibility trace algorithm as (12.35), but with the Sarsa TD error:\n\\85\\BC=Rt+1+ 7q(St+i, At+i, wt) - q(St, At, wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.36)\nto establish a general Sarsa(X) algorithm, applicable to both on-policy and off-policy data, that is the same as the Sarsa(X) algorithm that presented in Section 12.7 in the on-policy case with constant X and 7.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\nAt X = 1, these algorithms become closely related to corresponding Monte Carlo algorithms. One might expect that an exact equivalence would hold for episodic problems and off-line updating, but in fact the relationship is subtler and slightly weaker than that. Under these most favorable conditions still there is not an episode by episode equivalence of updates, only of their expectations. This should not be surprising as these method make irrevocable updates as a trajectory unfolds, whereas true Monte Carlo methods would make no update for a trajectory if any action within it has zero probability under the target policy. In particular, all of these methods, even at X = 1, still bootstrap in the sense that their targets depend on the current value estimates\\A1\\AAits just that the dependence cancels out in expected value. Whether this is a good or bad property in practice is another question. Recently methods have been proposed that do achieve an exact equivalence (Sutton, Mahmood, Precup and van Hasselt, 2014). These methods require an additional table of \\A1\\B0provisional values\\A1\\B1 that keep track of updates which have been made but may need to be retracted (or emphasized) depending on the actions taken later. The state and state-action versions of these methods are called PTD(X) and PQ(X) respectively, where the \\A1\\AEP\\A1\\AF stands for Provisional.\nThe practical consequences of all these new off-policy methods have not yet been established. Undoubtedly, issues of high variance will arise as they do in all off-policy methods using importance sampling (Section 11.9).\nIf X \u0026lt; 1, then all these off-policy algorithms involve bootstrapping and the deadly triad applies (Section 11.3), meaning that they can be guaranteed stable only for the tabular case, for state aggregation, and for other limited forms of function approxi\u0026shy;mation. For linear and more-general forms of function approximation the parameter vector may diverge to infinity as in the examples in Chapter 11. As we discussed there, the challenge of off-policy learning has two parts. Off-policy eligibility traces deal effectively with the first part of the challenge, correcting for the expected value of the targets, but not at all with the second part of the challenge, having to do with the distribution of updates. Three algorithmic strategies for meeting the second part of the challenge of off-policy learning with eligibility traces are presented in the next three sections.\nExercise 12.14 What are the dutch-trace and replacing-trace versions of off-policy eligibility traces for state-value and action-value methods?\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\F5\n12.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Watkins\\A3\\ACsQ(A) to Tree-Backup(A)\n   g to eligibility es in the usual after the first n Figure 12.12. licy version of it to arbitrary our treatment In Chapter 7, Tree Backup, ng. It remains well call Tree- to Q-learning ough it can be\niagram in Fig- ed in the usual led equations, parameters, it action values,\n     Several methods have been proposed over the years to extend Q-learnii traces. The original is Watkins's Q(A),which decays its eligibility trac way as long as a greedy action was taken, then cuts the traces to zero non-greedy action. The backup diagram for Watkins\\A1\\AFs Q(A) is shown i] In Chapter 6, we unified Q-learning and Expected Sarsa in the off-po the latter, which includes Q-learning as a special case, and generalizes target policies, and in the previous section of this chapter we completed of Expected Sarsa by generalizing it to off-policy eligibility traces. however, we distinguished multi-step Expected Sarsa from multi-step where the latter retained the property of not using importance sampli then to present the eligibility trace version of Tree Backup, which we Backup(A),or TB(A)for short. This is arguable the true successor because it retains its appealing lack of importance sampling even th applied to off-policy data.\nThe concept of TB(A) is straightforward. As shown in its backup d ure 12.13, the tree backups of each length (from Section 7.5) are weight way dependent on the bootstrapping parameter A. To get the deta with the right indexes on the general bootstrapping and discounting is best to start with a recursive form (12.26) for the A-return using\nWatkins\\A1\\AFs Q(A)\nSt At St+i Rt+i At+i\n \n   +o\\A1\\AAI *o\\A1\\AAI\n        St+2 Rt+2 At+2\n        ponent backups hichever comes\n        1 - A\n        OR\n        n-greedy action\n        (1 - A)A\n              \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Tree Backup(A)\n \n   \u0026#8226; \u0026#8226; \u0026#8226;\n        1- A\n     St At St+i Rt+1 At+i St + 2 Rt+2\nAt + 2\n \n\u0026nbsp;\n \n(1-\\C8\\EB)\\C8\\EB\n \n\u0026nbsp;\n\u0026nbsp;\n \n   (i -\\C8\\EB)\\C8\\EB2\n     St-i\n\\B6\\A1\u0026#8226; At -i\nI I\u0026nbsp;\u0026nbsp; St Rt\nAt -\nFigure 12.13: The backup diagram for the X version of the Tree Backup algorithm.\nand then expand the bootstrapping case of the target after the model of (7.13):\nRt+i + 7t+i ((1- Xt+i)^Qt+i + Xt+i (\n^ n(a|St+i)q(St+i,a,wt)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; + أ(At+ilSt+JG^+i))\n=Rt+i + 7t+i(6t+i + Xt+in(At+i|St+i^G\\A3\\BB+i - q(St+i,At+i, wt)))\nAs per the usual pattern, it can also be written approximately (ignoring changes in the approximate value function) as a sum of TD errors,\n-rAa\n \n   (12.37)\n        ~ q(St, At, wt) + t 5g n 7iXiPi,\n        t+i\n        -rAa\n        k=t\n     \u0026nbsp;\n using the expectation form of the action-based TD error (12.34). Following the same steps as in the previous section, we arrive at a special eligibility trace update involving the target-policy probabilities of the selected actions,\n   (12.38)\n     et == 7tXtn(At|St)et_i + Vq(St, At, wt).\nThis, together with the usual parameter-update rule (12.7), defines the TB(X) al\u0026shy;gorithm. Like all semi-gradient algorithms, TB(X) is not guaranteed to be stable when used with off-policy data and with a powerful function approximator. For that it would have to be combined with one of the methods presented in the next two sections.\n \n12.11\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Stable Off-policy Methods with Traces\nSeveral methods using eligibility traces have been proposed that achieve guarantees of stability under off-policy training, and here we present four of the most important using this book\\A1\\AFs standard notation, including general bootstrapping and discount\u0026shy;ing functions. All are based on either the Gradient-TD or the Emphatic-TD ideas presented in Sections 11.7 and 11.8. All the algorithms assume linear function ap\u0026shy;proximation, though extensions to nonlinear function approximation can also be found in the literature.\nGTD(A)is the eligibility-trace algorithm analogous to TDC, the better of the two state-value Gradient-TD prediction algorithms discussed in Section 11.7. It\\A1\\AFs goal is to learn a parameter wt such that {)(s,w) == w7x(s)\\B0\\D1Vn(s) even from data that is due to following another policy b. Its update is\nwt+i = wt + a8tset - a7t+i(1 - At+i) (efvt) xt+i,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.39)\nwith 8|, et, and pt defined in the usual ways for state values (12.29) (12.31) (11.1), and\nvt+l =¬\\BA\\C3et - P(vtTxt) xt,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.40)\nwhere, as in Section 11.7, v G Rd is a vector of the same dimension as w, initialized to vo = 0, and P \u0026gt; 0 is a second step-size parameter.\nGQ(A)is the Gradient-TD algorithm for action values with eligibility traces. It\\A1\\AFs goal is to learn a parameter wt such that q(s, a, wt) == wTx(s, a)\\B0\\D1q^(s, a) from off- policy data. If the target policy is e-greedy, or otherwise biased toward the greedy policy for q, then GQ(A) can be used as a control algorithm. Its update is\nwt+i = wt + a8t*et - a7t+i(1 - At+i) (efvt) xt+i,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.41)\nwhere xt is the average feature vector for St under the target policy,\nxt y^n(a|St)x(St,a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.42)\na\n8^ is the expectation form of the TD error, which can be written,\n8ta == Rt+i + 7t+iwTxt+i - wTxt,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.43)\net is defined in the usual ways for action values (12.35), and the rest is as in GTD(A), including the update for vt (12.40).\nHTD(A)is a hybrid state-value algorithm combining aspects of GTD(A) and TD(A). Its most appealing feature is that it is a strict generalization of TD(A) to off-policy learning, meaning that if the behavior policy happens to be the same as the target policy, then HTD(A) becomes the same as TD(A), which is not true for GTD(A). This is appealing because TD(A) is often faster than GTD(A) when both\nalgorithms converge, and TD(X) requires setting only a single step size. HTD(X) is defined by\n \n\u0026nbsp;\n \n   wt+i\nvt+i\net\n     =wt + a5tset + a ((et - eQTvt) (xt - 7t+ixt+i)\n   vo =\n .0,\n  e-i\n = 0,\n  eb\ne-i\n = 0,\n    \u0026nbsp;\n     =vt + ¬5tSet - P(4\\B6\\A1\\C1\\A6)\\A3\\A8xt - 7t+ixt+i),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; -u - ^(12\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 44)\n==Pt(71Xtet-i + xt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; '\u0026quot;\n=. 7tXtetb i+ xt,\n \n\u0026nbsp;\n \nwhere P \u0026gt; 0again is a second step-size parameter that becomes irrelevant in the on-policy case in which b= n. In addition to the second set of weights, vt, HTD(X) also has a second set of eligibility traces, ej?. These are a conventional accumulating eligibility trace for the behavior policy and become equal to et if all the pt are 1, which causes the second term in the wt update to be zero and the overall update to reduce to TD(X).\nEmphatic TD(X)is the extension of the one-step Emphatic-TD algorithm from Section 11.8 to eligibility traces. The resultant algorithm retains strong off-policy convergence guarantees while enabling any degree of bootstrapping, albiet at the cost of high variance and potentially slow convergence. Emphatic TD(X) is defined by\n   ittt ʮe MF\nA\n     Ot+ a5tet\nRt+i + 7t+ioTxt+i - OtTxt\npt(71Xtet-i + Mtxt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; with e_i = 0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (12.45)\nXt h+ (1- Xt)Ft\npt_i7tFt-i + It,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; with Fo = i(So),\nwhere Mt \u0026gt; 0is the general form of emphasis,Ft \u0026gt; 0is termed the followon trace, and It \u0026gt; 0 is the interest,as described in Section 11.8. Note that Mt, like 5t, is not really an additional memory variable. It can be removed from the algorithm by substituting its definition into the eligibility-trace equation. Pseudocode and software for the true online version of \\CD\\DFצ\\DA\\E0ذ\u0026amp;^\\B2\\B7\\B6\\A10(\\C8\\EB\\A3\\A9are available on the web (Sutton, 2015b).\nIn the on-policy case (pt = 0, Vt), Emphatic-TDQ) is similar to conventional TDQ), but still significantly different. In fact, whereas Emphatic-TDfX) is guaranteed to converge for all state-dependent \\C8\\EBfunctions, TD(X) is not. TD(X) is guaranteed convergent only for all constant \\C8\\EB.SeeYu\\A1\\AFs counterexample (Ghiassian, Rafiee, and Sutton, 2016).\n12.12\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Implementation Issues\nIt might at first appear that methods using eligibility traces are much more com\u0026shy;plex than one-step methods. A naive implementation would require every state (or state-action pair) to update both its value estimate and its eligibility trace on every time step. This would not be a problem for implementations on single-instruction, multiple-data, parallel computers or in plausible neural implementations, but it is a problem for implementations on conventional serial computers. Fortunately, fortypical values of A and 7the eligibility traces of almost all states are almost always nearly zero; only those that have recently been visited will have traces significantly greater than zero. In practice, only these few states need to be updated to closely approximate these algorithms.\nIn practice, then, implementations on conventional computers may keep track of and update only the few states with nonzero traces. Using this trick, the com\u0026shy;putational expense of using traces is typically just a few times that of a one-step method. The exact multiple of course depends on A and 7and on the expense of the other computations. Note that the tabular case is in some sense the worst case for the computational complexity of eligibility traces. When function approximation is used, the computational advantages of not using traces generally decrease. For example, if artificial neural networks and backpropagation are used, then eligibility traces generally cause only a doubling of the required memory and computation per step. Truncated A-return methods (Section 12.3) can be computationally efficient on conventional computers though always require some additional memory.\n12.13\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Conclusions\nEligibility traces in conjunction with TD errors provide an efficient, incremental way of shifting and choosing between Monte Carlo and TD methods. The atomic multi\u0026shy;step methods of Chapter 7 also enabled this, but eligibility trace methods are more general, often faster to learn, and offer different computational complexity tradeoffs. This chapter has offered an introduction to the elegant, emerging theoretical under\u0026shy;standing of eligibility traces for on- and off-policy learning and for variable boot\u0026shy;strapping and discounting. One aspect of this elegant theory is true online methods, which exactly reproduce the behavior of expensive ideal methods while retaining the computational congeniality of conventional TD methods. Another aspect is the possi\u0026shy;bility of derivations that automatically convert from intuitive forward-viewmethods to more efficient incremental backward-view algorithms. We illustrated this general idea in a derivation that started with a classical, expensive Monte Carlo algorithm and ended with a cheap incremental non-TD implementation using the same novel eligibility trace used in true online TD methods.\nAs we mentioned in Chapter 5, Monte Carlo methods may have advantages in non-Markov tasks because they do not bootstrap. Because eligibility traces make TD methods more like Monte Carlo methods, they also can have advantages in these cases. If one wants to use TD methods because of their other advantages, but the task is at least partially non-Markov, then the use of an eligibility trace method is indicated. Eligibility traces are the first line of defense against both long-delayed rewards and non-Markov tasks.\nBy adjusting A, we can place eligibility trace methods anywhere along a continuum from Monte Carlo to one-step TD methods. Where shall we place them? We do not yet have a good theoretical answer to this question, but a clear empirical answer appears to be emerging. On tasks with many steps per episode, or many stepswithin the half-life of discounting, it appears significantly better to use eligibility traces than not to (e.g., see Figure 12.14). On the other hand, if the traces are so long as to produce a pure Monte Carlo method, or nearly so, then performance degrades sharply. An intermediate mixture appears to be the best choice. Eligibility traces should be used to bring us toward Monte Carlo methods, but not all the way there. In the future it may be possible to vary the trade-off between TD and Monte Carlo methods more finely by using variable A, but at present it is not clear how this can be done reliably and usefully.\n   Mountain Car\n        dpr\n\\DA\\E8so epi\n\\E3\\EBe\n        \\C8\\EB\n        Random Walk\n        RMS error\n        0.4\n        0.3\n        0.2\n        0.5\n        Puddle World\n        \\C8\\EB\n        Cart and Pole\n        0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 0.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 1\n\\C8\\EB\n        Failures per 100,000 steps\n        Figure 12.14: The effect of A on reinforcement learning performance in four different test problems. In all cases, lowernumbers represent better performance. The two left panels are applications to simple continuous-state control tasks using the Sarsa(A) algorithm and tile coding, with either replacing or accumulating traces (Sutton, 1996). The upper-right panel is for policy evaluation on a random walk task using TD(A) (Singh and Sutton, 1996). The lower right panel is unpublished data for the pole-balancing task (Example 3.4) from an earlier study (Sutton, 1984).\n     Methods using eligibility traces require more computation than one-step methods, but in return they offer significantly faster learning, particularly when rewards are delayed by many steps. Thus it often makes sense to use eligibility traces when data are scarce and cannot be repeatedly processed, as is often the case in on\u0026shy;line applications. On the other hand, in off-line applications in which data can be generated cheaply, perhaps from an inexpensive simulation, then it often does not pay to use eligibility traces. In these cases the objective is not to get more out of alimited amount of data, but simply to process as much data as possible as quickly as possible. In these cases the speedup per datum due to traces is typically not worth their computational cost, and one-step methods are favored.\nExercise 12.15 Write pseudocode for Expected Sarsa(A) with dutch traces. \\A1\\F5 sKExercise 12.16 How might Double Expected Sarsa be extended to eligibility traces? \\A1\\F5\nBibliographical and Historical Remarks\nEligibility traces came into reinforcement learning via the fecund ideas of Klopf (1972). Our use of eligibility traces is based on Klopf\\A1\\AFs work (Sutton, 1978a, 1978b, 1978c; Barto and Sutton, 1981a, 1981b; Sutton and Barto, 1981a; Barto, Sutton, and Anderson, 1983; Sutton, 1984). We may have been the first to use the term \\A1\\B0eligibility trace\\A1\\B1 (Sutton and Barto, 1981). The idea that stimuli produce aftereffects in the nervous system that are important for learning is very old. See Chapter 14. Some of the earliest uses of eligibility traces were in the actor-critic methods discussed in Chapter 13 (Barto, Sutton, and Anderson, 1983; Sutton, 1984).\n12.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The A-return and its error-reduction properties were introduced by Watkins (1989) and further developed by Jaakkola, Jordan and Singh (1994). The random walk results in this and subsequent sections are new to this text, as are the terms \\A1\\B0forward view\\A1\\B1 and \\A1\\B0backward view.\\A1\\B1 The notion of A-return algorithm was introduced in the first edition of this text. The more refined treatment presented here was developed in conjunction with Harm van Seijen (e.g., van Seijen and Sutton, 2014).\n12.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD(A) with accumulating traces was introduced by Sutton (1988, 1984). Con\u0026shy;vergence in the mean was proved by Dayan (1992), and with probability 1 by many researchers, including Peng (1993), Dayan and Sejnowski (1994), and Tsitsiklis (1994) and Gurvits, Lin, and Hanson (1994). The bound on the error of the asymptotic A-dependent solution of linear TD(A) is due to Tsitsiklis and Van Roy (1997).\n12.3-5 Truncated TD methods were developed by Cichosz (1995) and van Seijen (2016). True online TD(A) and the other ideas presented in these sections are primarily due to work of van Seijen (van Seijen and Sutton, 2014; van Seijen et al., 2016) Replacing traces are due to Singh and Sutton (1996).\n12.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The material in this section is from van Hasselt and Sutton (2015).\n12.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Sarsa(A) with accumulating traces was first explored as a control method by Rummery and Niranjan (1994; Rummery, 1995). True Online Sarsa(A) was introduced by van Seijen and Sutton (2014). The algorithm on page 321 was adapted from van Seijen et al. (2016). The Mountain Car results were made new for this text, except for Figure 12.11 which is adapted from van Seijen and Sutton (2014).\n12.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Perhaps the first published discussion of variable \\C8\\EBwas by Watkins (1989), who pointed out that the cutting off of the backup sequence (Figure 12.12) in his Q(X) when a nongreedy action was selected could be implemented by temporarily setting X to 0.\nVariable X was introduced in the first edition of this text. The roots of variable 7are in the work on options (Sutton, Precup, and Singh, 1999) and its precursors (Sutton, 1995), becoming explicit in the \\A9\\96\\DA\\E0(\\C8\\EB\\A3\\A9paper (Maei and Sutton, 2010), which also introduced some of these recursive forms for the X-returns.\nA different notion of variable \\C8\\EBhas been developed by Yu (2012).\n12.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Off-policy eligibility traces were introduced by Precup et al. (2000, 2001), then further developed by Bertsekas and Yu (2009), Maei (2011; Maei and Sutton, 2010), Yu (2012), and by Sutton, Mahmood, Precup, and van Hasselt (2014). The latter reference in particular gives a powerful forward view for off- policy TD methods with general state-dependent X and 7. The presentation here seems to be new.\n12.10\u0026nbsp; Watkins\\A1\\AFs Qp) is due to Watkins (1989). Convergence has still not been proved for any control method for 0 \u0026lt; \\C8\\EB\u0026lt; 1. Tree Backup(X) is due to Precup, Sutton, and Singh (2000).\n12.11\u0026nbsp; GTDQ) is due to Maei (2011). GQQ) is due to Maei and Sutton (2010). HTD(X) is due to White and White (2016) based on the one-step HTD al\u0026shy;gorithm introduced by Hackman (2012). Emphatic TD(X) was introduced by Sutton, Mahmood, and White (2016), who proved its stability, then was proved to be convergent by Yu (2015a,b), and developed further by Hallak, Tamar, Munos, and Mannor (2016).\n \nChapter 13\nPolicy Gradient Methods\nIn this chapter we consider something new. So far in this book almost all the methods have learned the values of actions and then selected actions based on their estimated action values[21]; their policies would not even exist without the action-value estimates. In this chapter we consider methods that instead learn a parameterized policythat can select actions without consulting a value function. A value function may still be used to learnthe policy parameter, but is not required for action selection. We use the notation 6G Rd for the policy\\A1\\AFs parameter vector. Thus we write n(a|s, 6)= Pr{At = a | St = s, 6t= 6} for the probability that action a is taken at time t given that the agent is in state s at time t with parameter 6. If a method uses a learned value function as well, then the value function\\A1\\AFs weight vector is denoted w G Rm, as in V(s,w).\nIn this chapter we consider methods for learning the policy parameter based on the gradient of some performance measure J(6) with respect to the policy parameter. These methods seek to maximizeperformance, so their updates approximate gradient ascentin J:\n6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; t+i = 6t + aVJ (6t),(13.1)\nһ\\A1\\AA\\A1\\AA\nwhere VJ(6t) is a stochastic estimate whose expectation approximates the gradient of the performance measure with respect to its argument 6t. All methods that follow this general schema we call policy gradient methods, whether or not they also learn an approximate value function. Methods that learn approximations to both policy and value functions are often called actor-critic methods,where \\A1\\AEactor\\A1\\AF is a reference to the learned policy, and \\A1\\AEcritic\\A1\\AF refers to the learned value function, usually a state- value function. First we treat the episodic case, in which performance is defined as the value of the start state under the parameterized policy, before going on to consider the continuing case, in which performance is defined as the average reward rate, as in Section 10.3. In the end we are able to express the algorithms for both cases in very similar terms.\n13.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Approximation and its Advantages\nIn policy gradient methods, the policy can be parameterized in any way, as long as n(a|s, d)is differentiable with respect to its parameters, that is, as long as Ven(a|s, d) exists and is always finite. In practice, to ensure exploration we generally require that the policy never becomes deterministic (i.e., that n(a|s, d)G (0,1) Vs, a, 6. In this section we introduce the most common parameterization for discrete action spaces and point out the advantages it offers over action-value methods. Policy- based methods also offer useful ways of dealing with continuous action spaces, as we describe later in Section 13.7.\nIf the action space is discrete and not too large, then a natural kind of param\u0026shy;eterization is to form parameterized numerical preferences h(s, a, 6) G R for each state-action pair. The most preferred actions in each state are given the highest probability of being selected, for example, according to an exponential softmax dis\u0026shy;tribution:\nexp(h(s, a, 6))\n   (13.2)\n     n(a|s, 6)\nEb exp(h(s, b, 6)\\A3\\AC\nwhere exp\\A2\\C8=ex, where e c 2.71828 is the base of the natural logarithm. Note that the denominator here is just what is required so that the action probabilities in each state to sum to one. The preferences themselves can be parameterized arbitrarily. For example, they might be computed by a deep neural network, where 6is the vector of all the connection weights of the network (as in the AlphaGo system described in Section 16.7). Or the preferences could simply be linear in features,\nh(s, a, 6) = 6Tx(s, a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.3)\nusing feature vectors x(s, a) G Rd constructed by any of the methods described in Chapter 9.\nAn immediate advantage of selecting actions according to the softmax in action preferences (13.2) is that the approximate policy can approach determinism, whereas with e-greedy action selection over action values there is always an eprobability of selecting a random action. Of course, one could select according to a softmax over action values, but this alone would not approach determinism. Instead, the action- value estimates would converge to their corresponding true values, which would differ by a finite amount, translating to specific probabilities other than 0 and 1. If the softmax included a temperature parameter, then the temperature could be reduced over time to approach determinism, but in practice it would be difficult to choose the reduction schedule, or even the initial temperature, without more knowledge of the true action values than we would like to assume. Action preferences are different because they do not approach specific values; instead they are driven to produce the optimal stochastic policy. If the optimal policy is deterministic, then the preferences of the optimal actions will be driven infinitely higher than all suboptimal actions (if permited by the parameterization).\nPerhaps the simplest advantage that policy parameterization may have over action- value parameterization is that the policy may be a simpler function to approximate.\nProblems vary in the complexity of their policies and action-value functions. For some, the action-value function is simpler and thus easier to approximate. For others, the policy is simpler. In the latter case a policy-based method will typically be faster to learn and yield a superior asymptotic policy (as seems to be the case with Tetris; see \\A1\\ECimsek, AlgcSrta, and Kothiyal, 2016).\nIn problems with significant function approximation, the best approximate policy may be stochastic. For example, in card games with imperfect information the opti\u0026shy;mal play is often to do two different things with specific probabilities, such as when bluffing in Poker. Action-value methods have no natural way of finding stochastic op\u0026shy;timal policies, whereas policy approximating methods can, as shown in Example 13.1. This is a third significant advantage of policy-based methods.\nExample 13.1 Short corridor with switched actions\nConsider the small corridor gridworld shown inset in the graph below. The reward is -1 per step, as usual. In each of the three nonterminal states there are only two actions, right and left. These actions have their usual consequences in the first and third states, but in the second state they are reversed, so that right moves to the left and left moves to the right. The problem is difficult because all the states appear identical under the function approximation. In particular, we define x(s, right)= =[1, 0]T and x(s, left)= [0,1]T, for all s. An action-value method with e-greedy action selection is forced to choose between just two policies: choosing right with high probability\n1\u0026nbsp; - s/2on all steps or choosing left with the same high probability on all time steps. If e= 0.1, then these two policies achieve a value (at the start state) of less than -44 and -82, respectively, as shown in the graph. A method can do significantly better if it can learn a specific probability with which to select right. The best probability is about 0.59, which achieves a value of about\n11.6.\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n J(\u0026#10003;) = v^e\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n probability of right action\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nExercise 13.1 Use your knowledge of the gridworld and its dynamics to determine an exactsymbolic expression for the optimal probability of selecting the right action in Example 13.1.\u0026nbsp;\u0026nbsp; \\A1\\F5\nFinally, we note that the choice of policy parameterization is sometimes a good way of injecting prior knowledge about the desired form of the policy into the rein\u0026shy;forcement learning system.\n13.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Policy Gradient Theorem\nIn addition to the practical advantages of policy parameterization over e-greedy action selection, there is also an important theoretical advantage. With continuous policy parameterization, the action probabilities changes smoothly as a function of the learned parameter, whereas in e-greedy selection the action probabilities may change dramatically for an arbitrarily small change in the estimated action values, if that change results in a different action having the maximal value. Because of this, stronger convergence guarantees are available for policy-gradient methods than for action-value methods. In particular, it is the continuity of the parameterized policy that enables policy-gradient methods that approximate gradient ascent (13.1).\nThe episodic and continuing cases define the performance measure, J(6), differ\u0026shy;ently and thus have to be treated separately to some extent. Nevertheless, we will try to present both cases uniformly, and we develop a notation so that the major theoretical results can be decribed with a single set of equations.\nIn this section we treat the episodic case, for which we define the performance measure as the value of the start state of the episode. We can simplify the notation without losing any meaningful generality by assuming that every episode starts in some particular (non-random) state so. Then, in the episodic case we define perfor\u0026shy;mance as\nJ (6) = v ߵ(so),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.4)\nwhere is the true value function for , the policy determined by 6.\nWith function approximation, it may seem challenging to change the policy param\u0026shy;eter in a way that ensures improvement. The problem is that performance depends on both the action selections and the distribution of states in which those selections are made, and that both of these are affected by the policy parametre. Given a state, the effect of the policy parameter on the actions, and thus on reward, can be computed in a relatively straightforward way from knowledge of the parameteriza\u0026shy;tion. But the effect of the policy on the state distribution is completely a function of the environment and is typically unknown. How can we estimate the performance gradient with respect to the policy parameter, when the gradient depends on the unknown effect of changing the policy on the state distribution?\nFortunately, there is an excellent theoretical answer to this challenge in the form of the policy gradient theorem,which provides us an analytic expression for the gradient of performance with respect to the policy parameter (which is what we need to approximate for gradient ascent (13.1)) that does notinvolve the derivative\n\n\n   Proof of the Policy Gradient Theorem (episodic case)\n        Vn(a|s)qn(s, a) + n(a|s)\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; sf\nE [Vn(a'|s')qn(s', a') + n(a'|s') E 7P(s''|s', a')Vv^(s'')]\na;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s\\A1\\A8\n=^ y^7kPr(sx,k,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Vn(a|x)q^(x, a),\nx\\80S k=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\nafter repeated unrolling, where Pr(s x, k, n) is the probability of transition\u0026shy;ing from state s to state x in k steps under policy n. It is then immediate that\nVJ (6) = VVn (so)\n=H7kPr(so ^ s, k,أ)[Vn(a|s)qn(s, a)\ns k=0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\n=E \u0026#12316;(s)E Vn(a|s)qn(s, a).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Q.E.D.\n        Vn(a|s)qn(s, a) + أ(a|s)\\A8\\8C\\B6\\FEp(s\u0026#12316;r|s, a) (r+ 7\u0026#12316;(s'))\n(Exercise 3.12 and Equation 3.8)\n        Vn(a|s)qn(s, a) + n(a|s^ ^ 7p(s'|s, a)Vv^(s')\n        Vn(a|s)qn(s, a) + n(a|s)Vq^(s, a)\n        ^n(a|s)qn (s,a)\n        (Eq. 3.10) (unrolling)\n        VVn (s)\n        (Exercise 3.11) (product rule)\n        V\nE\na\nE\na\nE\na\nE\n        With just elementary calculus and re-arranging terms we can prove the policy gradient theorem from first principles. To keep the notation simple, we leave it implicit in all cases that n is a function of 6, and all gradients are also implicitly with respect to 6. First note that the gradient of the state-value function can be written in terms of the action-value function as\n     \u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n of the state distribution. The policy gradient theorem is that\n   (13.5)\n     VJ(6) = L \u0026quot;آ(s) E qn(s, a)Ven(a|s, 6),\nwhere the gradients in all cases are the column vectors of partial derivatives with respect to the components of 6,and n denotes the policy corresponding to parameter vector 6. The notion of the distribution \\C8\\E7here should be clear from what transpired in Chapters 9 and 10. That is, in the episodic case, (s) is defined to be the expected number of time steps t on which St = s in a randomly generated episode starting in so and following n and the dynamics of the MDP. The policy gradient theorem is proved for the episodic case in the box.\n13.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; REINFORCE: Monte Carlo Policy Gradient\nWe are now ready for our first policy-gradient learning algorithm. Recall our overall strategy of stochastic gradient ascent (13.1), for which we need a way of obtaining samples whose expectation is equal to the performance gradient. The policy gradient theorem gives us an exact expression for this gradient; all we need is some way of sampling whose expectation equals or approximates this expression. Notice that the right-hand side of the policy gradient theorem is a sum over states weighted by how often the states occurs under the target policy n, weighted again by 7times how many steps it takes to get to those states; if we just follow n we will encounter states in these proportions, which we can then weight by 7tto preserve the expected value.\nThus\n   (13.5)\n     VJ(6) = L \u0026quot;آ(s) E qn(s, a)V0n(a|s, 6),\nEn 7*^2,qn(St,a)V0n(a|St, 6).\nThis is good progress, and we would like to carry it further and handle the action in the same way (replacing a with the sample action At). The remaining part of the expectation above is a sum over actions; if only each term was weighted by the probability of selecting the actions, that is, according to n(a|St, 6). So let us make it that way, multiplying and dividing by this probability. Continuing from the previous equation, this gives us\n   VJ(6) = En 7^ n(a|St, 6)\\C8\\E7(St, a)\n\n     Vn(a|St, 6) n(a|St, 6)\n(replacing a by the sample At \u0026#12316;n)\n(because En[Gt|St, At]=\\C8\\E7(St, At))\nwhich is exactly what we want, a quantity that we can sample on each time step whose expectation is equal to the gradient. Using this sample to instantiate our generic stochastic gradient ascent algorithm (13.1), we obtain the update\n6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 6, \\A1\\AAt G \\A8\\8C\\D2\\D6(a \\B6\\D36)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13\n6t+[22]= 6t+ a7 Gt n(At|St, 6) .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.6)\nWe call this algorithm REINFORCE (after Williams, 1992). Its update has an intuitive appeal. Each increment is proportional to the product of a return Gt and a vector, the gradient of the probability of taking the action actually taken, divided by the probability of taking that action. The vector is the direction in parameter space that most increases the probability of repeating the action At on future visits to state\nSt. The update increases the parameter vector\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; inthisdirection\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; proportional\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; to the\nreturn, and inversely proportional to the action\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; probability.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Theformer makes sense\nbecause it causes the parameter to move most in the directions that favor actions that yield the highest return. The latter makes sense because otherwise actions that are selected frequently are at an advantage (the updates will be more often in their direction) and might win out even if they do not yield the highest return.\nNote that REINFORCE uses the complete return from time t, which includes all future rewards up until the end of the episode. In this sense REINFORCE is a Monte Carlo algorithm and is well defined only for the episodic case with all updates made in retrospect after the episode is completed (like the Monte Carlo algorithms in Chapter 5). This is shown explicitly in the boxed pseudocode below.\nREINFORCE, A Monte-Carlo Policy-Gradient Method (episodic)\nInput: a differentiable policy parameterization n(a|s, 6), Va G A,s G S, 6G Rd Initialize policy parameter 6 Repeat forever:\nGenerate an episode So, Ao, Ri,...,St_i, At_i, Rt, following n(-|-, 6)\nFor each step of the episode t= 0,...,T - 1:\nG return from step t\n6\u0026nbsp; \\A1\\AA 6 + \u0026laquo;7tG Ve logn(At|St, 6)\nAs a stochastic gradient method, REINFORCE has good theoretical convergence properties. By construction, the expected update over an episode is in the same direction as the performance gradient.[23]This assures an improvement in expected performance for sufficiently small a, and convergence to a local optimum under standard stochastic approximation conditions for decreasing a. However, as a Monte Carlo method REINFORCE may be of high variance and thus slow to learn.\nExercise 13.2 Prove (13.7) using the definitions and elementary calculus. \\A1\\F5\n13.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; REINFORCE with Baseline\nThe policy gradient theorem (13.5) can be generalized to include a comparison of the action value to an arbitrary baselineb(s):\nVJ(O) = L (s) L (\\C8\\E7(s,a) - b(s^ Ven(a|s, O).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.8)\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\nThe baseline can be any function, even a random variable, as long as it does not vary with a; the equation remains true, because the the subtracted quantity is zero:\ny^b(s)Ven(a|s, O) = b(s)Ve ^ n(a|s, O) = b(s)Ve 1 =0Vs G S.\naa\nHowever, after we convert the policy gradient theorem to an expectation and an update rule, using the same steps as in the previous section, then the baseline can have a significant effect on the varianceof the update rule.\nThe update rule that we end up with is a new version of REINFORCE that includes a general baseline:\nOt+i ^Ot+a71(Gt - b(St))\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; . (13.9)\nAs the baseline could be uniformly zero, this update is a strict generalization of REINFORCE. In general, the baseline leaves the expected value of the update un\u0026shy;changed, but it can have a large effect on its variance. For example, we saw in Section 2.8 that an analogous baseline can significantly reduce the variance (and thus speed the learning) of gradient bandit algorithms. In the bandit algorithms the baseline was just a number (the average of the rewards seen so far), but for MDPs the baseline should vary with state. In some states all actions have high values and we need a high baseline to differentiate the higher valued actions from the less highly valued ones; in other states all actions will have low values and a low baseline is appropriate.\n \nOne natural choice for the baseline is an estimate of the state value, V(St,w), where w G Rm is a weight vector learned by one of the methods presented in previous chapters. Because REINFORCE is a Monte Carlo method for learning the policy parameter, 6, it seems natural to also use a Monte Carlo method to learn the state- value weights, w. A complete pseudocode algorithm for REINFORCE with baseline is given in the box using such a learned state-value function as the baseline.\nREINFORCE with Baseline (episodic)\nInput: a differentiable policy parameterization n(a|s, 6), Va G A, s G S, 6G Rd Input: a differentiable state-value parameterization V(s,w), Vs G S, w G Rm Parameters: step sizes a \u0026gt; 0, P \u0026gt; 0\nInitialize policy parameter 6and state-value weights w Repeat forever:\nGenerate an episode So, Ao, Ri,...,St_l, At_i, Rt,following n(-|-, 6)\nFor each step of the episode t = 0,...,T - 1:\nGt\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; return from step t\n8\\A1\\AA Gt - V(St,w)w \\A1\\AA w + P8Vw V(St,w)\n6\u0026nbsp;\u0026nbsp; \\A1\\AA 6+ a7t8V^ log n(At|St, 6)\nThis algorithm has two step sizes, a and P. The step size for values (here P) is relatively easy; in the linear case we have rules of thumb for setting it, such as P = 0.1/E[||xt||^]. For action values though it is much less clear. It depends on the range of variation of the rewards and on the policy parameterization.\n13.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Actor\\A1\\AACritic Methods\nAlthough the REINFORCE-with-baseline method learns both a policy and a state- value function, we do not consider it to be an actor-critic method because its state- value function is used only as a baseline, not as a critic. That is, it is not used for bootstrapping (updating a state from the estimated values of subsequent states), but only as a baseline for the state being updated. This is a useful distinction, for only through bootstrapping do we introduce bias and an asymptotic dependence on the quality of the function approximation. As we have seen, the bias introduced through bootstrapping and reliance on the state representation is often on balance beneficial because it reduces variance and accelerates learning. REINFORCE with baseline is unbiased and will converge asymptotically to a local minimum, but like all Monte Carlo methods it tends to be slow to learn (of high variance) and inconvenient to implement online or for continuing problems. As we have seen earlier in this book, with temporal-difference methods we can eliminate these inconveniences, and through multi-step methods we can flexibly choose the degree of bootstrapping. In order to gain these advantages in the case of policy gradient methods we use actor-critic methods with a true bootstrapping critic.\nFirst consider one-step actor-critic methods, the analog of the TD methods intro\u0026shy;duced in Chapter 6such as TD(0), Sarsa(0), and Q-learning. The main appeal of one-step methods is that they are fully online and incremental, yet avoid the com\u0026shy;plexities of eligibility traces. They are a special case of the eligibility trace methods, and not as general, but easier to understand. One-step actor-critic methods replace the full return of REINFORCE (13.9) with the one-step return (and use a learned state-value function as the baseline) as follow:\nVe n(At|St, O)\nOt+[24] = Ot+ a7(Gt:t+i - V(St,w)7 n(At|St, O)\n=Ot + a7t(Rt+i + 7v(St+i,w) - v(St,w)) Veأ(At|St\\A3\\ACO)\n=Ot + a71 \u0026#12316;Ve n(At|St,O)\n   (13.11)\n        n(At|St, O)\n     (13.10)\n(13.12)\nn(At|St, O)'\nThe natural state-value-function learning method to pair with this is semi-gradient TD(0). Pseudocode for the complete algorithm is given in the box below. Note that it is now a fully online, incremental algorithm, with states, actions, and rewards processed as they occur and then never revisited.\nOne-step Actor-Critic (episodic)\nInput: a differentiable policy parameterization n(a|s, O), Va G A, s G S, O G Rd Input: a differentiable state-value parameterization v(s,w), Vs G S, w G Rm Parameters: step sizes a \u0026gt; 0, P \u0026gt; 0\nInitialize policy parameter O and state-value weights w Repeat forever:\nInitialize S (first state of episode)\nI ^ 1\nWhile S is not terminal:\nA \u0026#12316;n(-|S, O)\nTake action A, observe S', R\n5R + 7v(S',w) - v(S,w)(if Sحis terminal, then {)(S/,w) = 0)\nw \\A1\\AA w + P5 Vw v(S,w)\n0\u0026nbsp;\u0026nbsp; \\A1\\AA O + aI5 Ve log n(A|S, O)\n1\u0026nbsp;\u0026nbsp; \\A1\\AA 7I\nS\u0026nbsp; \\A1\\AA Sf\nActor-Critic with Eligibility Traces (episodic)\nInput: a differentiable policy parameterization n(a|s, 6), Va G A, s G S, 6G Rd Input: a differentiable state-value parameterization v(s,w), Vs G S, w G Rm Parameters: step sizes a\u0026gt; 0, ^ \u0026gt; 0\nInitialize policy parameter 6 and state-value weights w Repeat forever (for each episode):\nInitialize S (first state of episode)\nee \\A1\\AA 0 (n-component eligibility trace vector)\new\\A1\\AA 0 (m-component eligibility trace vector)\nI \\A1\\AA 1\nWhile S is not terminal (for each time step):\nA \u0026#12316;n(-|S, 6)\nTake action A, observe S', R\n8\\A1\\AA R + 7v(S',w) - v(S,w)(if S' is terminal, then {)(S',w) == 0)\new\\A1\\AA 7Awew+ I VwV(S,w) ee \\A1\\AA 7Aeee + I Ve log n(A|S, 6) w \\A1\\AA w + ^8ew\n6\\A1\\AA 6 + ee\nI\u0026nbsp; \u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z \\A1\\AA 7I\nS\\A1\\AA S'\n13.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Gradient for Continuing Problems\nAs discussed in Section 10.3, for continuing problems without episode boundaries we need to define performance in terms of the average rate of reward per time step:\n1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; T\nJ (6)=ʮ\\A3\\A9=limtY^ E[Rt I Ao\\A3\\BAt-i \u0026#12316;\\DB\\ED\n\\C1\\CB400 \\81A^\nt=1\n=limE[Rt | Ao\\A3\\BAt-i \u0026#12316;n] ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.6)\nt^^\n=E \\C8\\E7(s)En(a|s)E p(s', r|s, a)r,\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s;,r\nwhere is the steady-state distribution under n,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (s) = limt^^ Pr{St = s|Ao:t \u0026#12316;n},\nwhich is assumed to exist and to be independent of So (an ergodicity assumption). Remember that this is the special distribution under which, if you select actions according to n, you remain in the same distribution:\n^ \\C8\\E7(s) [ n(a|s, 6)p(s'|s, a)=\\C8\\E7(s').\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.7)\nsa\nWe also define values,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Vn(s)\u0026nbsp; ==\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; En[Gt|St= s]\u0026nbsp; andqn(s,a)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ==En[Gt|St = s, At\u0026nbsp;\u0026nbsp;\u0026nbsp; =\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a],\nwith respect to the differential return:\nGt == Rt+i -n(n) + Rt+2-n(n) + Rt+3-n(n) + \\A1\\AD.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (10.8)\nWith these alternate definitions, and 7= 1, the policy gradient theorem as given for the episodic case (13.5) remains true for the continuing case. A proof is given in the box on the next page. The forward and backward view equations also remain the same. Complete pseudocode for the backward view is given in the box below.\nActor-Critic with Eligibility Traces (continuing)\nInput: a differentiable policy parameterization n(a|s, 6), Va G A, s G S, 6G RdInput: a differentiable state-value parameterization V(s,w), Vs G S, w G RmParameters: step sizes a \u0026gt; 0, P \u0026gt; 0, n \u0026gt; 0\ne\\A1\\E3\\A1\\AA 0(n-component eligibility trace vector) ew \\A1\\AA 0(m-component eligibility trace vector)\nInitialize R G R (e.g., to 0)\nInitialize policy parameter 6and state-value weights w (e.g., to 0)\nInitialize S G S (e.g., to so)\nRepeat forever:\nA \u0026#12316;n(-|S, 6)\nTake action A, observe S;, R\n8 \\A1\\AA R - R + V(S;,w) - V(S,w)(if Sحis terminal, then {)(S/,w) == 0)\nR \\A1\\AA R + n8\new \\A1\\AA Awew + VwV(S,w)\ne\\A1\\E3\\A1\\AA A6e0+ Velogn(A|S, 6) w \\A1\\AA w + P8 ew\n6\u0026nbsp;\u0026nbsp; \\A1\\AA 6+ a8 e0\nS\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; S/\n \nProof of the Policy Gradient Theorem (continuing case)\nThe proof of the policy gradient theorem for the continuing case begins sim\u0026shy;ilarly to the episodic case. Again we leave it implicit in all cases that n is a function of O and that the gradients are with respect to O. Recall that in the continuing case J(O) = r(n) (10.6) and that and denote values with re\u0026shy;spect to the differential return (10.8). The gradient of the state-value function can be written as\n \n   (Exercise 3.15) (product rule)\n        ^ Vn(a|s)qn(s,a) + n(a|s)Vq^(s,a)\n        VVn (s) = V\n        ^n(a|s)qn (s,a)\n        sS\n     \u0026nbsp;\n\u0026nbsp;\n =\\B6\\FEVn(a|s)qn(s,a) + أ(a|s)\\A8\\8C\\B6\\FEp(s\u0026#12316;r|s,a)(r- r(O) + 7Vn(s'))\n\u0026nbsp;TOC \\o \u0026quot;1-5\u0026quot; \\h \\z a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s,,r\n=^ Vn(a|s)qn(s, a) + n(a|s) [-Vr(O) + ^7p(s'|s, a)Vvn(s')]\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s7\nAfter re-arranging terms, we obtain\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; r(O) =\u0026nbsp;\u0026nbsp;\u0026nbsp; Vn(a|s)qn(s, a)+n(a|s^ ^ 7p(s'|s, a)Vv^(s') -Vv^(s), Vs G S.\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s!\nNotice that the left-hand side can be written VJ(O) and that it does not depend on s. Thus the right-hand side does not depend on s either, and we can safely sum it over all s G S, weighted by \u0026quot;أ(s), without changing it\n(because Es\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (s) = 1). Thus\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; J(O) = L\u0026nbsp; (s) E Vn(a|s)qn(s, a) + أ(a|s) \\B6\\FE7P(s'|s, a)Vvn(s') - Vvn(s:\ns\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s!\n(s)YlVn(a|s)qn (s, a)\nsa\n+ \\C8\\E7(s)[أ(a|s) [ 7P(s'|s, a)Vvn(s')-\u0026#12316;(s) [ Vv^(s)\na\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; s7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; a\n(s)YlVn(a|s)qn (s, a)\nsa\n+\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\C8\\E7(s)I] n(a|s)p(s'|s, a) Vv^(s') - ^ \\C8\\E7(s)Vv^(s)\nMn (s7) (i0.7)\n[\u0026#12316;(s)[ Vn(a|s)qn(s, a) + [\\C8\\E7(s')Vv^(s')-[\\C8\\E7(s)Vv^(s)\n   Q.E.D.\n     آ(s) L Vn(a|s)qn(s,a).\n13.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Policy Parameterization for Continuous Actions\nPolicy-based methods offer practical ways of dealing with large actions spaces, even continuous spaces with an infinite number of actions. Instead of computing learned probabilities for each of the many actions, we instead compute learned the statistics of the probability distribution. For example, the action set might be the real numbers, with actions chosen from a normal (Gaussian) distribution.\nThe conventional probability density function for the normal distribution is written\n\\BF\\A7exp(-\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.13)\nwhere ^ and ahere are the mean and standard deviation of the normal distribution, and of course n here is just the number n \\B0\\D13.14159. The probability density function for several different means and standard deviations is shown in Figure 13.1. The value p(x) is the densityof the probability at x, not the probability. It can be greater than 1; it is the total area under p(x) that must sum to 1. In general, one can take the integral under p(x) for any range of x values to get the probability of x falling within that range.\nTo produce a policy parameterization, we can define the policy as the normal prob\u0026shy;ability density over a real-valued scalar action, with mean and standard deviation give by parametric function approximators. That is, we define\nn(a|s, 6)==\\A1\\AA\\A1\\AAexpf-(a-\\C7ɡ\\A26^^ .\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.14)\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; '\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A3\\BB\u0026nbsp;\u0026nbsp; a(s, 6)^\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; V\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 2a(s, 6)2J\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\A2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; !\nTo complete the example we need only give a form for the approximators for the mean and standard-deviation functions. For this we divide the policy\\A1\\AFs parameter vector into two parts, 6 = [6M, 6\\A1\\E3]T, one part to be used for the approximation of the mean and one part for the approximation of the standard deviation. The mean\n \n   (x \\A1\\AA /j)2 2a2\n        1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 5\n        p(x)\n        exp\n        r\\/2n\n        Figure 13.1: The probability density function of the normal distribution for different means and variances.\n        -5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; -4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; -3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; -2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; -1\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n can be approximated as a linear function. The standard deviation must always be positive and is better approximated as the exponential of a linear function. Thus\n^(s, w) == 6\u0026quot;Tx(s) and a(s, 6) == exp(6\\A1\\E3Tx(s)) ,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (13.15)\nwhere x(s) is a state feature vector constructed perhaps by one of the methods described in Chapter 9. With these definitions, all the algorithms described in the rest of this chapter can be applied to learn to select real-valued actions.\nExercise 13.3 A Bernoulli-logistic unitis a stochastic neuron-like unit used in some artificial neural networks (see Section 9.6). Its input at time t is a fea\u0026shy;ture vector x(St); its output, At, is a random variable having two values, 0and 1, with Pr{At = 1} = Pt and Pr{At = 0} = 1- Pt (the Bernoulli distribution). Let h(s, 0, 6) and h(s, 1, 6) be the preferences in state s for for the unit\\A1\\AFs two ac\u0026shy;tions given policy parameter 6. Assume that the difference between the prefer\u0026shy;ences is given by a weighted sum of the unit\\A1\\AFs input vector, that is, assume that h(s, 1, 6) - h(s, 0, 6) = 6Tx(s), where 6is the unit\\A1\\AFs weight vector.\n(a)\u0026nbsp;\u0026nbsp; Show that if the exponential softmax distribution (13.2) is used to convert pref\u0026shy;erences to policies, then Pt = n(1|St, 6t) = 1/(1+ exp(-6Tx(St))) (the logistic function).\n(b)\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;What is the Monte-Carlo REINFORCE update of 6t to 6t+i upon receipt of return Gt?\n(c)\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \u0026nbsp;Express the eligibility Ve logn(a|s, 6) for a Bernoulli-logistic unit, in terms of a, x(s), and n(a|s, 6) by calculating the gradient. Hint: separately for each action compute the derivative of the log first with respect to p= n(1|s, 6), combine the two results into one expression that depends on a and p, and then use the chain rule, noting that the derivative of the logistic function f(x) is f(x)(1- f(x)).\\A1\\F5\n13.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nPrior to this chapter, this book has focused on action-value methods\\A1\\AAmeaning meth\u0026shy;ods that learn action values and then use them to determine action selections. In this chapter, on the other hand, we have considered methods that learn a parameterized policy that enables actions to be taken without consulting action-value estimates\\A1\\AA though action-value estimates may still be learned and used to update the policy pa\u0026shy;rameter. In particular, we have considered policy-gradient methods\\A1\\AAmeaning meth\u0026shy;ods that update the policy parameter on each step in the direction of an estimate of performance with respect to the policy parameter.\nMethods that learn and store a policy parameter have many advantages. They can learn specific probabilities for their actions. They can learn appropriate levels of exploration and approach determinism asymptotically. They can naturally handle continuous state spaces. All these things are easy for policy-based methods, but awkward or impossible for e-greedy methods and for action-value methods in general. In addition, on some problems the policy is just simpler to represent parametrically than the value function; these are more suited to parameterized policy methods.\nParameterized policy methods also have an important theoretical advantage over action-value methods in the form of the policy gradient theorem, which gives an exact formula for how performance is affected by the policy parameter that does not involve derivatives of the state distribution. This theorem provides a theoretical foundation for all policy gradient methods.\nThe REINFORCEmethod follows directly from the policy gradient theorem. Adding a state-value function as a baselinereduces REINFORCE\\A1\\AFs variance without introducing bias. Using the state-value function for bootstrapping results introduces bias, but is often desirable for the same reason that bootstrapping TD methods are often superior to Monte Carlo methods (substantially reduced variance). The state-value function assigns credit to\\A1\\AAcritizes\\A1\\AAthe policy\\A1\\AFs action selections, and accordingly the former is termed the criticand the latter the actor, and these overall methods are sometimes termed actor-criticmethods.\nOverall, policy-gradient methods provide a significantly different set of proclivi\u0026shy;ties, strengths, and weaknesses than action-value methods. Today they are less well understood, but a subject of excitement and ongoing research.\nBibliographical and Historical Remarks\nMethods that we now see as related to policy gradients were actually some of the earli\u0026shy;est to be studied in reinforcement learning (Witten, 1977; Barto, Sutton, and Ander\u0026shy;son, 1983; Sutton, 1984; Williams, 1987, 1992) and in predecessor fields (Phansalkar and Thathachar, 1995). They were largely supplanted in the 1990s by the action- value methods that are the focus of the other chapters of this book. In recent years, however, extensive attention has returned to actor-critic methods and to policy- gradient methods in general. Among the further developments beyond what we cover here are natural-gradient methods (Amari, 1998; Kakade, 2002, Peters, Vi- jayakumar and Schaal, 2005; Peters and Schall, 2008; Park, Kim and Kang, 2005; Bhatnagar, Sutton, Ghavamzadeh and Lee, 2009; see Grondman, Busoniu, Lopes and Babuska, 2012), and deterministic policy gradient (Silver et al., 2014). Major applications include acrobatic helicopter autopilots and AlphaGo (see Section 16.7).\nOur presentation in this chapter is based primarily on that by Sutton, McAllester, Singh, and Mansour (2000), who introduced the term \\A1\\B0policy gradient methods\\A1\\B1. A useful overview is provided by Bhatnagar et al. (2003). One of the earliest related works is by Aleksandrov, Sysoyev, and Shemeneva (1968).\n13.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Example 13.1 was implemented by Eric Graves.\n13.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The policy gradient theorem was first obtained by Marbach and Tsitsiklis (1998, 2001) and then independently by Sutton et al. (2000). A similar expression was obtained by Cao and Chen (1997). Other early results are due to Konda and Tsitsiklis (2000, 2003) and Baxter and Bartlett (2000).\n   13.3\n     REINFORCE is due to Williams (1987, 1992). The use of a power of the \n \ndiscount factor in the update is due to Thomas (2014).\nPhansalkar and Thathachar (1995) proved both local and global convergence theorems for modified versions of REINFORCE algorithms.\n13.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The baseline was introduced in Williams\\A1\\AFs (1987, 1992) original work. Green- smith, Bartlett, and Baxter (2004) analyzed an arguable better baseline (see Dick, 2015).\n13.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Actor-critic methods were among the earliest to be investigated in reinforce\u0026shy;ment learning (Witten, 1977; Barto, Sutton, and Anderson, 1983; Sutton, 1984). The algorithms presented here and in Section 13.6 are based on the work of Degris, White, and Sutton (2012), who also introduced the study of off-policy policy-gradient methods.\n13.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The first to show how continuous actions could be handled this way appears\nto have been Williams (1987, 1992).\n \nPart III: Looking Deeper\nIn this last part of the book we look beyond the standard reinforcement learning ideas presented in the first two parts of the book to briefly survey their relationships with psychology and neuroscience, a sampling of reinforcement learning applications, and some of the active frontiers for future reinforcement learning research.\n \nChapter 14\nPsychology\nIn previous chapters we developed ideas for algorithms based on computational con\u0026shy;siderations alone. In this chapter we look at some of these algorithms from another perspective: the perspective of psychology and its study of how animals learn. The goals of this chapter are, first, to discuss ways that reinforcement learning ideas and algorithms correspond to what psychologists have discovered about animal learning, and second, to explain the influence reinforcement learning is having on the study of animal learning. The clear formalism provided by reinforcement learning that sys- temizes tasks, returns, and algorithms is proving to be enormously useful in making sense of experimental data, in suggesting new kinds of experiments, and in pointing to factors that may be critical to manipulate and to measure. The idea of optimizing return over the long term that is at the core of reinforcement learning is contributing to our understanding of otherwise puzzling features of animal learning and behavior.\nSome of the correspondences between reinforcement learning and psychological theories are not surprising because the development of reinforcement learning drew inspiration from psychological learning theories. However, as developed in this book, reinforcement learning explores idealized situations from the perspective of an ar\u0026shy;tificial intelligence researcher or engineer, with the goal of solving computational problems with efficient algorithms, rather than to to replicate or explain in detail how animals learn. As a result, some of the correspondences we describe connect ideas that arose independently in their respective fields. We believe these points of contact are specially meaningful because they expose computational principles important to learning, whether it is learning by artificial or by natural systems.\nFor the most part, we describe correspondences between reinforcement learning and learning theories developed to explain how animals like rats, pigeons, and rab\u0026shy;bits learn in controlled laboratory experiments. Thousands of these experiments were conducted throughout the 20th century, and many are still being conducted to\u0026shy;day. Although sometimes dismissed as irrelevant to wider issues in psychology, these experiments probe subtle properties of animal learning, often motivated by precise theoretical questions. As psychology shifted its focus to more cognitive aspects of behavior, that is, to mental processes such as thought and reasoning, animal learning experiments came to play less of a role in psychology than they once did. But this experimentation led to the discovery of learning principles that are elemental and widespread throughout the animal kingdom, principles that should not be neglected in designing artificial learning systems. In addition, as we shall see, some aspects of cognitive processing connect naturally to the computational perspective provided by reinforcement learning.\nThis chapter\\A1\\AFs final section includes references relevant to the connections we dis\u0026shy;cuss as well as to connections we neglect. We hope this chapter encourages readers to probe all of these connections more deeply. Also included in this final section is a discussion of how the terminology used in reinforcement learning relates to that of psychology. Many of the terms and phrases used in reinforcement learning are bor\u0026shy;rowed from animal learning theories, but the computational/engineering meanings of these terms and phrases do not always coincide with their meanings in psychology.\n14.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Prediction and Control\nThe algorithms we describe in this book fall into two broad categories: algorithms for predictionand algorithms for control. These categories arise naturally in solution methods for the reinforcement learning problem presented in Chapter 3. In many ways these categories respectively correspond to categories of learning extensively studied by psychologists: classical,or Pavlovian, conditioningand instrumental,or operant, conditioning. These correspondences are not completely accidental because of psychology\\A1\\AFs influence on reinforcement learning, but they are nevertheless striking because they connect ideas arising from different objectives.\nThe prediction algorithms presented in this book estimate quantities that depend on how features of an agent\\A1\\AFs environment are expected to unfold over the future. We specifically focus on estimating the amount of reward an agent can expect to receive over the future while it interacts with its environment. In this role, prediction algo\u0026shy;rithms are policy evaluation algorithms, which are integral components of algorithms for improving policies. But prediction algorithms are not limited to predicting future reward; they can predict any feature of the environment (see, for example, Modayil, White, and Sutton, 2014). The correspondence between prediction algorithms and classical conditioning rests on their common property of predicting upcoming stimuli, whether or not those stimuli are rewarding (or punishing).\nThe situation in an instrumental, or operant, conditioning experiment is different. Here, the experimental apparatus is set up so that an animal is given something it likes (a reward) or something it dislikes (a penalty) depending on what the animal did. The animal learns to increase its tendency to produce rewarded behavior and to decrease its tendency to produce penalized behavior. The reinforcing stimulus is said to be contingenton the animal\\A1\\AFs behavior, whereas in classical conditioning it is not (although it is difficult to remove all behavior contingencies in a classical conditioning experiment). Instrumental conditioning experiments are like those that inspired Thorndike\\A1\\AFs Law of Effect that we briefly discuss in Chapter 1. Controlis at the core of this form of learning, which corresponds to the operation of reinforcement learning\\A1\\AFs policy-improvement algorithms.[25]\nThinking of classical conditioning in terms of prediction, and instrumental condi\u0026shy;tioning in terms of control, is a starting point for connecting our computational view of reinforcement learning to animal learning, but in reality, the situation is more complicated than this. There is more to classical conditioning than prediction; it also involves action, and so is a mode of control, sometimes called Pavlovian con\u0026shy;trol. Further, classical and instrumental conditioning interact in interesting ways, with both sorts of learning likely being engaged in most experimental situations. Despite these complications, aligning the classical/instrumental distinction with the prediction/control distinction is a convenient first approximation in connecting rein\u0026shy;forcement learning to animal learning.\nIn psychology, the term reinforcement is used to describe learning in both classical and instrumental conditioning. Originally referring only to the strengthening a pat\u0026shy;tern of behavior, it is frequently also used for the weakening of a pattern of behavior. A stimulus considered to be the cause of the change in behavior is called a reinforcer, wether or not it is contingent on the animal\\A1\\AFs previous behavior. At the end of this chapter we discuss this terminology in more detail and how it relates to terminology used in machine learning.\n14.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Classical Conditioning\nWhile studying the activity of the digestive system, the celebrated Russian physiolo\u0026shy;gist Ivan Pavlov found that an animal\\A1\\AFs innate responses to certain triggering stimuli can come to be triggered by other stimuli that are quite unrelated to the inborn triggers. His experimental subjects were dogs that had undergone minor surgery to allow the intensity of their salivary reflex to be accurately measured. In one case he describes, the dog did not salivate under most circumstances, but about 5 seconds after being presented with food it produced about six drops of saliva over the next several seconds. After several repetitions of presenting another stimulus, one not re\u0026shy;lated to food, in this case the sound of a metronome, shortly before the introduction of food, the dog salivated in response to the sound of the metronome in the same way it did to the food. \\A1\\B0The activity of the salivary gland has thus been called into play by impulses of sound\\A1\\AAa stimulus quite alien to food\\A1\\B1 (Pavlov, 1927, p. 22). Summarizing the significance of this finding, Pavlov wrote:\nIt is pretty evident that under natural conditions the normal animal must respond not only to stimuli which themselves bring immediate benefit or harm, but also to other physical or chemical agencies\\A1\\AAwaves of sound, light, and the like\\A1\\AAwhich in themselves only signalthe approach of these stimuli; though it is not the sight and sound of the beast of prey which is\n \nDelay Conditioning CS\nUS\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n \nISI\n \n\u0026nbsp;\n \nTrace Conditioning CS\n \n\u0026nbsp;\n \nUS\n \n\u0026nbsp;\n\u0026nbsp;\n \nt\nFigure 14.1: Arrangement of stimuli in two types of classical conditioning experiments. In delay conditioning, the CS extends throughout the interstimulus interval, or ISI, which is the time interval between the CS onset and the US onset (often with the CS and US ending at the same time as shown here). In trace conditioning, there is a time interval, called the trace interval, between CS offset and US onset.\nin itself harmful to the smaller animal, but its teeth and claws. (Pavlov, 1927, p. 14)\n   Connecting new stimuli to innate Pavlovian, conditioning. Pavlov (or\n     reflexes in this way is now called classical, or more exactly, his translators) called inborn re\u0026shy;sponses (e.g., salivation in his demonstration described above) \\A1\\B0unconditioned re\u0026shy;sponses\\A1\\B1 (URs), their natural triggering stimuli (e.g., food) \\A1\\B0unconditioned stimuli\\A1\\B1 (USs), and new responses triggered by predictive stimuli (e.g., here also salivation) \\A1\\B0conditioned responses\\A1\\B1 (CRs). A stimulus that is initially neutral, meaning that it does not normally elicit strong responses (e.g., the metronome sound), becomes a \\A1\\B0conditioned stimulus\\A1\\B1 (CS) as the animal learns that it predicts the US and so comes to produce a CR in response to the CS. These terms are still used in describ\u0026shy;ing classical conditioning experiments (though better translations would have been \\A1\\B0conditional\\A1\\B1 and \\A1\\B0unconditional\\A1\\B1 instead of conditioned and unconditioned). The US is called a reinforcer because it reinforces producing a CR in response to the CS.\nFigure 14.1 shows the arrangement of stimuli in two types of classical conditioning experiments: in delay conditioning, the CS extends throughout the interstimulus interval, or ISI, which is the time interval between the CS onset and the US onset (with the CS ending when the US ends in a common version shown here). In trace conditioning, the US begins after the CS ends, and the time interval between CS offset and US onset is called the trace interval.\nThe salivation of Pavlov\\A1\\AFs dogs to the sound of a metronome is just one example of classical conditioning, which has been intensively studied across many response systems of many species of animals. URs are often preparatory in some way, like the salivation of Pavlov\\A1\\AFs dog, or protective in some way, like an eye blink in response to something irritating to the eye, or freezing in response to seeing a predator. Ex\u0026shy;periencing the CS-US predictive relationship over a series of trials causes the animal to learn that the CS predicts the US so that the animal can respond to the CS with a CR that prepares the animal for, or protects it from, the predicted US. Some CRs are similar to the UR but begin earlier and differ in ways that increase their effectiveness. In one intensively studied type of experiment, for example, a tone CS reliably predicts a puff of air (the US) to a rabbit\\A1\\AFs eye, triggering a UR consisting of the closure of a protective inner eyelid called the nictitating membrane. After one or more trials, the tone comes to trigger a CR consisting of membrane closure that begins before the air puff and eventually becomes timed so that peak closure occurs just when the air puff is likely to occur. This CR, being initiated in anticipation of the air puff and appropriately timed, offers better protection than simply initiating closure as a reaction to the irritating US. The ability to act in anticipation of impor\u0026shy;tant events by learning about predictive relationships among stimuli is so beneficial that it is widely present across the animal kingdom.\n14.2.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Blocking and Higher-order Conditioning\nMany interesting properties of classical conditioning have been observed in exper\u0026shy;iments. Beyond the anticipatory nature of CRs, two widely observed properties figured prominently in the development of classical conditioning models: blocking and higher-order conditioning.Blocking occurs when an animal fails to learn a CR when a potential CS in presented along with another CS that had been used previ\u0026shy;ously to condition the animal to produce that CR. For example, in the first stage of a blocking experiment involving rabbit nictitating membrane conditioning, a rabbit is first conditioned with a tone CS and an air puff US to produce the CR of closing its nictitating membrane in anticipation of the air puff. The experiment\\A1\\AFs second stage consists of additional trials in which a second stimulus, say a light, is added to the tone to form a compound tone/light CS followed by the same air puff US. In the experiment\\A1\\AFs third phase, the second stimulus alone\\A1\\AAthe light\\A1\\AAis presented to the rabbit to see if the rabbit has learned to respond to it with a CR. It turns out that the rabbit produces very few, or no, CRs in response to the light: learning to the light had been blockedby the previous learning to the tone.[26]Blocking results like this challenged the idea that conditioning depends only on simple temporal contigu\u0026shy;ity, that is, that a necessary and sufficient condition for conditioning is that a US frequently follows a CS closely in time. In the next section we describe the Rescorla- Wagner model(Rescorla and Wagner, 1972) that offered an influential explanation\nfor blocking.\nHigher-order conditioning occurs when a previously-conditioned CS acts as a US in conditioning another initially neutral stimulus. Pavlov described an experiment in which his assistant first conditioned a dog to salivate to the sound of a metronome that predicted a food US, as described above. After this stage of conditioning, a number of trials were conducted in which a black square, to which the dog was initially indifferent, was placed in the dog\\A1\\AFs line of vision followed by the sound of the metronome\\A1\\AAand this was notfollowed by food. In just ten trials, the dog began to salivate merely upon seeing the black square, despite the fact that the sight of it had never been followed by food. The sound of the metronome itself acted as a US in conditioning a salivation CR to the black square CS. This was second-order conditioning. If the black square had been used as a US to establish salivation CRs to another otherwise neutral CS, it would have been third-order conditioning, and so on. Higher-order conditioning is difficult to demonstrate, especially above the second order, in part because a higher-order reinforcer loses its reinforcing value due to not being repeatedly followed by the original US during higher-order conditioning trials. But under the right conditions, such as intermixing first-order trials with higher- order trials or by providing a general energizing stimulus, higher-order conditioning beyond the second order can be demonstrated. As we describe below, the TD model of classical conditioninguses the backup idea that is central to our approach to extend the Rescorla-Wagner model\\A1\\AFs account of blocking to include both the anticipatory nature of CRs and higher-order conditioning.\nHigher-order instrumental conditioning occurs as well. In this case, a stimulus that consistently predicts primary reinforcement becomes a reinforcer itself, where reinforcement is primary if its rewarding or penalizing quality has been built into the animal by evolution. The predicting stimulus becomes a secondary reinforcer, or more generally, a higher-orderor conditioned reinforcer\\A1\\AAthe latter being a bet\u0026shy;ter term when the predicted reinforcing stimulus is itself a secondary, or an even higher-order, reinforcer. A conditioned reinforcer delivers conditioned reinforcement: conditioned reward or conditioned penalty. Conditioned reinforcement acts like pri\u0026shy;mary reinforcement in increasing an animal\\A1\\AFs tendency to produce behavior that leads to conditioned reward, and to decrease an animal\\A1\\AFs tendency to produce behavior that leads to conditioned penalty. (See our comments at the end of this chapter that explain how our terminology sometimes differs, as it does here, from terminology used in psychology.)\nConditioned reinforcement is a key phenomenon that explains, for instance, why we work for the conditioned reinforcer money, whose worth derives solely from what is predicted by having it. In actor-critic methods described in Section 13.5 (and discussed in the context of neuroscience in Sections 15.7 and 15.8), the critic uses a TD method to evaluate the actor\\A1\\AFs policy, and its value estimates provide conditioned reinforcement to the actor, allowing the actor to improve its policy. This analog of higher-order instrumental conditioning helps address the credit-assignment problem mentioned in Section 1.7 because the critic gives moment-by-moment reinforcement to the actor when the primary reward signal is delayed. We discuss this more below in Section 14.4.\n14.2.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Rescorla\\A1\\AAWagner Model\nRescorla and Wagner created their model mainly to account for blocking. The core idea of the Rescorla-Wagner model is that an animal only learns when events violate its expectations, in other words, only when the animal is surprised (although with\u0026shy;out necessarily implying any consciousexpectation or emotion). We first present Rescorla and Wagner\\A1\\AFs model using their terminology and notation before shifting to the terminology and notation we use to describe the TD model.\nHere is how Rescorla and Wagner described their model. The model adjusts the \\A1\\B0associative strength\\A1\\B1 of each component stimulus of a compound CS, which is a number representing how strongly or reliably that component is predictive of a US. When a compound CS consisting of several component stimuli is presented in a clas\u0026shy;sical conditioning trial, the associative strength of each component stimulus changes in a way that depends on an associative strength associated with the entire stimulus compound, called the \\A1\\B0aggregate associative strength,\\A1\\B1 and not just on the associa\u0026shy;tive strength of each component itself.\nRescorla and Wagner considered a compound CS AX, consisting of component stimuli A and X, where the animal may have already experienced stimulus A, and stimulus X might be new to the animal. Let Va,VX, and Vaxrespectively denote the associative strengths of stimuli A, X, and the compound AX. Suppose that on a trial the compound CS AX is followed by a US, which we label stimulus Y. Then the associative strengths of the stimulus components change according to these ex\u0026shy;pressions:\nAFa= aAPY (ry - Vax)\nAVX = axPY (Ry - VAx),\nwhere aAPY and axPY are the step-size parameters, which depend on the identities of the CS components and the US, and RY is the asymptotic level of associative strength that the US Y can support. (Rescorla and Wagner used A here instead of R, but we use R to avoid confusion with our use of A and because we usually think of this as the magnitude of a reward signal, with the caveat that the US in classical conditioning is not necessarily rewarding or penalizing.) A key assumption of the model is that the aggregate associative strength VAxis equal to VA + VX. The associative strengths as changed by these As become the associative strengths at the beginning of the next trial.\nTo be complete, the model needs a response-generation mechanism, which is a way of mapping values of Vs to CRs. Since this mapping would depend on details of the experimental situation, Rescorla and Wagner did not specify a mapping but simply assumed that larger Vs would produce stronger or more likely CRs, and that negative Vs would mean that there would be no CRs.\nThe Rescorla-Wagner model accounts for the acquisition of CRs in a way that\n \nexplains blocking. As long as the aggregate associative strength, Vax, of the stim\u0026shy;ulus compound is below the asymptotic level of associative strength, Ry, that the US Y can support, the prediction error Ry - VAx is positive. This means that over successive trials the associative strengths VA and VX of the component stimuli in\u0026shy;crease until the aggregate associative strength VAx equals Ry, at which point the associative strengths stop changing (unless the US changes). When a new compo\u0026shy;nent is added to a compound CS to which the animal has already been conditioned, further conditioning with the augmented compound produces little or no increase in the associative strength of the added CS component because the error has already been reduced to zero, or to a low value. The occurrence of the US is already pre\u0026shy;dicted nearly perfectly, so little or no error\\A1\\AAor surprise\\A1\\AAis introduced by the new CS component. Prior learning blocks learning to the new component.\nTo transition from Rescorla and Wagner\\A1\\AFs model to the TD model of classical conditioning (which we just call the TD model), we first recast their model in terms of the concepts that we are using throughout this book. Specifically, we match the notation we use for learning with linear function approximation (Section 9.4), and we think of the conditioning process as one of learning to predict the \\A1\\B0magnitude of the US\\A1\\B1 on a trial on the basis of the compound CS presented on that trial, where the magnitude of a US Y is the Ry of the Rescorla-Wagner model as given above. We also introduce states. Because the Rescorla-Wagner model is a trial-level model, meaning that it deals with how associative strengths change from trial to trial without considering any details about what happens within and between trials, we do not have to consider how states change during a trial until we present the full TD model in the following section. Instead, here we simply think of a state as a way of labeling a trial in terms of the collection of component CSs that are present on the trial.\nTherefore, assume that trial-type, or state, s is described by a real-valued vector of features x(s) = (xi(s), X2(s),...,xn(s))T where Xi(s) = 1if CSi, the ith component of a compound CS, is present on the trial and 0 otherwise. Then if the n-dimensional vector of associative strengths is w, the aggregate associative strength for trial-type s is\n   (14.1)\nin reinforcement learning, and we think of it as\nnumber of a complete trial and not its usual to t\\A1\\AFs usual meaning when we extend this to that St is the state corresponding to trial t.\n     {)(s,w) = wTx(s).\nThis corresponds to a value estimate the US prediction.\nNow temporally let t denote the meaning as a time step (we revert the TD model below), and assume Conditioning trial t updates the associative strength vector wt to wt+i as follows:\nwt+i = wt + a5t x(St),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (14.2)\nwhere a is the step-size parameter, and\\A1\\AAbecause here we are describing the Rescorla- Wagner model\\A1\\AA5t is the prediction error\nRt is the target of the prediction on trial t, that is, the magnitude of the US, or in Rescorla and Wagner\\A1\\AFs terms, the associative strength that the US on the trial can support. Note that because of the factor x(St) in (14.2), only the associative strengths of CS components present on a trial are adjusted as a result of that trial. You can think of the prediction error as a measure of surprise, and the aggregate associative strength as the animal\\A1\\AFs expectation that is violated when it does not match the target US magnitude.\nFrom the perspective of machine learning, the Rescorla-Wagner model is an error- correction supervised learning rule. It is essentially the same as the Least Mean Square (LMS), or Widrow-Hoff, learning rule (Widrow and Hoff, 1960) that finds the weights\\A1\\AAhere the associative strengths\\A1\\AAthat make the average of the squares of all the errors as close to zero as possible. It is a \\A1\\B0curve-fitting,\\A1\\B1 or regression, algorithm that is widely used in engineering and scientific applications (see Section 9.4).[27]\nThe Rescorla-Wagner model was very influential in the history of animal learning theory because it showed that a \\A1\\B0mechanistic\\A1\\B1 theory could account for the main facts about blocking without resorting to more complex cognitive theories involv\u0026shy;ing, for example, an animal\\A1\\AFs explicit recognition that another stimulus component had been added and then scanning its short-term memory backward to reassess the predictive relationships involving the US. The Rescorla-Wagner model showed how traditional contiguity theories of conditioning\\A1\\AAthat temporal contiguity of stimuli was a necessary and sufficient condition for learning\\A1\\AAcould be adjusted in a simple way to account for blocking (Moore and Schmajuk, 2008).\nThe Rescorla-Wagner model provides a simple account of blocking and some other features of classical conditioning, but it is not a complete or perfect model of classical conditioning. Different ideas account for a variety of other observed effects, and progress is still being made toward understanding the many subtleties of classical conditioning. The TD model, which we describe next, though also not a complete or perfect model model of classical conditioning, extends the Rescorla-Wagner model to address how within-trial and between-trial timing relationships among stimuli can influence learning and how higher-order conditioning might arise.\n14.2.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The TD Model\nThe TD model is a real-timemodel, as opposed to a trial-level model like the Rescorla-Wagner model. A single step t in the our formulation of Rescorla and Wagner\\A1\\AFs model above represents an entire conditioning trial. The model does not apply to details about what happens during the time a trial is taking place, or what might happen between trials. Within each trial an animal might experience various stimuli whose onsets occur at particular times and that have particular durations. These timing relationships strongly influence learning. The Rescorla-Wagner model\n \nalso does not include a mechanism for higher-order conditioning, whereas for the TD model, higher-order conditioning is a natural consequence of the backup idea that is at the base of TD algorithms.\nTo describe the TD model we begin with the formulation of the Rescorla-Wagner model above, but tnow labels time steps within or between trials instead of complete trials. Think of the time between t and t +1 as a small time interval, say .01 second, and think of a trial as a sequences of states, one associated with each time step, where the state at step t now represents details of how stimuli are represented at t instead of just a label for the CS components present on a trial. In fact, we can completely abandon the idea of trials. From the point of view of the animal, a trial is just a fragment of its continuing experience interacting with its world. Following our usual view of an agent interacting with its environment, imagine that the animal is experiencing an endless sequence of states s, each represented by a feature vector x(s). That said, it is still often convenient to refer to trials as fragments of time during which patterns of stimuli repeat in an experiment.\nState features are not restricted to describing the external stimuli that an animal experiences; they can describe neural activity patterns that external stimuli produce in an animal\\A1\\AFs brain, and these patterns can be history-dependent, meaning that they can be persistent patterns produced by sequences of external stimuli. Of course, we do not know exactly what these neural activity patterns are, but a real-time model like the TD model allows one to explore the consequences on learning of different hypotheses about the internal representations of external stimuli. For these reasons, the TD model does not commit to any particular state representation. In addition, because the TD model includes discounting and eligibility traces that span time intervals between stimuli, the model also makes it possible to explore how discounting and eligibility traces interact with stimulus representations in making predictions about the results of classical conditioning experiments.\nBelow we describe some of the state representations that have been used with the TD model and some of their implications, but for the moment we stay agnostic about the representation and just assume that each state s is represented by a feature vector x(s) = (xi(s), X2(s),...,xn(s))T. Then the aggregate associative strength corresponding to a state s is given by (14.1), the same as for the Rescorla-Wgner model, but the TD model updates the associative strength vector, w, differently. With t now labeling a time step instead of a complete trial, the TD model governs learning according to this update:\nwt+i = wt + a8t et,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (14.4)\nwhich replaces xt (St) in the Rescorla-Wagner update (14.2) with et, a vector of eligibility traces, and instead of the 8t of (14.3), here 8t is a TD error:\n8t = Rt+i + 7v(St+i,wt) - v(St,wt),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (14.5)\nwhere 7is a discount factor (between 0and 1), Rt is the prediction target at time t, and v(St+i,wt) and v(St,wt) are aggregate associative strengths at t + 1and t as defined by (14.1).\nEach component iof the eligibility-trace vector et increments or decrements ac\u0026shy;cording to the component x^(St) of the feature vector x(St), and otherwise decays with a rate determined by 7A:\net+i = yAet + x(St).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (14.6)\nHere A is the usual eligibility trace decay parameter.\nNote that if 7= 0, the TD model reduces to the Rescorla-Wagner model with the exceptions that: the meaning of t is different in each case (a trial number for the Rescorla-Wagner model and a time step for the TD model), and in the TD model there is a one-time-step lead in the prediction target R. The TD model is equivalent to the backward view of the semi-gradient TD(A) algorithm with linear function approximation (Chapter 12), except that Rt in the model does not have to be a reward signal as it does when the TD algorithm is used to learn a value function for policy-improvement.\n14.2.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD Model Simulations\nReal-time conditioning models like the TD model are interesting primarily because they make predictions for a wide range of situations that cannot be represented by trial-level models. These situations involve the timing and durations of conditionable stimuli, the timing of these stimuli in relation to the timing of the US, and the timing and shapes of CRs. For example, the US generally must begin after the onset of a neutral stimulus for conditioning to occur, with the rate and effectiveness of learning depending on the inter-stimulus interval, or ISI, the interval between the onsets of the CS and the US. When CRs appear, they generally begin before the appearance of the US and their temporal profiles change during learning. In conditioning with compound CSs, the component stimuli of the compound CSs may not all begin and end at the same time, sometimes forming what is called a serial compoundin which the component stimuli occur in a sequence over time. Timing considerations like these make it important to consider how stimuli are represented, how these representations unfold over time during and between trials, and how they interact with discounting and eligibility traces.\nFigure 14.2 shows three of the stimulus representations that have been used in exploring the behavior of the TD model: the complete serial compound(CSC), the microstimulus(MS), and the presencerepresentations (Ludvig, Sutton, and Kehoe, 2012). These representations differ in the degree to which they force generalization among nearby time points during which a stimulus is present.\nThe simplest of the representations shown in Figure 14.2 is the presence repre\u0026shy;sentation in the figure\\A1\\AFs right column. This representation has a single feature for each component CS present on a trial, where the feature has value 1 whenever that component is present, and 0 otherwise.[28]The presence representation is not a real\u0026shy;istic hypothesis about how stimuli are represented in an animal\\A1\\AFs brain, but as we describe below, the TD model with this representation can produce many of the timing phenomena seen in classical conditioning.\nFor the CSC representation (left column of Figure 14.2), the onset of each exter\u0026shy;nal stimulus initiates a sequence of precisely-timed short-duration internal signals that continues until the external stimulus ends.5This is like assuming the animal\\A1\\AFs nervous system has a clock that keeps precise track of time during stimulus presenta-\nthroughout the trial, there is a feature, xi,for each component CSi, i=\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; where Xi(St)= 1\nfor all times twhen the CSi is present, and equals zero otherwise.\n5In our formalism, for each CS component CSi present on a trial, and for each time step tduring a trial, there is a separate feature xit, where xt(St^)= 1 if t= tحfor any tحat which CSi is present, and equals 0 otherwise. This is different from the CSC representation in Sutton and Barto (1990) in which there are the same distinct features for each time step but no reference to external stimuli; hence the name complete serial compound.\nComplete Serial ,ߊ.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ^\nCompound M(Crost(mul( Presence\n \nFigure 14.2: Three stimulus representations (in columns) sometimes used with the TD model. Each row represents one element of the stimulus representation. The three representations vary along a temporal generalization gradient, with no general\u0026shy;ization between nearby time points in the complete serial compound (left column) and complete generalization between nearby time points in the presence representation (right column). The microstimulus representation occupies a middle ground. The degree of temporal generalization determines the temporal granularity with which US predictions are learned. Adapted with minor changes from Learning \u0026amp; Behavior, Evaluating the TD Model of Classical Conditioning, volume 40, 2012, p. 311, E. A. Ludvig, R. S. Sutton, E. J. Kehoe. With permission of Springer.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\ntions; it is what engineers call a \\A1\\B0tapped delay line.\\A1\\B1 Like the presence representation, the CSC representation is unrealistic as a hypothesis about how the brain internally represents stimuli, but Ludvig et al. (2012) call it a \\A1\\B0useful fiction\\A1\\B1 because it can reveal details of how the TD model works when relatively unconstrained by the stimulus representation. The CSC representation is also used in most TD models of dopamine-producing neurons in the brain, a topic we take up in Chapter 15. The CSC representation is often viewed as an essential part of the TD model, although this view is mistaken.\nThe MS representation (center column of Figure 14.2) is like the CSC represen\u0026shy;tation in that each external stimulus initiates a cascade of internal stimuli, but in this case the internal stimuli\\A1\\AAthe microstimuli\\A1\\AAare not of such limited and non\u0026shy;overlapping form; they are extended over time and overlap. As time elapses from stimulus onset, different sets of microstimuli become more or less active, and each subsequent microstimulus becomes progressively wider in time and reaches a lower maximal level. Of course, there are many MS representations depending on the nature of the microstimuli, and a number of examples of MS representations have been studied in the literature, in some cases along with proposals for how an ani\u0026shy;mal\\A1\\AFs brain might generate them (see the Bibliographic and Historical Comments at the end of this chapter). MS representations are more realistic than the presence or CSC representations as hypotheses about neural representations of stimuli, and they allow the behavior of the TD model to be related to a broader collection of phenomena observed in animal experiments. In particular, by assuming that cas\u0026shy;cades of microstimuli are initiated by USs as well as by CSs, and by studying the significant effects on learning of interactions between microstimuli, eligibility traces, and discounting, the TD model is helping to frame hypotheses to account for many of the subtle phenomena of classical conditioning and how an animal\\A1\\AFs brain might produce them. We say more about this below, particularly in Chapter 15 where we discuss reinforcement learning and neuroscience.\nEven with the simple presence representation, however, the TD model produces all the basic properties of classical conditioning that are accounted for by the Rescorla- Wagner model, plus features of conditioning that are beyond the scope of trial-level models. For example, as we have already mentioned, a conspicuous feature of clas\u0026shy;sical conditioning is that the US generally must begin afterthe onset of a neutral stimulus for conditioning to occur, and that after conditioning, the CR begins before the appearance of the US. In other words, conditioning generally requires a positive ISI, and the CR generally anticipates the US. How the strength of conditioning (e.g., the percentage of CRs elicited by a CS) depends on the ISI varies substantially across species and response systems, but it typically has the following properties: it is neg\u0026shy;ligible for a zero or negative ISI, i.e., when the US onset occurs simultaneously with, or earlier than, the CS onset (although research has found that associative strengths sometimes increase slightly or become negative with negative ISIs); it increases to a maximum at a positive ISI where conditioning is most effective; and it then decreases to zero after an interval that varies widely with response systems. The precise shape of this dependency for the TD model depends on the values of its parameters anddetails of the stimulus representation, but these basic features of ISI-dependency are core properties of the TD model.\nOne of the theoretical issues arising with serial-compound conditioning, that is, conditioning with a compound CS whose components occur in a sequence, concerns the facilitation of remote associations. It has been found that if the empty trace interval between the CS and the US is filled with a second CS to form a serial- compound stimulus, then conditioning to the first CS is facilitated. Figure 14.3 shows the behavior of the TD model with the presence representation in a simulation of such an experiment whose timing details are shown at the top of the figure. Consistent with the experimental results (Kehoe, 1982), the model shows facilitation of both\nof the first CS due\nthe rate of conditioning and the asymptotic level of conditioning to the presence of the second CS.\n   A\n        Figure 14.3: Facilitation of a remote association by an intervening\n     CSA- CSB- US -\n   TRIALS\n     B\nstimulus in the TD\nmodel. Top: temporal relationships among stimuli within a trial. Bottom: behavior over trials of CSA\\A1\\AFs associative strength when CSA is presented in a serial compound as shown in the top panel, and when presented in an identical temporal relationship to the US, only without CSB. Adapted from Sutton and Barto (1990).\nA well-known demonstration of the effects on conditioning of temporal relation\u0026shy;ships among stimuli within a trial is an experiment by Egger and Miller (1962) that involved two overlapping CSs in a delay configuration as shown in the top panel of Figure 14.4. Although CSB was in a better temporal relationship with the US, the presence of CSA substantially reduced conditioning to CSB as compared to controls in which CSA was absent. The bottom panel of Figure 14.4 shows the same result be\u0026shy;ing generated by the TD model in a simulation of this experiment with the presence representation.\n CSA------ 1\u0026quot;\n\n1.6\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nCSA ABSENT\n   WCSA\n     B\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n0\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; 80 TRIALS\nFigure 14.4: The Egger-Miller, or primacy, effect in the TD model. Top: temporal rela\u0026shy;tionships among stimuli within a trial. Bottom: behavior over trials of CSB\\A1\\AFs associative strength when CSB is presented with and without CSA. Adapted from Sutton and Barto (1990).\nThe TD model accounts for blocking because it is an error-correcting learning rule like the Rescorla-Wagner model. Beyond accounting for basic blocking results, however, the TD model predicts (with the presence representation and more complex representations a well) that blocking is reversed if the blocked stimulus is moved earlier in time so that its onset occurs before the onset of the blocking stimulus. This feature of the TD model\\A1\\AFs behavior deserves attention because it had not been observed at the time of the model\\A1\\AFs introduction. Recall that in blocking, if an animal has already learned that one CS predicts a US, then learning that a newly-added second CS also predicts the US is much reduced, i.e., is blocked. But if the newly- added second CS begins earlier than the pretrained CS, then\\A1\\AAaccording to the TD model\\A1\\AA learning to the newly-added CS is not blocked. In fact, as training continues and the newly-added CS gains associative strength, and the pretrained CS loses associative strength. The behavior of the TD model under these conditions is shown in Figure 14.5. This simulation experiment differed from the Egger-Miller experiment of Figure 14.4 in that the shorter CS with the later onset was given prior training until it was fully associated with the US. This surprising prediction led Kehoe, Scheurs, and Graham (1987) to conduct the experiment using the well-studied rabbit nictitating membrane preparation. Their results confirmed the model\\A1\\AFs prediction, and they noted that non-TD models have considerable difficulty explaining their data.\n   080\n        Figure 14.5: Temporal primacy overriding blocking in the TD model. Top: temporal relationships between stimuli. Bottom: behavior over trials of CSB\\A1\\AFs associative strength when CSB is presented with and without CSA. The only difference between this simulation and that shown in Figure 14.4 was that here CSB started out fully conditioned\\A1\\AACSB\\A1\\AFs associative strength was initially set to 1.653, the final level reached when CSB was presented alone for 80 trials, as in the \\A1\\B0CSA-absent\\A1\\B1 case in Figure 14.4. Adapted from Sutton and Barto (1990).\n        TRIALS\n     With the TD model, an earlier predictive stimulus takes precedence over a later predictive stimulus because, like all the prediction methods described in this book, the TD model is based on the backup idea: updates to associative strengths shift the strengths at a particular state toward a \\A1\\B0backed-up\\A1\\B1 strength for that state. An\u0026shy;other consequence of backups is that the TD model provides an account of higher-order conditioning, a feature of classical conditioning that is beyond the scope of the Rescoral-Wagner and similar models. As we described above, higher-order con\u0026shy;ditioning is the phenomenon in which a previously-conditioned CS can act as a US in conditioning another initially neutral stimulus. Figure 14.6 shows the behavior of the TD model (again with the presence representation) in a higher-order condi\u0026shy;tioning experiment\\A1\\AAin this case it is second-order conditioning. In the first phase (not shown in the figure), CSB is trained to predict a US so that its associative strength increases, here to 1.6. In the second phase, CSA is paired with CSB in the absence of the US, in the sequential arrangement shown at the top of the figure. CSA acquires associative strength even though it is never paired with the US. With continued training, CSA\\A1\\AFs associative strength reaches a peak and then decreases because the associative strength of CSB, the secondary reinforcer, decreases so that it loses its ability to provide secondary reinforcement. CSB\\A1\\AFs associative strength decreases because the US does not occur in these higher-order conditioning trials. These are extinction trialsfor CSB because its predictive relationship to the US is disrupted so that its ability to act as a reinforcer decreases. This same pattern is seen in animal experiments. This extinction of conditioned reinforcement in higher- order conditioning trials makes it difficult to demonstrate higher-order conditioning unless the original predictive relationships are periodically refreshed by occasionally inserting first-order trials.\nThe TD model produces an analog of second- and higher-order conditioning be-\n   Figure 14.6: Second-order conditioning with the TD model. Top: temporal relationships between stimuli. Bottom: behavior of the associative strengths associated with CSA and CSB over trials. The second stimulus, CSB, has an initial associative strength of 1.653 at the beginning of the simulation. Adapted from Sutton and Barto (1990).\n        TRIALS\n     cause 7{)(St+i,wt) - v(St,wt) appears in the TD error \u0026amp; (14.5). This means that as a result of previous learning, 7v(St+i,wt) can differ from v(St,wt), making \u0026#12316;non-zero (a temporal difference). This difference has the same status as Rt+i in (14.5), im\u0026shy;plying that as far as learning is concerned there is no difference between a temporal difference and the occurrence of a US. In fact, this feature of the TD algorithm is one of the major reasons for its development, which we now understand through its connection to dynamic programming as described in Chapter 6. Backing up values is intimately related to second-order, and higher-order, conditioning.\nIn the examples of the TD model\\A1\\AFs behavior described above, we examined only the changes in the associative strengths of the CS components; we did not look at what the model predicts about properties of an animal\\A1\\AFs conditioned responses (CRs): their timing, shape, and how they develop over conditioning trials. These properties depend on the species, the response system being observed, and parameters of the conditioning trials, but in many experiments with different animals and different response systems, the magnitude of the CR, or the probability of a CR, increases as the expected time of the US approaches. For example, in classical conditioning of a rabbit\\A1\\AFs nictitating membrane response that we mentioned above, over conditioning trials the delay from CS onset to when the nictitating membrane begins to move across the eye decreases over trials, and the amplitude of this anticipatory closure gradually increases over the interval between the CS and the US until the membrane reaches maximal closure at the expected time of the US. The timing and shape of this CR is critical to its adaptive significance\\A1\\AAcovering the eye too early reduces vision (even though the nictitating membrane is translucent), while covering it too late is of little protective value. Capturing CR features like these is challenging for models of classical conditioning.\nThe TD model does not include as part of its definition any mechanism for trans\u0026shy;lating the time course of the US prediction, {)(St,wt), into a profile that can be compared with the properties of an animal\\A1\\AFs CR. The simplest choice is to let the time course of a simulated CR equal the time course of the US prediction. In this case, features of simulated CRs and how they change over trials depend only on the stimulus representation chosen and the values of the model\\A1\\AFs parameters a, 7, and A.\nFigure 14.7 shows the time courses of US predictions at different points during learning with the three representations shown in Figure 14.2. For these simulations the US occurred 25 times steps after the onset of the CS, and a= .05, A = .95 and 7= .97. With the CSC representation (Figure 14.7 left), the curve of the US prediction formed by the TD model increases exponentially throughout the interval between the CS and the US until it reaches a maximum exactly when the US occurs (at time step 25). This exponential increase is the result of discounting in the TD model learning rule. With the presence representation (Figure 14.7 middle), the US prediction is nearly constant while the stimulus is present because there is only one weight, or associative strength, to be learned for each stimulus. Consequently, the TD model with the presence representation cannot recreate many features of CR timing. With an MS representation (Figure 14.7 right), the development of the TD modePs US prediction is more complicated. After 200 trials the prediction\\A1\\AFs profile is a reasonable approximation of the US prediction curve produced with the CSC representation.\n\n\n\u0026nbsp;SHAPE \u0026nbsp;\\* MERGEFORMAT    \u0026nbsp;\n      \u0026nbsp;\n \n Complete Serial Compound\n\n    \u0026nbsp;\n   Microstimulus\n        -Trial 200 -Trial 50 Trial 25\n        Time Steps\n        Presence\n     Time Steps\n\n\n\u0026nbsp;\n \nFigure 14.7: Time course of US prediction over the course of acquisition for the TD model with three different stimulus representations. Left: With the complete serial compound (CSC),the US prediction increases exponentially through the interval, peaking at the time of the US. At asymptote (trial 200), the US prediction peaks at the US intensity (1 in these simulations). Middle: With the presence representa\u0026shy;tion, the US prediction converges to an almost constant level. This constant level is determined by the US intensity and the length of the CS-US interval. Right: With the microstimulus representation, at asymptote, the TD model approximates the exponentially increasing time course depicted with the CSC through a linear combi\u0026shy;nation of the different microstimuli. Adapted with minor changes from Learning \u0026amp; Behavior,Evaluating the TD Model of Classical Conditioning, volume 40, 2012, E. A. Ludvig, R. S. Sutton, E. J. Kehoe. With permission of Springer.\nThe US prediction curves shown in Figure 14.7 were not intended to precisely match profiles of CRs as they develop during conditioning in any particular animal experiment, but they illustrate the strong influence that the stimulus representation has on predictions derived from the TD model. Further, although we can only men\u0026shy;tion it here, how the stimulus representation interacts with discounting and eligibility traces is important in determining properties of the US prediction profiles produced by the TD model. Another dimension beyond what we can discuss here is the influ\u0026shy;ence of different response-generation mechanisms that translate US predictions into CR profiles; the profiles shown in Figure 14.7 are \\A1\\B0raw\\A1\\B1 US prediction profiles. Even without any special assumption about how an animal\\A1\\AFs brain might produce overt responses from US predictions, however, the profiles in Figure 14.7 for the CSC and MS representations increase as the time of the US approaches and reach a maximum at the time of the US, as is seen in many animal conditioning experiments.\nThe TD model, when combined with particular stimulus representations and response- generation mechanisms, is able to account for a surprisingly-wide range of phenomena observed in animal classical conditioning experiments, but it is far from being a per\u0026shy;fect model. To generate other details of classical conditioning the model needs to be extended, perhaps by adding model-based elements and mechanisms for adap\u0026shy;tively altering some of its parameters. Other approaches to modeling classical condi\u0026shy;tioning depart significantly from the Rescorla-Wagner-style error-correction process. Bayesian models, for example, work within a probabilistic framework in which expe\u0026shy;rience revises probability estimates. All of these models usefully contribute to our understanding of classical conditioning.\nPerhaps the most notable feature of the TD model is that it is based on a theory\\A1\\AA the theory we have described in this book\\A1\\AAthat suggests an account of what an animal\\A1\\AFs nervous system is trying to dowhile undergoing conditioning: it is trying to form accurate long-term predictions,consistent with the limitations imposed by the way stimuli are represented and how the nervous system works. In other words, it suggests a normative accountof classical conditioning in which long-term, instead of immediate, prediction is a key feature.\nThe development of the TD model of classical conditioning is one instance in which the explicit goal was to model some of the details of animal learning behavior. In addition to its standing as an algorithm, then, TD learning is also the basis of this modelof aspects of biological learning. As we discuss in Chapter 15, TD learning has also turned out to underlie an influential model of the activity of neurons that produce dopamine, a chemical in the brain of mammals that is deeply involved in reward processing. These are instances in which reinforcement learning theory makes detailed contact with animal behavioral and neural data.\nWe now turn to considering correspondences between reinforcement learning and animal behavior in instrumental conditioning experiments, the other major type of laboratory experiment studied by animal learning psychologists.\n \n14.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Instrumental Conditioning\nIn instrumental conditioningexperiments learning depends on the consequences of behavior: the delivery of a reinforcing stimulus is contingent on what the animal does. In classical conditioning experiments, in contrast, the reinforcing stimulus\\A1\\AA the US\\A1\\AAis delivered independently of the animal\\A1\\AFs behavior. Instrumental condi\u0026shy;tioning is usually considered to be the same as operant conditioning,the term B. F. Skinner (1938, 1961) introduced for experiments with behavior-contingent reinforce\u0026shy;ment, though the experiments and theories of those who use these two terms differ in a number of ways, some of which we touch on below. We will exclusively use the term instrumental conditioning for experiments in which reinforcement is contingent upon behavior. The roots of instrumental conditioning go back to experiments per\u0026shy;formed by the American psychologist Edward Thorndike one hundred years before publication of the first edition of this book.\nThorndike observed the behavior of cats when they were placed in \\A1\\B0puzzle boxes\\A1\\B1 from which they could escape by appropriate actions (Figure 14.8). For example, a cat could open the door of one box by performing a sequence of three separate actions: depressing a platform at the back of the box, pulling a string by clawing at it, and pushing a bar up or down. When first placed in a puzzle box, with food visible outside, all but a few of Thorndike\\A1\\AFs cats displayed \\A1\\B0evident signs of discomfort\\A1\\B1 and extraordinarily vigorous activity \\A1\\B0to strive instinctively to escape from confinement\\A1\\B1 (Thorndike, 1898).\nIn experiments with different cats and boxes with different escape mechanisms, Thorndike recorded the amounts of time each cat took to escape over multiple ex\u0026shy;periences in each box. He observed that the time almost invariably decreased with successive experiences, for example, from 300 seconds to 6or 7 seconds. He described\n \nFigure 14.8: One of Thorndike\\A1\\AFs puzzle boxes. Reprinted from Thorndike, Animal Intelli\u0026shy;gence: An Experimental Study of the Associative Processes in Animals, The Psychological Review, Series of Monograph Supplements,II(4), Macmillan, New York, 1898, permission pending.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\ncats\\A1\\AF behavior in a puzzle box like this:\nThe cat that is clawing all over the box in her impulsive struggle will probably claw the string or loop or button so as to open the door. And gradually all the other non-successful impulses will be stamped out and the particular impulse leading to the successful act will be stamped in by the resulting pleasure, until, after many trials, the cat will, when put in the box, immediately claw the button or loop in a definite way. (Thorndike 1898, p. 13)\nThese and other experiments (some with dogs, chicks, monkeys, and even fish) led Thorndike to formulate a number of \\A1\\B0laws\\A1\\B1 of learning, the most influential being the Law of Effect,a version of which we quoted in Chapter 1. This law describes what is generally known as learning by trial and error. As mentioned in Chapter 1, many aspects of the Law of Effect have generated controversy, and its details have been modified over the years. Still the law\\A1\\AAin one form or anotherһexpresses an enduring principle of learning.\nEssential features of reinforcement learning algorithms correspond to features of animal learning described by the Law of Effect. First, reinforcement learning algo\u0026shy;rithms are selectional, meaning that they try alternatives and select among them by comparing their consequences. Second, reinforcement learning algorithms are associative, meaning that the alternatives found by selection are associated with particular situations, or states, to form the agent\\A1\\AFs policy. Like learning described by the Law of Effect, reinforcement learning is not just the process of findingactions that produce a lot of reward, but also of connectingthese actions to situations or states. Thorndike used the phrase learning by \\A1\\B0selecting and connecting\\A1\\B1 (Hilgard, 1956). Natural selection in evolution is a prime example of a selectional process, but it is not associative (at least as it is commonly understood); supervised learning is associative, but it is not selectional because it relies on instructions that directly tell the agent how to change its behavior.\nIn computational terms, the Law of Effect describes an elementary way of com\u0026shy;bining searchand memory: search in the form of trying and selecting among many actions in each situation, and memory in the form of associations linking situations with the actions found\\A1\\AAso far\\A1\\AAto work best in those situations. Search and memory are essential components of all reinforcement learning algorithms, whether memory takes the form of an agent\\A1\\AFs policy, value function, or environment model.\nA reinforcement learning algorithm\\A1\\AFs need to search means that it has to explore in some way. Animals clearly explore as well, and early animal learning researchers disagreed about the degree of guidance an animal uses in selecting its actions in sit\u0026shy;uations like Thorndike\\A1\\AFs puzzle boxes. Are actions the result of \\A1\\B0absolutely random, blind groping\\A1\\B1 (Woodworth, 1938, p. 777), or is there some degree of guidance, either from prior learning, reasoning, or other means? Although some thinkers, including Thorndike, seem to have taken the former position, others favored more deliberate exploration. Reinforcement learning algorithms allow wide latitude for how much guidance an agent can employ in selecting actions. The forms of exploration we have used in the algorithms presented in this book, such as e-greedy and upper-confidence- bound action selection, are merely among the simplest. More sophisticated methods are possible, with the only stipulation being that there has to be someform of exploration for the algorithms to work effectively.\nThe feature of our treatment of reinforcement learning allowing the set of actions available at any time to depend on the environment\\A1\\AFs current state echoes something Thorndike observed in his cats\\A1\\AF puzzle-box behaviors. The cats selected actions from those that they instinctively perform in their current situation, which Thorndike called their \\A1\\B0instinctual impulses.\\A1\\B1 First placed in a puzzle box, a cat instinctively scratches, claws, and bites with great energy: a cat\\A1\\AFs instinctual responses to finding itself in a confined space. Successful actions are selected from these and not from every possible action or activity. This is like the feature of our formalism where the action selected from a state sbelongs to a set of admissible actions, A(s).Specifying these sets is an important aspect of reinforcement learning because it can radically simplify learning. They are like an animal\\A1\\AFs instinctual impulses. On the other hand, Thorndike\\A1\\AFs cats might have been exploring according to an instinctual context- specific orderingover actions rather than by just selecting from a set of instinctual impulses. This is another way to make reinforcement learning easier.\nAmong the most prominent animal learning researchers influenced by the Law of Effect were Clark Hull (e.g., Hull, 1943) and B. F. Skinner (e.g., Skinner, 1938). At the center of their research was the idea of selecting behavior on the basis of its consequences. Reinforcement learning has features in common with Hull\\A1\\AFs theory, which included eligibility-like mechanisms and secondary reinforcement to account for the ability to learn when there is a significant time interval between an action and the consequent reinforcing stimulus (see Section 14.4). Randomness also played a role in Hull\\A1\\AFs theory through what he called \\A1\\B0behavioral oscillation\\A1\\B1 to introduce exploratory behavior.\nSkinner did not fully subscribe to the memory aspect of the Law of Effect. Be\u0026shy;ing averse to the idea of associative linkages, he instead emphasized selection from spontaneously-emitted behavior. He introduced the term \\A1\\B0operant\\A1\\B1 to emphasize the key role of an action\\A1\\AFs effects on an animal\\A1\\AFs environment. Unlike the experiments of Thorndike and others, which consisted of sequences of separate trials, Skinner\\A1\\AFs operant conditioning experiments allowed animal subjects to behave for extended periods of time without interruption. He invented the operant conditioning cham\u0026shy;ber, now called a \\A1\\B0Skinner box,\\A1\\B1 the most basic version of which contains a lever or key that an animal can press to obtain a reward, such as food or water, which would be delivered according to a well-defined rule, called a reinforcement schedule. By recording the cumulative number of lever presses as a function of time, Skinner and his followers could investigate the effect of different reinforcement schedules on the animal\\A1\\AFs rate of lever-pressing. Modeling results from experiments likes these using the reinforcement learning principles we present in this book is not well developed, but we mention some exceptions in the Bibliographic and Historical Remarks section at the end of this chapter.\nAnother of Skinner\\A1\\AFs contributions resulted from his recognition of the effective\u0026shy;ness of training an animal by reinforcing successive approximations of the desired behavior, a process he called shaping.Although this technique had been used by others, including Skinner himself, its significance was impressed upon him when he and colleagues were attempting to train a pigeon to bowl by swiping a wooden ball with its beak. After waiting for a long time without seeing any swipe that they could reinforce, they\n... decided to reinforce any response that had the slightest resemblance to a swipe\\A1\\AAperhaps, at first, merely the behavior of looking at the ball\\A1\\AA and then to select responses which more closely approximated the final form. The result amazed us. In a few minutes, the ball was caroming off the walls of the box as if the pigeon had been a champion squash player. (Skinner, 1958, p. 94)\nNot only did the pigeon learn a behavior that is unusual for pigeons, it learned quickly through an interactive process in which its behavior and the reinforcement contingencies changed in response to each other. Skinner compared the process of altering reinforcement contingencies to the work of a sculptor shaping clay into a de\u0026shy;sired form. Shaping is a powerful technique for computational reinforcement learning systems as well. When it is difficult for an agent to receive any non-zero reward sig\u0026shy;nal at all, either due to sparseness of rewarding situations or their inaccessibility given initial behavior, starting with an easier problem and incrementally increasing its difficulty as the agent learns can be an effective, and sometimes indispensable, strategy.\nA concept from psychology that is especially relevant in the context of instrumental conditioning is motivation, which refers to processes that influence the direction and strength, or vigor, of behavior. Thorndike\\A1\\AFs cats, for example, were motivated to escape from puzzle boxes because they wanted the food that was sitting just outside. Obtaining this goal was rewarding to them and reinforced the actions allowing them to escape. It is difficult to link the concept of motivation, which has many dimensions, in a precise way to reinforcement learning\\A1\\AFs computational perspective, but there are clear links with some of its dimensions.\nIn one sense, a reinforcement learning agent\\A1\\AFs reward signal is at the base of its motivation: the agent is motivated to maximize the total reward it receives over the long run. A key facet of motivation, then, is what makes an agent\\A1\\AFs experience rewarding. In reinforcement learning, reward signals depend on the state of the reinforcement learning agent\\A1\\AFs environment and the agent\\A1\\AFs actions. Further, as pointed out in Chapter 1, the state of the agent\\A1\\AFs environment not only includes information about what is external to the machine, like an organism or a robot, that houses the agent, but also what is internal to this machine. Some internal state components correspond to what psychologists call an animal\\A1\\AFs motivational state, which influences what is rewarding to the animal. For example, an animal will be more rewarded by eating when it is hungry than when it has just finished a satisfying meal. The concept of state dependence is broad enough to allow for many types of modulating influences on the generation of reward signals.\nValue functions provide a further link to psychologists\\A1\\AF concept of motivation. If the most basic motive for selecting an action is to obtain as much reward as possible, for a reinforcement learning agent that selects actions using a value function, a more proximal motive is to ascend the gradient of its value function, that is, to select actions expected to lead to the most highly-valued next states (or what is essentially the same thing, to select actions with the greatest action-values). For these agents, value functions are the main driving force determining the direction of their behavior.\nAnother dimension of motivation is that an animal\\A1\\AFs motivational state not only influences learning, but also influences the strength, or vigor, of the animal\\A1\\AFs behavior after learning. For example, after learning to find food in the goal box of a maze, a hungry rat will run faster to the goal box than one that is not hungry. This aspect of motivation does not link so cleanly to the reinforcement learning framework we present here, but in the Bibliographical and Historical Remarks section at the end of this chapter we cite several publications that propose theories of behavioral vigor based on reinforcement learning.\nWe turn now to the subject of learning when reinforcing stimuli occur well after the events they reinforce. The mechanisms used by reinforcement learning algorithms to enable learning with delayed reinforcement\\A1\\AAeligibility traces and TD learning\\A1\\AA closely correspond to psychologists\\A1\\AF hypotheses about how animals can learn under these conditions.\n14.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Delayed Reinforcement\nThe Law of Effect requires a backward effect on connections, and some early critics of the law could not conceive of how the present could affect something that was in the past. This concern was amplified by the fact that learning can even occur when there is a considerable delay between an action and the consequent reward or penalty. Similarly, in classical conditioning, learning can occur when US onset follows CS offset by a non-negligible time interval. We call this the problem of delayed reinforcement, which is related to what Minsky (1961) called the \\A1\\B0credit-assignment problem for learning systems\\A1\\B1: how do you distribute credit for success among the many decisions that may have been involved in producing it? The reinforcement learning algorithms presented in this book include two basic mechanisms for addressing this problem. The first is the use of eligibility traces, and the second is the use of TD methods to learn value functions that provide nearly immediate evaluations of actions (in tasks like instrumental conditioning experiments) or that provide immediate prediction targets (in tasks like classical conditioning experiments). Both of these methods correspond to similar mechanisms proposed in theories of animal learning.\nPavlov (1927) pointed out that every stimulus must leave a trace in the nervous system that persists for some time after the stimulus ends, and he proposed that stimulus traces make learning possible when there is a temporal gap between the CS offset and the US onset. To this day, conditioning under these conditions is called trace conditioning(Figure 14.1). Assuming a trace of the CS remains when the US \n\n\narrives, learning occurs through the simultaneous presence of the trace and the US. We discuss some proposals for trace mechanisms in the nervous system in Chapter 15.\nStimulus traces were also proposed as a means for bridging the time interval be\u0026shy;tween actions and consequent rewards or penalties in instrumental conditioning. In Hull\\A1\\AFs influential learning theory, for example, \\A1\\B0molar stimulus traces\\A1\\B1 accounted for what he called an animal\\A1\\AFs goal gradient, a description of how the maximum strength of an instrumentally-conditioned response decreases with increasing delay of reinforcement (Hull, 1932, 1943). Hull hypothesized that an animal\\A1\\AFs actions leave internal stimuli whose traces decay exponentially as functions of time since an action was taken. Looking at the animal learning data available at the time, he hypothesized that the traces effectively reach zero after 30 to 40 seconds.\nThe eligibility traces used in the algorithms described in this book are like Hull\\A1\\AFs traces: they are decaying traces of past state visitations, or of past state-action pairs. Eligibility traces were introduced by Klopf (1972) in his neuronal theory in which they are temporally-extended traces of past activity at synapses, the connections between neurons. Klopf\\A1\\AFs traces are more complex than the exponentially-decaying traces our algorithms use, and we discuss this more when we take up his theory in Section 15.9.\nTo account for goal gradients that extend over longer time periods than spanned by stimulus traces, Hull (1943) proposed that longer gradients result from conditioned reinforcement passing backwards from the goal, a process acting in conjunction with his molar stimulus traces. Animal experiments showed that if conditions favor the development of conditioned reinforcement during a delay period, learning does not decrease with increased delay as much as it does under conditions that obstruct sec\u0026shy;ondary reinforcement. Conditioned reinforcement is favored if there are stimuli that regularly occur during the delay interval. Then it is as if reward is not actually delayed because there is more immediate conditioned reinforcement. Hull therefore envisioned that there is a primary gradient based on the delay of the primary rein\u0026shy;forcement mediated by stimulus traces, and that this is progressively modified, and lengthened, by conditioned reinforcement.\nAlgorithms presented in this book that use both eligibility traces and value func\u0026shy;tions to enable learning with delayed reinforcement correspond to Hull\\A1\\AFs hypothesis about how animals are able to learn under these conditions. The actor-critic ar\u0026shy;chitecture discussed in Sections 13.5, 15.7, and 15.8 illustrates this correspondence most clearly. The critic uses a TD algorithm to learn a value function associated with the system\\A1\\AFs current behavior, that is, to predict the current policy\\A1\\AFs return. The actor updates the current policy based on the critic\\A1\\AFs predictions, or more exactly, on changes in the critic\\A1\\AFs predictions. The TD error produced by the critic acts as a conditioned reinforcement signal for the actor, providing an immediate evaluation of performance even when the primary reward signal itself is considerably delayed. Algorithms that estimate action-value functions, such as Q-learning and Sarsa, sim\u0026shy;ilarly use TD learning principles to enable learning with delayed reinforcement by means of conditioned reinforcement. The close parallel between TD learning and the activity of dopamine producing neurons that we discuss in Chapter 15 lends addi\u0026shy;tional support to links between reinforcement learning algorithms and this aspect of Hull\\A1\\AFs learning theory.\n14.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Cognitive Maps\nModel-based reinforcement learning algorithms use environment models that have elements in common with what psychologists call cognitive maps.Recall from our discussion of planning and learning in Chapter 8that by an environment model we mean anything an agent can use to predict how its environment will respond to its actions in terms of state transitions and rewards, and by planning we mean any process that computes a policy from such a model. Environment models consist of two parts: the state-transition part encodes knowledge about the effect of actions on state changes, and the reward-model part encodes knowledge about the reward signals expected for each state or each state-action pair. A model-based algorithm selects actions by using a model to predict the consequences of possible courses of action in terms of future states and the reward signals expected to arise from those states. The simplest kind of planning is to compare the predicted consequences of collections of \\A1\\B0imagined\\A1\\B1 sequences of decisions.\nQuestions about whether or not animals use environment models, and if so, what are the models like and how are lthey learned, have played influential roles in the history of animal learning research. Some researchers challenged the then-prevailing stimulus-response (S-R) view of learning and behavior, which corresponds to the simplest model-free way of learning policies, by demonstrating latent learning. In the earliest latent learning experiment, two groups of rats were run in a maze. For the experimental group, there was no reward during the first stage of the experiment, but food was suddenly introduced into the goal box of the maze at the start of the second stage. For the control group, food was in the goal box throughout both stages. The question was whether or not rats in the experimental group would have learned anything during the first stage in the absence of food reward. Although the experimental rats did not appearto learn much during the first, unrewarded, stage, as soon as they discovered the food that was introduced in the second stage, they rapidly caught up with the rats in the control group. It was concluded that \\A1\\B0during the non-reward period, the rats [in the experimental group] were developing a latent learning of the maze which they were able to utilize as soon as reward was introduced\\A1\\B1 (Blodgett, 1929).\nLatent learning is most closely associated with the psychologist Edward Tolman, who interpreted this result, and others like it, as showing that animals could learn a \\A1\\B0cognitive map of the environment\\A1\\B1 in the absence of rewards or penalties, and that they could use the map later when they were motivated to reach a goal (Tolman, 1948). A cognitive map could also allow a rat to plan a route to the goal that was different from the route the rat had used in its initial exploration. Explanations of results like these led to the enduring controversy lying at the heart of the behav- iorist/cognitive dichotomy in psychology. In modern terms, cognitive maps are not restricted to models of spatial layouts but are more generally environment models, or models of an animal\\A1\\AFs \\A1\\B0task space\\A1\\B1 (e.g., Wilson, Takahashi, Schoenbaum, and Niv, 2014). The cognitive map explanation of latent learning experiments is analogous to the claim that animals use model-based algorithms, and that environment models can be learned even without explicit rewards or penalties. Models are then used for planning when the animal is motivated by the appearance of rewards or penalties.\nTolman\\A1\\AFs account of how animals learn cognitive maps was that they learn stimulus- stimulus, or S-S, associations by experiencing successions of stimuli as they explore an environment. In psychology this is called expectancy theory: given S-S associa\u0026shy;tions, the occurrence of a stimulus generates an expectation about the stimulus to come next. This is much like what control engineers call system identification, in which a model of a system with unknown dynamics is learned from labeled training examples. In the simplest discrete-time versions, training examples are S-S; pairs, where S is a state and S;, the subsequent state, is the label. When S is observed, the model creates the \\A1\\B0expectation\\A1\\B1 that S' will be observed next. Models more useful for planning involve actions as well, so that examples look like SA-S', where S' is expected when action A is executed in state S. It is also useful to learn how the environment generates rewards. In this case, examples are of the form S-R or SA-R, where R is a reward signal associated with S or the SA pair. These are all forms of supervised learning by which an agent can acquire cognitive-like maps whether or not it receives any non-zero reward signals while exploring its environment.\n14.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Habitual and Goal-directed Behavior\nThe distinction between model-free and model-based reinforcement learning algo\u0026shy;rithms corresponds to the distinction psychologists make between habitual and goal- directed control of learned behavioral patterns. Habits are behavior patterns trig\u0026shy;gered by appropriate stimuli and then performed more-or-less automatically. Goal- directed behavior, according to how psychologists use the phrase, is purposeful in the sense that it is controlled by knowledge of the value of goals and the relationship between actions and their consequences. Habits are sometimes said to be controlled by antecedent stimuli, whereas goal-directed behavior is said to be controlled by its consequences (Dickinson, 1980, 1985). Goal-directed control has the advantage that it can rapidly change an animal\\A1\\AFs behavior when the environment changes its way of reacting to the animal\\A1\\AFs actions. While habitual behavior responds quickly to input from an accustomed environment, it is unable to quickly adjust to changes in the environment. The development of goal-directed behavioral control was likely a major advance in the evolution of animal intelligence.\nFigure 14.9 illustrates the difference between model-free and model-based decision strategies in a hypothetical task in which a rat has to navigate a maze that has distinctive goal boxes, each delivering an associated reward of the magnitude shown (Figure 14.9 top). Starting at Si, the rat has to first select left (L) or right (R) and then has to select L or R again at S2or S3to reach one of the goal boxes. The goal boxes are the terminal states of each episode of the rat\\A1\\AFs episodic task. A model-free strategy (Figure 14.9 lower left) relies on stored values for state-action pairs. These action values (Q-values) are estimates of the highest return the rat can expect for each action taken from each (nonterminal) state. They are obtained over many trials of running the maze from start to finish. When the action values have become good enough estimates of the optimal returns, the rat just has to select at each state the action with the largest action value in order to make optimal decisions. In this case, when the action-value estimates become accurate enough, the rat selects L from Si and R from S2to obtain the maximum return of 4. A different model-free strategy might simply rely on a cached policy instead of action values, making direct links from Si to L and from S2to R. In neither of these strategies do decisions rely on an environment model. There is no need to consult a state-transition model, and no connection is required between the features of the goal boxes and the rewards they deliver.\nFigure 14.9 (lower right) illustrates a model-based strategy. It uses an environment model consisting of a state-transition model and a reward model. The state-transition model is shown as a decision tree, and the reward model associates the distinctive features of the goal boxes with the rewards to be found in each. (The rewards associated with states Si, S2, and S3are also part of the reward model, but here they are zero and are not shown.) A model-based agent can decide which way to turn at each state by using the model to simulate sequences of action choices to find a path yielding the highest return. In this case the return is the reward obtained from the outcome at the end of the path. Here, with a sufficiently accurate model, the rat would select L and then R to obtain reward of 4. Comparing the predicted returns of simulated paths is a simple form of planning, which can be done in a variety of ways as discussed in Chapter 8.\nWhen the environment of a model-free agent changes the way it reacts to the agent\\A1\\AFs actions, the agent has to acquire new experience in the changed environment during which it can update its policy and/or value function. In the model-free strategy shown in Figure 14.9 (lower left), for example, if one of the goal boxes were to somehow shift to delivering a different reward, the rat would have to traverse the maze, possibly many times, to experience the new reward upon reaching that goal box, all the while updating either its policy or its action-value function (or both) based on this experience. The key point is that for a model-free agent to change the action its policy specifies for a state, or to change an action value associated with a state, it has to move to that state, act from it, possibly many times, and experience the consequences of its actions.\nA model-based agent can accommodate changes in its environment without this kind of \\A1\\AEpersonal experience\\A1\\AF with the states and actions affected by the change. A change in its model automatically (through planning) changes its policy. Planning can determine the consequences of changes in the environment that have never been linked together in the agent\\A1\\AFs own experience. For example, again referring to the maze task of Figure 14.9, imagine that a rat with a previously learned transition and reward model is placed directly in the goal box to the right of S2to find that the reward available there now has value 1 instead of 4. The rat\\A1\\AFs reward model will change even though the action choices required to find that goal box in the maze\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nModel-Free\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Model-Based\nFigure 14.9: Model-based and model-free strategies to solve a hypothetical sequential action- selection problem. Top: a rat navigates a maze with distinctive goal boxes, each associated with a reward having the value shown. Lower left: a model-free strategy relies on stored action values for all the state-action pairs obtained over many learning trials. To make decisions the rat just has to select at each state the action with the largest action value for that state. Lower right: in a model-based strategy, the rat learns an environment model, consisting of knowledge of state-action-next-state transitions and a reward model consisting of knowledge of the reward associated with each distinctive goal box. The rat can decide which way to turn at each state by using the model to simulate sequences of action choices to find a path yielding the highest return. Adapted from Trends in Cognitive Science,volume 10, number 8, Y. Niv, D. Joel, and P. Dayan, A Normative Perspective on Motivation, p. 376, 2006, with permission from Elsevier.\nwere not involved. The planning process will bring knowledge of the new reward to bear on maze running without the need for additional experience in the maze; in this case changing the policy to right turns at both Si and S3to obtain a return of 3.\nExactly this logic is the basis of outcome-devaluation experimentswith animals. Results from these experiments provide insight into whether an animal has learned a habit or if its behavior is under goal-directed control. Outcome-devaluation ex\u0026shy;periments are like latent-learning experiments in that the reward changes from one stage to the next. After an initial rewarded stage of learning, the reward value of an outcome is changed, including being shifted to zero or even to a negative value.\nAn early important experiment of this type was conducted by Adams and Dickin\u0026shy;son (1981). They trained rats via instrumental conditioning until the rats energet\u0026shy;ically pressed a lever for sucrose pellets in a training chamber. The rats were then placed in the same chamber with the lever retracted and allowed non-contingent food, meaning that pellets were made available to them independently of their actions. Af\u0026shy;ter 15-minutes of this free-access to the pellets, rats in one group were injected with the nausea-inducing poison lithium chloride. This was repeated for three sessions, in the last of which none of the injected rats consumed any of the non-contingent pellets, indicating that the reward value of the pellets had been decreased\\A1\\AAthe pel\u0026shy;lets had been devalued. In the next stage taking place a day later, the rats were again placed in the chamber and given a session of extinction training, meaning that the response lever was back in place but disconnected from the pellet dispenser so that pressing it did not release pellets. The question was whether the rats that had the reward value of the pellets decreased would lever-press less than rats that did not have the reward value of the pellets decreased, even without experiencing the devalued reward as a result of lever-pressing. It turned out that the injected rats had significantly lower response rates than the non-injected rats right from the start of the extinction trials.\nAdams and Dickinson concluded that the injected rats associated lever pressing with consequent nausea by means of a cognitive map linking lever pressing to pellets, and pellets to nausea. Hence, in the extinction trials, the rats \\A1\\B0knew\\A1\\B1 that the consequences of pressing the lever would be something they did not want, and so they reduced their lever-pressing right from the start. The important point is that they reduced lever-pressing without ever having experienced lever-pressing directly followed by being sick: no lever was present when they were made sick. They seemed able to combine knowledge of the outcome of a behavioral choice (pressing the lever will be followed by getting a pellet) with the reward value of the outcome (pellets are to be avoided) and hence could alter their behavior accordingly. Not every psychologist agrees with this \\A1\\B0cognitive\\A1\\B1 account of this kind of experiment, and it is not the only possible way to explain these results, but the model-based planning explanation is widely accepted.\nNothing prevents an agent from using both model-free and model-based algo\u0026shy;rithms, and there are good reasons for using both. We know from our own experience that with enough repetition, goal-directed behavior tends to turn into habitual be\u0026shy;havior. Experiments show that this happens for rats too. Adams (1982) conducted \n\n\nan experiment to see if extended training would convert goal-directed behavior into habitual behavior. He did this by comparing the effect of outcome devaluation on rats that experienced different amounts of training. If extended training made the rats less sensitive to devaluation compared to rats that received less training, this would be evidence that extended training made the behavior more habitual. Adams\\A1\\AF exper\u0026shy;iment closely followed the Adams and Dickinson (1981) experiment just described. Simplifying a bit, rats in one group were trained until they made 100 rewarded lever- presses, and rats in the other group\\A1\\AAthe overtrained group\\A1\\AAwere trained until they made 500 rewarded lever-presses. After this training, the reward value of the pel\u0026shy;lets was decreased (using lithium chloride injections) for rats in both groups. Then both groups of rats were given a session of extinction training. Adams\\A1\\AF question was whether devaluation would effect the rate of lever-pressing for the overtrained rats less than it would for the non-overtrained rats, which would be evidence that extended training reduces sensitivity to outcome devaluation. It turned out that de\u0026shy;valuation strongly decreased the lever-pressing rate of the non-overtrained rats. For the overtrained rats, in contrast, devaluation had little effect on their lever-pressing; in fact, if anything, it made it more vigorous. (The full experiment included con\u0026shy;trol groups showing that the different amounts of training did not by themselves significantly effect lever-pressing rates after learning.) This result suggested that while the non-overtrained rats were acting in a goal-directed manner sensitive to their knowledge of the outcome of their actions, the overtrained rats had developed a lever-pressing habit.\nViewing this and other results like it from a computational perspective provides insight as to why one might expect animals to behave habitually in some circum\u0026shy;stances, in a goal-directed way in others, and why they shift from one mode of control to another as they continue to learn. While animals undoubtedly use algorithms that do not exactly match those we have presented in this book, one can gain insight into animal behavior by considering the tradeoffs that various reinforcement learning al\u0026shy;gorithms imply. An idea developed by computational neuroscientists Daw, Niv, and Dayan (2005) is that animals use both model-free and model-based processes. Each process proposes an action, and the action chosen for execution is the one proposed by the process judged to be the more trustworthy of the two as determined by mea\u0026shy;sures of confidence that are maintained throughout learning. Early in learning the planning process of a model-based system is more trustworthy because it chains to\u0026shy;gether short-term predictions which can become accurate with less experience than long-term predictions of the model-free process. But with continued experience, the model-free process becomes more trustworthy because planning is prone to mak\u0026shy;ing mistakes due to model inaccuracies and short-cuts necessary to make planning feasible, such as various forms of tree-pruning. According to this idea one would expect a shift from goal-directed behavior to habitual behavior as more experience accumulates. Other ideas have been proposed for how animals arbitrate between goal-directed and habitual control, and both behavioral and neuroscience research continues to examine this and related questions.\nThe distinction between model-free and model-based algorithms is proving to be useful for this research. One can examine the computational implications of these types of algorithms in abstract settings that expose basic advantages and limitations of each type. This serves both to suggest and to sharpen questions that guide the de\u0026shy;sign of experiments necessary for increasing psychologists\\A1\\AF understanding of habitual and goal-directed behavioral control.\n14.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nOur goal in this chapter has been to discuss correspondences between reinforcement learning and the experimental study of animal learning in psychology. We emphasized at the outset that reinforcement learning as described in this book is not intended to model details of animal behavior. It is an abstract computational framework that explores idealized situations from the perspective of artificial intelligence and engineering. But many of the basic reinforcement learning algorithms were inspired by psychological theories, and in some cases, these algorithms have contributed to the development of new animal learning models. This chapter described the most conspicuous of these correspondences.\nThe distinction in reinforcement learning between algorithms for prediction and algorithms for control parallels animal learning theory\\A1\\AFs distinction between classi\u0026shy;cal, or Pavlovian, conditioning and instrumental conditioning. The key difference between instrumental and classical conditioning experiments is that in the former the reinforcing stimulus is contingent upon the animal\\A1\\AFs behavior, whereas in the latter it is not. Learning to predict via a TD algorithm corresponds to classical con\u0026shy;ditioning, and we described the TD model of classical conditioningas one instance in which reinforcement learning principles account for some details of animal learning behavior. This model generalizes the influential Rescorla-Wagner model by including the temporal dimension where events within individual trials influence learning, and it provides an account of second-order conditioning, where predictors of reinforcing stimuli become reinforcing themselves. It also is the basis of an influential view of the activity of dopamine neurons in the brain, something we take up in Chapter 15.\nLearning by trial and error is at the base of the control aspect of reinforcement learning. We presented some details about Thorndike\\A1\\AFs experiments with cats and other animals that led to his Law of Effect,which we discussed here and in Chap\u0026shy;ter 1. We pointed out that in reinforcement learning, exploration does not have to be limited to \\A1\\B0blind groping\\A1\\B1; trials can be generated by sophisticated methods using innate and previously learned knowledge as long as there is someexploration. We discussed the training method B. F. Skinner called shapingin which reward contin\u0026shy;gencies are progressively altered to train an animal to successively approximate a desired behavior. Shaping is not only indispensable for animal training, it is also an effective tool for training reinforcement learning agents. There is also a connection to the idea of an animal\\A1\\AFs motivational state, which influences what an animal will approach or avoid and what events are rewarding or punishing for the animal.\nThe reinforcement learning algorithms presented in this book include two basic\nmechanisms for addressing the problem of delayed reinforcement: eligibility traces and value functions learned via TD algorithms. Both mechanisms have antecedents in theories of animal learning. Eligibility traces are similar to stimulus traces of early theories, and value functions correspond to the role of secondary reinforcement in providing nearly immediate evaluative feedback.\nThe next correspondence the chapter addressed is that between reinforcement learning\\A1\\AFs environment models and what psychologists call cognitive maps.Exper\u0026shy;iments conducted in the mid 20th century purported to demonstrate the ability of animals to learn cognitive maps as alternatives to, or as additions to, state-action associations, and later use them to guide behavior, especially when the environment changes unexpectedly. Environment models in reinforcement learning are like cog\u0026shy;nitive maps in that they can be learned by supervised learning methods without relying on reward signals, and then they can be used later to plan behavior.\nReinforcement learning\\A1\\AFs distinction between model-freeand model-basedalgo\u0026shy;rithms corresponds to the distinction in psychology between habitualand goal-directed behavior. Model-free algorithms make decisions by accessing information that has been strored in a policy or an action-value function, whereas model-based methods select actions as the result of planning ahead using a model of the agent\\A1\\AFs envi\u0026shy;ronment. Outcome-devaluation experiments provide information about whether an animal\\A1\\AFs behavior is habitual or under goal-directed control. Reinforcement learning theory has helped clarify thinking about these issues.\nAnimal learning clearly informs reinforcement learning, but as a type of machine learning, reinforcement learning is directed toward designing and understanding ef\u0026shy;fective learning algorithms, not toward replicating or explaining details of animal behavior. We focused on aspects of animal learning that relate in clear ways to methods for solving prediction and control problems, highlighting the fruitful two\u0026shy;way flow of ideas between reinforcement learning and psychology without venturing deeply into many of the behavioral details and controversies that have occupied the attention of animal learning researchers. Future development of reinforcement learn\u0026shy;ing theory and algorithms will likely exploit links to many other features of animal learning as the computational utility of these features becomes better appreciated. We expect that a flow of ideas between reinforcement learning and psychology will continue to bear fruit for both disciplines.\nMany connections between reinforcement learning and areas of psychology and other behavioral sciences are beyond the scope of this chapter. We largely omit discussing links to the psychology of decision-making, which focusses on how actions are selected, or how decisions are made, afterlearning has taken place. We also do not discuss links to ecological and evolutionary aspects of behavior studied by ethologists and behavioral ecologists: how animals relate to one another and to their physical surroundings, and how their behavior contributes to evolutionary fitness. Optimization, MDPs, and dynamic programming figure prominently in these fields, and our emphasis on agent interaction with dynamic environments connects to the study of agent behavior in complex \\A1\\B0ecologies.\\A1\\B1 Multi-agent reinforcement learning, omitted in this book, has connections to social aspects of behavior. Despite the\nlack of treatment here, reinforcement learning should by no means be interpreted as dismissing evolutionary perspectives. Nothing about reinforcement learning implies a tabula rasaview of learning and behavior. Indeed, experience with engineering applications has highlighted the importance of building into reinforcement learning systems knowledge that is analogous to what evolution provides to animals.\nBibliographical and Historical Remarks\nLudvig, Bellemare, and Pearson (2011) and Shah (2012) review reinforcement learn\u0026shy;ing in the contexts of psychology and neuroscience. These publications are useful companions to this chapter and the following chapter on reinforcement learning and neuroscience.\n14.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Dayan, Niv, Seymour, and Daw (2006) focused on interactions between clas\u0026shy;sical and instrumental conditioning, particularly situations where classically- conditioned and instrumental responses are in conflict. They proposed a Q- learning framework for modeling aspects of this interaction. Modayil and Sut\u0026shy;ton (2014) used a mobile robot to demonstrate the effectiveness of a control method combining a fixed response with online prediction learning. Calling this Pavlovian control, they emphasized that it differs from the usual control methods of reinforcement learning, being based on predictively executing fixed responses and not on reward maximization. The electro-mechanical machine of Ross (1933) and especially the learning version of Walter\\A1\\AFs tur\u0026shy;tle (Walter, 1951) were very early illustrations of Pavlovian control. What is now called Pavlovian-instrumental transfer was first observed by Estes (1943, 1948).\n14.2.1\u0026nbsp;\u0026nbsp;\u0026nbsp; Kamin (1968) first reported blocking, now commonly known as Kamin block\u0026shy;ing, in classical conditioning. Moore and Schmajuk (2008) provide an excel\u0026shy;lent summary of the blocking phenomenon, the research it stimulated, and its lasting influence on animal learning theory. Gibbs, Cool, Land, Kehoe, and Gormezano (1991) describe second-order conditioning of the rabbit\\A1\\AFs nic\u0026shy;titating membrane response and its relationship to conditioning with serial- compound stimuli. Finch and Culler (1934) reported obtaining fifth-order conditioning of a dog\\A1\\AFs foreleg withdrawal \\A1\\B0when the motivationof the ani\u0026shy;mal is maintained through the various orders.\\A1\\B1\n14.2.2\u0026nbsp;\u0026nbsp;\u0026nbsp; The idea built into the Rescorla-Wagner model that learning occurs when animals are surprised is derived from Kamin (1969). Models of classical conditioning other than Rescorla and Wagner\\A1\\AFs include the models of Klopf (1988), Grossberg (1975), Mackintosh (1975), Moore and Stickney (1980), Pearce and Hall (1980), and Courville, Daw, and Touretzky (2006). Schmajuk (2008) review models of classical conditioning.\n \n14.2.3\u0026nbsp;\u0026nbsp;\u0026nbsp; An early version of the TD model of classical conditioning appeared in Sut\u0026shy;ton and Barto (1981), which also included the early model\\A1\\AFs prediction that temporal primacy overrides blocking, later shown by Kehoe, Scheurs, and Graham (1987) to occur in the rabbit nictitating membrane preparation. Sutton and Barto (1981) contains the earliest recognition of the near identity between the Rescorla-Wagner model and the Least-Mean-Square (LMS), or Widrow-Hoff, learning rule (Widrow and Hoff, 1960). This early model was revised following Sutton\\A1\\AFs development of the TD algorithm (Sutton, 1984, 1988) and was first presented as the TD model in Sutton and Barto (1987) and more completely in Sutton and Barto (1990), upon which this section is largely based. Additional exploration of the TD model and its possible neural implementation was conducted by Moore and colleagues (Moore, Desmond, Berthier, Blazis, Sutton, and Barto, 1986; Moore and Blazis, 1989; Moore, Choi, and Brunzell, 1998; Moore, Marks, Castagna, and Polewan, 2001). Klopf\\A1\\AFs (1988) drive-reinforcement theory of classical conditioning extends the TD model to address additional experimental details, such as the S- shape of acquisition curves. In some of these publications TD is taken to mean Time Derivative instead of Temporal Difference.\n14.2.4\u0026nbsp;\u0026nbsp;\u0026nbsp; Ludvig, Sutton, and Kehoe (2012) evaluated the performance of the TD model in previously unexplored tasks involving classical conditioning and examined the influence of various stimulus representations, including the mi\u0026shy;crostimulus representation that they introduced earlier (Ludvig, Sutton, and Kehoe, 2008). Earlier investigations of the influence of various stimulus repre\u0026shy;sentations and their possible neural implementations on response timing and topography in the context of the TD model are those of Moore and colleagues cited above. Although not in the context of the TD model, representations like the microstimulus representation of Ludvig et al. (2012) have been pro\u0026shy;posed and studied by Grossberg and Schmajuk (1989), Brown, Bullock, and Grossberg (1999), Buhusi and Schmajuk (1999), and Machado (1997).\n14.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Section 1.7 includes comments on the history of trial-and-error learning and the Law of Effect. The idea that Thorndikes cats might have been exploring according to an instinctual context-specific ordering over actions rather than by just selecting from a set of instinctual impulses was suggested by Peter Dayan (personal communication). Selfridge, Sutton, and Barto (1985) illus\u0026shy;trated the effectiveness of shaping in a pole-balancing reinforcement learning task. Other examples of shaping in reinforcement learning are Gullapalli and Barto (1992), Mahadevan and Connell (1992), Mataric (1994), Dorigo and Colombette (1994), Saksida, Raymond, and Touretzky (1997), and Randl0v and Alstr0m (1998). Ng (2003) and Ng, Harada, and Russell (1999) used the term shaping in a sense somewhat different from Skinner\\A1\\AFs, focussing on the problem of how to alter the reward signal without altering the set of optimal policies.\nDickinson and Balleine (2002) discuss the complexity of the interaction be-\ntween learning and motivation. Wise (2004) provides an overview of rein\u0026shy;forcement learning and its relation to motivation. Daw and Shohamy (2008) link motivation and learning to aspects of reinforcement learning theory. See also McClure, Daw, and Montague (2003), Niv, Joel, and Dayan (2006), Rangel et al. (2008), and Dayan and Berridge (2014). McClure et al. (2003), Niv, Daw, and Dayan (2005), and Niv, Daw, Joel, and Dayan (2007) present theories of behavioral vigor related to the reinforcement learning framework.\n14.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Spence, Hull\\A1\\AFs student and collaborator at Yale, elaborated the role of higher- order reinforcement in addressing the problem of delayed reinforcement (Spence, 1947). Learning over very long delays, as in taste-aversion conditioning with delays up to several hours, led to interference theories as alternatives to decaying-trace theories (e.g., Revusky and Garcia, 1970; Boakes and Costa, 2014). Other views of learning under delayed reinforcement invoke roles for awareness and working memory (e.g., Clark and Squire, 1998; Seo, Barra- clough, and Lee, 2007).\n14.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Thistlethwaite (1951) is an extensive review of latent learning experiments up to the time of its publication. Ljung (1998) is an overview of model learning, or system identification, techniques in engineering. Gopnik, Glymour, Sobel, Schulz, Kushnir, and Danks (2004) present a Bayesian theory about how children learn models.\n14.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Connections between habitual and goal-directed behavior and model-free and model-based reinforcement learning were first proposed by Daw, Niv, and Dayan (2005). The hypothetical maze task used to explain habitual and goal-directed behavioral control is based on the explanation of Niv, Joel, and Dayan (2006). Dolan and Dayan (2013) review four generations of experi\u0026shy;mental research related to this issue and discuss how it can move forward on the basis of reinforcement learning\\A1\\AFs model-free/model-based distinction. Dickinson (1980, 1985) and Dickinson and Balleine (2002) discuss exper\u0026shy;imental evidence related to this distinction. Donahoe and Burgos (2000) alternatively argue that model-free processes can account for the results of outcome-devaluation experiments. Dayan and Berridge (2014) argue that classical conditioning involves model-based processes. Rangel, Camerer, and Montague (2008) review many of the outstanding issues involving habitual, goal-directed, and Pavlovian modes of control.\nComments on Terminology\\A1\\AA The traditional meaning of reinforcementin psy\u0026shy;chology is the strengthening of a pattern of behavior (by increasing either its intensity or frequency) as a result of an animal receiving a stimulus (or experiencing the omis\u0026shy;sion of a stimulus) in an appropriate temporal relationship with another stimulus or with a response. Reinforcement produces changes that remain in future behavior. Sometimes in psychology reinforcement refers to the process of producing lasting changes in behavior, whether the changes strengthen or weaken a behavior pattern\n(Mackintosh, 1983). Letting reinforcement refer to weakening in addition to strength\u0026shy;ening is at odds with the everyday meaning of reinforce, and its traditional use in psychology, but it is a useful extension that we have adopted here. In either case, a stimulus considered to be the cause of the behavioral change is called a reinforcer.\nPsychologists do not generally use the specific phrase reinforcement learningas we do. Animal learning pioneers probably regarded reinforcement and learning as being synonymous, so it would be redundant to use both words. Our use of the phrase follows its use in computational and engineering research, influenced mostly by Minsky (1961). But the phrase is lately gaining currency in psychology and neuroscience, likely because strong parallels have surfaced between reinforcement learning algorithms and animal learning\\A1\\AAparallels described in this chapter and the next.\nAccording to common usage, a rewardis an object or event that an animal will approach and work for. A reward may be given to an animal in recognition of its \\A1\\AEgood\\A1\\AF behavior, or given in order to make the animal\\A1\\AFs behavior \\A1\\AEbetter.\\A1\\AF Similarly, a penaltyis an object or event that the animal usually avoids and that is given as a consequence of \\A1\\AEbad\\A1\\AF behavior, usually in order to change that behavior. Primary rewardis reward due to machinery built into an animal\\A1\\AFs nervous system by evolution to improve its chances of survival and reproduction, e.g., reward produced by the taste of nourishing food, sexual contact, successful escape, and many other stimuli and events that predicted reproductive success over the animal\\A1\\AFs ancestral history. As explained in Section 14.2.1, higher-order rewardis reward delivered by stimuli that predict primary reward, either directly or indirectly by predicting other stimuli that predict primary reward. Reward is secondaryif its rewarding quality is the result of directly predicting primary reward.\nI\u0026nbsp; this book we call Rthe \\A1\\AEreward signal at time Vor sometimes just the \\A1\\AEreward at time V,\\A1\\AF but we do not think of it as an object or event in the agent\\A1\\AFs environment. Because R is a number\\A1\\AAnot an object or an event\\A1\\AAit is more like a reward signal in neuroscience, which is a signal internal to the brain, like the activity of neurons, that influences decision making and learning. This signal might be triggered when the animal perceives an attractive (or an aversive) object, but it can also be triggered by things that do not physically exist in the animal\\A1\\AFs external environment, such as memories, ideas, or hallucinations. Because our Rcan be positive, negative, or zero, it might be better to call a negative R a penalty, and an R equal to zero a neutral signal, but for simplicity we generally avoid these terms.\nIn reinforcement learning, the process that generates all theR^s defines the problem the agent is trying to solve. The agent\\A1\\AFs objective is to keep the magnitude of R as large as possible over time. In this respect, R is like primary reward for an animal if we think of the problem the animal faces as the problem of obtaining as much primary reward as possible over its lifetime (and thereby, through the prospective \\A1\\B0wisdom\\A1\\B1 of evolution, improve its chances of solving its real problem, which is to pass its genes on to future generations. However, as we suggest in Chapter 15, it is unlikely that there is a single \\A1\\B0master\\A1\\B1 reward signal like Rin an animal\\A1\\AFs brain.)\nNot all reinforcers are rewards or penalties. Sometimes reinforcement is not the result of an animal receiving a stimulus that evaluates its behavior by labeling the behavior good or bad. A behavior pattern can be reinforced by a stimulus that arrives to an animal no matter how the animal behaved. As described in Section 14.1, whether the delivery of reinforcer depends, or does not depend, on preceding behavior is the defining difference between instrumental, or operant, conditioning experiments and classical, or Pavlovian, conditioning experiments. Reinforcement is at work in both types of experiments, but only in the former is it feedback that evaluates past behavior. (Though It has often been pointed out that even when the reinforcing US in a classical conditioning experiment is not contingent on the subject\\A1\\AFs preceding behavior, its reinforcing value can be influenced by this behavior, an example being that a closed eye makes an air puff to the eye less aversive.)\nThe distinction between reward signals and reinforcement signals is a crucial point when we discuss neural correlates of these signals in the next chapter. Like a reward signal, for us, the reinforcement signal at any specific time is a positive or negative number, or zero. A reinforcement signal is the major factor directing changes a learn\u0026shy;ing algorithm makes in an agent\\A1\\AFs policy, value estimates, or environment models. The definition that makes the most sense to us is that a reinforcement signal at any time is a number that multiplies (possibly along with some constants) a vector to determine parameter updates in some learning algorithm.\nFor some algorithms, the reward signal alone is the critical multiplier in the parameter-update equation. For these algorithms the reinforcement signal is the same as the reward signal. But for most of the algorithms we discuss in this book, reinforcement signals include terms in addition to the reward signal, an example being a TD error \u0026#12316;=Rt+i + 7V(St+i) \\A1\\AA V(St), which is the reinforcement signal for TD state-value learning (and analogous TD errors for action-value learning). In this reinforcement signal, Rt+i is the primary reinforcementcontribution, and the temporal difference in predicted values, 7V(St+i) \\A1\\AA V(St) (or an analogous temporal difference for action values), is the conditioned reinforcementcontribution. Thus, whenever 7V(St+i) \\A1\\AA V(St) = 0, \u0026amp; signals \\A1\\AEpure\\A1\\AF primary reinforcement; and when\u0026shy;ever Rt+i = 0, it signals \\A1\\AEpure\\A1\\AF conditioned reinforcement, but it often signals a mixture of these. Note as we mentioned in Section 6.1, this \u0026#12316;is not available until time t+ 1. We therefore think of \u0026#12316;as the reinforcement signal at time t+ 1, which is fitting because it reinforces predictions and/or actions made earlier at step t.\nA possible source of confusion is the terminology used by the famous psycholo\u0026shy;gist B.F. Skinner and his followers. For Skinner, positive reinforcement occurs when the consequences of an animal\\A1\\AFs behavior increase the frequency of that behavior; punishment occurs when the behavior\\A1\\AFs consequences decrease that behavior\\A1\\AFs fre\u0026shy;quency. Negative reinforcement occurs when behavior leads to the removal of an aversive stimulus (that is, a stimulus the animal does not like), thereby increasing the frequency of that behavior. Negative punishment, on the other hand, occurs when behavior leads to the removal of an appetitive stimulus (that is, a stimulus the animal likes), thereby decreasing the frequency of that behavior. We find no critical need for these distinctions because our approach is more abstract than this, with both reward and reinforcement signals allowed to take on both positive and negative \n \nvalues. (But note especially that when our reinforcement signal is negative, it is not the same as Skinner\\A1\\AFs negative reinforcement.)\nOn the other hand, it has often been pointed out that using a single number as a reward or a penalty signal, depending only on its sign, is at odds with the fact that animals\\A1\\AF appetitive and aversive systems have qualitatively different properties and involve different brain mechanisms. This points to a direction in which the reinforce\u0026shy;ment learning framework might be developed in the future to exploit computational advantages of separate appetitive and aversive systems, but for now we are passing over these possibilities.\nAnother discrepancy in terminology is how we use the word action. To many cognitive scientists, an action is purposeful in the sense of being the result of an animal\\A1\\AFs knowledge about the relationship between the behavior in question and the consequences of that behavior. An action is goal-directed and the result of a decision, in contrast to a response, which is triggered by a stimulus; the result of a reflex or a habit. We use the word action without differentiating among what others call actions, decisions, and responses. These are important distinctions, but for us they are encompassed by differences between model-free and model-based reinforcement learning algorithms, which we discussed above in relation to habitual and goal-directed behavior in Section 14.6. Dickinson (1985) discusses the distinction between responses and actions.\nA term used a lot in this book is control. What we mean by control is entirely different from what it means to animal learning psychologists. By control we mean that an agent influences its environment to bring about states or events that the agent prefers: the agent exerts control over its environment. This is the sense of control used by control engineers. In psychology, on the other hand, control typically means that an animal\\A1\\AFs behavior is influenced by\\A1\\AAis controlled by\\A1\\AAthe stimuli the animal receives (stimulus control) or the reinforcement schedule it experiences. Here the environment is controlling the agent. Control in this sense is the basis of behavior modification therapy. Of course, both of these directions of control are at play when an agent interacts with its environment, but our focus is on the agent as controller; not the environment as controller. A view equivalent to ours, and perhaps more illuminating, is that the agent is actually controlling the input it receives from its environment (Powers, 1973). This is notwhat psychologists mean by stimulus control.\nSometimes reinforcement learning is understood to refer solely to learning policies directly from rewards (and penalties) without the involvement of value functions or environment models. This is what psychologists call stimulus-response, or S\u0026shy;R, learning. But for us, along with most of today\\A1\\AFs psychologists, reinforcement learning is much broader than this, including in addition to S-R learning, methods involving value functions, environment models, planning, and other processes that are commonly thought to belong to the more cognitive side of mental functioning.\n392\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER\u0026nbsp; 14.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; PSYCHOLOGY\n \nChapter 15\nNeuroscience\nNeuroscience is the multidisciplinary study of nervous systems: how they regulate bodily functions; control behavior; change over time as a result of development, learning, and aging; and how cellular and molecular mechanisms make these functions possible. One of the most exciting aspects of reinforcement learning is the mounting evidence from neuroscience that the nervous systems of humans and many other animals implement algorithms that correspond in striking ways to reinforcement learning algorithms. The main objective of this chapter is to explain these parallels and what they suggest about the neural basis of reward-related learning in animals.\nThe most remarkable point of contact between reinforcement learning and neuro\u0026shy;science involves dopamine, a chemical deeply involved in reward processing in the brains of mammals. Dopamine appears to convey temporal-difference (TD) errors to brain structures where learning and decision making take place. This parallel is expressed by the reward prediction error hypothesis of dopamine neuron activity,a hy\u0026shy;pothesis that resulted from the convergence of computational reinforcement learning and results of neuroscience experiments. In this chapter we discuss this hypothesis, the neuroscience findings that led to it, and why it is a significant contribution to un\u0026shy;derstanding brain reward systems. We also discuss parallels between reinforcement learning and neuroscience that are less striking than this dopamine/TD-error parallel but that provide useful conceptual tools for thinking about reward-based learning in animals. Other elements of reinforcement learning have the potential to impact the study of nervous systems, but their connections to neuroscience are still relatively undeveloped. We discuss several of these evolving connections that we think will grow in importance over time.\nAs we outlined in the history section of this book\\A1\\AFs introductory chapter (Sec\u0026shy;tion 1.7), many aspects of reinforcement learning were influenced by neuroscience. A second objective of this chapter is to acquaint readers with ideas about brain function that have contributed to our approach to reinforcement learning. Some elements of reinforcement learning are easier to understand when seen in light of theories of brain function. This is particularly true for the idea of the eligibility trace, one of the ba\u0026shy;sic mechanisms of reinforcement learning, that originated as a conjectured property of synapses, the structures by which nerve cells\\A1\\AAneurons\\A1\\AAcommunicate with one another.\nIn this chapter we do not delve very deeply into the enormous complexity of the neural systems underlying reward-based learning in animals: this chapter too short, and we are not neuroscientists. We do not try to describe\\A1\\AAor even to name\\A1\\AAthe very many brain structures and pathways, or any of the molecular mechanisms, be\u0026shy;lieved to be involved in these processes. We also do not do justice to hypotheses and models that are alternatives to those that align so well with reinforcement learning. It should not be surprising that there are differing views among experts in the field. We can only provide a glimpse into this fascinating and developing story. We hope, though, that this chapter convinces you that a very fruitful channel has emerged con\u0026shy;necting reinforcement learning and its theoretical underpinnings to the neuroscience of reward-based learning in animals.\nMany excellent publications cover links between reinforcement learning and neu\u0026shy;roscience, some of which we cite in this chapter\\A1\\AFs final section. Our treatment differs from most of these because we assume familiarity with reinforcement learning as presented in the earlier chapters of this book, but we do not assume knowledge of neuroscience. We begin with a brief introduction to the neuroscience concepts needed for a basic understanding of what is to follow.\n15.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Neuroscience Basics\nSome basic information about nervous systems is helpful for following what we cover in this chapter. Terms that we refer to later are italicized. Skipping this section will not be a problem if you already have an elementary knowledge of neuroscience.\nNeurons,the main components of nervous systems, are cells specialized for pro\u0026shy;cessing and transmitting information using electrical and chemical signals. They come in many forms, but a neuron typically has a cell body, dendrites, and a single axon.Dendrites are structures that branch from the cell body to receive input from other neurons (or to also receive external signals in the case of sensory neurons). A neuron\\A1\\AFs axon is a fiber that carries the neuron\\A1\\AFs output to other neurons (or to muscles or glands). A neuron\\A1\\AFs output consists of sequences of electrical pulses called action potentialsthat travel along the axon. Action potentials are also called spikes, and a neuron is said to firewhen it generates a spike. In models of neural networks it is common to use real numbers to represent a neuron\\A1\\AFs firing rate, the average number of spikes per some unit of time.\nA neuron\\A1\\AFs axon can branch widely so that the neuron\\A1\\AFs action potentials reach many targets. The branching structure of a neuron\\A1\\AFs axon is called the neuron\\A1\\AFs axonal arbor. Because the conduction of an action potential is an active process, not unlike the burning of a fuse, when an action potential reaches an axonal branch point it \\A1\\B0lights up\\A1\\B1 action potentials on all of the outgoing branches (although propagation to a branch can sometimes fail). As a result, the activity of a neuron with a large axonal arbor can influence many target sites.\nA synapseis a structure generally at the termination of an axon branch that medi\u0026shy;ates the communication of one neuron to another. A synapse transmits information from the presynapticneuron\\A1\\AFs axon to a dendrite or cell body of the postsynaptic neuron. With a few exceptions, synapses release a chemical neurotransmitterupon the arrival of an action potential from the presynaptic neuron. (The exceptions are cases of direct electric coupling between neurons, but these will not concern us here.) Neurotransmitter molecules released from the presynaptic side of the synapse diffuse across the synaptic cleft, the very small space between the presynaptic ending and the postsynaptic neuron, and then bind to receptors on the surface of the postsy- naptic neuron to excite or inhibit its spike-generating activity, or to modulate its behavior in other ways. A particular neurotransmitter may bind to several different types of receptors, with each producing a different effect on the postsynaptic neuron. For example, there are at least five different receptor types by which the neurotrans\u0026shy;mitter dopamine can affect a postsynaptic neuron. Many different chemicals have been identified as neurotransmitters in animal nervous systems.\nA neuron\\A1\\AFs backgroundactivity is its level of activity, usually its firing rate, when the neuron does not appear to be driven by synaptic input related to the task of in\u0026shy;terest to the experimenter, for example, when the neuron\\A1\\AFs activity is not correlated with a stimulus delivered to a subject as part of an experiment. Background activity can be irregular due to input from the wider network, or due to noise within the neu\u0026shy;ron or its synapses. Sometimes background activity is the result of dynamic processes intrinsic to the neuron. A neuron\\A1\\AFs phasicactivity, in contrast to its background ac\u0026shy;tivity, consists of bursts of spiking activity usually caused by synaptic input. Activity that varies slowly and often in a graded manner, whether as background activity or not, is called a neuron\\A1\\AFs tonicactivity.\nThe strength or effectiveness by which the neurotransmitter released at a synapse influences the postsynaptic neuron is the synapse\\A1\\AFs efficacy.One way a nervous system can change through experience is through changes in synaptic efficacies as a result of combinations of the activities of the presynaptic and postsynaptic neurons, and sometimes by the presence of a neuromodulator, which is a neurotransmitter having effects other than, or in addition to, direct fast excitation or inhibition.\nBrains contain several different neuromodulation systems consisting of clusters of neurons with widely branching axonal arbors, with each system using a different neu\u0026shy;rotransmitter. Neuromodulation can alter the function of neural circuits, mediate motivation, arousal, attention, memory, mood, emotion, sleep, and body tempera\u0026shy;ture. Important here is that a neuromodulatory system can distribute something like a scalar signal, such as a reinforcement signal, to alter the operation of synapses in widely distributed sites critical for learning.\nThe ability of synaptic efficacies to change is called synaptic plasticity. It is one of the primary mechanisms responsible for learning. The parameters, or weights, adjusted by learning algorithms correspond to synaptic efficacies. As we detail below, modulation of synaptic plasticity via the neuromodulator dopamine is a plausible mechanism for how the brain might implement learning algorithms like many of those described in this book.\n15.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Reward Signals, Reinforcement Signals, Values, and Prediction Errors\nLinks between neuroscience and computational reinforcement learning begin as paral\u0026shy;lels between signals in the brain and signals playing prominent roles in reinforcement learning theory and algorithms. In Chapter 3 we said that any problem of learn\u0026shy;ing goal-directed behavior can be reduced to the three signals representing actions, states, and rewards. However, to explain links that have been made between neuro\u0026shy;science and reinforcement learning, we have to be less abstract than this and consider other reinforcement learning signals that correspond, in certain ways, to signals in the brain. In addition to reward signals, these include reinforcement signals (which we argue are different from reward signals), value signals, and signals conveying pre\u0026shy;diction errors. When we label a signal by its function in this way, we are doing it in the context of reinforcement learning theory in which the signal corresponds to a term in an equation or an algorithm. On the other hand, when we refer to a signal in the brain, we mean a physiological event such as a burst of action potentials or the secretion of a neurotransmitter. Labeling a neural signal by its function, for example calling the phasic activity of a dopamine neuron a reinforcement signal, means that the neural signal behaves like, and is conjectured to function like, the corresponding theoretical signal.\nUncovering evidence for these correspondences involves many challenges. Neu\u0026shy;ral activity related to reward processing can be found in nearly every part of the brain, and it is difficult to interpret results unambiguously because representations of different reward-related signals tend to be highly correlated with one another. Experiments need to be carefully designed to allow one type of reward-related signal to be distinguished with any degree of certainty from others\\A1\\AAor from an abundance of other signals not related to reward processing. Despite these difficulties, many experiments have been conducted with the aim of reconciling aspects of reinforce\u0026shy;ment learning theory and algorithms with neural signals, and some compelling links have been established. To prepare for examining these links, in the rest of this sec\u0026shy;tion we remind the reader of what various reward-related signals mean according to reinforcement learning theory.\nIn our Comments on Terminology at the end of the previous chapter, we said that Rt is like a reward signal in an animal\\A1\\AFs brain and not as an object or event in the animal\\A1\\AFs environment. In reinforcement learning, the reward signal (along with an agent\\A1\\AFs environment) defines the problem a reinforcement learning agent is trying to solve. It this respect, Rt is like a signal in an animal\\A1\\AFs brain that distributes primary reward to sites throughout the brain. But it is unlikely that a unitary master reward signal like Rt exists in an animal\\A1\\AFs brain. It is best to think of Rt as an abstraction summarizing the overall effect of a multitude of neural signals generated by many systems in the brain that assess the rewarding or punishing qualities of sensations and states.\nReinforcement signalsin reinforcement learning are different from reward signals. The function of a reinforcement signal is to direct the changes a learning algo-\n \nrithm makes in an agent\\A1\\AFs policy, value estimates, or environment models. For a TD method, for instance, the reinforcement signal at time V is the TD error \u0026#12316;_i = Rt + 7V(St) \\A1\\AA V(St-i).[29] The reinforcement signal for some algorithms could be just the reward signal, but for most of the algorithms we consider the reinforce\u0026shy;ment signal is the reward signal adjusted by other information, such as the value estimates in TD errors.\nEstimates of state values or of action values, that is, V or Q, specify what is good or bad for the agent over the long run. They are predictions of the total reward an agent can expect to accumulate over the future. Agents make good decisions by selecting actions leading to states with the largest estimated state values, or by selecting actions with the largest estimated action values.\nPrediction errors measure discrepancies between expected and actual signals or sensations. Reward prediction errors (RPEs) specifically measure discrepancies be\u0026shy;tween the expected and the received reward signal, being positive when the reward signal is greater than expected, and negative otherwise. TD errors like (6.5) are spe\u0026shy;cial kinds RPEs that signal discrepancies between current and earlier expectations of reward over the long-term. When neuroscientists refer to RPEs they generally (though not always) mean TD RPEs, which we simply call TD errors throughout this chapter. Also in this chapter, a TD error is generally one that does not depend on actions, as opposed to TD errors used in learning action-values by algorithms like Sarsa and Q-learning. This is because the most well-known links to neuroscience are stated in terms of action-free TD errors, but we do not mean to rule out possible similar links involving action-dependent TD errors. (TD errors for predicting signals other than rewards are useful too, but that case will not concern us here. See, for example, Modayil, White, and Sutton, 2014.)\nOne can ask many questions about links between neuroscience data and these theoretically-defined signals. Is an observed signal more like a reward signal, a value signal, a prediction error, a reinforcement signal, or something altogether different? And if it is an error signal, is it an RPE, a TD error, or a simpler error like the Rescorla-Wagner error (14.3)? And if it is a TD error, does it depend on actions like the TD error of Q-learning or Sarsa? As indicated above, probing the brain to answer questions like these is extremely difficult. But experimental evidence suggests that one neurotransmitter, specifically the neurotransmitter dopamine, signals RPEs, and further, that the phasic activity of dopamine-producing neurons in fact conveys TD errors (see Section 15.1 for a definition of phasic activity). This evidence led to the reward prediction error hypothesis of dopamine neuron activity, which we describe next.\n \n15.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Reward Prediction Error Hypothesis\nThe reward prediction error hypothesis of dopamine neuron activityproposes that one of the functions of the phasic activity of dopamine-producing neurons in mammals is to deliver an error between an old and a new estimate of expected future reward to target areas throughout the brain. This hypothesis (though not in these exact words) was first explicitly stated by Montague, Dayan, and Sejnowski (1996), who showed how the TD error concept from reinforcement learning accounts for many features of the phasic activity of dopamine neurons in mammals. The experiments that led to this hypothesis were performed in the 1980s and early 1990s in the laboratory of neuroscientist Wolfram Schultz. Section 15.5 describes these influential experiments, Section 15.6 explains how the results of these experiments align with TD errors, and the Bibliographical and Historical Remarks section at the end of this chapter includes a guide to the literature surrounding the development of this influential hypothesis.\nMontague et al. (1996) compared the TD errors of the TD model of classical con\u0026shy;ditioning with the phasic activity of dopamine-producing neurons during classical conditioning experiments. Recall from Section 14.2 that the TD model of classi\u0026shy;cal conditioning is basically the semi-gradient-descent TD(A) algorithm with linear function approximation. Montague et al. made several assumptions to set up this comparison. First, since a TD error can be negative but neurons cannot have a neg\u0026shy;ative firing rate, they assumed that the quantity corresponding to dopamine neuron activity is \u0026amp;_i + bt, where bt is the background firing rate of the neuron. A neg\u0026shy;ative TD error corresponds to a drop in a dopamine neuron\\A1\\AFs firing rate below its background rate.[30]\nA second assumption was needed about the states visited in each classical condi\u0026shy;tioning trial and how they are represented as inputs to the learning algorithm. This is the same issue we discussed in Section 14.2.4 for the TD model. Montague et al. chose a complete serial compound (CSC)representation as shown in the left column of Figure 14.2, but where the sequence of short-duration internal signals continues until the onset of the US, which here is the arrival of a non-zero reward signal. This representation allows the TD error to mimic the fact that dopamine neuron activ\u0026shy;ity not only predicts a future reward, but that it is also sensitive to whenafter a predictive cue that reward is expected to arrive. There has to be some way to keep track of the time between sensory cues and the arrival of reward. If a stimulus ini\u0026shy;tiates a sequence of internal signals that continues after the stimulus ends, and if there is a different signal for each time step following the stimulus, then each time step after the stimulus is represented by a distinct state. Thus, the TD error, being state-dependent, can be sensitive to the timing of events within a trial.\nIn simulated trials with these assumptions about background firing rate and input representation, TD errors of the TD model are remarkably similar to dopamine neu\u0026shy;ron phasic activity. Previewing our description of details about these similarities in Section 15.5 below, the TD errors parallel the following features of dopamine neuron activity: 1) the phasic response of a dopamine neuron only occurs when a rewarding event is unpredicted; 2) early in learning, neutral cues that precede a reward do not cause substantial phasic dopamine responses, but with continued learning these cues gain predictive value and come to elicit phasic dopamine responses; 3) if an even ear\u0026shy;lier cue reliably precedes a cue that has already acquired predictive value, the phasic dopamine response shifts to the earlier cue, ceasing for the later cue; and 3) if after learning, the predicted rewarding event is omitted, a dopamine neuron\\A1\\AFs response decreases below its baseline level shortly after the expected time of the rewarding event.\nAlthough not every dopamine neuron monitored in the experiments of Schultz and colleagues behaved in all of these ways, the striking correspondence between the activities of most of the monitored neurons and TD errors lends strong support to the reward prediction error hypothesis. There are situations, however, in which predictions based on the hypothesis do not match what is observed in experiments. The choice of input representation is critical to how closely TD errors match some of the details of dopamine neuron activity, particularly details about the timing of dopamine neuron responses. Different ideas, some of which we discuss below, have been proposed about input representations and other features of TD learning to make the TD errors fit the data better, though the main parallels appear with the CSC representation that Montague et al. used. Overall, the reward prediction error hy\u0026shy;pothesis has received wide acceptance among neuroscientists studying reward-based learning, and it has proven to be remarkably resilient in the face of accumulating results from neuroscience experiments.\nTo prepare for our description of the neuroscience experiments supporting the re\u0026shy;ward prediction error hypothesis, and to provide some context so that the significance of the hypothesis can be appreciated, we next present some of what is known about dopamine, the brain structures it influences, and how it is involved in reward-based learning.\n15.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Dopamine\nDopamine is produced as a neurotransmitter by neurons whose cell bodies lie mainly in two clusters of neurons in the midbrain of mammals: the substantia nigra pars compacta (SNpc) and the ventral tegmental area (VTA). Dopamine plays essen\u0026shy;tial roles in many processes in the mammalian brain. Prominent among these are motivation, learning, action-selection, most forms of addiction, and the disorders schizophrenia and Parkinson\\A1\\AFs disease. Dopamine is called a neuromodulator be\u0026shy;cause it performs many functions other than direct fast excitation or inhibition of targeted neurons. Although much remains unknown about dopamine\\A1\\AFs functions and details of its cellular effects, it is clear that it is fundamental to reward processing in the mammalian brain. Dopamine is not the only neuromodulator involved in reward processing, and its role in aversive situations\\A1\\AApunishment\\A1\\AAremains controversial. Dopamine also can function differently in non-mammals. But no one doubts that dopamine is essential for reward-related processes in mammals, including humans.\nAn early, traditional view is that dopamine neurons broadcast a reward signal to multiple brain regions implicated in learning and motivation. This view followed from a famous 1954 paper by James Olds and Peter Milner that described the effects of electrical stimulation on certain areas of a rat\\A1\\AFs brain. They found that electrical stimulation to particular regions acted as a very powerful reward in controlling the rat\\A1\\AFs behavior: \\A1\\B0... the control exercised over the animal\\A1\\AFs behavior by means of this reward is extreme, possibly exceeding that exercised by any other reward previously used in animal experimentation\\A1\\B1 (Olds and Milner, 1954). Later research revealed that the sites at which stimulation was most effective in producing this rewarding effect excited dopamine pathways, either directly or indirectly, that ordinarily are excited by natural rewarding stimuli. Effects similar to these with rats were also observed with human subjects. These observations strongly suggested that dopamine neuron activity signals reward.\nBut if the reward prediction error hypothesis is correct\\A1\\AAeven if it accounts for only some features of a dopamine neuron\\A1\\AFs activity\\A1\\AAthis traditional view of dopamine neuron activity is not entirely correct: phasic responses of dopamine neurons signal reward prediction errors, not reward itself. In reinforcement learning\\A1\\AFs terms, a dopamine neuron\\A1\\AFs phasic response at a time tcorresponds to \u0026amp;_i = Rt + 7V(St)\\A1\\AA\nV\u0026nbsp; (St_i), not to Rt.\nReinforcement learning theory and algorithms help reconcile the reward-prediction- error view with the conventional notion that dopamine signals reward. In many of the algorithms we discuss in this book, 5functions as a reinforcement signal, mean\u0026shy;ing that it is the main driver of learning. For example, 5 is the critical factor in the TD model of classical conditioning, and 5 is the reinforcement signal for learn\u0026shy;ing both a value function and a policy in an actor-critic architecture (Sections 13.5 and 15.7). Action-dependent forms of 5 are reinforcement signals for Q-learning and Sarsa. The reward signal Rt is a crucial component of 5t_i, but it is not the com\u0026shy;plete determinant of its reinforcing effect in these algorithms. The additional term 7V(St) \\A1\\AA V(St_i) is the higher-order reinforcement part of 5t_i, and even if reward occurs (Rt = 0), the TD error can be silent if the reward is fully predicted (which is fully explained in Section 15.6 below).\nA closer look at Olds\\A1\\AF and Milner\\A1\\AFs 1954 paper, in fact, reveals that it is mainly about the reinforcing effect of electrical stimulation in an instrumental condition\u0026shy;ing task. Electrical stimulation not only energized the rats\\A1\\AF behavior\\A1\\AAthrough dopamine\\A1\\AFs effect on motivation\\A1\\AAit also led to the rats quickly learning to stimulate themselves by pressing a lever, which they would do frequently for long periods of time. The activity of dopamine neurons triggered by electrical stimulation reinforced the rats\\A1\\AF lever pressing.\nMore recent experiments using optogenetic methods clinch the role of phasic re\u0026shy;sponses of dopamine neurons as reinforcement signals. These methods allow neuro\u0026shy;scientists to precisely control the activity of selected neuron types at a millisecond timescale in awake behaving animals. Optogenetic methods introduce light-sensitive proteins into selected neuron types so that these neurons can be activated or silenced by means of flashes of laser light. The first experiment using optogenetic methods to study dopamine neurons showed that optogenetic stimulation producing phasic acti\u0026shy;vation of dopamine neurons in mice was enough to condition the mice to prefer the side of a chamber where they received this stimulation as compared to the chamber\\A1\\AFs other side where they received no, or lower-frequency, stimulation (Tsai et al. 2009). In another example, Steinberg et al. (2013) used optogenetic activation of dopamine neurons to create artificial bursts of dopamine neuron activity in rats at the times when rewarding stimuli were expected but omitted\\A1\\AAtimes when dopamine neuron activity normally pauses. With these pauses replaced by artificial bursts, responding was sustained when it would ordinarily decrease due to lack of reinforcement (in extinction trials), and learning was enabled when it would ordinarily be blocked due to the reward being already predicted (the blocking paradigm; Section 14.2.1).\nAdditional evidence for the reinforcing function of dopamine comes from optoge- netic experiments with fruit flies, except in these animals dopamine\\A1\\AFs effect is the opposite of its effect in mammals: optically triggered bursts of dopamine neuron ac\u0026shy;tivity act just like electric foot shock in reinforcing avoidance behavior, at least for the population of dopamine neurons activated (Claridge-Chang et al. 2009). Although none of these optogenetic experiments showed that phasic dopamine neuron activity is specifically like a TD error, they convincingly demonstrated that phasic dopamine neuron activity acts just like 5acts (or perhaps like minus 5acts in fruit flies) as the reinforcement signal in algorithms for both prediction (classical conditioning) and control (instrumental conditioning).\nDopamine neurons are particularly well suited to broadcasting a reinforcement signal to many areas of the brain. These neurons have huge axonal arbors, each releasing dopamine at 100to 1,000times more synaptic sites than reached by the axons of typical neurons. Figure 15.1 shows the axonal arbor of a single dopamine neuron whose cell body is in the SNpc of a rat\\A1\\AFs brain. Each axon of a SNpc or VTA dopamine neuron makes roughly 500,000 synaptic contacts on the dendrites of neurons in targeted brain areas.\nIf dopamine neurons broadcast a reinforcement signal like reinforcement learning\\A1\\AFs 5, then since this is a scalar signal, i.e., a single number, all dopamine neurons in both the SNpc and VTA would be expected to activate more-or-less identically so that they would act in near synchrony to send the same signal to all of the sites their axons target. Although it has been a common belief that dopamine neurons do act together like this, modern evidence is pointing to the more complicated picture that different subpopulations of dopamine neurons respond to input differently depending on the structures to which they send their signals and the different ways these signals act on their target structures. Dopamine has functions other than signaling RPEs, and even for dopamine neurons that do signal RPEs, it can make sense to send different RPEs to different structures depending on the roles these structures play in producing reinforced behavior. This is beyond what we treat in any detail in this book, but vector-valued RPE signals make sense from the perspective of reinforcement learning when decisions can be decomposed into separate sub-decisions, or more generally, as a way to address the structuralversion of the credit assignment problem: How do you distribute credit for success (or blame for failure) of a decision among the many component structures that could have been involved in producing it? We say a bit more about this in Section 15.10 below.\nThe axons of most dopamine neurons make synaptic contact with neurons in the frontal cortex and the basal ganglia, areas of the brain involved in voluntary move\u0026shy;ment, decision-making, learning, and cognitive functions such a planning. Since most ideas relating dopamine to reinforcement learning focus on the basal ganglia, and the connections from dopamine neurons are particularly dense there, we focus on the basal ganglia here. The basal ganglia are a collection neuron groups, or nuclei, lying at the base of the forebrain. The main input structure of the basal ganglia is called the striatum. Essentially all of the cerebral cortex, among other structures, provides input to the striatum. The activity of cortical neurons conveys a wealth of informa\u0026shy;tion about sensory input, internal states, and motor activity. The axons of cortical neurons make synaptic contacts on the dendrites of the main input/output neurons of the striatum, called medium spiny neurons. Output from the striatum loops back via other basal ganglia nuclei and the thalamus to frontal areas of cortex, and to motor areas, making it possible for the striatum to influence movement, abstract decision processes, and reward processing. Two main subdivisions of the striatum are important for reinforcement learning: the dorsal striatum, primarily implicated\n \nFigure 15.1: Axonal arbor of a single neuron producing dopamine as a neurotransmitter whose cell body is in the SNpc of a rat\\A1\\AFs brain. These axons make synaptic contacts with a huge number of dendrites of neurons in targeted brain areas. Adapted from Journal of Neuroscience,Matsuda, Furuta, Nakamura, Hioki, Fujiyama, Arai, and Kaneko, volume 29, 2009, page 451.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n \nFigure 15.2: Spine of a striatal neuron showing input from both cortical and dopamine neurons. Axons of cortical neurons influence striatal neurons via corticostriatal synapses releasing the neurotransmitter glutamate at the tips of spines covering the dendrites of striatal neurons. An axon of a VTA or SNpc dopamine neuron is shown passing by the spine (from the lower right). \\A1\\B0Dopamine varicosities\\A1\\B1 on this axon release dopamine at or near the spine stem, in an arrangement that brings together presynaptic input from cortex, postsynaptic activity of the striatal neuron, and dopamine, making it possible that several types of learning rules govern the plasticity of corticostriatal synapses. Each axon of a dopamine neuron makes synaptic contact with the stems of roughly 500,000 spines. Some of the complexity omitted from our discussion is shown here by other neurotransmitter pathways and multiple receptor types, such as D1 an D2 dopamine receptors by which dopamine can produce different effects at spines and other postsynaptic sites. From Journal of Neurophysiology,W. Schultz, vol. 80, 1998, page 10.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nin influencing action selection, and the ventral striatum, thought to be critical for different aspects of reward processing, including the assignment of affective value to sensations.\nThe dendrites of medium spiny neurons are covered with spines on whose tips the axons of neurons in the cortex make synaptic contact. Also making synaptic contact with these spines\\A1\\AAin this case contacting the spine stems\\A1\\AAare axons of dopamine neurons (Figure 15.2). This arrangement brings together presynaptic ac\u0026shy;tivity of cortical neurons, postsynaptic activity of medium spiny neurons, and input from dopamine neurons. What actually occurs at these spines is complex and not completely understood. Figure 15.2 hints at the complexity by showing two types of receptors for dopamine, receptors for glutamate\\A1\\AAthe neurotransmitter of the cor\u0026shy;tical inputs\\A1\\AAand multiple ways that the various signals can interact. But evidence is mounting that changes in the efficacies of the synapses on the pathway from the cortex to the striatum, which neuroscientists call corticostriatal synapses,depend critically on appropriately-timed dopamine signals.\n15.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Experimental Support for the Reward Prediction Error Hypothesis\nDopamine neurons respond with bursts of activity to intense, novel, or unexpected visual and auditory stimuli that trigger eye and body movements, but very little of their activity is related to the movements themselves. This is surprising because degeneration of dopamine neurons is a cause of Parkinson\\A1\\AFs disease, whose symptoms include motor disorders, particularly deficits in self-initiated movement. Motivated by the weak relationship between dopamine neuron activity and stimulus-triggered eye and body movements, Romo and Schultz (1990) and Schultz and Romo (1990) took the first steps toward the reward prediction error hypothesis by recording the activity of dopamine neurons and muscle activity while monkeys moved their arms.\nThey trained two monkeys to reach from a resting hand position into a bin con\u0026shy;taining a bit of apple, a piece of cookie, or a raisin, when the monkey saw and heard the bin\\A1\\AFs door open. The monkey could then grab and bring the food to its mouth. After a monkey became good at this, it was trained on two additional tasks. The purpose of the first task was to see what dopamine neurons do when movements are self-initiated. The bin was left open but covered from above so that the monkey could not see inside but could reach in from below. No triggering stimuli were pre\u0026shy;sented, and after the monkey reached for and ate the food morsel, the experimenter usually (though not always), silently and unseen by the monkey, replaced food in the bin by sticking it onto a rigid wire. Here too, the activity of the dopamine neurons Romo and Schultz monitored was not related to the monkey\\A1\\AFs movements, but a large percentage of these neurons produced phasic responses whenever the monkey first touched a food morsel. These neurons did not respond when the monkey touched just the wire or explored the bin when no food was there. This was good evidence that the neurons were responding to the food and not to other aspects of the task.\nThe purpose of Romo and Schultz\\A1\\AFs second task was to see what happens when movements are triggered by stimuli. This task used a different bin with a moveable cover. The sight and sound of the bin opening triggered reaching movements to the bin. In this case, Romo and Schultz found that after some period of training, the dopamine neurons no longer responded to the touch of the food but instead responded to the sight and sound of the opening cover of the food bin. The phasic responses of these neurons had shifted from the reward itself to stimuli predicting the availability of the reward. In a followup study, Romo and Schultz found that most of the dopamine neurons whose activity they monitored did not respond to the sight and sound of the bin opening outside the context of the behavioral task. These observations suggested that the dopamine neurons were responding neither to the initiation of a movement nor to the sensory properties of the stimuli, but were rather signaling an expectation of reward.\nSchultz\\A1\\AFs group conducted many additional studies involving both SNpc and VTA dopamine neurons. A particular series of experiments was influential in suggesting that the phasic responses of dopamine neurons correspond to TD errors and not to simpler errors like those in the Rescorla-Wagner model (14.3). In the first of \n\n\nthese experiments (Ljungberg, Apicella, and Schultz, 1992), monkeys were trained to depress a lever after a light was illuminated as a \\A1\\AEtrigger cue\\A1\\AF to obtain a drop of apple juice. As Romo and Schultz had observed earlier, many dopamine neurons initially responded to the reward\\A1\\AAthe drop of juice (Figure 15.3, top panel). But many of these neurons lost that reward response as training continued and devel\u0026shy;oped responses instead to the illumination of the light that predicted the reward (Figure 15.3, middle panel). With continued training, lever pressing became faster while the number of dopamine neurons responding to the trigger cue decreased.\n \nFigure 15.3: The response of dopamine neurons shifts from initial responses to primary reward to earlier predictive stimuli. These are plots of the number of action potentials produced by monitored dopamine neurons within small time intervals, averaged over all the monitored dopamine neurons (ranging from 23 to 44 neurons for these data). Top: dopamine neurons are activated by the unpredicted delivery of drop of apple juice. Middle: with learning, dopamine neurons developed responses to the reward-predicting trigger cue and lost responsiveness to the delivery of reward. Bottom: with the addition of an instruction cue preceding the trigger cue by 1second, dopamine neurons shifted their responses from the trigger cue to the earlier instruction cue. From Schultz et al. (1995), MIT Press.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nFollowing this study, the same monkeys were trained on a new task (Schultz, Apicella, and Ljungberg, 1993). Here the monkeys faced two levers, each with a light above it. Illuminating one of these lights was an \\A1\\AEinstruction cue\\A1\\AF indicating which of the two levers would produce a drop of apple juice. In this task, the instruction cue preceded the trigger cue of the previous task by a fixed interval of\n1\u0026nbsp; second. The monkeys learned to withhold reaching until seeing the trigger cue, and dopamine neuron activity increased, but now the responses of the monitored dopamine neurons occurred almost exclusively to the earlier instruction cue and not to the trigger cue (Figure 15.3, bottom panel). Here again the number of dopamine neurons responding to the instruction cue was much reduced when the task was well learned. During learning across these tasks, dopamine neuron activity shifted from \n\n\ninitially responding to the reward to responding to the earlier predictive stimuli, first progressing to the trigger stimulus then to the still earlier instruction cue. As responding moved earlier in time it disappeared from the later stimuli. This shifting of responses to earlier reward predictors, while losing responses to later predictors is a hallmark of TD learning (see, for example, Figure 14.5).\nThe task just described revealed another property of dopamine neuron activity shared with TD learning. The monkeys sometimes pressed the wrong key, that is, the key other than the instructed one, and consequently received no reward. In these trials, many of the dopamine neurons showed a sharp decrease in their firing rates below baseline shortly after the reward\\A1\\AFs usual time of delivery, and this happened without the availability of any external cue to mark the usual time of reward delivery (Figure 15.4). Somehow the monkeys were internally keeping track of the timing of the reward. (Response timing is one area where the simplest version of TD learning needs to be modified to account for some of the details of the timing of dopamine neuron responses. We consider this issue in the following section.)\nThe observations from the studies described above led Schultz and his group to conclude that dopamine neurons respond to unpredicted rewards, to the earliest predictors of reward, and that dopamine neuron activity decreases below baseline if a reward, or a predictor of reward, does not occur at its expected time. Researchers familiar with reinforcement learning were quick to recognize that these results are strikingly similar to how the TD error behaves as the reinforcement signal in a TD algorithm. The next section explores this similarity by working through a specific example in detail.\n15.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD Error/Dopamine Correspondence\nThis section explains the correspondence between the TD error 5and the phasic responses of dopamine neurons observed in the experiments just described. We examine how 5 changes over the course of learning in a task something like the one described above where a monkey first sees an instruction cue and then a fixed time later has to respond correctly to a trigger cue in order to obtain reward. We use a simple idealized version of this task, but we go into a lot more detail than is usual because we want to emphasize the theoretical basis of the parallel between TD errors and dopamine neuron activity.\n   Figure 15.4: The response of dopamine neurons drops below baseline time when an expected reward fails to occur. Top: dopamine neurons the unpredicted delivery of a drop of apple juice. Middle: dopamine neurons respond to a conditioned stimulus (CS) that predicts reward and do not respond to the reward itself. Bottom: when the reward predicted by the CS fails to occur, the activity of dopamine neurons drops below baseline shortly after the time the reward is expected to occur. At the top of each of these panels is shown the average number of action potentials produced by monitored dopamine neurons within small time intervals around the indicated times. The raster plots below show the activity patterns of the individual dopamine neurons that were monitored; each dot represents an action potential. From Schultz, Dayan, and Montague, A Neural Substrate of Prediction and Reward, Science,vol. 275, issue 5306, pages 1593-1598, March 14, 1997. Reprinted with permission from AAAS.\n        shortly after the are activated by\n     The first simplifying assumption is that the agent has already learned the actions required to obtain reward. Then its task is just to learn accurate predictions of future reward for the sequence of states it experiences. This is then a prediction task, or more technically, a policy-evaluation task: learning the value function for a fixed policy (Sections 4.1 and 6.1). The value function to be learned assigns to each state a value that predicts the return that will follow that state if the agent selects actions according to the given policy, where the return is the (possibly discounted) sum of all the future rewards. This is unrealistic as a model of the monkey\\A1\\AFs situation because the monkey would likely learn these predictions at the same time that it is learning toact correctly (as would a reinforcement learning algorithm that learns policies as well as value functions, such as an actor-critic algorithm), but this scenario is simpler to describe than one in which a policy and a value function are learned simultaneously.\nNow imagine that the agent\\A1\\AFs experience divides into multiple trials, in each of which the same sequence of states repeats, with a distinct state occurring on each time step during the trial. Further imagine that the return being predicted is limited to the return over a trial, which makes a trial analogous to a reinforcement learning episode as we have defined it. In reality, of course, the returns being predicted are not confined to single trials, and the time interval between trials is an important factor in determining what an animal learns. This is true for TD learning as well, but here we assume that returns do not accumulate over multiple trials. Given this, then, a trial in experiments like those conducted by Schultz and colleagues is equivalent to an episode of reinforcement learning. (Though in this discussion, we will use the term trial instead of episode to relate better to the experiments.)\nAs usual, we also need to make an assumption about how states are represented as inputs to the learning algorithm, an assumption that influences how closely the TD error corresponds to dopamine neuron activity. We discuss this issue later, but for now we assume the same CSC representation used by Montague et al. (1996) in which there is a separate internal stimulus for each state visited at each time step in a trial. This reduces the process to the tabular case covered in the first part of this book. Finally, we assume that the agent uses TD(0) to learn a value function, V, stored in a lookup table initialized to be zero for all the states. We also assume that this is a deterministic task and that the discount factor, 7, is very nearly one so that we can ignore it.\nFigure 15.5 shows the time courses of R, V, and 5 at several stages of learning in this policy-evaluation task. The time axes represent the time interval over which a sequence of states is visited in a trial (where for clarity we omit showing individual states). The reward signal is zero throughout each trial except when the agent reaches the rewarding state, shown near the right end of the time line, when the reward signal becomes some positive number, say R*. The goal of TD learning is to predict the return for each state visited in a trial, which in this undiscounted case and given our assumption that predictions are confined to individual trials, is simply R* for each state.\nPreceding the rewarding state is a sequence of reward-predicting states, with the earliest reward-predicting stateshown near the left end of the time line. This is like the state near the start of a trial, for example like the state marked by the instruction cue in a trial of the monkey experiment of Schultz et al. (1993) described above. It is the first state in a trial that reliably predicts that trial\\A1\\AFs reward. (Of course, in reality states visited on preceding trials are even earlier reward-predicting states, but since we are confining predictions to individual trials, these do not qualify as predictors of thistrial\\A1\\AFs reward. Below we give a more satisfactory, though more abstract, description of an earliest reward-predicting state.) The latest reward-predicting state in a trial is the state immediately preceding the trial\\A1\\AFs rewarding state. This is the state near the far right end of the time line in Figure 15.5. Note that the rewarding state of a trial does not predict the return for that trial: the value of this state would come to predict the return over all the followingtrials, which here we are assuming to be zero in this episodic formulation.\nFigure 15.5 shows the first-trial time courses of V and 5 as the graphs labeled \\A1\\AEearly in learning.\\A1\\AF Because the reward signal is zero throughout the trial except when the rewarding state is reached, and all the V-values are zero, the TD error is also zero until it becomes R* at the rewarding state. This follows because 5t-i =\nR\n\u0026lt; regular predictors of Rover this interval -\nearly in V learning\nlearning\ncomplete\nRomitted S\nFigure 15.5: The behavior of the TD error 5 during TD learning is consistent with features of the phasic activation of dopamine neurons. (Here 5 is the TD error available at time t, i.e., 5t\\A1\\AA1). Top: a sequence of states, shown as an interval of regular predictors, is followed by a non-zero reward R*. Early in learning: the initial value function, V, and initial 5, which at first is equal to R*. Learning complete: the value function accurately predicts future reward, 5 is positive at the earliest predictive state, and 5 = 0 at the time of the non-zero reward. R* omitted: at the time the predicted reward is omitted, 5 becomes negative. See text for a complete explanation of why this happens.\nRt + Vt \\A1\\AA Vt_i = Rt + 0 \\A1\\AA 0 = Rt, which is zero until it equals R* when the reward occurs. Here Vt and Vt_i are respectively the estimated values of the states visited at times t and t \\A1\\AA 1 in a trial. The TD error at this stage of learning is analogous to a dopamine neuron responding to an unpredicted reward, e.g., a drop apple juice, at the start of training.\nThroughout this first trial and all successive trials, TD(0) backups occur at each state transition as described in Chapter 6. This successively increases the values of the reward-predicting states, with the increases spreading backwards from the rewarding state, until the values converge to the correct return predictions. In this case (since we are assuming no discounting) the correct predictions are equal to R* for all the reward-predicting states. This can be seen in Figure 15.5 as the graph of\nV\u0026nbsp;\u0026nbsp; labeled \\A1\\AElearning complete\\A1\\AF where the values of all the states from the earliest to the latest reward-predicting states all equal R*. The values of the states preceding the earliest reward-predicting state remain low (which Figure 15.5 shows as zero) because they are not reliable predictors of reward.\nWhen learning is complete, that is, when V attains its correct values, the TD errors associated with transitions from any reward-predicting state are zero because the predictions are now accurate. This is because for a transition from a reward- predicting state to another reward-predicting state, we have 5t-i = Rt + Vt \\A1\\AA Vt_i = 0+ R* \\A1\\AA R* = 0, and for the transition from the latest reward-predicting state to the rewarding state, we have 5t-i = Rt + Vt \\A1\\AA Vt_i = R* + 0 \\A1\\AA R* = 0. On the other hand, the TD error on a transition from any state to the earliest reward-predicting state is positive because of the mismatch between this state\\A1\\AFs low value and the larger value of the following reward-predicting state. Indeed, if the value of a state preceding the earliest reward-predicting state were zero, then after the transition to the earliest reward-predicting state, we would have that 5t-i = Rt + Vt \\A1\\AA Vt-i = 0 + R* \\A1\\AA 0 = R*. The \\A1\\AElearning complete\\A1\\AF graph of 5 in Figure 15.5 shows this positive value at the earliest reward-predicting state, and zeros everywhere else.\nThe positive TD error upon transitioning to the earliest reward-predicting state is analogous to the persistence of dopamine responses to the earliest stimuli predicting reward. By the same token, when learning is complete, a transition from the latest reward-predicting state to the rewarding state produces a zero TD error because the latest reward-predicting state\\A1\\AFs value, being correct, cancels the reward. This parallels the observation that fewer dopamine neurons generate a phasic response to a fully predicted reward than to an unpredicted reward.\nAfter learning, if the reward is suddenly omitted, the TD error goes negative at the usual time of reward because the value of the latest reward-predicting state is then too high: 5t-i = Rt + Vt \\A1\\AA Vt-i = 0+ 0\\A1\\AA R* = \\A1\\AAR*, as shown at the right end of the \\A1\\AER omitted\\A1\\AF graph of 5 in Figure 15.5. This is like dopamine neuron activity decreasing below baseline at the time an expected reward is omitted as seen in the experiment of Schultz et al. (1993) described above and shown in Figure 15.4.\nThe idea of an earliest reward-predicting state deserves more attention. In the scenario described above, since experience is divided into trials, and we assumed that predictions are confined to individual trials, the earliest reward-predicting state is always the first state of a trial. Clearly this is artificial. A more general way to think of an earliest reward-predicting state is that it is an unpredicted predictor of reward, and there can be many such states. In an animal\\A1\\AFs life, many different states may precede an earliest reward-predicting state. However, because these states are more often followed by other states that do not predict reward, their reward-predicting powers, that is, their values, remain low. A TD algorithm, if operating throughout the animal\\A1\\AFs life, would back up values to these states too, but the backups would not consistently accumulate because, by assumption, none of these states reliably precedes an earliest reward-predicting state. If any of them did, they would be reward-predicting states as well. This might explain why with overtraining, dopamine responses decrease to even the earliest reward-predicting stimulus in a trial. With overtraining one would expect that even a formerly-unpredicted predictor state would become predicted by stimuli associated with earlier states: the animal\\A1\\AFs interaction with its environment both inside and outside of an experimental task would become commonplace. Upon breaking this routine with the introduction of a new task, however, one would see TD errors reappear, as indeed is observed in dopamine neuron\nactivity.\nThe example described above explains why the TD error shares key features with the phasic activity of dopamine neurons when the animal is learning in a task similar to the idealized task of our example. But not every property of the phasic activity of dopamine neurons coincides so neatly with properties of 5. One of the most troubling discrepancies involves what happens when a reward occurs earlierthan expected. We have seen that the omission of an expected reward produces a negative prediction error at the reward\\A1\\AFs expected time, which corresponds to the activity of dopamine neurons decreasing below baseline when this happens. If the reward arrives later than expected, it is then an unexpected reward and generates a positive prediction error. This happens with both TD errors and dopamine neuron responses. But when reward arrives earlier than expected, dopamine neurons do not do what the TD error does\\A1\\AAat least with the CSC representation used by Montague et al. (1996) and by us in our example. Dopamine neurons do respond to the early reward, which is consistent with a positive TD error because the reward is not predicted to occur then. However, at the later time when the reward is expected but omitted, the TD error is negative whereas, in contrast to this prediction, dopamine neuron activity does not drop below baseline in the way the TD model predicts (Hollerman and Schultz, 1998). Something more complicated is going on in the animal\\A1\\AFs brain than simply TD learning with a CSC representation.\nSome of the mismatches between the TD error and dopamine neuron activity can be addressed by selecting suitable parameter values for the TD algorithm and by using stimulus representations other than the CSC representation. For instance, to address the early-reward mismatch just described, Suri and Schultz (1999) proposed a CSC representation in which the sequences of internal signals initiated by earlier stimuli are cancelled by the occurrence of a reward. Another proposal by Daw, Courville, and Touretzky (2006) is that the brain\\A1\\AFs TD system uses representations produced by statistical modeling carried out in sensory cortex rather than simpler representations based on raw sensory input. Ludvig, Sutton, and Kehoe (2008) found that TD learning with a microstimulus (MS) representation (Figure 14.2) fits the activity of dopamine neurons in the early-reward and other situations better than when a CSC representation is used. Pan, Schmidt, Wickens, and Hyland (2005) found that even with the CSC representation, prolonged eligibility traces improve the fit of the TD error to some aspects of dopamine neuron activity. In general, many fine details of TD-error behavior depend on subtle interactions between eligibility traces, discounting, and stimulus representations. Findings like these elaborate and refine the reward prediction error hypothesis without refuting its core claim that the phasic activity of dopamine neurons is well characterized as signaling TD errors.\nOn the other hand, there are other discrepancies between the TD theory and ex\u0026shy;perimental data that are not so easily accommodated by selecting parameter values and stimulus representations (we mention some of these discrepancies in the Bib\u0026shy;liographical and Historical Remarks section at the end of this chapter), and more mismatches are likely to be discovered as neuroscientists conduct ever more refined experiments. But the reward prediction error hypothesis has been functioning very effectively as a catalyst for improving our understanding of how the brain\\A1\\AFs reward system works. Intricate experiments have been designed to validate or refute pre\u0026shy;dictions derived from the hypothesis, and experimental results have, in turn, led to refinement and elaboration of the TD error/dopamine hypothesis.\nA remarkable aspect of these developments is that the reinforcement learning algo\u0026shy;rithms and theory that connect so well with properties of the dopamine system were developed from a computational perspective in total absence of any knowledge about the relevant properties of dopamine neurons\\A1\\AAremember, TD learning and its con\u0026shy;nections to optimal control and dynamic programming were developed many years before any of the experiments were conducted that revealed the TD-like nature of dopamine neuron activity. This unplanned correspondence, despite not being per\u0026shy;fect, suggests that the TD error/dopamine parallel captures something significant about brain reward processes.\nIn addition to accounting for many features of the phasic activity of dopamine neurons, the reward prediction error hypothesis links neuroscience to other aspects of reinforcement learning, in particular, to learning algorithms that use TD errors as reinforcement signals. Neuroscience is still far from reaching complete understand\u0026shy;ing of the circuits, molecular mechanisms, and functions of the phasic activity of dopamine neurons, but evidence supporting the reward prediction error hypothe\u0026shy;sis, along with evidence that phasic dopamine responses are reinforcement signals for learning, suggest that the brain might implement something like an actor-critic algorithm in which TD errors play critical roles. Other reinforcement learning algo\u0026shy;rithms are plausible candidates too, but actor-critic algorithms fit the anatomy and physiology of the mammalian brain particularly well, as we describe in the following two sections.\n15.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Neural Actor\\A1\\AACritic\nActor-critic algorithms learn both policies and value functions. The \\A1\\AEactor\\A1\\AF is the component that learns policies, and the \\A1\\AEcritic\\A1\\AF is the component that learns about whatever policy is currently being followed by the actor in order to \\A1\\AEcriticize\\A1\\AF the actor\\A1\\AFs action choices. The critic uses a TD algorithm to learn the state-value function for the actor\\A1\\AFs current policy. The value function allows the critic to critique the actor\\A1\\AFs action choices by sending TD errors, 5, to the actor. A positive 5 means that the action was \\A1\\AEgood\\A1\\AF because it led to a state with a better-than-expected value; a negative 5 means that the action was \\A1\\AEbad\\A1\\AF because it led to a state with a worse-than-expected value. Based on these critiques, the actor continually updates its policy.\nTwo distinctive features of actor-critic algorithms are responsible for thinking that the brain might implement an algorithm like this. First, the two components of an actor-critic algorithm\\A1\\AAthe actor and the critic\\A1\\AAsuggest that two parts of the striatum\\A1\\AAthe dorsal and ventral subdivisions (Section 15.4), both critical for reward- based learning\\A1\\AAmay function respectively something like an actor and a critic. A \n \nsecond property of actor-critic algorithms that suggests a brain implementation is that the TD error has the dual role of being the reinforcement signal for both the actor and the critic, though it has a different influence on learning in each of these components. This fits well with several properties of the neural circuitry: axons of dopamine neurons target both the dorsal and ventral subdivisions of the striatum; dopamine appears to be critical for modulating synaptic plasticity in both structures; and how a neuromodulator such as dopamine acts on a target structure depends on properties of the target structure and not just on properties of the neuromodulator.\nSection 13.5 presents actor-critic algorithms as policy gradient methods, but the actor-critic algorithm of Barto, Sutton, and Anderson (1983) was simpler and was presented as an artificial neural network. Here we describe an artificial neural net\u0026shy;work implementation something like that of Barto et al., and we follow Takahashi, Schoenbaum, and Niv (2008) in giving a schematic proposal for how this artificial neural network might be implemented by real neural networks in the brain. We postpone discussion of the actor and critic learning rules until Section 15.8, where we present them as special cases of the policy-gradient formulation and discuss what they suggest about how dopamine might modulate synaptic plasticity.\nFigure 15.6a shows an implementation of an actor-critic algorithm as an artificial neural network with component networks implementing the actor and the critic. The critic consists of a single neuron-like unit, V , whose output activity represents state values, and a component shown as the diamond labeled TD that computes TD errors by combining V \\A1\\AFs output with reward signals and with previous state values (as suggested by the loop from the TD diamond to itself). The actor network has a single layer of kactor units labeled Ai, i= 1,...,k.The output of each actor unit is a component of a k-dimensional action vector. An alternative is that there are k separate actions, one commanded by each actor unit, that compete with one another to be executed, but here we will think of the entire \\D2\\E6-vector as an action.\nBoth the critic and actor networks receive input consisting of multiple features representing the state of the agent\\A1\\AFs environment. (Recall from Chapter 1 that the environment of a reinforcement learning agent includes components both inside and outside of the \\A1\\AEorganism\\A1\\AF containing the agent.) The figure shows these features as the circles labeled xi, X2,...,xn, shown twice just to keep the figure simple. A weight representing the efficacy of a synapse is associated with each connection from each feature Xi to the critic unit, V, and to each of the action units, Ai. The weights in the critic network parameterize the value function, and the weights in the actor network parameterize the policy. The networks learn as these weights change according to the critic and actor learning rules that we describe in the following section.\nThe TD error produced by circuitry in the critic is the reinforcement signal for changing the weights in both the critic and the actor networks. This is shown in Figure 15.6a by the line labeled \\A1\\AETD error 5\\A1\\AF extending across all of the connections in the critic and actor networks. This aspect of the network implementation, together with the reward prediction error hypothesis and the fact that the activity of dopamine neurons is so widely distributed by the extensive axonal arbors of these neurons, suggests that an actor-critic network something like this may not be too farfetched\nas a hypothesis about how reward-related learning might happen in the brain.\nFigure 15.6b suggests\\A1\\AAvery schematically\\A1\\AAhow the artificial neural network on the figure\\A1\\AFs left might map onto structures in the brain according to the hypothesis of Takahashi et al. (2008). The hypothesis puts the actor and the value-learning part of the critic respectively in the dorsal and ventral subdivisions of the striatum, the input structure of the basal ganglia. Recall from Section 15.4 that the dorsal striatum is primarily implicated in influencing action selection, and the ventral stria\u0026shy;tum is thought to be critical for different aspects of reward processing, including the assignment of affective value to sensations. The cerebral cortex, along with other structures, sends input to the striatum conveying information about stimuli, internal states, and motor activity.\nIn this hypothetical actor-critic brain implementation, the ventral striatum sends value information to the VTA and SNpc, where dopamine neurons in these nuclei\n \n   EnsIJls lrtSJoQ\n        jlnlujls/SJBls\n        = n\u0026pound;jls/s\u0026lt;ulnjls\n        (SE.Jrt9ld!llnlu) X91JOU\n                                        \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 15.6: Actor-critic artificial neural network and a hypothetical neural implementa\u0026shy;tion. a) Actor-critic algorithm as an artificial neural network. The actor adjusts a policy based on the TD error 5 it receives from the critic; the critic adjusts state-value parameters using the same 5. The critic produces a TD error from the reward signal, R, and the current change in its estimate of state values. The actor does not have direct access to the reward signal, and the critic does not have direct access to the action. b) Hypothetical neural im\u0026shy;plementation of an actor-critic algorithm. The actor and the value-learning part of the critic are respectively placed in the ventral and dorsal subdivisions of the striatum. The TD error is transmitted by dopamine neurons located in the VTA and SNpc to modulate changes in synaptic efficacies of input from cortical areas to the ventral and dorsal striatum. Adapted from Frontiers in Neuroscience, vol. 2(1), 2008, Y. Takahashi, G. Schoenbaum, and Y. Niv, Silencing the critics: Understanding the effects of cocaine sensitization on dorsolateral and ventral striatum in the context of an Actor/Critic model.\ncombine it with information about reward to generate activity corresponding to TD errors (though exactly how dopaminergic neurons calculate these errors is not yet un\u0026shy;derstood). The \\A1\\AETD error 5\\A1\\AF line in Figure 15.6a becomes the line labeled \\A1\\AEDopamine\\A1\\AF in Figure 15.6b, which represents the widely branching axons of dopamine neurons whose cell bodies are in the VTA and SNpc. Referring back to Figure 15.2, these axons make synaptic contact with the spines on the dendrites of medium spiny neu\u0026shy;rons, the main input/output neurons of both the dorsal and ventral divisions of the striatum. Axons of the cortical neurons that send input to the striatum make synaptic contact on the tips of these spines. According to the hypothesis, it is at these spines where changes in the efficacies of the synapses from cortical regions to the stratum are governed by learning rules that critically depend on a reinforcement signal supplied by dopamine.\nAn important implication of the hypothesis illustrated in Figure 15.6b is that the dopamine signal is not the \\A1\\AEmaster\\A1\\AF reward signal like the scalar Rt of reinforcement learning. In fact, the hypothesis implies that one should not necessarily be able to probe the brain and record any signal like Rt in the activity of any single neuron. Many interconnected neural systems generate reward-related information, with dif\u0026shy;ferent structures being recruited depending on different types of rewards. Dopamine neurons receive information from many different brain areas, so the input to the SNpc and VTA labeled \\A1\\AEReward\\A1\\AF in Figure 15.6b should be thought of as vector of reward-related information arriving to neurons in these nuclei along multiple input channels. What the theoretical scalar reward signal Rt might correspond to, then, is the net contribution of all reward-related information to dopamine neuron activity. It is the result of a pattern of activity across many neurons in different areas of the brain.\nAlthough the actor-critic neural implementation illustrated in Figure 15.6b may be correct on some counts, it clearly needs to be refined, extended, and modified to qualify as a full-fledged model of the function of the phasic activity of dopamine neurons. The Historical and Bibliographic Remarks section at the end of this chapter cites publications that discuss in more detail both empirical support for this hypoth\u0026shy;esis and places where it falls short. We now look in detail at what the actor and critic learning algorithms suggest about the rules governing changes in synaptic efficacies of corticostriatal synapses.\n15.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Actor and Critic Learning Rules\nIf the brain does implement something like the actor-critic algorithm\\A1\\AAand assuming populations of dopamine neurons broadcast a common reinforcement signal to the corticostriatal synapses of both the dorsal and ventral striatum as illustrated in Figure 15.6b (which is likely an oversimplification as we mentioned above)\\A1\\AAthen this reinforcement signal affects the synapses of these two structures in different ways. The learning rules for the critic and the actor use the same reinforcement signal, the TD error 5, but its effect on learning is different for these two components. The TD error (combined with eligibility traces) tells the actor how to update action probabilities in order to reach higher-valued states. Learning by the actor is like instrumental conditioning using a Law-of-Effect-type learning rule (Section 1.7): the actor works to keep 5 as positive as possible. On the other hand, the TD error (when combined with eligibility traces) tells the critic the direction and magnitude in which to change the parameters of the value function in order to improve its predictive accuracy. The critic works to reduce 5\\A1\\AFs magnitude to be as close to zero as possible using a learning rule like the TD model of classical conditioning (Section 14.2). The difference between the critic and actor learning rules is relatively simple, but this difference has a profound effect on learning and is essential to how the actor-critic algorithm works. The difference lies solely in the eligibility traces each type of learning rule uses.\nMore than one set of learning rules can be used in actor-critic neural networks like those in Figure 15.6b, but to be specific, here we focus on rules based on the REINFORCE policy-gradient formulation described in Section 13.5. The box below recaps that method using the pseudocode for a policy-gradient actor-critic with eligibility traces from the box in Section 13.5.\nPolicy-Gradient Actor-Critic\nInput: a differentiable policy parameterization n(a|s, 0), Va G A, s G S, Q G Rd Input: a differentiable state-value parameterization v(s,w), Vs G S, w G Rm Hyperparameters: step sizes a \u0026gt; 0, ^ \u0026gt; 0\nAt each iteration:\nCurrent state is S Take action A \u0026#12316;n(-|S, Q), observe S!, R\n5\u0026nbsp; \\A1\\AA R + yv(S ;,w) \\A1\\AA {)(S,w) ew\\A1\\AA Awew+ Vw \\D0\\C4(S,w) e\\A1\\E3 \\A1\\AA A6e0 + Ve logn(A|S, Q) w \\A1\\AA w + ¬5 ewQ \\A1\\AA Q + a5 e0\nThe first step is to think of the value function as the output of a single linear neuron-like unit, called the critic unit and labeled V in Figure 15.6a. Then the value function is a linear function of the feature-vector representation of state s, x(s) = (xi(s),..., xn(s))T, parameterized by a weight vector wT= (wi,..., wn):\nv(s,w) = wTx(s).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (15.1)\nEach Xi(s) is like the presynaptic signal to a neuron\\A1\\AFs synapse whose efficacy is Wi. The weights are updated according to the rule in the box above: w \\A1\\AA w + ^5ew, where the reinforcement signal, 5, corresponds to a dopamine signal being broadcast to all of the critic unit\\A1\\AFs synapses. The eligibility trace vector, ew, for the critic unit is a trace of VwV(s,w) for past states s. Since v(s,w) is linear in the weights,\nV\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; w v(s,w) = x(s).\nIn neural terms, this means that each synapse has its own eligibility trace, which is one component of the vector ew. A synapse\\A1\\AFs eligibility trace accumulates according to the level of activity arriving at that synapse, that is, the level of presynaptic activity, represented here by the component of the feature vector x(s) arriving at that synapse. The trace otherwise decays toward zero at a rate governed by the fraction Aw. A synapse is eligible for modificationas long as its eligibility trace is non-zero. How the synapse\\A1\\AFs efficacy is actually modified depends on the reinforcement signals that arrive while the synapse is eligible. We call eligibility traces like these of the critic unit\\A1\\AFs synapses non-contingent eligibility tracesbecause they only depend on presynaptic activity and are not contingent in any way on postsynaptic activity.\nThe non-contingent eligibility traces of the critic unit\\A1\\AFs synapses mean that the critic unit\\A1\\AFs learning rule is essentially the TD model of classical conditioning de\u0026shy;scribed in Section 14.2. With the definition we have given above of the critic unit and its learning rule, the critic in Figure 15.6a is the same as the critic in the neural network actor-critic of Barto et al. (1983). Clearly, a critic like this consisting of just one linear neuron-like unit is the simplest starting point; this critic unit is a proxy for a more complicated neural network able to learn value functions of greater complexity.\nThe actor in Figure 15.6a is a one-layer network of kneuron-like actor units, each receiving the same feature vector, x(s), that the critic unit receives. Each actor unit j, j= 1,\\A1\\AD,k,has its own weight vector, , but since the actor units are all identical, we describe just one of the units and omit the subscript. One way for these units to follow the policy-gradient formulation in the box above is for each to be a Bernoulli-logistic unitwith a REINFORCE policy-gradient learning rule. This means that the output of each actor unit is a random variable, A, taking value 0 or 1. Think of value 1 as the neuron firing, that is, emitting an action potential. The weighted sum, 0Tx(s), of a unit\\A1\\AFs input vector determines the unit\\A1\\AFs action probabilities via the exponential softmax distribution (13.2), which for two actions is the logistic function:\nn(1|s,0) = 1\\A1\\AA n(0|s, $= 1+ exp(\\A1\\AA^Tx(s)).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (15.2)\nThe weights of each actor unit are updated by the rule in the box above: Q^\\A8D d+ ¬5 e\\A1\\E3, where 5 again corresponds to the dopamine signal: the same reinforcement signal that is sent to all the critic unit\\A1\\AFs synapses. Figure 15.6a shows 5 being broadcast to all the synapses of all the actor units (which makes this actor network a teamof reinforcement learning agents, something we discuss in Section 15.10 below). The actor eligibility trace vector e9is a trace of Velog n(A|s, Q) for past states s. To understand this eligibility trace refer to Exercise 13.7, which defines this kind of unit and asks you to give the REINFORCE learning rule for it. That exercise asked you to express Ve logn(A|s, Q) in terms of A, x(s), and n(A|s, Q) by calculating the gradient. The answer we were looking for is:\nVen(A|s, Q) = (A \\A1\\AA n(A|s, Q))x(s).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (15.3)\nUnlike the non-contingent eligibility trace of a critic synapse that only accumu\u0026shy;lates the presynaptic activity x(s), the eligibility trace of an actor unit\\A1\\AFs synapse in addition depends on the activity of the actor unit itself. We call this a contingent eligibility tracebecause it is contingent on this postsynaptic activity. The eligibility trace at each synapse continually decays, but increments or decrements depending on the activity of the presynaptic neuron AND whether or not the postsynaptic neuron fires. The factor A\\A1\\AA n(A|s, d)in (15.3) is positive when A= 1and negative other\u0026shy;wise. The postsynaptic contingency in the eligibility traces of actor units is the only difference between the critic and actor learning rules.By keeping information about what actions were taken in what states, contingent eligibility traces allow credit for reward (positive 5), or blame for punishment (negative 5), to be apportioned among the policy parameters (the efficacies of the actor units\\A1\\AF synapses) according to the contributions these parameters made to the units\\A1\\AF outputs that could have influ\u0026shy;enced later values of 5. Contingent eligibility traces mark the synapses as to how they should be modified to alter the units\\A1\\AF future responses to favor positive values of 5.\nWhat do the critic and actor learning rules suggest about how efficacies of corti- costriatal synapses change? Both learning rules are related to Donald Hebb\\A1\\AFs classic proposal that whenever a presynaptic signal participates in activating the postsy\u0026shy;naptic neuron, the synapse\\A1\\AFs efficacy increases (Hebb, 1949). The critic and actor learning rules share with Hebb\\A1\\AFs proposal the idea that changes in a synapse\\A1\\AFs ef\u0026shy;ficacy depend on the interaction of several factors. In the critic learning rule the interaction is between the reinforcement signal 5 and eligibility traces that depend only on presynaptic signals. Neuroscientists call this a two-factor learning rulebe\u0026shy;cause the interaction is between two signals or quantities. The actor learning rule, on the other hand, is a three-factor learning rulebecause, in addition to depending on 5, its eligibility traces depend on both presynaptic and postsynaptic activity. Unlike Hebb\\A1\\AFs proposal, however, the relative timing of the factors is critical to how synaptic efficacies change, with eligibility traces intervening to allow the reinforcement signal to affect synapses that were active in the recent past.\nSome subtleties about signal timing for the actor and critic learning rules de\u0026shy;serve closer attention. In defining the neuron-like actor and critic units, we ignored the small amount of time it takes synaptic input to effect the firing of a real neu\u0026shy;ron. When an action potential from the presynaptic neuron arrives at a synapse, neurotransmitter molecules are released that diffuse across the synaptic cleft to the postsynaptic neuron, where they bind to receptors on the postsynaptic neuron\\A1\\AFs sur\u0026shy;face; this activates molecular machinery that causes the postsynaptic neuron to fire (or to inhibit its firing in the case of inhibitory synaptic input). This process can take several tens of milliseconds. According to (15.1) and (15.2), though, the in\u0026shy;put to a critic and actor unit instantaneously produces the unit\\A1\\AFs output. Ignoring activation time like this is common in abstract models of Hebbian-style plasticity in which synaptic efficacies change according to a simple product of simultaneous pre- and postsynaptic activity. More realistic models must take activation time into account.\nActivation time is especially important for a more realistic actor unit because it influences how contingent eligibility traces have to work in order to properly\n \napportion credit for reinforcement to the appropriate synapses. The expression (A \\A1\\AA n(A|s, Q))x(s) defining contingent eligibility traces for the actor unit\\A1\\AFs learning rule given above includes the postsynaptic factor (A \\A1\\AA n(A|s, Q)) and the presynaptic factor x(s). This works because by ignoring activation time, the presynaptic activity x(s) participates in causingthe postsynaptic activity appearing in (A \\A1\\AA n(A|s, Q)). To assign credit for reinforcement correctly, the presynaptic factor defining the eli\u0026shy;gibility trace must be a cause of the postsynaptic factor that also defines the trace. Contingent eligibility traces for a more realistic actor unit would have to take ac\u0026shy;tivation time into account. (Activation time should not be confused with the time required for a neuron to receive a reinforcement signal influenced by that neuron\\A1\\AFs activity. The function of eligibility traces is to span this time interval which is gen\u0026shy;erally much longer than the activation time. We discuss this further in the following section.)\nThere are hints from neuroscience for how this process might work in the brain. Neuroscientists have discovered a form of Hebbian plasticity called spike-timing- dependent plasticity(STDP) that lends plausibility to the existence of actor-like synaptic plasticity in the brain. STDP is a Hebbian-style plasticity, but changes in a synapse\\A1\\AFs efficacy depend on the relative timing of presynaptic and postsynaptic action potentials. The dependence can take different forms, but in the one most studied, a synapse increases in strength if spikes incoming via that synapse arrive shortly before the postsynaptic neuron fires. If the timing relation is reversed, with a presynaptic spike arriving shortly after the postsynaptic neuron fires, then the strength of the synapse decreases. STDP is a type of Hebbian plasticity that takes the activation time of a neuron into account, which is one of the ingredients needed for actor-like learning.\nThe discovery of STDP has led neuroscientists to investigate the possibility of a three-factor form of STDP in which neuromodulatory input must follow appropriately- timed pre- and postsynaptic spikes. This form of synaptic plasticity, called reward- modulated STDP,is much like the actor learning rule discussed here. Synaptic changes that would be produced by regular STDP only occur if there is neuromodu- latory input within a time window after a presynaptic spike is closely followed by a postsynaptic spike. Evidence is accumulating that reward-modulated STDP occurs at the spines of medium spiny neurons of the dorsal striatum, with dopamine pro\u0026shy;viding the neuromodulatory factor\\A1\\AAthe sites where actor learning takes place in the hypothetical neural implementation of an actor-critic algorithm illustrated in Fig\u0026shy;ure 15.6b. Experiments have demonstrated reward-modulated STDP in which lasting changes in the efficacies of corticostriatal synapses occur only if a neuromodulatory pulse arrives within a time window that can last up to 10seconds after a presynaptic spike is closely followed by a postsynaptic spike (Yagishita et al. 2014). Although the evidence is indirect, these experiments point to the existence of contingent eligibility traces having prolonged time courses. The molecular mechanisms producing these traces, as well as the much shorter traces that likely underly STDP, are not yet un\u0026shy;derstood, but research focusing on time-dependent and neuromodulator-dependent synaptic plasticity is continuing.\nThe neuron-like actor unit that we have described here, with its Law-of-Effect- style learning rule, appeared in somewhat simpler form in the actor-critic network of Barto et al. (1983). That network was inspired by the \\A1\\B0hedonistic neuron\\A1\\B1 hypothesis proposed by physiologist A. H. Klopf (1972, 1982). Not all the details of Klopf\\A1\\AFs hypothesis are consistent with what has been learned about synaptic plasticity, but the discovery of STDP and the growing evidence for a reward-modulated form of STDP suggest that Klopf\\A1\\AFs ideas may not have been far off the mark. We discuss Klopf\\A1\\AFs hedonistic neuron hypothesis next.\n15.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Hedonistic Neurons\nIn his hedonistic neuron hypothesis, Klopf (1972, 1982) conjectured that individual neurons seek to maximize the difference between synaptic input treated as rewarding and synaptic input treated as punishing by adjusting the efficacies of their synapses on the basis of rewarding or punishing consequences of their own action potentials. In other words, individual neurons can be trained with response-contingent rein\u0026shy;forcement like an animal can be trained in an instrumental conditioning task. His hypothesis included the idea that rewards and punishments are conveyed to a neuron via the same synaptic input that excites or inhibits the neuron\\A1\\AFs spike-generating ac\u0026shy;tivity. (Had Klopf known what we know today about neuromodulatory systems, he might have assigned the reinforcing role to neuromodulatory input, but he wanted to avoid any centralized source of training information.) Synaptically-local traces of past pre- and postsynaptic activity had the key function in Klopf\\A1\\AFs hypothesis of making synapses eligible\\A1\\AAthe term he introduced\\A1\\AAfor modification by later re\u0026shy;ward or punishment. He conjectured that these traces are implemented by molecular mechanisms local to each synapse and therefore different from the electrical activity of both the pre- and the postsynaptic neurons. In the Bibliographical and Historical Remarks section of this chapter we bring attention to some similar proposals made by others.\nKlopf specifically conjectured that synaptic efficacies change in the following way. When a neuron fires an action potential, all of its synapses that were active in contributing to that action potential become eligible to undergo changes in their efficacies. If the action potential is followed within an appropriate time period by an increase of reward, the efficacies of all the eligible synapses increase. Symmetrically, if the action potential is followed within an appropriate time period by an increase of punishment, the efficacies of eligible synapses decrease. This is implemented by triggering an eligibility trace at a synapse upon a coincidence of presynaptic and postsynaptic activity (or more exactly, upon pairing of presynaptic activity with the postsynaptic activity that that presynaptic activity participates in causing)\\A1\\AAwhat we call a contingent eligibility trace. This is essentially the three-factor learning rule of an actor unit described in the previous section.\nThe shape and time course of an eligibility trace in Klopf\\A1\\AFs theory reflects the dura\u0026shy;tions of the many feedback loops in which the neuron is embedded, some of which lie entirely within the brain and body of the organism, while others extend out through the organism\\A1\\AFs external environment as mediated by its motor and sensory systems. His idea was that the shape of a synaptic eligibility trace is like a histogram of the durations of the feedback loops in which the neuron is embedded. The peak of an eligibility trace would then occur at the duration of the most prevalent feedback loops in which that neuron participates. The eligibility traces used by algorithms described in this book are simplified versions of Klopf\\A1\\AFs original idea, being expo\u0026shy;nentially (or geometrically) decreasing functions controlled by the parameters \\C8\\EBand Y. This simplifies simulations as well as theory, but we regard these simple eligi\u0026shy;bility traces as a placeholders for traces closer to Klopf\\A1\\AFs original conception, which would have computational advantages in complex reinforcement learning systems by refining the credit-assignment process.\nKlopf\\A1\\AFs hedonistic neuron hypothesis is not as implausible as it may at first appear. A well-studied example of a single cell that seeks some stimuli and avoids others is the bacterium Escherichia coli. The movement of this single-cell organism is influenced by chemical stimuli in its environment, behavior known as chemotaxis. It swims in its liquid environment by rotating hairlike structures called flagella attached to its surface. (Yes, it rotates them!) Molecules in the bacterium\\A1\\AFs environment bind to receptors on its surface. Binding events modulate the frequency with which the bacterium reverses flagellar rotation. Each reversal causes the bacterium to tumble in place and then head off in a random new direction. A little chemical memory and computation causes the frequency of flagellar reversal to decrease when the bacterium swims toward higher concentrations of molecules it needs to survive (attractants) and increase when the bacterium swims toward higher concentrations of molecules that are harmful (repellants). The result is that the bacterium tends to persist in swimming up attractant gradients and tends to avoid swimming up repellant gradients.\nThe chemotactic behavior just described is called klinokinesis. It is a kind of trial- and-error behavior, although it is unlikely that learning is involved: the bacterium needs a modicum of short-term memory to detect molecular concentration gradients, but it probably does not maintain long-term memories. Artificial intelligence pioneer Oliver Selfridge called this strategy \\A1\\B0run and twiddle,\\A1\\B1 pointing out its utility as a basic adaptive strategy: \\A1\\B0keep going in the same way if things are getting better, and otherwise move around\\A1\\B1\\A3\\A8Selfridge, 1978, 1984). Similarly, one might think of a neuron \\A1\\B0swimming\\A1\\B1 (not literally of course) in a medium composed of the com\u0026shy;plex collection of feedback loops in which it is embedded, acting to obtain one type of input signal and to avoid others. Unlike the bacterium, however, the neuron\\A1\\AFs synaptic strengths retain information about its past trial-and-error behavior. If this view of the behavior of a neuron (or just one type of neuron) is plausible, then the closed-loop nature of how the neuron interacts with its environment is important for understanding its behavior, where the neuron\\A1\\AFs environment consists of the rest of the animal together with the environment with which the animal as a whole interacts.\nKlopf\\A1\\AFs hedonistic neuron hypothesis extended beyond the idea that individual neurons are reinforcement learning agents. He argued that many aspects of intelligent behavior can be understood as the result of the collective behavior of a population of self-interested hedonistic neurons interacting with one another in an immense society or economic system making up an animal\\A1\\AFs nervous system. Whether or not this view of nervous systems is useful, the collective behavior of reinforcement learning agents has implications for neuroscience. We take up this subject next.\n15.10\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Collective Reinforcement Learning\nThe behavior of populations of reinforcement learning agents is deeply relevant to the study of social and economic systems, and if anything like Klopf\\A1\\AFs hedonistic neuron hypothesis is correct, to neuroscience as well. The hypothesis described above about how an actor-critic algorithm might be implemented in the brain only narrowly addresses the implications of the fact that the dorsal and ventral subdivisions of the striatum, the respective locations of the actor and the critic according to the hypothesis, each contain millions of medium spiny neurons whose synapses undergo change modulated by phasic bursts of dopamine neuron activity.\nThe actor in Figure 15.6a is a single-layer network of k actor units. The actions produced by this network are vectors (Ai, A2, \\A1\\F6 \\A1\\F6 \\A1\\F6 , Ak)T presumed to drive the ani\u0026shy;mal\\A1\\AFs behavior. Changes in the efficacies of the synapses of all of these units depend on the reinforcement signal 5. Because actor units attempt to make 5 as large as possible, 5 effectively acts as a reward signal for them (so in this case reinforcement is the same as reward). Thus, each actor unit is itself a reinforcement learning agent\\A1\\AA a hedonistic neuron if you will. Now, to make the situation as simple as possible, assume that each of these units receives the same reward signal at the same time (although, as indicated above, the assumption that dopamine is released at all the corticostriatal synapses under the same conditions and at the same times is likely an oversimplification).\nWhat can reinforcement learning theory tell us about what happens when all mem\u0026shy;bers of a population of reinforcement learning agents learn according to a common reward signal? The field of multi-agent reinforcement learningconsiders many as\u0026shy;pects of learning by populations of reinforcement learning agents. Although this field is beyond the scope of this book, we believe that some of its basic concepts and re\u0026shy;sults are relevant to thinking about the the brain\\A1\\AFs diffuse neuromodulatory systems. In multi-agent reinforcement learning (and in game theory), the scenario in which all the agents try to maximize a common reward signal that they simultaneously receive is known as a cooperative gameor a team problem.\nWhat makes a team problem interesting and challenging is that the common re\u0026shy;ward signal sent to each agent evaluates the patternof activity produced by the entire population, that is, it evaluates the collective actionof the team members. This means that any individual agent has only limited ability to affect the reward signal because any single agent contributes just one component of the collective ac\u0026shy;tion evaluated by the common reward signal. Effective learning in this scenario requires addressing a structural credit assignment problem: which team members, or groups of team members, deserve credit for a favorable reward signal, or blame for an \n \nunfavorable reward signal? It is a cooperativegame, or a team problem, because the agents are united in seeking to increase the same reward signal: there are no conflicts of interest among the agents. The scenario would be a competitive gameif different agents receive different reward signals, where each reward signal again evaluates the collective action of the population, and the objective of each agent is to increase its own reward signal. In this case there might be conflicts of interest among the agents, meaning that actions that are good for some agents are bad for others. Even deciding what the best collective action should be is a non-trivial aspect of game theory. This competitive setting might be relevant to neuroscience too (for example, to account for heterogeneity of dopamine neuron activity), but here we focus only on the cooperative, or team, case.\nHow can each reinforcement learning agent in a team learn to \\A1\\B0do the right thing\\A1\\B1 so that the collective action of the team is highly rewarded? An interesting result is that if each agent can learn effectively despite its reward signal being corrupted by a large amount of noise, and despite its lack of access to complete state infor\u0026shy;mation, then the population as a whole will learn to produce collective actions that improve as evaluated by the common reward signal, even when the agents cannot communicate with one another. Each agent faces its own reinforcement learning task in which its influence on the reward signal is deeply buried in the noise created by the influences of other agents. In fact, for any agent, all the other agents are part of its environment because its input, both the part conveying state information and the reward part, depends on how all the other agents are behaving. Furthermore, lacking access to the actions of the other agents, indeed lacking access to the param\u0026shy;eters determining their policies, each agent can only partially observe the state of its environment. This makes each team member\\A1\\AFs learning task very difficult, but if each uses a reinforcement learning algorithm able to increase a reward signal even under these difficult conditions, teams of reinforcement learning agents can learn to produce collective actions that improve over time as evaluated by the team\\A1\\AFs common reward signal.\nIf the team members are neuron-like units, then each unit has to have the goal of increasing the amount of reward it receives over time, as the actor unit does that we described in Section 15.8. Each unit\\A1\\AFs learning algorithm has to have two essential features. First, it has to use contingent eligibility traces. Recall that a contingent eligibility trace, in neural terms, is initiated (or increased) at a synapse when its presynaptic input participates in causing the postsynaptic neuron to fire. A non\u0026shy;contingent eligibility trace, in contrast, is initiated or increased by presynaptic input independently of what the postsynaptic neuron does. As explained in Section 15.8, by keeping information about what actions were taken in what states, contingent eligibility traces allow credit for reward, or blame for punishment, to be apportioned to an agent\\A1\\AFs policy parameters according to the contribution the values of these parameters made in determining the agent\\A1\\AFs action. By similar reasoning, a team member must remember its recent action so that it can either increase or decrease the likelihood of producing that action according to the reward signal that is subse\u0026shy;quently received. The action component of a contingent eligibility trace implements this action memory. Because of the complexity of the learning task, however, con\u0026shy;tingent eligibility is merely a preliminary step in the credit assignment process: the relationship between a single team member\\A1\\AFs action and changes in the team\\A1\\AFs re\u0026shy;ward signal is a statistical correlation that has to be estimated over many trials. Contingent eligibility is an essential but preliminary step in this process.\nLearning with non-contingent eligibility traces does not work at all in the team setting because it does not provide a way to correlate actions with consequent changes in the reward signal. Non-contingent eligibility traces are adequate for learning to predict, as the critic component of the actor-critic algorithm does, but they do not support learning to control, as the actor component must do. The members of a population of critic-like agents may still receive a common reinforcement signal, but they would all learn to predict the same quantity (which in the case of an actor-critic method, would be the expected return for the current policy). How successful each member of the population would be in learning to predict the expected return would depend on the information it receives, which could be very different for different members of the population. There would be no need for the population to produce differentiated patterns of activity. This is not a team problem as defined here.\nA second requirement for collective learning in a team problem is that there has to be variability in the actions of the team members in order for the team to explore the space of collective actions. The simplest way for a team of reinforcement learning agents to do this is for each member to independently explore its own action space through persistent variability in its output. This will cause the team as a whole to vary its collective actions. For example, a team of the actor units described in Section 15.8 explores the space of collective actions because the output of each unit, being a Bernoulli-logistic unit, probabilistically depends on the weighted sum of its input vector\\A1\\AFs components. The weighted sum biases firing probability up or down, but there is always variability. Because each unit uses a REINFORCE policy gradient algorithm (Chapter 13), each unit adjusts its weights with the goal of maximizing the average reward rate it experiences while stochastically exploring its own action space. One can show, as Williams (1992) did, that a team of Bernoulli-logistic REINFORCE units implements a policy gradient algorithm as a wholewith respect to average rate of the team\\A1\\AFs common reward signal, where the actions are the collective actions of the team.\nFurther, Williams (1992) showed that a team of Bernoulli-logistic units using RE\u0026shy;INFORCE ascends the average reward gradient when the units in the team are interconnected to form a multilayer neural network. In this case, the reward signal is broadcast to all the units in the network, though reward may depend only on the collective actions of the network\\A1\\AFs output units. This means that a multilayer team of Bernoulli-logistic REINFORCE units learns like a multilayer network trained by the widely-used error backpropagation method, but in this case the backpropagation process is replaced by the broadcasted reward signal. In practice, the error backprop- agation method is considerably faster, but the reinforcement learning team method is more plausible as a neural mechanism, especially in light of what is being learned about reward-modulated STDP as discussed in Section 15.8.\nExploration through independent exploration by team members is only the sim\u0026shy;plest way for a team to explore; more sophisticated methods are possible if the team members communicate with one another so that they can coordinate their actions to focus on particular parts of the collective action space. There are also mechanisms more sophisticated than contingent eligibility traces for addressing structural credit assignment, which is easier in a team problem when the set of possible collective actions is restricted in some way. An extreme case is a winner-take-all arrangement (for example, the result of lateral inhibition in the brain) that restricts collective actions to those to which only one, or a few, team members contribute. In this case the winners get the credit or blame for resulting reward or punishment.\nDetails of learning in cooperative games (or team problems) and non-cooperative game problems are beyond the scope of this book. The Bibliographical and Historical Remarks section at the end of this chapter cites a selection of the relevant publica\u0026shy;tions, including extensive references to research on implications for neuroscience of collective reinforcement learning.\n15.11\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Model-based Methods in the Brain\nReinforcement learning\\A1\\AFs distinction between model-free and model-based algorithms is proving to be useful for thinking about animal learning and decision processes. Section 14.6 discusses how this distinction aligns with that between habitual and goal-directed animal behavior. The hypothesis discussed above about how the brain might implement an actor-critic algorithm is relevant only to an animal\\A1\\AFs habitual mode of behavior because the basic actor-critic method is model-free. What neural mechanisms are responsible for producing goal-directed behavior, and how do they interact with those underlying habitual behavior?\nOne way to investigate questions about the brain structures involved in these modes of behavior is to inactivate an area of a rat\\A1\\AFs brain and then observe what the rat does in an outcome-devaluation experiment (Section 14.6). Results from experiments like these indicate that the actor-critic hypothesis described above is too simple in placing the actor in the dorsal striatum. Inactivating one part of the dorsal striatum, the dorsolateral striatum (DLS), impairs habit learning, causing the animal to rely more on goal-directed processes. On the other hand, inactivating the dorsomedial striatum (DMS) impairs goal-directed processes, requiring the animal to rely more on habit learning. Results like these support the view that the DLS in rodents is more involved in model-free processes, whereas their DMS is more involved in model-based processes. Results of studies with human subjects in similar experiments using functional neuroimaging, and with non-human primates, support the view that the analogous structures in the primate brain are differentially involved in habitual and goal-directed modes of behavior.\nOther studies identify activity associated with model-based processes in the pre- frontal cortex of the human brain, the front-most part of the frontal cortex impli\u0026shy;cated in executive function, including planning and decision making. Specifically implicated is the orbitofrontal cortex (OFC), the part of the prefrontal cortex imme\u0026shy;diately above the eyes. Functional neuroimaging in humans, and also recordings of the activities of single neurons in monkeys, reveals strong activity in the OFC related to the subjective reward value of biologically significant stimuli, as well as activity related to the reward expected as a consequence of actions. Although not free of controversy, these results suggest significant involvement of the OFC in goal-directed choice. It may be critical for the reward part of an animal\\A1\\AFs environment model.\nAnother structure involved in model-based behavior is the hippocampus, a struc\u0026shy;ture critical for memory and spatial navigation. A rat\\A1\\AFs hippocampus plays a critical role in the rat\\A1\\AFs ability to navigate a maze in the goal-directed manner that led Tolman to the idea that animals use models, or cognitive maps, in selecting actions (Section 14.5). The hippocampus may also be a critical component of our human ability to imagine new experiences (Hassabis and Maguire, 2007; Olafsd6ttir, Barry, Saleem, Hassabis, and Spiers, 2105).\nThe findings that most directly implicate the hippocampus in planning\\A1\\AAthe pro\u0026shy;cess needed to enlist an environment model in making decisions\\A1\\AAcome from exper\u0026shy;iments that decode the activity of neurons in the hippocampus to determine what part of space hippocampal activity is representing on a moment-to-moment basis. When a rat pauses at a choice point in a maze, the representation of space in the hippocampus sweeps forward (and not backwards) along the possible paths the ani\u0026shy;mal can take from that point (Johnson and Redish, 2007). Furthermore, the spatial trajectories represented by these sweeps closely correspond to the rat\\A1\\AFs subsequent navigational behavior (Pfeiffer and Foster, 2013). These results suggest that the hip\u0026shy;pocampus is critical for the state-transition part of an animal\\A1\\AFs environment model, and that it is part of a system that uses the model to simulate possible future state sequences to assess the consequences of possible courses of action: a form of planning.\nThe results described above add to a voluminous literature on neural mechanisms underlying goal-directed, or model-based, learning and decision making, but many questions remain unanswered. For example, how can areas as structurally similar as the DLS and DMS be essential components of modes of learning and behavior that are as different as model-free and model-based algorithms? Are separate structures re\u0026shy;sponsible for (what we call) the transition and reward components of an environment model? Is all planning conducted at decision time via simulations of possible future courses of action as the forward sweeping activity in the hippocampus suggests? In other words, is all planning something like a rollout algorithm (Section 8.10)? Or are models sometimes engaged in the background to refine or recompute value infor\u0026shy;mation as illustrated by the Dyna architecture (Section 8.2)? How does the brain arbitrate between the use of the habit and goal-directed systems? Is there, in fact, a clear separation between the neural substrates of these systems?\nThe evidence is not pointing to a positive answer to this last question. Summariz\u0026shy;ing the situation, Doll, Simon, and Daw (2012) wrote that \\A1\\B0model-based influences appear ubiquitous more or less wherever the brain processes reward information,\\A1\\B1 and this is true even in the regions thought to be critical for model-free learning. This includes the dopamine signals themselves, which can exhibit the influence of \n \nmodel-based information in addition to the reward prediction errors thought to be the basis of model-free processes.\nContinuing neuroscience research informed by reinforcement learning\\A1\\AFs model-free and model-based distinction has the potential to sharpen our understanding of ha\u0026shy;bitual and goal-directed processes in the brain. A better grasp of these neural mech\u0026shy;anisms may lead to algorithms combining model-free and model-based methods in ways that have not yet been explored in computational reinforcement learning.\n15.12\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Addiction\nUnderstanding the neural basis of drug abuse is a high-priority goal of neuroscience with the potential to produce new treatments for this serious public health problem. One view is that drug craving is the result of the same motivation and learning processes that lead us to seek natural rewarding experiences that serve our biological needs. Addictive substances, by being intensely reinforcing, effectively co-opt our natural mechanisms of learning and decision making. This is plausible given that many\\A1\\AAthough not all\\A1\\AAdrugs of abuse increase levels of dopamine either directly or indirectly in regions around terminals of dopamine neuron axons in the striatum, a brain structure firmly implicated in normal reward-based learning (Section 15.7). But the self-destructive behavior associated with drug addiction is not characteristic of normal learning. What is different about dopamine-mediated learning when the reward is the result of an addictive drug? Is addiction the result of normal learning in response to substances that were largely unavailable throughout our evolutionary history, so that evolution could not select against their damaging effects? Or do addictive substances somehow interfere with normal dopamine-mediated learning?\nThe reward prediction error hypothesis of dopamine neuron activity and its con\u0026shy;nection to TD learning are the basis of a model due to Redish (2004) of some\\A1\\AAbut certainly not all\\A1\\AAfeatures of addiction. The model is based on the observation that administration of cocaine and some other addictive drugs produces a transient in\u0026shy;crease in dopamine. In the model, this dopamine surge is assumed to increase the TD error, 5, in a way that cannot be cancelled out by changes in the value function. In other words, whereas 5 is reduced to the degree that a normal reward is pre\u0026shy;dicted by antecedent events (Section 15.6), the contribution to 5 due to an addictive stimulus does not decrease as the reward signal becomes predicted: drug rewards cannot be \\A1\\B0predicted away.\\A1\\B1 The model does this by preventing 5 from ever becom\u0026shy;ing negative when the reward signal is due to an addictive drug, thus eliminating the error-correcting feature of TD learning for states associated with administration of the drug. The result is that the values of these states increase without bound, making actions leading to these states preferred above all others.\nAddictive behavior is much more complicated than this result from Redish\\A1\\AFs model, but the model\\A1\\AFs main idea may be a piece of the puzzle. Or the model might be mis\u0026shy;leading. Dopamine appears not to play a critical role in all forms of addiction, and not everyone is equally susceptible to developing addictive behavior. Moreover, the model does not include the changes in many circuits and brain regions that accom\u0026shy;pany chronic drug taking, for example, changes that lead to a drug\\A1\\AFs diminishing effect with repeated use. It is also likely that addiction involves model-based pro\u0026shy;cesses. Still, Redish\\A1\\AFs model illustrates how reinforcement learning theory can be enlisted in the effort to understand a major health problem. In a similar manner, reinforcement learning theory has been influential in the development of the new field of computational psychiatry, which aims to improve understanding of mental disorders through mathematical and computational methods.\n15.13\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Summary\nThe neural pathways involved in the brain\\A1\\AFs reward system are complex and incom\u0026shy;pletely understood, but neuroscience research directed toward understanding these pathways and their roles in behavior is progressing rapidly. This research is reveal\u0026shy;ing striking correspondences between the brain\\A1\\AFs reward system and the theory of reinforcement learning as presented in this book.\nThe reward prediction error hypothesis of dopamine neuron activitywas proposed by scientists who recognized striking parallels between the behavior of TD errors and the activity of neurons that produce dopamine, a neurotransmitter essential in mammals for reward-related learning and behavior. Experiments conducted in the late 1980s and 1990s in the laboratory of neuroscientist Wolfram Schultz showed that dopamine neurons respond to rewarding events with substantial bursts of activity, called phasic responses, only if the animal does not expect those events, suggesting that dopamine neurons are signaling reward prediction errors instead of reward itself. Further, these experiments showed that as an animal learns to predict a rewarding event on the basis of preceding sensory cues, the phasic activity of dopamine neurons shifts to earlier predictive cues while decreasing to later predictive cues. This parallels the backup action of the TD error as a reinforcement learning agent learns to predict reward.\nOther experimental results firmly establish that the phasic activity of dopamine neurons is a reinforcement signal for learning that reaches multiple areas of the brain by means of profusely branching axons of dopamine producing neurons. These results are consistent with the distinction we make between a reward signal, Rt, and a reinforcement signal, which is the TD error 5t in most of the algorithms we present. Phasic responses of dopamine neurons are reinforcement signals, not reward signals.\nA prominent hypothesis is that the brain implements something like an actor-critic algorithm. Two structures in the brain (the dorsal and ventral subdivisions of the striatum), both of which play critical roles in reward-based learning, may function respectively like an actor and a critic. That the TD error is the reinforcement signal for both the actor and the critic fits well with the facts that dopamine neuron axons target both the dorsal and ventral subdivisions of the striatum; that dopamine appears to be critical for modulating synaptic plasticity in both structures; and that the effect on a target structure of a neuromodulator such as dopamine depends on\nproperties of the target structure and not just on properties of the neuromodulator.\nThe actor and the critic can be implemented by artificial neural networks consist\u0026shy;ing of neuron-like units having learning rules based on the policy-gradient actor-critic method described in Section 13.5. Each connection in these networks is like a synapse between neurons in the brain, and the learning rules correspond to rules governing how synaptic efficacies change as functions of the activities of the presynaptic and the postsynaptic neurons, together with neuromodulatory input corresponding to input from dopamine neurons. In this setting, each synapse has its own eligibility trace that records past activity involving that synapse. The only difference between the actor and critic learning rules is that they use different kinds of eligibility traces: the critic unit\\A1\\AFs traces are non-contingentbecause they do not involve the critic unit\\A1\\AFs output, whereas the actor unit\\A1\\AFs traces are contingentbecause in addition to the actor unit\\A1\\AFs input, they depend on the the actor unit\\A1\\AFs output. In the hypothetical implementation of an actor-critic system in the brain, these learning rules respec\u0026shy;tively correspond to rules governing plasticity of corticostriatal synapses that convey signals from the cortex to the principal neurons in the dorsal and ventral striatal subdivisions, synapses that also receive inputs from dopamine neurons.\nThe learning rule of an actor unit in the actor-critic network closely corresponds to reward-modulated spike-timing-dependent plasticity.In spike-timing-dependent plas\u0026shy;ticity (STDP), the relative timing of pre- and postsynaptic activity determines the direction of synaptic change. In reward-modulated STDP, changes in synapses in addition depend on a neuromodulator, such as dopamine, arriving within a time window that can last up to 10 seconds after the conditions for STDP are met. Evi\u0026shy;dence accumulating that reward-modulated STDP occurs at corticostriatal synapses, where the actor\\A1\\AFs learning takes place in the hypothetical neural implementation of an actor-critic system, adds to the plausibility of the hypothesis that something like an actor-critic system exists in the brains of some animals.\nThe idea of synaptic eligibility and basic features of the actor learning rule de\u0026shy;rive from Klopf\\A1\\AFs hypothesis of the \\A1\\B0hedonistic neuron\\A1\\B1 (Klopf, 1972, 1981). He conjectured that individual neurons seek to obtain reward and to avoid punishment by adjusting the efficacies of their synapses on the basis of rewarding or punishing consequences of their action potentials. A neuron\\A1\\AFs activity can affect its later input because the neuron is embedded in many feedback loops, some within the animal\\A1\\AFs nervous system and body and others passing through the animal\\A1\\AFs external environ\u0026shy;ment. Klopf\\A1\\AFs idea of eligibility is that synapses are temporarily marked as eligible for modification if they participated in the neuron\\A1\\AFs firing (making this the contin\u0026shy;gent form of eligibility trace). A synapse\\A1\\AFs efficacy is modified if a reinforcing signal arrives while the synapse is eligible. We alluded to the chemotactic behavior of a bacterium as an example of a single cell that directs its movements in order to seek some molecules and to avoid others.\nA conspicuous feature of the dopamine system is that fibers releasing dopamine project widely to multiple parts of the brain. Although it is likely that only some populations of dopamine neurons broadcast the same reinforcement signal, if this signal reaches the synapses of many neurons involved in actor-type learning, then the situation can be modeled as a team problem.In this type of problem, each agent in a collection of reinforcement learning agents receives the same reinforcement signal, where that signal depends on the activities of all members of the collection, or team. If each team member uses a sufficiently capable learning algorithm, the team can learn collectively to improve performance of the entire team as evaluated by the globally-broadcast reinforcement signal, even if the team members do not directly communicate with one another. This is consistent with the wide dispersion of dopamine signals in the brain and provides a neurally plausible alternative to the widely-used error-backpropagation method for training multilayer networks.\nThe distinction between model-free and model-based reinforcement learning is helping neuroscientists investigate the neural bases of habitual and goal-directed learning and decision making. Research so far points to their being some brain re\u0026shy;gions more involved in one type of process than the other, but the picture remains unclear because model-free and model-based processes do not appear to be neatly separated in the brain. Many questions remain unanswered. Perhaps most intriguing is evidence that the hippocampus, a structure traditionally associated with spatial navigation and memory, appears to be involved in simulating possible future courses of action as part of an animal\\A1\\AFs decision-making process. This suggests that it is part of a system that uses an environment model for planning.\nReinforcement learning theory is also influencing thinking about neural processes underlying drug abuse. A model of some features of drug addiction is based on the reward prediction error hypothesis. It proposes that an addicting stimulant, such as cocaine, destabilizes TD learning to produce unbounded growth in the values of actions associated with drug intake. This is far from a complete model of addiction, but it illustrates how a computational perspective suggests theories that can be tested with further research. The new field of computational psychiatry similarly focuses on the use of computational models, some derived from reinforcement learning, to better understand mental disorders.\nThis chapter only touched the surface of how the neuroscience of reinforcement learning and the development of reinforcement learning in computer science and engineering have influenced one another. Most features of reinforcement learning algorithms owe their design to purely computational considerations, but some have been influenced by hypotheses about neural learning mechanisms. Remarkably, as experimental data has accumulated about the brain\\A1\\AFs reward processes, many of the purely computationally-motivated features of reinforcement learning algorithms are turning out to be consistent with neuroscience data. Other features of compu\u0026shy;tational reinforcement learning, such eligibility traces and the ability of teams of reinforcement learning agents to learn to act collectively under the influence of a globally-broadcast reinforcement signal, may also turn out to parallel experimental data as neuroscientists continue to unravel the neural basis of reward-based animal learning and behavior.\n \nBibliographical and Historical Remarks\nThe number of publications treating parallels between the neuroscience of learning and decision making and the approach to reinforcement learning presented in this book is enormous. We can cite only a small selection. Niv (2009), Dayan and Niv\n(2008)\u0026nbsp;\u0026nbsp; , Gimcher (2011), Ludvig, Bellemare, and Pearson (2011), and Shah (2012) are good places to start.\nTogether with economics, evolutionary biology, and mathematical psychology, re\u0026shy;inforcement learning theory is helping to formulate quantitative models of the neural mechanisms of choice in humans and non-human primates. With its focus on learn\u0026shy;ing, this chapter only lightly touches upon the neuroscience of decision making. Glimcher (2003) introduced the field of \\A1\\B0neuroeconomics,\\A1\\B1 in which reinforcement learning contributes to the study of the neural basis of decision making from an eco\u0026shy;nomics perspective. See also Glimcher and Fehr (2013). The text on computational and mathematical modeling in neuroscience by Dayan and Abbott (2001) includes reinforcement learning\\A1\\AFs role in these approaches. Sterling and Laughlin (2015) ex\u0026shy;amined the neural basis of learning in terms of general design principles that enable efficient adaptive behavior.\n15.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; There are many good expositions of basic neuroscience. Kandel, Schwartz, Jessell, Siegelbaum, and Hudspeth (2013) is an authoritative and very com\u0026shy;prehensive source.\n15.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Berridge and Kringelbach (2008) reviewed the neural basis of reward and pleasure, pointing out that reward processing has many dimensions and in\u0026shy;volves many neural systems. Space prevents discussion of the influential research of Berridge and Robinson (1998), who distinguish between the he\u0026shy;donic impact of a stimulus, which they call \\A1\\B0liking,\\A1\\B1 and the motivational effect, which they call \\A1\\B0wanting.\\A1\\B1 Hare, O\\A1\\AFDoherty, Camerer, Schultz, and Rangel (2008) examined the neural basis of value-related signals from an eco\u0026shy;nomic perspective, distinguishing between goal values, decision values, and prediction errors. Decision value is goal value minus action cost. See also Rangel, Camerer, and Montague (2008), Rangel and Hare (2010), and Peters and Biichel (2010).\n15.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The reward prediction error hypothesis of dopamine neuron activity is most prominently discussed by Schultz, Montague, and Dayan (1997). The hy\u0026shy;pothesis was first explicitly put forward by Montague, Dayan, and Sejnowski (1996). As they stated the hypothesis, it referred to reward prediction errors (RPEs) but not specifically to TD errors; however, their development of the hypothesis made it clear that they were referring to TD errors. The earliest recognition of the TD-error/dopamine connection of which we are aware is that of Montague, Dayan, Nowlan, Pouget, and Sejnowski (1992), who pro\u0026shy;posed a TD-error-modulated Hebbian learning rule motivated by results on dopamine signaling from Schultz\\A1\\AFs group. The connection was also pointed out in an abstract by Quartz, Dayan, Montague, and Sejnowski (1992). Mon\u0026shy;tague and Sejnowski (1994) emphasized the importance of prediction in the brain and outlined how predictive Hebbian learning modulated by TD er\u0026shy;rors could be implemented via a diffuse neuromodulatory system, such as the dopamine system. Friston, Tononi, Reeke, Sporns, and Edelman (1994) presented a model of value-dependent learning in the brain in which synaptic changes are mediated by a TD-like error provided by a global neuromodula- tory signal (although they did not single out dopamine). Montague, Dayan, Person, and Sejnowski (1995) presented a model of honeybee foraging using the TD error. The model is based on research by Hammer, Menzel, and colleagues (Hammer and Menzel, 1995; Hammer, 1997) showing that the neuromodulator octopamine acts as a reinforcement signal in the honeybee. Montague et al. (1995) pointed out that dopamine likely plays a similar role in the vertebrate brain. Barto (1995) related the actor-critic architecture to basal-ganglionic circuits and discussed the relationship between TD learn\u0026shy;ing and the main results from Schultz\\A1\\AFs group. Houk, Adams, and Barto (1995) suggested how TD learning and the actor-critic architecture might map onto the anatomy, physiology, and molecular mechanism of the basal ganglia. Doya and Sejnowski (1998) extended their earlier paper on a model of birdsong learning (Doya and Sejnowski, 1994) by including a TD-like er\u0026shy;ror identified with dopamine to reinforce the selection of auditory input to be memorized. O\\A1\\AFReilly and Frank (2006) and O\\A1\\AFReilly, Frank, Hazy, and Watz (2007) argued that phasic dopamine signals are RPEs but not TD er\u0026shy;rors. In support of their theory they cited results with variable interstimulus intervals that do not match predictions of a simple TD model, as well as the observation that higher-order conditioning beyond second-order condi\u0026shy;tioning is rarely observed, while TD learning is not so limited. Dayan and Niv (2008) discussed \\A1\\B0the good, the bad, and the ugly\\A1\\B1 of how reinforcement learning theory and the reward prediction error hypothesis align with exper\u0026shy;imental data. Glimcher (2011) reviewed the empirical findings that support the reward prediction error hypothesis and emphasized the significance of the hypothesis for contemporary neuroscience.\n15.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Graybiel (2000) is a brief primer on the basal ganglia. The experiments mentioned that involve optogenetic activation of dopamine neurons were con\u0026shy;ducted by Tsai, Zhang, Adamantidis, Stuber, Bonci, de Lecea, and Deisseroth (2009), Steinberg, Keiflin, Boivin, Witten, Deisseroth, and Janak (2013), and Claridge-Chang, Roorda, Vrontou, Sjulson, Li, Hirsh, and Miesenbock\n(2009)\u0026nbsp;\u0026nbsp; . Fiorillo, Yun, and Song (2013), Lammel, Lim, and Malenka (2014), and Saddoris, Cacciapaglia, Wightmman, and Carelli (2015) are among stud\u0026shy;ies showing that the signaling properties of dopamine neurons are specialized for different target regions. RPE-signaling neurons may belong to one among multiple populations of dopamine neurons having different targets and sub\u0026shy;serving different functions. Eshel, Tian, Bukwich, and Uchida (2016) found homogeneity of reward prediction error responses of dopamine neurons in the lateral VTA during classical conditioning in mice, tough their results do not rule out response diversity across wider areas. Gershman, Pesaran, and Daw (2009) studied reinforcement learning tasks that can be decomposed into independent components with separate reward signals, finding evidence in human neuroimaging data suggesting that the brain exploits this kind of structure.\n15.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Schultz\\A1\\AFs 1998 survey article (Schultz, 1998) is a good entree into the very extensive literature on reward predicting signaling of dopamine neurons. Berns, McClure, Pagnoni, and Montague (2001), Breiter, Aharon, Kahne- man, Dale, and Shizgal (2001), Pagnoni, Zink, Montague, and Berns (2002), and O\\A1\\AFDoherty, Dayan, Friston, Critchley, and Dolan (2003) described func\u0026shy;tional brain imaging studies supporting the existence of signals like TD errors in the human brain.\n15.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; This section roughly follows Barto (1995) in explaining how TD errors mimic the main results from Schultz\\A1\\AFs group on the phasic responses of dopamine neurons.\n15.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; This section is largely based on Takahashi, Schoenbaum, and Niv (2008) and Niv (2009). To the best of our knowledge, Barto (1995) and Houk, Adams, and Barto (1995) first speculated about possible implementations of actor- critic algorithms in the basal ganglia. On the basis of functional magnetic resonance imaging of human subjects while engaged in instrumental condi\u0026shy;tioning, O\\A1\\AFDoherty, Dayan, Schultz, Deichmann, Friston, and Dolan (2004) suggested that the actor and the critic are most likely located respectively in the dorsal and ventral striatum. Gershman, Moustafa, and Ludvig (2013) focused on how time is represented in reinforcement learning models of the basal ganglia, discussing evidence for, and implications of, various computa\u0026shy;tional approaches to time representation.\nThe hypothetical neural implementation of the actor-critic architecture de\u0026shy;scribed in this section includes very little detail about known basal ganglia anatomy and physiology. In addition to the more detailed hypothesis of Houk, Adams, and Barto (1995), a number of other hypotheses include more specific connections to anatomy and physiology and are claimed to explain additional data. These include hypotheses proposed by Suri and Schultz (1998, 1999), Brown, Bullock, and Grossberg (1999), Contreras-Vidal and Schultz (1999), Suri, Bargas, and Arbib (2001), O\\A1\\AFReilly and Frank (2006), and O\\A1\\AFReilly, Frank, Hazy, and Watz (2007). Joel, Niv, and Ruppin (2002) critically evaluated the anatomical plausibility of several of these models and present an alternative intended to accommodate some neglected features of basal ganglionic circuitry.\n15.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The actor learning rule discussed here is more complicated than the one in the early actor-critic network of Barto et al. (1983). Actor-unit eligi\u0026shy;bility traces in that network were traces of just A x x(s) instead of the full (A \\A1\\AA n(A|S, w))x(s). That work did not benefit from the policy-gradient the\u0026shy;ory presented in Chapter 13 or the contributions of Williams (1986, 1992), who showed how an artificial neural network of Bernoulli-logistic units could implement a policy-gradient method.\nReynolds and Wickens (2002) proposed a three-factor rule for synaptic plas\u0026shy;ticity in the corticostriatal pathway in which dopamine modulates changes in corticostriatal synaptic efficacy. They discussed the experimental support for this kind of learning rule and its possible molecular basis. The definitive demonstration of spike-timing-dependent plasticity (STDP) is attributed to Markram, Liibke, Frotscher, and Sakmann (1997), with evidence from earlier experiments by Levy and Steward (1983) and others that the relative timing of pre- and postsynaptic spikes is critical for inducing changes in synaptic effi\u0026shy;cacy. Rao and Sejnowski (2001) suggested how STDP could be the result of a TD-like mechanism at synapses with non-contingent eligibility traces lasting about 10 milliseconds. Dayan (2002) commented that this would require an error as in Sutton and Barto\\A1\\AFs (1981) early model of classical conditioning and not a true TD error. Representative publications from the extensive litera\u0026shy;ture on reward-modulated STDP are Wickens (1990), Reynolds and Wickens (2002), and Calabresi, Picconi, Tozzi and Di Filippo (2007). Pawlak and Kerr (2008) showed that dopamine is necessary to induce STDP at the corticos- triatal synapses of medium spiny neurons. See also Pawlak, Wickens, Kirk\u0026shy;wood, and Kerr (2010). Yagishita, Hayashi-Takagi, Ellis-Davies, Urakubo, Ishii, and Kasai (2014) found that dopamine promotes spine enlargement of the medium spiny neurons of mice only during a time window of from 0.3 to\n2seconds after STDP stimulation. Izhikevich (2007) proposed and explored the idea of using STDP timing conditions to trigger contingent eligibility traces.\n15.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Klopf\\A1\\AFs hedonistic neuron hypothesis (Klopf 1972, 1982) inspired our actor- critic algorithm implemented as an artificial neural network with a single neuron-like unit, called the actor unit, implementing a Law-of-Effect-like learning rule (Barto, Sutton, and Anderson, 1983). Ideas related to Klopf\\A1\\AFs synaptically-local eligibility have been proposed by others. Crow (1968) pro\u0026shy;posed that changes in the synapses of cortical neurons are sensitive to the consequences of neural activity. Emphasizing the need to address the time delay between neural activity and its consequences in a reward-modulated form of synaptic plasticity, he proposed a contingent form of eligibility, but associated with entire neurons instead of individual synapses. According to his hypothesis, a wave of neuronal activity\nleads to a short-term change in the cells involved in the wave such that they are picked out from a background of cells not so activated.\n... such cells are rendered sensitive by the short-term change to a reward signal ... in such a way that if such a signal occurs before the end of the decay time of the change the synaptic connexions\n \nbetween the cells are made more effective. (Crow, 1968)\nCrow argued against previous proposals that reverberating neural circuits play this role by pointing out that the effect of a reward signal on such a cir\u0026shy;cuit would \\A1\\B0...establish the synaptic connexions leading to the reverberation (that is to say, those involved in activity at the time of the reward signal) and not those on the path which led to the adaptive motor output.\\A1\\B1 Crow fur\u0026shy;ther postulated that reward signals are delivered via a \\A1\\B0distinct neural fiber system,\\A1\\B1 presumably the one into which Olds and Milner (1954) tapped, that would transform synaptic connections \\A1\\B0from a short into a long-term form.\\A1\\B1\nIn another farsighted hypothesis, Miller (1981) proposed a Law-of-Effect-like learning rule that includes synaptically-local contingent eligibility traces:\n... it is envisaged that in a particular sensory situation neurone B, by chance, fires a \\A1\\AEmeaningful burst\\A1\\AF of activity, which is then trans\u0026shy;lated into motor acts, which then change the situation. It must be supposed that the meaningful burst has an influence, at the neu\u0026shy;ronal level, on all of its own synapses which are active at the time ... thereby making a preliminary selection of the synapses to be strengthened, though not yet actually strengthening them. ...The strengthening signal ... makes the final selection ... and accom\u0026shy;plishes the definitive change in the appropriate synapses. (Miller,\n1981, p. 81)\nMiller\\A1\\AFs hypothesis also included a critic-like mechanism, which he called a \\A1\\B0sensory analyzer unit,\\A1\\B1 that worked according to classical conditioning principles to provide reinforcement signals to neurons so that they would learn to move from lower- to higher-valued states, thus anticipating the use of the TD error as a reinforcement signal in the actor-critic architecture. Miller\\A1\\AFs idea not only parallels Klopf\\A1\\AFs (with the exception of its explicit invocation of a distinct \\A1\\B0strengthening signal\\A1\\B1), it also anticipated the general features of reward-modulated STDP.\nA related though different idea, which Seung (2003) called the \\A1\\B0hedonistic synapse,\\A1\\B1 is that synapses individually adjust the probability that they re\u0026shy;lease neurotransmitter in the manner of the Law of Effect: if reward follows release, the release probability increases, and decreases if reward follows fail\u0026shy;ure to release. This is essentially the same as the learning scheme Minsky used in his 1954 Princeton Ph.D. dissertation (Minsky, 1954), where he called the synapse-like learning element a SNARC (Stochastic Neural-Analog Re\u0026shy;inforcement Calculator). Contingent eligibility is involved in these ideas too, although it is contingent on the activity of an individual synapse instead of the postsynaptic neuron.\nFrey and Morris (1997) proposed the idea of a \\A1\\B0synaptic tag\\A1\\B1 for the induction of long-lasting strengthening of synaptic efficacy. Though not unlike Klopf\\A1\\AFs eligibility, their tag was hypothesized to consist of a temporary strengthening\nof a synapse that could be transformed into a long-lasting strengthening by subsequent neuron activation. The model of O\\A1\\AFReilly and Frank (2006) and O\\A1\\AFReilly, Frank, Hazy, and Watz (2007) uses working memory to bridge temporal intervals instead of eligibility traces. Wickens and Kotter (1995) discuss possible mechanisms for synaptic eligibility. He, Huertas, Hong, Tie, Hell, Shouval, Kirkwood (2015) provide evidence supporting the existence of contingent eligibility traces in synapses of cortical neurons with time courses like those of the eligibility traces Klopf postulated.\nThe metaphor of a neuron using a learning rule related to bacterial chemo- taxis was discussed by Barto (1989). Koshland\\A1\\AFs extensive study of bacterial chemotaxis was in part motivated by similarities between features of bacteria and features of neurons (Koshland, 1980). See also Berg (1975). Shiman- sky (2009) proposed a synaptic learning rule somewhat similar to Seung\\A1\\AFs mentioned above in which each synapse individually acts like a chemotactic bacterium. In this case a collection of synapses \\A1\\B0swims\\A1\\B1 toward attractants in the high-dimensional space of synaptic weight values. Montague, Dayan, Person, and Sejnowski (1995) proposed a chemotactic-like model of the bee\\A1\\AFs foraging behavior involving the neuromodulator octopamine.\n15.10\u0026nbsp;\u0026nbsp; Research on the behavior of reinforcement learning agents in team and game problems has a long history roughly occurring in three phases. To the best or our knowledge, the first phase began with investigations by the Russian math\u0026shy;ematician and physicist M. L. Tsetlin. A collection of his work was published as Tsetlin (1973) after his death in 1966. Our Sections 1.7 and 4.8 refer to his study of learning automata in connection to bandit problems. The Tsetlin collection also includes studies of learning automata in team and game prob\u0026shy;lems, which led to later work in this area using stochastic learning automata as described by Narendra and Thathachar (1974), Viswanathan and Narendra (1974), Lakshmivarahan and Narendra (1982), Narendra and Wheeler (1983), Narendra (1989), and Thathachar and Sastry (2002). Thathachar and Sastry\n(2011)is a more recent comprehensive account. These studies were mostly restricted to non-associative learning automata, meaning that they did not address associative, or contextual, bandit problems (Section 2.9).\nThe second phase began with the extension of learning automata to the associative, or contextual, case. Barto, Sutton, and Brouwer (1981) and Barto and Sutton (1981) experimented with associative stochastic learning automata in single-layer artificial neural networks to which a global reinforce\u0026shy;ment signal was broadcast. They called neuron-like elements implementing this kind of learning associative search elements(ASEs). Barto and Anan- dan (1985) introduced a more sophisticated associative reinforcement learn\u0026shy;ing algorithm called the associative reward-penalty(Ar-p) algorithm. They proved a convergence result by combining theory of stochastic learning au\u0026shy;tomata with theory of pattern classification. Barto (1985, 1986) and Barto and Jordan (1987) described results with teams of Ar_p units connected into multi-layer neural networks, showing that they could learn nonlinear\nfunctions, such as XOR and others, with a globally-broadcast reinforcement signal. Barto (1985) extensively discussed this approach to artificial neural networks and how this type of learning rule is related to others in the litera\u0026shy;ture at that time. Williams (1992) mathematically analyzed and broadened this class of learning rules and related their use to the error backpropagation method for training multilayer artificial neural networks. Williams (1988) de\u0026shy;scribed several ways that backpropagation and reinforcement learning can be combined for training artificial neural networks. Williams (1992) showed that a special case of the Ar-palgorithm is a REINFORCE algorithm, although better results were obtained with the general Ar-palgorithm (Barto,1985).\nThe third phase of interest in teams of reinforcement learning agents was influenced by increased understanding of the role of dopamine as a widely broadcast neuromodulator and speculation about the existence of reward- modulated STDP. Much more so than earlier research, this research considers details of synaptic plasticity and other constraints from neuroscience. Pub\u0026shy;lications include the following (chronologically and alphabetically): Bartlett and Baxter (1999, 2000), Xie and Seung (2004), Baras and Meir (2007), Far- ries and Fairhall (2007), Florian (2007), Izhikevich (2007), Pecevski, Maass, and Legenstein (2007), Legenstein, Pecevski, and Maass (2008), Kolodziejski, Porr, and Worgotter (2009), Urbanczik and Senn (2009), and Vasilaki, Fremaux, Urbanczik, Senn, and Gerstner (2009). Nowe, Vrancx, and De Hauwere (2012) reviewed more recent developments in the wider field of multi-agent reinforcement learning\n15.11\u0026nbsp;\u0026nbsp; Yin and Knowlton (2006) reviewed findings from outcome-devaluation ex\u0026shy;periments with rodents supporting the view that habitual and goal-directed behavior (as psychologists use the phrase) are respectively most associated with processing in the dorsolateral striatum (DLS) and the dorsomedial stria\u0026shy;tum (DMS). Results of functional imaging experiments with human subjects in the outcome-devaluation setting by Valentin, Dickinson, and O\\A1\\AFDoherty (2007) suggest that the orbitofrontal cortex (OFC) is an important compo\u0026shy;nent of goal-directed choice. Single unit recordings in monkeys by Padoa- Schioppa and Assad (2006) support the role of the OFC in encoding values guiding choice behavior. Rangel, Camerer, and Montague (2008) and Rangel and Hare (2010) reviewed findings from the perspective of neuroeconomics about how the brain makes goal-directed decisions. Pezzulo, van der Meer, Lansink, and Pennartz (2014) reviewed the neuroscience of internally gen\u0026shy;erated sequences and presented a model of how these mechanisms might be components of model-based planning. Daw and Shohamy (2008) proposed that while dopamine signaling connects well to habitual, or model-free, be\u0026shy;havior, other processes are involved in goal-directed, or model-based, behav\u0026shy;ior. Data from experiments by Bromberg-Martin, Matsumoto, Hong, and Hikosaka (2010) indicate that dopamine signals contain information perti\u0026shy;nent to both habitual and goal-directed behavior. Doll, Simon, and Daw\n(2012)argued that there may not a clear separation in the brain between\nmechanisms that subserve habitual and goal-directed learning and choice.\n   15.12\n     Keiflin and Janak (2015) reviewed connections between TD errors and addic\u0026shy;tion. Nutt, Lingford-Hughes, Erritzoe, and Stokes (2015) critically evaluated the hypothesis that addiction is due to a disorder of the dopamine system. Montague, Dolan, Friston, and Dayan (2012) outlined the goals and early ef\u0026shy;forts in the field of computational psychiatry, and Adams, Huys, and Roiser (2015) reviewed more recent progress.\n \nChapter 16\nApplications and Case Studies\nIn this final chapter we present a few case studies of reinforcement learning. Several of these are substantial applications of potential economic significance. One, Samuel\\A1\\AFs checkers player, is primarily of historical interest. Our presentations are intended to illustrate some of the trade-offs and issues that arise in real applications. For example, we emphasize how domain knowledge is incorporated into the formulation and solution of the problem. We also highlight the representation issues that are so often critical to successful applications. The algorithms used in some of these case studies are substantially more complex than those we have presented in the rest of the book. Applications of reinforcement learning are still far from routine and typically require as much art as science. Making applications easier and more straightforward is one of the goals of current research in reinforcement learning.\n16.1\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; TD-Gammon\nOne of the most impressive applications of reinforcement learning to date is that by Gerald Tesauro to the game of backgammon (Tesauro, 1992, 1994, 1995, 2002). Tesauro\\A1\\AFs program, TD-Gammon,required little backgammon knowledge, yet learned to play extremely well, near the level of the world\\A1\\AFs strongest grandmasters. The learning algorithm in TD-Gammon was a straightforward combination of the TD(A) algorithm and nonlinear function approximation using a multilayer neural network trained by backpropagating TD errors.\nBackgammon is a major game in the sense that it is played throughout the world, with numerous tournaments and regular world championship matches. It is in part a game of chance, and it is a popular vehicle for waging significant sums of money. There are probably more professional backgammon players than there are profes\u0026shy;sional chess players. The game is played with 15 white and 15 black pieces on a board of 24 locations, called points. Figure 16.1 shows a typical position early in the game, seen from the perspective of the white player.\nIn this figure, white has just rolled the dice and obtained a 5 and a 2. This means that he can move one of his pieces 5 steps and one (possibly the same piece) 2 steps.\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nFor example, he could move two pieces from the 12 point, one to the 17 point, and one to the 14 point. White\\A1\\AFs objective is to advance all of his pieces into the last quadrant (points 19-24) and then off the board. The first player to remove all his pieces wins. One complication is that the pieces interact as they pass each other going in different directions. For example, if it were black\\A1\\AFs move in Figure 16.1, he could use the dice roll of 2 to move a piece from the 24 point to the 22 point, \\A1\\B0hitting\\A1\\B1 the white piece there. Pieces that have been hit are placed on the \\A1\\B0bar\\A1\\B1 in the middle of the board (where we already see one previously hit black piece), from whence they reenter the race from the start. However, if there are two pieces on a point, then the opponent cannot move to that point; the pieces are protected from being hit. Thus, white cannot use his 5-2 dice roll to move either of his pieces on the 1point, because their possible resulting points are occupied by groups of black pieces. Forming contiguous blocks of occupied points to block the opponent is one of the elementary strategies of the game.\nBackgammon involves several further complications, but the above description gives the basic idea. With 30 pieces and 24 possible locations (26, counting the bar and off-the-board) it should be clear that the number of possible backgammon positions is enormous, far more than the number of memory elements one could have in any physically realizable computer. The number of moves possible from each position is also large. For a typical dice roll there might be 20 different ways of playing. In considering future moves, such as the response of the opponent, one must consider the possible dice rolls as well. The result is that the game tree has an effective branching factor of about 400. This is far too large to permit effective use of the conventional heuristic search methods that have proved so effective in games like chess and checkers.\nOn the other hand, the game is a good match to the capabilities of TD learning methods. Although the game is highly stochastic, a complete description of the game\\A1\\AFs state is available at all times. The game evolves over a sequence of moves and positions until finally ending in a win for one player or the other, ending the game. The outcome can be interpreted as a final reward to be predicted. On theother hand, the theoretical results we have described so far cannot be usefully applied to this task. The number of states is so large that a lookup table cannot be used, and the opponent is a source of uncertainty and time variation.\nTD-Gammon used a nonlinear form of TD(A). The estimated value, v(s,w), of any state (board position) swas meant to estimate the probability of winning starting from state s. To achieve this, rewards were defined as zero for all time steps except those on which the game is won. To implement the value function, TD-Gammon used a standard multilayer neural network, much as shown in Figure 16.2. (The real network had two additional units in its final layer to estimate the probability of each player\\A1\\AFs winning in a special way called a \\A1\\B0gammon\\A1\\B1 or \\A1\\B0backgammon.\\A1\\B1) The network consisted of a layer of input units, a layer of hidden units, and a final output unit. The input to the network was a representation of a backgammon position, and the output was an estimate of the value of that position.\n   predictedprobability\n        hidden units(40-80)\n        Figure 16.2: The neural network used in TD-Gammon\n        backgammon position (198 input units)\n     In the first version of TD-Gammon, TD-Gammon 0.0, backgammon positions were represented to the network in a relatively direct way that involved little backgammon knowledge. It did, however, involve substantial knowledge of how neural networks work and how information is best presented to them. It is instructive to note the exact representation Tesauro chose. There were a total of 198 input units to the network. For each point on the backgammon board, four units indicated the number of white pieces on the point. If there were no white pieces, then all four units took on the value zero. If there was one piece, then the first unit took on the value 1. This encoded the elementary concept of a \\A1\\B0blot,\\A1\\B1 i.e., a piece that can be hit by the opponent. If there were two or more pieces, then the second unit was set to 1. This encoded the basic concept of a \\A1\\B0made point\\A1\\B1 on which the opponent cannot land. If there were exactly three pieces on the point, then the third unit was set to 1. This encoded the basic concept of a \\A1\\B0single spare,\\A1\\B1 i.e., an extra piece in addition to the two pieces that made the point. Finally, if there were more than three pieces, the fourth unit was set to a value proportionate to the number of additional pieces beyond three. Letting ndenote the total number of pieces on the point, if n\u0026gt; 3, then the fourth unit took on the value (n \\A1\\AA3)/2.This encoded a linear representationof \\A1\\B0multiple spares\\A1\\B1 at the given point.\nWith four units for white and four for black at each of the 24 points, that made a total of 192 units. Two additional units encoded the number of white and black pieces on the bar (each took the value n/2, where n is the number of pieces on the bar), and two more encoded the number of black and white pieces already successfully removed from the board (these took the value n/15, where n is the number of pieces already borne off). Finally, two units indicated in a binary fashion whether it was white\\A1\\AFs or black\\A1\\AFs turn to move. The general logic behind these choices should be clear. Basically, Tesauro tried to represent the position in a straightforward way, while keeping the number of units relatively small. He provided one unit for each conceptually distinct possibility that seemed likely to be relevant, and he scaled them to roughly the same range, in this case between 0and 1.\nGiven a representation of a backgammon position, the network computed its esti\u0026shy;mated value in the standard way. Corresponding to each connection from an input unit to a hidden unit was a real-valued weight. Signals from each input unit were multiplied by their corresponding weights and summed at the hidden unit. The output, h(j), of hidden unit j was a nonlinear sigmoid function of the weighted sum:\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nwhere x is the value of the ith input unit and Wj- is the weight of its connection to the jth hidden unit (all the weights in the network together make up the parameter vector w). The output of the sigmoid is always between 0 and 1, and has a natural interpretation as a probability based on a summation of evidence. The computation from hidden units to the output unit was entirely analogous. Each connection from a hidden unit to the output unit had a separate weight. The output unit formed the weighted sum and then passed it through the same sigmoid nonlinearity.\nTD-Gammon used the semi-gradient form of the TD(A) algorithm described in Section 12.2, with the gradients computed by the error backpropagation algorithm (Rumelhart, Hinton, and Williams, 1986). Recall that the general update rule for this case is\nwtʮ1== wt + a Rt+1+ Y^(St+1,wt) \\A1\\AA v(St,wt) eu\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (16.1)\nwhere wt is the vector of all modifiable parameters (in this case, the weights of the network) and et is a vector of eligibility traces, one for each component of wt, updated by\net == 7Aet-i + W(St,wt),\nwith eo == 0. The gradient in this equation can be computed efficiently by the backpropagation procedure. For the backgammon application, in which 7= 1 and the reward is always zero except upon winning, the TD error portion of the learning rule is usually just v(St+i,w) \\A1\\AA {)(St,w), as suggested in Figure 16.2.\nTo apply the learning rule we need a source of backgammon games. Tesauro obtained an unending sequence of games by playing his learning backgammon player against itself. To choose its moves, TD-Gammon considered each of the 20 or so ways it could play its dice roll and the corresponding positions that would result. The resulting positions are afterstatesas discussed in Section 6.8. The network was consulted to estimate each of their values. The move was then selected that would lead to the position with the highest estimated value. Continuing in this way, with TD-Gammon making the moves for both sides, it was possible to easily generate large numbers of backgammon games. Each game was treated as an episode, with\nthe sequence of positions acting as the states, So, Si, S2,\u0026nbsp;\u0026nbsp;\u0026nbsp;  Tesauro applied the\nnonlinear TD rule (16.1) fully incrementally, that is, after each individual move.\nThe weights of the network were set initially to small random values. The initial evaluations were thus entirely arbitrary. Since the moves were selected on the basis of these evaluations, the initial moves were inevitably poor, and the initial games often lasted hundreds or thousands of moves before one side or the other won, almost by accident. After a few dozen games however, performance improved rapidly.\nAfter playing about 300,000 games against itself, TD-Gammon 0.0 as described above learned to play approximately as well as the best previous backgammon com\u0026shy;puter programs. This was a striking result because all the previous high-performance computer programs had used extensive backgammon knowledge. For example, the reigning champion program at the time was, arguably, Neurogammon,another pro\u0026shy;gram written by Tesauro that used a neural network but not TD learning. Neu\u0026shy;rogammon\\A1\\AFs network was trained on a large training corpus of exemplary moves provided by backgammon experts, and, in addition, started with a set of features specially crafted for backgammon. Neurogammon was a highly tuned, highly effec\u0026shy;tive backgammon program that decisively won the World Backgammon Olympiad in 1989. TD-Gammon 0.0, on the other hand, was constructed with essentially zero backgammon knowledge. That it was able to do as well as Neurogammon and all other approaches is striking testimony to the potential of self-play learning methods.\nThe tournament success of TD-Gammon 0.0 with zero expert backgammon knowl\u0026shy;edge suggested an obvious modification: add the specialized backgammon features but keep the self-play TD learning method. This produced TD-Gammon 1.0. TD- Gammon 1.0 was clearly substantially better than all previous backgammon pro\u0026shy;grams and found serious competition only among human experts. Later versions of the program, TD-Gammon 2.0 (40 hidden units) and TD-Gammon 2.1 (80 hidden units), were augmented with a selective two-ply search procedure. To select moves, these programs looked ahead not just to the positions that would immediately result, but also to the opponent\\A1\\AFs possible dice rolls and moves. Assuming the opponent always took the move that appeared immediately best for him, the expected value of each candidate move was computed and the best was selected. To save computer time, the second ply of search was conducted only for candidate moves that were ranked highly after the first ply, about four or five moves on average. Two-ply search affected only the moves selected; the learning process proceeded exactly as before. The final versions of the program, TD-Gammon 3.0 and 3.1, used 160 hidden units\nProgram\n Hidden\nUnits\n Training\nGames\n Opponents\n Results\n  TD-Gam 0.0\n 40\n 300,000\n other programs\n tied for best\n  TD-Gam 1.0\n 80\n 300,000\n Robertie, Magriel, ...\n \\A1\\AA13 pts / 51 games\n  TD-Gam 2.0\n 40\n 800,000\n various Grandmasters\n \\A1\\AA7 pts / 38 games\n  TD-Gam 2.1\n 80\n 1,500,000\n Robertie\n \\A1\\AA1 pt / 40 games\n  TD-Gam 3.0\n 80\n 1,500,000\n Kazaros\n +6pts / 20games\n     Table 16.1: Summary of TD-Gammon Results\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nand a selective three-ply search. TD-Gammon illustrates the combination of learned value functions and decision-time search as in heuristic search and MCTS methods. In follow-on work, Tesauro and Galperin (1997) explored trajectory sampling meth\u0026shy;ods as an alternative to full-width search, which reduced the error rate of live play by large numerical factors (4x-6x) while keeping the think time reasonable at \u0026#12316;5-10 seconds per move.\nDuring the 1990s, Tesauro was able to play his programs in a significant number of games against world-class human players. A summary of the results is given in Table 16.1. Based on these results and analyses by backgammon grandmasters (Robertie, 1992; see Tesauro, 1995), TD-Gammon 3.0 appeared to play at close to, or possibly better than, the playing strength of the best human players in the world. Tesauro reported in a subsequent article (Tesauro, 2002) the results of an extensive rollout analysis of the move decisions and doubling decisions of TD-Gammon relative to top human players. The conclusion was that TD-Gammon 3.1 had a \\A1\\B0lopsided advantage\\A1\\B1 in piece-movement decisions, and a \\A1\\B0slight edge\\A1\\B1 in doubling decisions, over top humans.\nTD-Gammon had a significant impact on the way the best human players play the game. For example, it learned to play certain opening positions differently than was the convention among the best human players. Based on TD-Gammon\\A1\\AFs success and further analysis, the best human players now play these positions as TD-Gammon does (Tesauro, 1995). The impact on human play was greatly accelerated when sev\u0026shy;eral other self-teaching neural net backgammon programs inspired by TD-Gammon, such as Jellyfish, Snowie, and GNUBackgammon, became widely available. These programs enabled wide dissemination of new knowledge generated by the neural nets, resulting in great improvements in the overall caliber of human tournament play (Tesauro, 2002).\n16.2\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Samuel,s Checkers Player\nAn important precursor to Tesauro\\A1\\AFs TD-Gammon was the seminal work of Arthur Samuel (1959, 1967) in constructing programs for learning to play checkers. Samuel was one of the first to make effective use of heuristic search methods and of what we would now call temporal-difference learning. His checkers players are instructive \n\n\ncase studies in addition to being of historical interest. We emphasize the relationship of Samuel\\A1\\AFs methods to modern reinforcement learning methods and try to convey some of Samuel\\A1\\AFs motivation for using them.\nSamuel first wrote a checkers-playing program for the IBM 701 in 1952. His first learningprogram was completed in 1955 and was demonstrated on television in 1956. Later versions of the program achieved good, though not expert, playing skill. Samuel was attracted to game-playing as a domain for studying machine learning because games are less complicated than problems \\A1\\B0taken from life\\A1\\B1 while still allowing fruitful study of how heuristic procedures and learning can be used together. He chose to study checkers instead of chess because its relative simplicity made it possible to focus more strongly on learning.\nSamuel\\A1\\AFs programs played by performing a lookahead search from each current position. They used what we now call heuristic search methods to determine how to expand the search tree and when to stop searching. The terminal board positions of each search were evaluated, or \\A1\\B0scored,\\A1\\B1 by a value function, or \\A1\\B0scoring polynomial,\\A1\\B1 using linear function approximation. In this and other respects Samuel\\A1\\AFs work seems to have been inspired by the suggestions of Shannon (1950). In particular, Samuel\\A1\\AFs program was based on Shannon\\A1\\AFs minimax procedure to find the best move from the current position. Working backward through the search tree from the scored terminal positions, each position was given the score of the position that would result from the best move, assuming that the machine would always try to maximize the score, while the opponent would always try to minimize it. Samuel called this the backed-up score of the position. When the minimax procedure reached the search tree\\A1\\AFs root\\A1\\AAthe current position\\A1\\AAit yielded the best move under the assumption that the opponent would be using the same evaluation criterion, shifted to its point of view. Some versions of Samuel\\A1\\AFs programs used sophisticated search control methods analogous to what are known as \\A1\\B0alpha-beta\\A1\\B1 cutoffs (e.g., see Pearl, 1984).\nSamuel used two main learning methods, the simplest of which he called rote learn\u0026shy;ing. It consisted simply of saving a description of each board position encountered during play together with its backed-up value determined by the minimax procedure. The result was that if a position that had already been encountered were to occur again as a terminal position of a search tree, the depth of the search was effectively amplified since this position\\A1\\AFs stored value cached the results of one or more searches conducted earlier. One initial problem was that the program was not encouraged to move along the most direct path to a win. Samuel gave it a \\A1\\B0a sense of direc\u0026shy;tion\\A1\\B1 by decreasing a position\\A1\\AFs value a small amount each time it was backed up a level (called a ply) during the minimax analysis. \\A1\\B0If the program is now faced with a choice of board positions whose scores differ only by the ply number, it will automatically make the most advantageous choice, choosing a low-ply alternative if winning and a high-ply alternative if losing\\A1\\B1 (Samuel, 1959, p. 80). Samuel found this discounting-like technique essential to successful learning. Rote learning produced slow but continuous improvement that was most effective for opening and endgame play. His program became a \\A1\\B0better-than-average novice\\A1\\B1 after learning from many games against itself, a variety of human opponents, and from book games in a su-\n \nFigure 16.3: The backup diagram for Samuel\\A1\\AFs checkers player.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\npervised learning mode.\nRote learning and other aspects of Samuel\\A1\\AFs work strongly suggest the essential idea of temporal-difference learningһthat the value of a state should equal the value of likely following states. Samuel came closest to this idea in his second learning method, his \\A1\\B0learning by generalization\\A1\\B1 procedure for modifying the parameters of the value function. Samuel\\A1\\AFs method was the same in concept as that used much later by Tesauro in TD-Gammon. He played his program many games against another version of itself and performed a backup operation after each move. The idea of Samuel\\A1\\AFs backup is suggested by the diagram in Figure 16.3. Each open circle represents a position where the program moves next, an on-moveposition, and each solid circle represents a position where the opponent moves next. A backup was made to the value of each on-move position after a move by each side, resulting in a second on- move position. The backup was toward the minimax value of a search launched from the second on-move position. Thus, the overall effect was that of a backup consisting of one full move of real events and then a search over possible events, as suggested by Figure 16.3. Samuel\\A1\\AFs actual algorithm was significantly more complex than this for computational reasons, but this was the basic idea.\nSamuel did not include explicit rewards. Instead, he fixed the weight of the most important feature, the piece advantagefeature, which measured the number of pieces the program had relative to how many its opponent had, giving higher weight to kings, and including refinements so that it was better to trade pieces when winning than when losing. Thus, the goal of Samuel\\A1\\AFs program was to improve its piece advantage, which in checkers is highly correlated with winning.\nHowever, Samuel\\A1\\AFs learning method may have been missing an essential part of a sound temporal-difference algorithm. Temporal-difference learning can be viewed as a way of making a value function consistent with itself, and this we can clearly see in Samuel\\A1\\AFs method. But also needed is a way of tying the value function to the true value of the states. We have enforced this via rewards and by discounting or giving a fixed value to the terminal state. But Samuel\\A1\\AFs method included no rewards and no special treatment of the terminal positions of games. As Samuel himself pointed out, his value function could have become consistent merely by giving a constant value to all positions. He hoped to discourage such solutions by giving his piece-advantage term a large, nonmodifiable weight. But although this may decrease the likelihood of finding useless evaluation functions, it does not prohibit them. For example, a constant function could still be attained by setting the modifiable weights so as to cancel the effect of the nonmodifiable one.\nSince Samuel\\A1\\AFs learning procedure was not constrained to find useful evaluation functions, it should have been possible for it to become worse with experience. In fact, Samuel reported observing this during extensive self-play training sessions. To get the program improving again, Samuel had to intervene and set the weight with the largest absolute value back to zero. His interpretation was that this drastic intervention jarred the program out of local optima, but another possibility is that it jarred the program out of evaluation functions that were consistent but had little to do with winning or losing the game.\nDespite these potential problems, Samuel\\A1\\AFs checkers player using the generaliza\u0026shy;tion learning method approached \\A1\\B0better-than-average\\A1\\B1 play. Fairly good amateur opponents characterized it as \\A1\\B0tricky but beatable\\A1\\B1 (Samuel, 1959). In contrast to the rote-learning version, this version was able to develop a good middle game but remained weak in opening and endgame play. This program also included an ability to search through sets of features to find those that were most useful in forming the value function. A later version (Samuel, 1967) included refinements in its search procedure, such as alpha-beta pruning, extensive use of a supervised learning mode called \\A1\\B0book learning,\\A1\\B1 and hierarchical lookup tables called signature tables (Grif\u0026shy;fith, 1966) to represent the value function instead of linear function approximation. This version learned to play much better than the 1959 program, though still not at a master level. Samuel\\A1\\AFs checkers-playing program was widely recognized as a significant achievement in artificial intelligence and machine learning.\n16.3\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; The Acrobot\nReinforcement learning has been applied to a wide variety of physical control tasks (e.g., for a collection of robotics applications, see Kober and Peters, 2012). One such task is the acrobot, a two-link, underactuated robot roughly analogous to a gymnast swinging on a high bar (Figure 16.4). The first joint (corresponding to the gymnast\\A1\\AFs hands on the bar) cannot exert torque, but the second joint (corresponding to the gymnast bending at the waist) can. The system has four continuous state variables: two joint positions and two joint velocities. The equations of motion are given in Figure 16.5. This system has been widely studied by control engineers (e.g., Spong, 1994) and machine-learning researchers (e.g., Dejong and Spong, 1994; Boone, 1997).\nOne objective for controlling the acrobot is to swing the tip (the \\A1\\B0feet\\A1\\B1) above the first joint by an amount equal to one of the links in minimum time. In this task, the torque applied at the second joint is limited to three choices: positive torque of a fixed magnitude, negative torque of the same magnitude, or no torque. A reward of \\A1\\AA1 is given on all time steps until the goal is reached, which ends the episode. No discounting is used (7= 1). Thus, the optimal value, v^(s),of any state, s, is the minimum time to reach the goal (an integer number of steps) starting from s.\nSutton (1996) addressed the acrobot swing-up task in an on-line, modelfree con\u0026shy;text. Although the acrobot was simulated, the simulator was not available for use by the agent/controller in any way. The training and interaction were just as if a real, physical acrobot had been used. Each episode began with both links of the ac\u0026shy;robot hanging straight down and at rest. Torques were applied by the reinforcement learning agent until the goal was reached, which always happened eventually. Then the acrobot was restored to its initial rest position and a new episode was begun.\nThe learning algorithm used was Sarsa(A) with linear function approximation, tile coding, and replacing traces as on page 319. With a small, discrete action set, it is natural to use a separate set of tilings for each action. The next choice is of the continuous variables with which to represent the state. A clever designer would probably represent the state in terms of the angular position and velocity of the center of mass and of the second link, which might make the solution simpler and consistent with broad generalization. But since this was just a test problem, a more naive, direct representation was used in terms of the positions and velocities of the links: 0i,6i,02, and 62. The two angles are restricted to a limited range by the physics of the acrobot (see Figure 16.5) and the two angles are naturally restricted to [0, 2n]. Thus, the state space in this task is a bounded rectangular region in four dimensions.\nThis leaves the question of what tilings to use. There are many possibilities, as discussed in Chapter 9. One is to use a complete grid, slicing the four-dimensional space along all dimensions, and thus into many small four-dimensional tiles. Alterna\u0026shy;tively, one could slice along only one of the dimensions, making hyperplanar stripes. In this case one has to pick which dimension to slice along. And of course in all\nGoal: Raise tip above line\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n tip\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 16.4: The acrobot.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\n-d- (d202+ 0i) f72 \\-\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; i\n   0i = 6*2=\nwhere\ndi = d2=\n\\9Bli =\n\\9Bl2=\n     d2\nm21^2+ h \\A1\\AA di J( T + di\\9Bli \\A1\\AA m2li1c2^?2sin 6 \\A1\\AA\\9Bl2\nmil^i + צ2\\CF\\FB+ 1^2+ 21i1c2cos 02) + h+ h m2(1^2+ 1i 1c2cos 6*2) + h \\A1\\AAm2li1c2^?2sin 02\\A1\\AA 2m2li1c2^62^6i sin 02 + (milci + m2li)g cos(0i \\A1\\AA n/2) + \\9Bl2 m2lc2g cos(0i + 02\\A1\\AA n/2).\nFigure 16.5: The equations of motions of the simulated acrobot. A time step of 0.05 seconds was used in the simulation, with actions chosen after every four time steps. The torque applied at the second joint is denoted by t G {+1, \\A1\\AA1, 0}. There were no constraints on the joint positions, but the angular velocities were limited to G [\\A1\\AA4n, 4n] and 02G [\\A1\\AA9n, 9n]. The constants were mi = m2= 1 (masses of the links), 1i = I2= 1 (lengths of links), 1ci = 1C2= 0.5 (lengths to center of mass of links), Ii = I2= 1 (moments of inertia of links), and g = 9.8 (gravity).\ncases one has to pick the width of the slices, the number of tilings of each kind, and, if there are multiple tilings, how to offset them. One could also slice along pairs or triplets of dimensions to get other tilings. For example, if one expected the velocities of the two links to interact strongly in their effect on value, then one might make many tilings that sliced along both of these dimensions. If one thought the region around zero velocity was particularly critical, then the slices could be more closely spaced there.\nSutton used tilings that sliced in a variety of simple ways. Each of the four di\u0026shy;mensions was divided into six equal intervals. A seventh interval was added to the angular velocities so that tilings could be offset by a random fraction of an inter\u0026shy;val in all dimensions (see Chapter 9, subsection \\A1\\B0Tile Coding\\A1\\B1\\A3\\A9. Of the total of 48 tilings, 12sliced along all four dimensions as discussed above, dividing the space into\n6\u0026nbsp;\u0026nbsp;\u0026nbsp; x 7 x 6x 7 = 1764 tiles each. Another 12tilings sliced along three dimensions (3 randomly offset tilings each for each of the 4 sets of three dimensions), and another 12sliced along two dimensions (2tilings for each of the 6sets of two dimensions. Finally, a set of 12 tilings depended each on only one dimension (3 tilings for each of the 4 dimensions). This resulted in a total of approximately 25, 000 tiles for each action. This number is small enough that hashing was not necessary. All tilings were offset by a random fraction of an interval in all relevant dimensions.\n   Figure 16.6: Learning curves for Sarsa(A) on the acrobot task.\n        Episodes\n     The remaining parameters of the learning algorithm were a = 0.2/48, A = 0.9, e = 0, and wo = 0. The use of a greedy policy (^ = 0) seemed preferable on this task because long sequences of correct actions are needed to do well. One exploratory action could spoil a whole sequence of good actions. Exploration was ensured instead \n\n\nby starting the action values optimistically, at the low value of 0. As discussed in Section 2.7 and Example 9.2, this makes the agent continually disappointed with whatever rewards it initially experiences, driving it to keep trying new things.\nFigure 16.6 shows learning curves for the acrobot task and the learning algorithm described above. Note from the single-run curve that single episodes were sometimes extremely long. On these episodes, the acrobot was usually spinning repeatedly at the second joint while the first joint changed only slightly from vertical down. Although this often happened for many time steps, it always eventually ended as the action values were driven lower. All runs ended with an efficient policy for solving the problem, usually lasting about 75 steps. A typical final solution is shown in\n \n   %\n     \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n  \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 16.7: A typical learned behavior of the acrobot. Each group is a series of consecutive positions, the thicker line being the first. The arrow indicates the torque applied at the second joint.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\n\n\u0026nbsp;\nFigure 16.7. First the acrobot pumps back and forth several times symmetrically, with the second link always down. Then, once enough energy has been added to the system, the second link is swung upright and stabbed to the goal height.\n16.4\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Watson\\A1\\AFs Daily-Double Wagering\nIBM Watson[31] is the system developed by a team of IBM researchers to play the popular TV quiz show Jeopardy!.[32]It gained fame in 2011 by winning first prize in an exhibition match against human champions. Although the main technical achievement demonstrated by Watson was its ability to quickly and accurately answer natural language questions over broad areas of general knowledge, its win\u0026shy;ning Jeopardy!performance also relied on sophisticated decision-making strategies for critical parts of the game. Tesauro, Gondek, Lechner, Fan, and Prager (2012, 2013) adapted Tesauro\\A1\\AFs TD-Gammon system described above to create the strategy used by Watson in \\A1\\B0Daily-Double\\A1\\B1 (DD) wagering in its celebrated winning perfor\u0026shy;mance against human champions. These authors report that the effectiveness of this wagering strategy went well beyond what human players are able to do in live game play, and that it, along with other advanced strategies, was an important contributor to Watson\\A1\\AFs impressive winning performance. Here we focus only on DD wager\u0026shy;ing because it is the component of Watson that owes the most to reinforcement learning.\nJeopardy!is played by three contestants who face a board showing 30 squares, each of which hides a clue and has a dollar value. The squares are arranged in six columns, each corresponding to a different category. A contestant selects a square, the host reads the square\\A1\\AFs clue, and each contestant may choose to respond to the clue by sounding a buzzer (\\A1\\B0buzzing in\\A1\\B1). The first contestant to buzz in gets to try responding to the clue. If this contestant\\A1\\AFs response is correct, their score increases by the dollar value of the square; if their response is not correct, or if they do not respond within five seconds, their score decreases by that amount, and the other contestants get a chance to buzz in to respond to the same clue. One or two squares (depending on the game\\A1\\AFs current round) are special DD squares. A contestant who selects one of these gets an exclusive opportunity to respond to the square\\A1\\AFs clue and has to decideһbefore the clue is revealedһon how much to wager, or bet. The bet has to be greater than five dollars but not greater than the contestant\\A1\\AFs current score. If the contestant responds correctly to the DD clue, their score increases by the bet amount; otherwise it decreases by the bet amount. At the end of each game is a \\A1\\B0Final Jeopardy\\A1\\B1 (FJ) round in which each contestant writes down a sealed bet and then writes an answer after the clue is read. The contestant with the highest score after three rounds of play (where a round consists of revealing all 30 clues) is the winner. The game has many other details, but these are enough to appreciate the importance of DD wagering. Winning or losing often depends on a contestant\\A1\\AFs DD wagering strategy.\nWhenever Watson selected a DD square, it chose its bet by comparing action values, q(s, bet), that estimated the probability of a win from the current game state, s, for each round-dollar legal bet. Except for some risk-abatement measures described below, Watson selected the bet with the maximum action value. Action values were computed whenever a betting decision was needed by using two types of estimates that were learned before any live game play took place. The first were estimated values of the afterstates (Section 6.8) that would result from selecting each legal bet. These estimates were obtained from a state-value function, {)(-,w), defined by parameters w, that gave estimates of the probability of a win for Watson from any game state. The second estimates used to compute action values gave the \\A1\\B0in\u0026shy;category DD confidence,\\A1\\B1 pdd, which estimated the likelihood that Watson would respond correctly to the as-yet unrevealed DD clue.\nTesauro et al. used the reinforcement learning approach of TD-Gammon described above to learn v(-,w):a straightforward combination of nonlinear TD(A) using a multilayer neural network with weights w trained by backpropagating TD errors during many simulated games. States were represented to the network by feature vectors specifically designed for Jeopardy!.Features included the current scores of the three players, how many DDs remained, the total dollar value of the remaining clues, and other information related to the amount of play left in the game. Unlike TD-Gammon, which learned by self-play, Watson\\A1\\AFs Vwas learned over millions of simulated games against carefully-crafted models of human players. In-category confidence estimates were conditioned on the number of right responses rand wrong responses wthat Watson gave in previously-played clues in the current category. The dependencies on (r, w) were estimated from Watson\\A1\\AFs actual accuracies over many thousands of historical categories.\nWith the previously learned value function v and in-category DD confidence pdd , Watson computed q(s, bet) for each legal round-dollar bet as follows:\nq(s, bet) = pdd x V(Sw + bet,...) + (1\\A1\\AA pdd) x v(Sw \\A1\\AA bet,...),\u0026nbsp; (16.2)\nwhere Sw is Watson\\A1\\AFs current score, and v gives the estimated value for the game state after Watson\\A1\\AFs response to the DD clue, which is either correct or incorrect. Computing an action value this way corresponds to the insight from Exercise 3.12 that an action value is the expected next state value given the action (except that here it is the expected next afterstatevalue because the full next state of the entire game depends on the next square selection).\nTesauro et al. found that selecting bets by maximizing action values incurred \\A1\\B0a frightening amount of risk,\\A1\\B1 meaning that if Watson\\A1\\AFsresponse to the clue happened to be wrong, the loss could be disastrous for its chances of winning. To decrease the downside risk of a wrong answer, Tesauro et al. adjusted (16.2) by subtracting a small fraction of the standard deviation over Watson\\A1\\AFscorrect/incorrect afterstate evaluataions. They further reduced risk by prohibiting bets that would cause the wrong-answer afterstate value to decrease below a certain limit. These measures slightly reduced Watson\\A1\\AFsexpectation of winning, but they significantly reduced downside risk, not only in terms of average risk per DD bet, but even more so in extreme-risk scenarios where a risk-neutral Watson would bet most or all of its bankroll.\nWhy was the TD-Gammon method of self-play not used to learn the critical value function v? Learning from self-play in Jeopardy!would not have worked very well because Watson was so different from any human contestant. Self-play would have led to exploration of state space regions that are not typical for play against human opponents, particularly human champions. In addition, unlike backgammon, Jeop\u0026shy;ardy!is a game of imperfect information because contestants do not have access to all the information influencing their opponents\\A1\\AF play. In particular, Jeopardy!con\u0026shy;testants do not know how much confidence their opponents have for responding to clues in the various categories. Self-play would have been something like playing poker with someone who is holding the same cards that you hold.\nAs a result of these complications, much of the effort in developing Watson\\A1\\AFs DD-wagering strategy was devoted to creating good models of human opponents. The models did not address the natural language aspect of the game, but were instead stochastic process models of events that can occur during play. Statistics were extracted from an extensive fan-created archive of game information from the beginning of the show to the present day. The archive includes information such as the ordering of the clues, right and wrong contestant answers, DD locations, and DD and FJ bets for nearly 300,000 clues. Three models were constructed: an Average Contestant model (based on all the data), a Champion model (based on statistics from games with the 100 best players), and a Grand Champion model (based on statistics from games with the 10 best players). In addition to serving as opponents during learning, the models were used to asses the benefits produced by the learned DD-wagering strategy. Watson\\A1\\AFs win rate in simulation when it used a baseline heuristic DD-wagering strategy was 61%; when it used the learned values and a default confidence value, its win rate increased to 64%; and with live in-category confidence, it was 67%. Tesauro et al. regarded this as a significant improvement, given that the DD wagering was needed only about 1.5 to 2 times in each game.\nBecause Watson had only a few seconds to bet, as well as to select squares and decide whether or not to buzz in, the computation time needed to make these decisions was a critical factor. The neural network implementation of v allowed DD bets to be made quickly enough to meet the time constraints of live play. However, once games could be simulated fast enough through improvements in the simulation software, near the end of a game it was feasible to estimate the value of bets by averaging over many Monte-Carlo trials in which the consequence of each bet was determined by simulating play to the game\\A1\\AFs end. Selecting endgame DD bets in live play based on Monte-Carlo trials instead of the neural network significantly improved Watson\\A1\\AFs performance because errors in value estimates in endgames could seriously affect its chances of winning. Making all the decisions via Monte-Carlo trials might have led to better wagering decisions, but this was simply impossible given the complexity of the game and the time constraints of live play.\nAlthough its ability to quickly and accurately answer natural language questions stands out as Watson\\A1\\AFs major achievement, all of its sophisticated decision strategies \n\n\ncontributed to its impressive defeat of human champions. According to Tesauro et al. (2012):\n... it is plainly evident that our strategy algorithms achieve a level of quantitative precision and real-time performance that exceeds human ca\u0026shy;pabilities. This is particularly true in the cases of DD wagering and endgame buzzing, where humans simply cannot come close to matching the precise equity and confidence estimates and complex decision calcu\u0026shy;lations performed by Watson.\n16.5\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Optimizing Memory Control\nMost computers use dynamic random access memory (DRAM) as their main memory because of its low cost and high capacity. The job of a DRAM memory controller is to efficiently use the interface between the processor chip and an off-chip DRAM system to provide the high-bandwidth and low-latency data transfer necessary for high-speed program execution. A memory controller needs to deal with dynamically changing patterns of read/write requests while adhering to a large number of timing and resource constraints required by the hardware. This is a formidable scheduling problem, especially with modern processors with multiple cores sharing the same DRAM.\nIpek, Mutlu, Martinez, and Caruana (2008) (also Martinez and Ipek, 2009) de\u0026shy;signed a reinforcement learning memory controller and demonstrated that it can significantly improve the speed of program execution over what was possible with conventional controllers at the time of their research. They were motivated by lim\u0026shy;itations of existing state-of-the-art controllers that used policies that did not take advantage of past scheduling experience and did not account for long-term conse\u0026shy;quences of scheduling decisions. Ipek et al.\\A1\\AFs project was carried out by means of simulation, but they designed the controller at the detailed level of the hardware needed to implement it\\A1\\AAincluding the learning algorithm\\A1\\AAdirectly on a processor chip.\nAccessing DRAM involves a number of steps that have to be done according to strict time constraints. DRAM systems consist of multiple DRAM chips, each con\u0026shy;taining multiple rectangular arrays of storage cells arranged in rows and columns. Each cell stores a bit as the charge on a capacitor. Since the charge decreases over time, each DRAM cell needs to be recharged\\A1\\AArefreshed\\A1\\AAevery few milliseconds to prevent memory content from being lost. This need to refresh the cells is why DRAM is called \\A1\\B0dynamic.\\A1\\B1\nEach cell array has a row buffer that holds a row of bits that can be transferred into or out of one of the array\\A1\\AFs rows. An activatecommand \\A1\\B0opens a row,\\A1\\B1 which means moving the contents of the row whose address is indicated by the command into the row buffer. With a row open, the controller can issue readand writecommands to the cell array. Each read command transfers a word (a short sequence of consecutive bits) in the row buffer to the external data bus, and each write command transfers a word in the external data bus to the row buffer. Before a different row can be opened, a prechargecommand must be issued which transfers the (possibly updated) data in the row buffer back into the addressed row of the cell array. After this, another activate command can open a new row to be accessed. Read and write commands are column commandsbecause they sequentially transfer bits into or out of columns of the row buffer; multiple bits can be transferred without re-opening the row. Read and write commands to the currently-open row can be carried out more quickly than accessing a different row, which would involve additional row commands: precharge and activate; this is sometimes referred to as \\A1\\B0row locality.\\A1\\B1 A memory controller maintains a memory transaction queuethat stores memory-access requests from the processors sharing the memory system. The controller has to process requests by issuing commands to the memory system while adhering to a large number of timing constraints.\nA controller\\A1\\AFs policy for scheduling access requests can have a large effect on the performance of the memory system, such as the average latency with which requests can be satisfied and the throughput the system is capable of achieving. The simplest scheduling strategy handles access requests in the order in which they arrive by issu\u0026shy;ing all the commands required by the request before beginning to service the next one. But if the system is not ready for one of these commands, or executing a command would result in resources being underutilized (e.g., due to timing constraints arising from servicing that one command), it makes sense to begin servicing a newer request before finishing the older one. Policies can gain efficiency by reordering requests, for example, by giving priority to read requests over write requests, or by giving priority to read/write commands to already open rows. The policy called First-Ready, First- Come-First-Serve (FR-FCFS), gives priority to column commands (read and write) over row commands (activate and precharge), and in case of a tie gives priority to the oldest command. FR-FCFS was shown to outperform other scheduling policies in terms of average memory-access latency under conditions commonly encountered (Rixner, 2004).\nFigure 16.8 is a high-level view of Ipek et al.\\A1\\AFs reinforcement learning memory controller. They modeled the DRAM access process as an MDP whose states are the contents of the transaction queue and whose actions are commands to the DRAM system: precharge, activate, read, write, and NoOp. The reward signal is 1 whenever the action is reador write, and otherwise it is 0. State transitions were considered to be stochastic because the next state of the system not only depends on the scheduler\\A1\\AFs command, but also on aspects of the system\\A1\\AFs behavior that the scheduler cannot control, such as the workloads of the processor cores accessing the DRAM system.\nCritical to this MDP are constraints on the actions available in each state. Recall from Chapter 3 that the set of available actions can depend on the state: At G A(St), where At is the action at time step tand A(St) is the set of actions available in state St. In this application, the integrity of the DRAM system was assured by not allowing actions that would violate timing or resource constraints. Although Ipek et al. did not make it explicit, they effectively accomplished this by pre-defining the sets A(St) for all possible states St.\n \n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n Figure 16.8: High-level view of the reinforcement learning DRAM controller. The scheduler is the reinforcement learning agent. Its environment is represented by features of the trans\u0026shy;action queue, and its actions are commands to the DRAM system. \u0026copy;2009 IEEE. Reprinted, with permission, from J. F. Martinez and E. Ipek, Dynamic multicore resource management: A machine learning approach, Micro, IEEE, 29(5), p. 12.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n lAJVQCa\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nThese constraints explain why the MDP has a NoOpaction and why the reward signal is 0 except when a reador writecommand is issued. NoOpis issued when it is the sole legal action in a state. To maximize utilization of the memory system, the controller\\A1\\AFs task is to drive the system to states in which either a reador a write action can be selected: only these actions result in sending data over the external data bus, so it is only these that contribute to the throughput of the system. Although prechargeand activateproduce no immediate reward, the agent needs to select these actions to make it possible to later select the rewarded readand writeactions.\nThe scheduling agent used Sarsa (Figure 6.4) to learn an action-value function. States were represented by six integer-valued features. To approximate the action- value function, the algorithm used linear function approximation implemented by tile coding with hashing (Section 9.5.4). The tile coding had 32 tilings, each storing 256 action values as 16-bit fixed point numbers. Exploration was e-greedy with e = 0.05.\nState features included the number of read requests in the transaction queue, the number of write requests in the transaction queue, the number of write requests in the transaction queue waiting for their row to be opened, and the number of read requests in the transaction queue waiting for their row to be opened that are the oldest issued by their requesting processors. (The other features depended on how the DRAM interacts with cache memory, details we omit here.) The selection of the state features was based on Ipek et al.\\A1\\AFs understanding of factors that impact DRAM performance. For example, balancing the rate of servicing reads and writes based on how many of each are in the transaction queue can help avoid stalling the DRAM system\\A1\\AFs interaction with cache memory. The authors in fact generated a relatively long list of potential features, and then pared them down to a handful using simulations guided by stepwise feature selection.\nAn interesting aspect of this formulation of the scheduling problem as an MDP is that the features input to the tile coding for defining the action-value function were different from the features used to specify the action-constraint sets A(St). Whereas the tile coding input was derived from the contents of the transaction queue, the constraint sets depended on a host of other features related to timing and resource constraints that had to be satisfied by the hardware implementation of the entire system. In this way, the action constraints ensured that the learning algorithm\\A1\\AFs ex\u0026shy;ploration could not endanger the integrity of the physical system, while learning was effectively limited to a \\A1\\B0safe\\A1\\B1 region of the much larger state space of the hardware implementation.\nSince an objective of this work was that the learning controller could be imple\u0026shy;mented on a chip so that learning could occur on-line while a computer is running, hardware implementation details were important considerations. The design included two five-stage pipelines to calculate and compare two action values at every processor clock cycle, and to update the appropriate action value. This included accessing the tile coding which was stored on-chip in static RAM. For the configuration Ipek et al. simulated, which was a 4GHz 4-core chip typical of high-end workstations at the time of their research, there were 10 processor cycles for every DRAM cycle. Consid\u0026shy;ering the cycles needed to fill the pipes, up to 12actions could be evaluated in each DRAM cycle. Ipek et al. found that the number of legal commands for any state was rarely greater than this, and that performance loss was negligible if enough time was not always available to consider all legal commands. These and other clever design details made it feasible to implement the complete controller and learning algorithm on a multi-processor chip.\nIpek et al. evaluated their learning controller in simulation by comparing it with three other controllers: 1) the FR-FCFS controller mentioned above that produces the best on-average performance, 2) a conventional controller that processes each request in order, and 3) an unrealizable ideal controller, called the Optimistic con\u0026shy;troller, able to sustain 100% DRAM throughput if given enough demand by ignoring all timing and resource constraints, but otherwise modeling DRAM latency (as row buffer hits) and bandwidth. They simulated nine memory-intensive parallel work\u0026shy;loads consisting of scientific and data-mining applications. Figure 16.9 shows the performance (the inverse of execution time normalized to the performance of FR- FCFS) of each controller for the nine applications, together with the geometric mean of their performances over the applications. The learning controller, labeled RL in the figure, improved over that of FR-FCFS by from 7% to 33% over the nine ap\u0026shy;plications, with an average improvement of 19%. Of course, no realizable controller can match the performance of Optimistic, which ignores all timing and resource con\u0026shy;straints, but the learning controller\\A1\\AFs performance closed the gap with Optimistic\\A1\\AFs upper bound by an impressive 27%.\nBecause the rationale for on-chip implementation of the learning algorithm was to allow the scheduling policy to adapt on-line to changing workloads, Ipek et al. analyzed the impact of on-line learning compared to a previously-learned fixed policy. They trained their controller with data from all nine benchmark applications and then held the resulting action values fixed throughout the simulated execution of the applications. They found that the average performance of the controller that learned\n\n\n \nFigure 16.9: Performances of four controllers over a suite of 9 simulated benchmark ap\u0026shy;plications. The controllers are: the simplest \\A1\\AEin-order\\A1\\AF controller, FR-FCFS, the learning controller RL, and the unrealizable Optimistic controller which ignores all timing and re\u0026shy;source constraints to provide a performance upper bound. Performance, normalized to that of FR-FCFS, is the inverse of execution time. At far right is the geometric mean of perfor\u0026shy;mances over the 9 benchmark applications for each controller. Controller RL comes closest to the ideal performance. @2009 IEEE. Reprinted, with permission, from J. F. Martinez and E. Ipek, Dynamic multicore resource management: A machine learning approach, Micro, IEEE, 29(5), p. 13.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\non-line was 8% better than that of the controller using the fixed policy, leading them to conclude that on-line learning is an important feature of their approach.\nThis learning memory controller was never committed to physical hardware be\u0026shy;cause of the large cost of fabrication. Nevertheless, Ipek et al. could convincingly argue on the basis of their simulation results that a memory controller that learns on-line via reinforcement learning has the potential to improve performance to levels that would otherwise require more complex and more expensive memory systems, while removing from human designers some of the burden required to manually de\u0026shy;sign efficient scheduling policies. Mukundan and Martinez (2012) took this project forward by investigating learning controllers with additional actions, other perfor\u0026shy;mance criteria, and more complex reward functions derived using genetic algorithms. They considered additional performance criteria related to energy efficiency. The re\u0026shy;sults of these studies surpassed the earlier results described above and significantly surpassed the 2012state-of-the-art for all of the performance criteria they consid\u0026shy;ered. The approach is especially promising for developing sophisticated power-aware DRAM interfaces.\n16.6\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Human-level Video Game Play\nOne of the greatest challenges in applying reinforcement learning to real-world prob\u0026shy;lems is deciding how to represent and store value functions and/or policies. Unless the state set is finite and small enough to allow exhaustive representation by a lookup table\\A1\\AAas in many of our illustrative examples\\A1\\AAone must use a parameterized func\u0026shy;tion approximation scheme. Whether linear or non-linear, function approximation relies on features that have to be readily accessible to the learning system and able to convey the information necessary for skilled performance. Most successful appli\u0026shy;cations of reinforcement learning owe much to sets of features carefully handcrafted based on human knowledge and intuition about the specific problem to be tackled.\nA team of researchers at Google DeepMind developed an impressive demonstra\u0026shy;tion that a deep multi-layer artificial neural network (ANN) can automate the feature design process (Mnih et al., 2015). Multi-layer ANNs have been used for function ap\u0026shy;proximation in reinforcement learning ever since the 1986 popularization of the back- propagation algorithm as a method for learning internal representations (Rumelhart, Hinton, and Williams, 1986; see Section 9.6).Striking results have been obtained by coupling reinforcement learning with backpropagation. The results obtained by Tesauro and colleages with TD-Gammon and Watson discussed above are notable examples. These and other applications benefited from the ability of multi-layer ANNs to learn task-relevant features. However, in all the examples of which we are aware, the most impressive demonstrations required the network\\A1\\AFs input to be rep\u0026shy;resented in terms of specialized features handcrafted for the given problem. This is vividly apparent in the TD-Gammon results. TD-Gammon 0.0, whose network in\u0026shy;put was essentially a \\A1\\B0raw\\A1\\B1 representation of he backgammon board, meaning that it involved very little knowledge of backgammon, learned to play approximately as well as the best previous backgammon computer programs. Adding specialized backgam\u0026shy;mon features produced TD-Gammon 1.0 which was substantially better than all previous backgammon programs and competed well against human experts.\nMnih et al. developed a reinforcement learning agent called deep Q-network(DQN) that combined Q-learning with a deep convolutionalANN, a many-layered, or deep, ANN specialized for processing spatial arrays of data such as images. We describe deep convolutional ANNs in Section 9.6. By the time of Mnih et al.\\A1\\AFs work with DQN, deep ANNs, including deep convolutional ANNs, had produced impressive results in many applications, but they had not been widely used in reinforcement learning.\nMnih et al. used DQN to show how a single reinforcement learning agent can achieve high levels of performance in many different problems without relying on different problem-specific feature sets. To demonstrate this, they let DQN learn to play 49 different Atari 2600 video games by interacting with a game emulator. For learning each game, DQN used the same raw input, the same network architecture, and the same parameter values (e.g., step-size, discount rate, exploration parame\u0026shy;ters, and many more specific to the implementation). DQN achieved levels of play at or beyond human level on a large fraction of these games. Although the games were alike in being played by watching streams of video images, they varied widely in other respects. Their actions had different effects, they had different state-transition dynamics, and they needed different policies for earning high scores. The deep con\u0026shy;volutional ANN learned to transform the raw input common to all the games into features specialized for representing the action values required for playing at the high level DQN achieved for most of the games.\nThe Atari 2600 is a home video game console that was sold in various versions by Atari Inc. from 1977 to 1992. It introduced or popularized many arcade video games that are now considered classics, such as Pong, Breakout, Space Invaders, and Asteroids. Although much simpler than modern video games, Atari 2600 games are still entertaining and challenging for human players, and they have been attractive as testbeds for developing and evaluating reinforcement learning methods (Diuk, Co\u0026shy;hen, Littman, 2008; Naddaf, 2010; Cobo, Zang, Isbell, and Thomaz, 2011; Bellemare, Veness, and Bowling, 2012). Bellemare, Naddaf, Veness, and Bowling (2012) devel\u0026shy;oped the publicly available Arcade Learning Environment (ALE) to encourage and simplify using Atari 2600 games to study learning and planning algorithms.\nThese previous studies and the availability of ALE made the Atari 2600 game collection a good choice for Mnih et al.\\A1\\AFs demonstration, which was also influenced by the impressive human-level performance that TD-Gammon was able to achieve in backgammon. DQN is similar to TD-Gammon in using a multi-layer ANN as the function approximation method for a semi-gradient form of a TD algorithm, with the gradients computed by the backpropagation algorithm. However, instead of using TD(A) as TD-Gammon did, DQN used the semi-gradient form of Q-learning. TD-Gammon estimated the values of afterstates, which were easily obtained from the rules for making backgammon moves. To use the same algorithm for the Atari games would have required generating the next states for each possible action (which would not have been afterstates in that case). This could have been done by using the game emulator to run single-step simulations for all the possible actions (which ALE makes possible). Or a model of each game\\A1\\AFs state-transition function could have been learned and used to predict next states (Oh, Guo, Lee, Lewis, and Singh, 2015). While these methods might have produced results comparable to DQN\\A1\\AFs, they would have been more complicated to implement and would have significantly increased the time needed for learning. Another motivation for using Q-learning was that DQN used the experience replaymethod, described below, which requires an off-policy algorithm. Being model-free and off-policy made Q-learning a natural choice.\nBefore describing the details of DQN and how the experiments were conducted, we look at the skill levels DQN was able to achieve. Mnih et al. compared the scores of DQN with the scores of the best performing learning system in the literature at the time, the scores of a professional human games tester, and the scores of an agent that selected actions at random. The best system from the literature used linear function approximation with features hand designed using some knowledge about Atari 2600 games (Bellemare, Naddaf, Veness, and Bowling, 2012). DQN learned on each game by interacting with the game emulator for 50 million frames, which corresponds to about 38 days of experience with the game. At the start of learning on each game, the weights of DQN\\A1\\AFs network were reset to random values. To evaluate DQN\\A1\\AFs skill level after learning, its score was averaged over 30 sessions on each game, each lasting up to 5 minutes and beginning with a random initial game state. The professional human tester played using the same emulator (with the sound turned off to remove any possible advantage over DQN which did not process audio). After 2 hours of practice, the human played about 20 episodes of each game for up to 5 minutes each and was not allowed to take any break during this time. DQN learned to play better than the best previous reinforcement learning systems on all but 6of the games, and played better than the human player on 22 of the games. By considering any performance that scored at or above 75% of the human score to be comparable to, or better than, human-level play, Mnih et al. concluded that the levels of play DQN learned reached or exceeded human level on 29 of the 46 games. See Mnih et al. (2015) for a more detailed account of these results.\nFor an artificial learning system to achieve these levels of play would be impressive enough, but what makes these results remarkable\\A1\\AAand what many at the time con\u0026shy;sidered to be breakthrough results for artificial intelligence\\A1\\AAis that the very same learning system achieved these levels of play on widely varying games without relying on any game-specific modifications.\nA human playing any of these 46 Atari games sees 210 x 160 pixel image frames with 128 colors at 60Hz. In principle, exactly these images could have formed the raw input to DQN, but to reduce memory and processing requirements, Mnih et al. preprocessed each frame to produce an 84 x 84 array of luminance values. Since the full states of many of the Atari games are not completely observable from the image frames, Mnih et al. \\A1\\B0stacked\\A1\\B1 the four most recent frames so that the inputs to the network had dimension 84x84x4. This did not eliminate partial observability for all of the games, but it was helpful in making many of them more Markovian.\nAn essential point here is that these preprocessing steps were exactly the same for all 46 games. No game-specific prior knowledge was involved beyond the gen\u0026shy;eral understanding that it should still be possible to learn good policies with this reduced dimension and that stacking adjacent frames should help with the partial observability of some of the games. Since no game-specific prior knowledge beyond this minimal amount was used in preprocessing the image frames, we can think of the 84x84x 4 input vectors as being \\A1\\B0raw\\A1\\B1 input to DQN.\nThe basic architecture of DQN is similar to the deep convolutional ANN illustrated in Figure 9.15 (though unlike that network, subsampling in DQN is treated as part of each convolutional layer, with feature maps consisting of units having only a selection of the possible receptive fields). DQN has three hidden convolutional layers, followed by one fully connected hidden layer, followed by the output layer. The three successive hidden convolutional layers of DQN produce 32 20 x 20 feature maps, 64 9x9 feature maps, and 64 7x7 feature maps. The activation function of the units of each feature map is a rectifier nonlinearity (max(0, x)). The 3,136 (64x7x7) units in this third convolutional layer all connect to each of 512 units in the fully connected hidden layer, which then each connect to all 18 units in the output layer, one for each possible action in an Atari game.\nThe activation levels of DQN\\A1\\AFs output units were the estimated optimal action values (optimal Q-values) of the corresponding state-action pairs, for the state rep\u0026shy;resented by the network\\A1\\AFs input. The assignment of output units to a game\\A1\\AFs actions varied from game to game, and since the number of valid actions varied between 4 and 18 for the games, not all output units had functional roles in all of the games. It helps to think of the network as if it were 18 separate networks, one for estimating the optimal action value of each possible action. In reality, these networks shared their initial layers, but the output units learned to use the features extracted by these layers in different ways.\nDQN\\A1\\AFs reward signal indicated how a games\\A1\\AFs score changed from one time step to the next: +1whenever it increased, \\A1\\AA1whenever it decreased, and 0otherwise. This standardized the reward signal across the games and made a single step-size parameter work well for all the games despite their varying ranges of scores. DQN used an e-greedy policy, with e decreasing linearly over the first million frames and remaining at a low value for the rest of the learning session. The values of the various other parameters, such as the learning step-size, discount rate, and others specific to the implementation, were selected by performing informal searches to see which values worked best for a small selection of the games. These values were then held fixed for all of the games.\nAfter DQN selected an action, the action was executed by the game emulator, which returned a reward and the next video frame. The frame was preprocessed and added to the four-frame stack that became the next input to the network. Skipping for the moment the changes to the basic Q-learning procedure made by Mnih et al., DQN used the following semi-gradient form of Q-learning to update the network\\A1\\AFs weights:\nwt+i = wt + a Rt+i + 7maxq(St+i, a, wt) \\A1\\AA q(St, At, wt) Vwtq(St, At, wt), (16.3)\nLa\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\B9\nwhere wt is the vector of the network\\A1\\AFs weights, At is the action selected at time step t, and St and St+i are respectively the preprocessed image stacks input to the network at time steps t and t + 1.\nThe gradient in (16.3) was computed by backpropagation. Imagining again that there was a separate network for each action, for the update at time step t, back- propagation was applied only to the network corresponding to At. Mnih et al. took advantage of techniques shown to improve the basic backpropagation algorithm when applied to large networks. They used a mini-batch methodthat updated weights only after accumulating gradient information over a small batch of images (here after 32 images). This yielded smoother sample gradients compared to the usual procedure that updates weights after each action. They also used a gradient-ascent algorithm called RMSProp (Tieleman and Hinton, 2012) that accelerates learning by adjusting the step-size parameter for each weight based on a running average of the magnitudes of recent gradients for that weight.\nMnih et al. modified the basic Q-learning procedure in three ways. First, they used a method called experience replayfirst studied by Lin (1992). This method stores the agent\\A1\\AFs experience at each time step in a replay memory that is accessed to perform the weight updates. It worked like this in DQN. After the game emulator executed action At in a state represented by the image stack St, and returned reward Rt+i and image stack St+i, it added the tuple (St, At, Rt+i, St+i) to the replay memory. This memory accumulated experiences over many plays of the same game. At each time step multiple Q-learning updates\\A1\\AAa mini-batch\\A1\\AAwere performed based on experiences sampled uniformly at random from the replay memory. Instead of St+i becoming the new St for the next update as it would in the usual form of Q-learning, a new unconnected experience was drawn from the replay memory to supply data for the next update. Since Q-learning is an off-policy algorithm, it does not need to be applied along connected trajectories.\nQ-learning with experience replay provided several advantages over the usual form of Q-learning. The ability to use each stored experience for many updates allowed DQN to learn more efficiently from its experiences. Experience replay reduced the variance of the updates because successive updates were not correlated with one another as they would be with standard Q-learning. And by removing the dependence of successive experiences on the current weights, experience replay eliminated one source of instability.\nMnih et al. modified standard Q-learning in a second way to improve its stability. As in other methods that bootstrap, the target for a Q-learning update depends on the current action-value function estimate. When a parameterized function approx\u0026shy;imation method is used to represent action values, the target is a function of the same parameters that are being updated. For example, the target in the update given by (16.3) is 7maxa q(St+i,a, wt). Its dependence on wt complicates the pro\u0026shy;cess compared to the simpler supervised-learning situation in which the targets do not depend on the parameters being updated. As discussed in Chapter 11this can lead to oscillations and/or divergence.\nTo address this problem Mnih et al. used a technique that brought Q-learning closer to the simpler supervised-learning case while still allowing it to bootstrap. Whenever a certain number, C, of updates had been done to the weights w of the action value network, they inserted the network\\A1\\AFs current weights into another network and held these duplicate weights fixed for the next C updates of w. The outputs of this duplicate network over the next C updates of w were used as the Q-learning targets. Letting qdenote the output of this duplicate network, then instead of (16.3) the update rule was:\nwt+i = wt + a Rt+i + Ymaxq(St+i,a, wt) - q(St, At, wt) Vw\u0026pound;q(St, At, wt).\nLa\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; \\A1\\B9\nA final modification of standard Q-learning was also found to improve stability. They clipped the error term Rt+i + Y maxa \\8CT(St+i, a, wt) \\A1\\AA q(St, At, wt) so that it remained in the interval [\\A1\\AA1,1].\nMnih et al. conducted a large number of learning runs on 5 of the games to gain insight into the effect that various of DQN\\A1\\AFs design features had on its performance. They ran DQN with the four combinations of experience replay and the duplicate target network being included or not included. Although the results varied from game to game, each of these features alone significantly improved performance, and very dramatically improved performance when used together. Mnih et al. also studied the role played by the deep convolutional ANN in DQN\\A1\\AFs learning ability by comparing the deep convolutional version of DQN with a version having a network of just one linear layer, both receiving the same stacked preprocessed video frames. Here, the improvement of the deep convolutional version over the linear version was particularly striking across all 5 of the test games.\nCreating artificial agents that excel over a diverse collection of challenging tasks has been an enduring goal of artificial intelligence. The promise of machine learning \n\n\nas a means for achieving this has been frustrated by the need to craft problem-specific representations. DeepMind\\A1\\AFs DQN stands as a major step forward by demonstrating that a single agent can learn problem-specific features enabling it to acquire human- competitive skills over a range of tasks. But as Mnih et al. point out, DQN is not a complete solution to the problem of task-independent learning. Although the skills needed to excel on the Atari games were markedly diverse, all the games were played by observing video images, which made a deep convolutional ANN a natural choice for this collection of tasks. In addition, DQN\\A1\\AFs performance on some of the Atari 2600 games fell considerably short of human skill levels on these games. The games most difficult for DQN\\A1\\AAespecially Montezuma\\A1\\AFs Revenge on which DQN learned to perform about as well as the random player\\A1\\AArequire deep planning beyond what DQN was designed to do. Further, learning control skills through extensive practice, like DQN learned how to play the Atari games, is just one of the types of learning humans routinely accomplish. Despite these limitations, DQN advanced the state-of- the-art in machine learning by impressively demonstrating the promise of combining reinforcement learning with modern methods of deep learning.\n16.7\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Mastering the Game of Go\nThe ancient Chinese game of Go has challenged artificial intelligence researchers for many decades. Methods that achieve human-level skill, or even superhuman-level skill, in other games have not been successful in producing strong Go programs. Thanks to a very active community of Go programmers and international competi\u0026shy;tions, the level of Go program play has improved significantly over the years. Until recently, however, no Go program had been able to play anywhere near the level of a human Go master. Here we describe a program called AlphaGo developed by a Google DeepMind team (Silver et al., 2016) that broke this barrier by combin\u0026shy;ing deep artificial neural networks (deep ANNs, Section 9.6), supervised learning, Monte Carlo tree search (MCTS, Section 8.11), and reinforcement learning. By the time of Silver et al.\\A1\\AFs 2016 publication, AlphaGo had been shown to be decisively stronger than other current Go programs, and it had defeated the human European Go champion 5 games to 0. These were the first victories of a Go program over a human professional Go player without handicap in full Go games. Shortly thereafter, AlphaGo went on to stunning victories over an 18-time world champion Go player, winning 4 out of a 5 games in a challenge match, making worldwide headline news. Artificial intelligence researchers thought that it would be many more years, perhaps decades, for a program to reach this level of play.\nIn many ways, AlphaGo is a descendant of Tesauo\\A1\\AFs TD-Gammon (Section 16.1), itself a descendant of Samuel\\A1\\AFs checkers player (Section 16.2). AlphaGo, like these earlier programs, used reinforcement learning with function approximation over many simulated games. AlphaGo also built upon the progress made by Google DeepMind on playing Atari games with the program DQN (Section 16.6) by approximating value functions with deep convolutional ANNs. By using a novel variant of MCTS, AlphaGo extended the technology responsible for the impressive gains of the most successful preceding Go programs. But AlphaGo was not a simple combination of these technologies: it combined them in a highly-engineered way that was perhaps critical for AlphaGo\\A1\\AFs impressive performance. Another element of AlphaGo was its distributed architecture: many of its computations were executed in parallel on many processors so that it could select moves quickly enough to meet the time constraints of live play. Although this contributed to AlphaGo\\A1\\AFs success, most of its playing skill was due to algorithmic innovations, and here we neglect AlphaGo\\A1\\AFs distributed architecture.\nGo is a game between two players who alternately place black and white \\A1\\AEstones\\A1\\AF on unoccupied intersections, or \\A1\\AEpoints,\\A1\\AF on a board with a grid of 19 horizontal and 19 vertical lines (Figure 16.10). The game\\A1\\AFs goal is to capture an area of the board larger than that captured by the opponent. Stones are captured according to simple rules. A player\\A1\\AFs stones are captured if they are completely surrounded by the other player\\A1\\AFs stones, meaning that there is no horizontally or vertically adjacent point that is unoccupied. For example, Figure 16.11 shows on the left three white stones with an unoccupied adjacent point (labeled X). If player black places a stone on X, the three white stones are captured and taken off the board (Figure 16.11 middle). However, if player white were to place a stone on point X first, than the possibility of this capture would be blocked (Figure 16.11 right). Other rules are needed to prevent infinite capturing/re-capturing loops. The game ends when neither player wishes to place another stone. These rules are simple, but they produce a very complex game that has had wide appeal for thousands of years.\n \nFigure 16.10: A Go board configuration.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nMethods that produce strong play for other games, such as chess, have not worked as well for Go. The search space for Go is significantly larger than that of chess because Go has a larger number of legal moves per position than chess (^ 250 versus \\B0\\D135) and Go games tend to involve more moves than chess games (^ 150 versus ^ 80). But the size of the search space is not the major factor that makes Go so difficult. Exhaustive search is infeasible for both chess and Go, and Go on smaller\n_\\EBs_\nFigure 16.11: Go capturing rule. Left: the three white stones are not surrounded because point X is unoccupied. Middle: if black places a stone on X, the three white stones are captured and removed from the board. Right: if white places a stone on point X first, the capture is blocked.\nboards, e.g., 9 x 9, has proven to be exceedingly difficult as well. Experts agree that the major stumbling block to creating stronger-than-amateur Go programs is the difficulty of defining an adequate position evaluation function. A good evaluation function allows search to be truncated at a feasible depth by providing relatively easy- to-compute predictions of what deeper search would likely yield. According to Muller (2002): \\A1\\B0No simple yet reasonable evaluation function will ever be found for Go.\\A1\\B1 A major step forward was the introduction of MCTS to Go programs, which does not attempt to store an evaluation function, instead evaluating moves at decision time by running many Monte Carlo simulations of entire games. The strongest programs at the time of AlphaGo\\A1\\AFs development all used MCTS, but master-level skill remained elusive.\nThe main innovation of AlphaGo is its use of a variant of MCTS called \\A1\\B0asyn\u0026shy;chronous policy and value MCTS,\\A1\\B1 or APV-MCTS. APV-MCTS selects moves via basic MCTS as described in Section 8.11 and illustrated in Figure 8.13, but with some twists in terms of how policies and value functions are computed and ultimately how each move is chosen. In addition to the tree policyfor traversing the search tree, and a rollout policy,pn, used in the Monte Carlo simulations, there is a supervised learning policy(SL policy), pa, a reinforcement learning policy(RL policy), pp, and a state-value function,v^. These policies and value function were all learned off-line before actual play. The SL policy is used in the expansion phase of APV-MCTS iterations, the phase in which a node in the search tree is selected as a promising node from which to explore further. In contrast to basic MCTS, which expands the selected node by choosing an unexplored action based on stored action-values, APV- MCTS chooses an action according to prior probabilities supplied by the SL-policy. Both the rollout policy and the SL policy were learned before play via supervised learning using large databases of expert human moves. The RL policy was learned via self-play reinforcement learning and was used to derive the state-value function \\CE\\C7.Below we explain how this was done.\nIn contrast to basic MCTS, which evaluates the expanded node solely on the basis of the return of the simulation initiated from it, APV-MCTS evaluates the node in two ways: by this return of the simulation, but also by the value function v: if s is the node selected for expansion, its value becomes\nV\u0026nbsp; (s) = (1\\A1\\AA n)ve (s) + nG,\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (16.4)\nwhere Gis the return of the simulation and n controls the mixing of the values\n\n\nluation methods.\nhe rollout policy, the SL policy, the RL policy, and the Ns came into play. These policies were learned by deep tively called the rollout policy network,the SL policy ork, and the value network. Figure 16.12 illustrates the works in what the DeepMind team called the \\A1\\B0AlphaGo ained before any live game play took place and their ighout AlphaGo\\A1\\AFs live play.\n-play process was to train the SL policy network. This \\A1\\AFs deep convolutional network described in Section 16.6 pt that it had 13 layers with the final layer consisting of a n the 19 x 19 board. The network\\A1\\AFs input was a 19 x 19 ch point on the Go board was represented by the values ed features. For example, for each point, one feature upied by one of AlphaGo\\A1\\AFs stones, one of its opponent\\A1\\AFs thus providing the \\A1\\B0raw\\A1\\B1 representation of the board es were based on the rules of Go, such as the number empty, the number of opponent stones that would be here, the number of turns since a stone was placed there, at the design team considered to be important. The SL rvised learning to predict moves contained in a data base noves. Its output, which was a probability distribution the SL policy that supplied the action probabilities in -MCTS. Training took approximately 3 weeks using a\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n distributed implementation of stochastic gradient ascent on 50 processors. The SL network achieved 57% accuracy, compared to best accuracy achieved by other groups at the time of publication of 44.4%.\nThe goal for the rollout policy network was that it should select actions quickly while still being reasonably accurate. In principle, the SL policy could have served as the rollout policy, but the forward propagation through the SL policy network took too much time for this network to be used in rollout simulations, a great many of which had to be carried out for each move decision during live play. For this reason, the rollout policy network was less complex than the SL policy network, and its input features could be computed more quickly than the features used for the SL policy network. This network was trained by supervised learning on a corpus of 8 million human moves. The resulting rollout policy network allowed approximately 1,000complete game simulations per second to be run on each of the processing threads that AlphaGo used.\nNext, the value function, , needed by APV-MCTS had to be created. Ideally, would be the optimal state-value function. It might have been possible to approx\u0026shy;imate the optimal value function along the lines of TD-Gammon described above: self-play with nonlinear TD(A) coupled to a deep convolutional ANN. But the Deep- Mind team took a different approach that held more promise for a game as complex as Go. They divided the process into two stages. In the first stage, they created the best policy they could by training a deep convolutional network by means of a policy-gradient reinforcement learning algorithm. This resulted in the RL policy network implementing the RL policy pp.\nThe RL policy network had the same architecture as the SL policy network and was initialized with the final weights of the SL policy network that were learned via supervised learning. Reinforcement learning was then used to improve upon the SL policy. Learning was by means of simulated games between the network\\A1\\AFs current policy and opponents using policies randomly selected from policies produced by earlier iterations of the learning algorithm. Playing against a randomly selected collection of opponents prevented overfitting to the current policy. The reward signal was +1 if the current policy won, \\A1\\AA1 if it lost, and zero otherwise. These games directly pitted two policies against one another without involving any search. By simulating many games in parallel on 50 processors, the DeepMind team trained the RL policy network on a million games in a single day. In testing the final RL policy Pp, they found that it won more than 80% of games played against the SL policy , and it won 85% of games played against a Go program using Monte Carlo search that simulated 100,000games per move.\nFinally, the value function v^ was learned by the value network: a deep convolu\u0026shy;tional ANN whose structure was like that of the SL and RL policy networks except that its single output unit produced state values (the right-most network in Fig\u0026shy;ure 16.12) instead of probability distributions over legal actions. The value network was trained by Monte Carlo policy evaluation on data obtained from a large number of simulated games in which each player used the RL policy pp. The team found that the values produced by this network were more accurate than values produced by multiple simulations using the rollout policy pn, and in fact compared well with val\u0026shy;ues produced by simulations using the higher-performing RL policy ppһeven though they could be computed 15,000 times more quickly.\nOne may wonder why APV-MCTS used the SL policy pa instead of the better RL policy pp to select actions in the expansion phase. These policies took the same amount of time to compute since they used the same network architecture. The team actually found that AlphaGo worked better against human opponents when APV-MCTS used as its SL policy pa instead of pp. They conjectured that the reason for this was that the pp was tuned to respond to optimal moves rather than to the broader set of moves characteristic of human play. Interestingly, the situation was reversed for the value function, v^, used by APV-MCTS. They found that when APV-MCTS used the value function derived from the RL policy, it performed better than if it used the value function derived from the SL policy.\nSeveral methods worked together to produce AlphaGo\\A1\\AFs impressive playing skill. The DeepMind team evaluated different versions of AlphaGo in order to asses the contributions made by these various components. The parameter n in (16.4) controls the mixing of game state evaluations produced by the value network and by rollouts. With n = 0, AlphaGo used just the value network without rollouts, and with n = 1, evaluation relied just on rollouts. They found that AlphaGo using just the value network played better than the rollout-only AlphaGo, and in fact played better than the strongest of all other Go programs. The best play resulted from setting n = 0.5, indicating that combining the value network with rollouts was particularly important to AlphaGo\\A1\\AFs success. These evaluation methods complemented one another: the value network evaluated the high-performance policy pp that was too slow to be used in live play, while rollouts using the weaker but much faster rollout policy p^ were able to add precision to the value network\\A1\\AFs evaluations for specific states that occurred during games.\nOverall, AlphaGo\\A1\\AFs remarkable success helped fuel a new round of enthusiasm for the promise of artificial intelligence, specifically for systems combining reinforcement learning with deep ANNs, to address problems in many other challenging domains.\n16.8\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Personalized Web Services\nPersonalizing web services such as the delivery of news articles or advertisements is one approach to increasing users\\A1\\AF satisfaction with a website or to increase the yield of a marketing campaign. A policy can recommend content considered to be the best for each particular user based on a profile of that user\\A1\\AFs interests and preferences inferred from their history of online activity. This is a natural domain for machine learning, and in particular, for reinforcement learning. A reinforcement learning system can improve a recommendation policy by making adjustments in response to user feedback. One way to obtain user feedback is by means of website satisfaction surveys, but for acquiring feedback in real time it is common to monitor user clicks as indicators of interest in a link.\nA method long used in marketing called A/B testingis a simple type of reinforce\u0026shy;ment learning used to decide which of two versions, A or B, of a website users prefer. Because it is non-associative, like a two-armed bandit problem, this approach does not personalize content delivery. Adding context consisting of features describing individual users and the content to be delivered allows personalizing service. This has been formalized as a contextual bandit problem (or an associative reinforcement learning problem, Section 2.9) with the objective of maximizing the total number of user clicks. Li, Chu, Langford, and Schapire (2010) applied a contextual bandit al\u0026shy;gorithm to the problem of personalizing the Yahoo! Front Page Today webpage (one of the most visited pages on the internet at the time of their research) by selecting the news story to feature. Their objective was to maximize the click-through rate (CTR), which is the ratio of the total number of clicks all users make on a webpage to the total number of visits to the page. Their contextual bandit algorithm improved over a standard non-associative bandit algorithm by 12.5%.\nTheocharous, Thomas, and Ghavamzadeh (2015) argued that better results are possible by formulating personalized recommendation as a Markov decision problem (MDP) with the objective of maximizing the total number of clicks users make over repeated visits to a website. Policies derived from the contextual bandit formulation are greedy in the sense that they do not take long-term effects of actions into account. These policies effectively treat each visit to a website as if it were made by a new visitor uniformly sampled from the population of the website\\A1\\AFs visitors. By not using the fact that many users repeatedly visit the same websites, greedy policies do not take advantage of possibilities provided by long-term interactions with individual users.\nAs an example of how a marketing strategy might take advantage of long-term user interaction, Theocharous et al. contrasted a greedy policy with a longer-term policy for displaying ads for buying a product, say a car. The ad displayed by the greedy policy might offer a discount if the user buys the car immediately. A user either takes the offer or leaves the website, and if they ever return to the site, they would likely see the same offer. A longer-term policy, on the other hand, can transition the user \\A1\\B0down a sales funnel\\A1\\B1 before presenting the final deal. It might start by describing the availability of favorable financing terms, then praise an excellent service department, and then, on the next visit, offer the final discount. This type of policy can result in more clicks by a user over repeated visits to the site, and if the policy is suitably designed, more eventual sales.\nWorking at Adobe Systems Incorporated, Theocharous et al. conducted experi\u0026shy;ments to see if policies designed to maximize clicks over the long term could in fact improve over short-term greedy policies. The Adobe Marketing Cloud, a set of tools that many companies use to to run digital marketing campaigns, provides infrastruc\u0026shy;ture for automating user-targed advertising and fund-raising campaigns. Actually deploying novel policies using these tools entails significant risk because a new policy may end up performing poorly. For this reason, the research team needed to assess what a policy\\A1\\AFs performance would be if it were to be actually deployed, but to do so on the basis of data collected under the execution of other policies. A critical aspect of this research, then, was off-policy evaluation. Further, the team wanted to do this with high confidence to reduce the risk of deploying a new policy. Although high confidence off-policy evaluation was a central component of this research (see also Thomas, 2015; Thomas, Theocharous, and Ghavamzadeh, 2015), here we focus only on the algorithms and their results.\nTheocharous et al. compared the results of two algorithms for learning ad recom\u0026shy;mendation policies. The first algorithm, which they called greedy optimization,had the goal of maximizing only the probability of immediate clicks. As in the standard contextual bandit formulation, this algorithm did not take the long-term effects of recommendations into account. The other algorithm, a reinforcement learning algo\u0026shy;rithm based on an MDP formulation, aimed at improving the number of clicks users made over multiple visits to a website. They called this latter algorithm life-time value(LTV) optimization. Both algorithms faced challenging problems because the reward signal in this domain is very sparse since users usually do not click on ads, and user clicking is very random so that returns have high variance.\nData sets from the banking industry were used for training and testing these algo\u0026shy;rithms. The data sets consisted of many complete trajectories of customer interaction with a bank\\A1\\AFs website that showed each customer one out of a collection of possible offers. If a customer clicked, the reward was 1, and otherwise it was 0. One data set contained approximately 200,000interactions from a month of a bank\\A1\\AFs campaign that randomly offered one of 7 offers. The other data set from another bank\\A1\\AFs cam\u0026shy;paign contained 4,000,000 interactions involving 12possible offers. All interactions included customer features such as the time since the customer\\A1\\AFs last visit to the website, the number of their visits so far, the last time the customer clicked, geo\u0026shy;graphic location, one of a collection of interests, and features giving demographic information.\nGreedy optimization was based on a mapping estimating the probability of a click as a function of user features. The mapping was learned via supervised learning from one of the data sets by means of a random forest (RF) algorithm (Breiman, 2001). RF algorithms have been widely used for large-scale applications in industry because they are effective predictive tools that tend not to overfit and are relatively insensitive to outliers and noise. Theocharous et al. then used the mapping to define an e-greedy policy that selected with probability 1-e the offer predicted by the RF algorithm to have the highest probability of producing a click, and otherwise selected from the other offers uniformly at random.\nLTV optimization used a batch-mode reinforcement learning algorithm called fitted Q iteration(FQI). It is a variant of fitted value iteration(Gordon, 1999) adapted to Q-learning. Batch mode means that the entire data set for learning is available from the start, as opposed to the on-line mode of the algorithms we focus on in this book in which data are acquired sequentially while the learning algorithm executes. Batch-mode reinforcement learning algorithms are sometimes necessary when on\u0026shy;line learning is not practical, and they can use any batch-mode supervised learning regression algorithm, including algorithms known to scale well to high-dimensional spaces. The convergence of FQI depends on properties of the function approximation \n \nalgorithm (Gordon, 1999). For their application to LTV optimi et al. used the same RF algorithm they used for the greedy opt Since in this case FQI convergence is not monotonic, Theochar of the best FQI policy by off-policy evaluation using a validati( final policy for testing the LTV approach was the e-greedy poli( policy produced by FQI with the initial action-value function produced by the RF for the greedy optimization approach.\nTo measure the performance of the policies produced by the proaches, Theocharous et al. used the CTR metric and a metric metric. These metrics are similar, except that the LTV metric cr between individual website visitors:\nTotal # of Clicks\nCTR\nTotal \u0026#8226;of Visits5Total # of Clicks\nLTV\nTotal # of Visitors Figure 16.13 illustrates how these metrics differ. Each circle re to the site; black circles are visits at which the user clicks. Each by a particular user. By not distinguishing between visitors, sequences is 0.35, whereas the LTV is 1.5. Because LTV is larg extent that individual users revisit the site\\A3\\ACit is an indicator policy is in encouraging users to engage in extended interaction\nVisit 1 Visit 2 Visit 3 Visit 4 Visit 5\n \n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n Figure 16.13: Click through rate (CTR) versus life-time value (LTV). a user visit; black circles are visits at which the user clicks. Adapted al. (2015) permission pending.\nTesting the policies produced by the greedy and LTV appr ing a high confidence off-policy evaluation method on a test of real-world interactions with a bank website served by a ran pected, results showed that greedy optimization performed b the CTR metric, while LTV optimization performed best as m metric. Furthermoreһalthough we have omitted its details\\A1\\AA off-policy evaluation method provided probabilistic guarantees mization method would, with high probability, produce policie policies currently deployed. Assured by these probabilistic gu nounced in 2016 that the new LTV algorithm would be a standa\n \nAdobe Marketing Cloud so that a retailer could issue a sequence of offers following a policy likely to yield higher return than a policy that is insensitive to long-term results.\n16.9\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Thermal Soaring\nBirds and gliders take advantage of upward air currents\\A1\\AAthermals\\A1\\AAto gain altitude in order maintain flight while expending little, or no, energy. Thermal soaring, as this behavior is called, is a complex skill requiring responding to subtle environmental cues to increase altitude by exploiting a rising column of air for as long as possi\u0026shy;ble. Reddy, Celani, Sejnowski, and Vergassola (2016) used reinforcement learning to investigate thermal soaring policies that are effective in the strong atmospheric tur\u0026shy;bulence usually accompanying rising air currents. Their primary goal was to provide insight into the cues birds sense and how they use them to achieve their impressive thermal soaring performance, but the results also contribute to technology relevant to autonomous gliders. Reinforcement learning had previously been applied to the problem of navigating efficiently to the vicinity of a thermal updraft (Woodbury, Dunn, and Valasek, 2014) but not to the more challenging problem of soaring within the turbulence of the updraft itself.\nReddy et al. modeled the soaring problem as an MDP. The agent interacted with a detailed model of a glider flying in turbulent air. They devoted significant effort toward making the model generate realistic thermal soaring conditions, including investigating several different approaches to atmospheric modeling. For the learn\u0026shy;ing experiments, air flow in a three-dimensional box with one kilometer sides, one of which was at ground level, was modeled by a sophisticated physics-based set of partial differential equations involving air velocity, temperature, and pressure. Intro\u0026shy;ducing small random perturbations into the numerical simulation caused the model to produce analogs of thermal updrafts and accompanying turbulence (Figure 16.14 Left) Glider flight was modeled by aerodynamic equations involving velocity, lift, drag, and other factors governing powerless flight of a fixed-wing aircraft. Maneu\u0026shy;vering the glider involved changing its angle of attack (the angle between the glider\\A1\\AFs wing and the direction of air flow) and its bank angle (Figure 16.14 Right).\nThe interface between the agent and the environment required defining the agent\\A1\\AFs actions, the state information the agent receives from the environment, and the reward signal. By experimenting with various possibilities, Reddy et al. decided that three actions each for the angle of attack and the bank angle were enough for their purposes: increment or decrement the current bank angle and angle of attack by 5\\A1\\E3 and 2.5\\A1\\E3, respectively, or leave them unchanged. This resulted in 32possible actions. The bank angle was bounded to remain between -15\\A1\\E3 and +15\\A1\\E3.\nBecause a goal of their study was to try to determine what minimal set of sensory cues are necessary for effective soaring, both to shed light on the cues birds might use for soaring and to minimize the sensing complexity required for automated glider soaring, the authors tried various sets of signals as input to the reinforcement learning\n z\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Lift\u0026nbsp; L\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; ,\n\nFigure 16.14: Thermal soaring model: Left: snapshot of the vertical velocity field of the simulated cube of air: in light (dark) grey is a region of large upward (downward) flow. Right: diagram of powerless flight showing bank angle \\iand angle of attack a.Adapted with permission From PNAS vol. 113(22), p. E4879, 2016, Reddy, Celani, Sejnowski, and Vergassola, Learning to Soar in Turbulent Environments.\n    \u0026lt;![if !supportTextWrap]\u0026gt;\u0026lt;![endif]\u0026gt;\n\u0026nbsp;\nagent. They started by using state aggregation (Chapter 9) of a four-dimensional state space with dimensions giving local vertical wind speed, local vertical wind acceleration, torque depending on the difference between the vertical wind velocities at the left and right wing tips, and the local temperature. Each dimension was discretized into three bins: positive high, negative high, and small. Results, described below, showed that only two of these dimensions were critical for effective soaring behavior.\nThe overall objective of thermal soaring is to gain as much altitude as possible from each rising column of air. Reddy et al. tried a straightforward reward signal that rewarded the agent at the end of each episode based on the altitude gained over the episode, a large negative reward signal if the glider touched the ground, and zero otherwise. They found that learning was not successful with this reward signal for episodes of realistic duration and that eligibility traces did not help. By experimenting with various reward signals, they found that learning was best with a reward signal that at each time step linearly combined the vertical wind velocity and vertical wind acceleration observed on the previous time step.\nLearning was by Sarsa with action selection using softmax applied to action values normalized to the interval [0,1]. The temperature parameter was initialized to 2.0 and incrementally decreased to 0.2 during learning. The step-size and discount-rate parameters were fixed at 0.1 and 0.98 respectively. Each learning episode took place with the agent controlling simulated flight in an independently generated period of simulated turbulent air currents. Each episode lasted 2.5 minutes simulated with a 1 second time step. Learning effectively converged after a few hundred episodes. The left panel of Figure 16.15 shows a sample trajectory before learning where the agent selects actions randomly. Starting at the top of the volume shown, the glider\\A1\\AFstrajectory is in the direction indicated by the arrow and quickly loses altitude. Fig\u0026shy;ure 16.15\\A1\\AFs right panel is a trajectory after learning. The glider starts at the same place (here appearing at the bottom of the volume) and gains altitude by spiraling within the rising column of air. Although Reddy at al. found that performance varied widely over different simulated periods of air flow, the number of times the glider touched the ground consistently decreased to nearly zero as learning progressed.\n\n\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n\u0026nbsp;\n After experimenting with different sets of features available to the learning agent, it turned out that the combination of just vertical wind acceleration and torques worked best. The authors conjectured that because these features give information about the gradient of vertical wind velocity in two different directions, they allow the controller to select between turning by changing the bank angle or continuing along the same course by leaving the bank angle alone. This allows the glider to stay within a rising column of air. Vertical wind velocity is indicative of the strength of the thermal but does not help in staying within the flow. They found that sensitivity to temperature was of little help. They also found that controlling the angle of attack is not helpful in staying within a particular thermal, being useful instead for traveling between thermals when covering large distances, as in cross-country gliding and bird migration.\nSince soaring in different levels of turbulence requires different policies, training was done in conditions ranging from weak to strong turbulence. In strong turbulence the rapidly changing wind and glider velocities allowed less time for the controller to react. This reduced the amount of control possible compared to what was possible for maneuvering when fluctuations were weak. Reddy at al. examined the policies\nSarsa learned under these different conditions. Common to policies learned in all regimes were these features: when sensing negative wind acceleration, bank sharply in the direction of the wing with the higher lift; when sensing large positive wind acceleration and no torque, do nothing. However, different levels of turbulence led to policy differences. Policies learned in strong turbulence were more conservative in that they preferred small bank angles, whereas in weak turbulence, the best ac\u0026shy;tion was to turn as much as possible by banking sharply. Systematic study of the bank angles preferred by the policies learned under the different conditions led the authors to suggest that by detecting when vertical wind acceleration crosses a cer\u0026shy;tain threshold the controller can adjust its policy to cope with different turbulence regimes.\nReddy et al. also conducted experiments to investigate the effect of the discount- rate parameter Y on the performance of the learned policies. They found that the altitude gained in an episode increased as Y increased, reaching a maximum for\nY\u0026nbsp; = .99, suggesting that effective thermal soaring requires taking into account long\u0026shy;term effects of control decisions.\nThis computational study of thermal soaring illustrates how reinforcement learning can further progress toward different kinds of objectives. Learning policies having access to different sets of environmental cues and control actions contributes to both the engineering objective of designing autonomous gliders and the scientific objective of improving understanding of the soaring skills of birds. In both cases, hypotheses resulting from the learning experiments can be tested in the field by instrumenting real gliders and by comparing predictions with observed bird soaring behavior.\n \nChapter 17\nFrontiers\n \n478\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; CHAPTER\u0026nbsp; 17.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; FRONTIERS\nReferences\nAbbeel, P., and Ng, A. Y. (2004). Apprenticeship learning via inverse reinforcement learning. In Proceedings of the twenty-first international conference on Machine learning.ACM.\nAbramson, B. (1990). Expected-outcome: A general model of static evaluation. IEEE transactions on pattern analysis and machine intelligence 12(2):182-193.\nAdams, C. (1982). Variations in the sensitivity of instrumental responding to reinforcer devaluation. The Quarterly Journal of Experimental Psychology,34(2):77-98.\nAdams, C. D. and Dickinson, A. (1981). Instrumental responding following reinforcer deval\u0026shy;uation. The Quarterly Journal of Experimental Psychology33(2):109-121.\nAdams, R. A., Huys, Q. J. M., and Roiser, J. P. (2015). Computational Psychiatry: to\u0026shy;wards a mathematically informed understanding of mental illness. Journal of Neurology, Neurosurgery \u0026amp; Psychiatry,doi:10.1136/jnnp-2015-310737.\nAgrawal, R. (1995). Sample mean based index policies with O(logn) regret for the multi\u0026shy;armed bandit problem. Advances in Applied Probability,27:1054-1078.\nAgre, P. E. (1988). The Dynamic Structure of Everyday Life.Ph.D. thesis, Massachusetts Institute of Technology. AI-TR 1085, MIT Artificial Intelligence Laboratory.\nAgre, P. E., Chapman, D. (1990). What are plans for? Robotics and Autonomous Systems, 6:17-34.\nAizerman, M. A., Braverman, E. f., and Rozonoer, L. I. (1964).\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Probability problem\nof pattern recognition learning and potential functions method.\u0026nbsp; Avtomat. i Telemekh\n25(9):1307-1323.\nAlbus, J. S. (1971). A theory of cerebellar function. Mathematical Biosciences,10:25-61.\nAlbus, J. S. (1981). Brain, Behavior, and Robotics.Byte Books, Peterborough, NH.\nAleksandrov, V. M., Sysoev, V. I., Shemeneva, V. V. (1968). Stochastic optimization of systems. Izv. Akad. Nauk SSSR, Tekh. Kibernetika,14-19.\nAmari, S. I. (1998). Natural gradient works efficiently in learning.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; Neural Computation\n10(2), 251-276.\nAn, P.-C. E. (1991). An Improved Multi-dimensional CMAC Neural network: Receptive Field Function and Placement(Doctoral dissertation, PhD Thesis, Dept. Electrical and Computer Engineering, New Hampshire Univ., New Hampshire, USA).\nAn, P. C. E., Miller, W. T., Parks, P. C. (1991). Design improvements in associative mem\u0026shy;ories for cerebellar model articulation controllers (CMAC). Artificial Neural Networks, pp. 1207-1210, Elsvier North-Holland.\nAnderson, C. W. (1986). Learning and Problem Solving with Multilayer Connectionist Sys\u0026shy;tems.Ph.D. thesis, University of Massachusetts, Amherst.\nAnderson, C. W. (1987). Strategy learning with multilayer connectionist representations.\n \nProceedings of the Fourth International Workshop on Machine Learning,pp. 103\\A1\\AA114. Morgan Kaufmann, San Mateo, CA.\nAnderson, C. W. (1989). Learning to control an inverted pendulum using neural networks. IEEE Control Systems Magazine 9(3):31-37.\nAnderson, J. A., Silverstein, J. W., Ritz, S. A., Jones, R. S. (1977). Distinctive features, categorical perception, and probability learning: Some applications of a neural model. Psychological Review,84:413-451.\nAndreae, J. H. (1963). STELLA: A scheme for a learning machine. In Proceedings of the 2nd IFAC Congress, Basle,pp. 497-502. Butterworths, London.\nAndreae, J. H. (1969a). A learning machine with monologue. International Journal of Man-Machine Studies,1:1-20.\nAndreae, J. H. (1969b). Learning machines\\A1\\AAa unified view. In A. R. Meetham and R. A. Hudson (eds.), Encyclopedia of Information, Linguistics, and Control,pp. 261\u0026shy;270. Pergamon, Oxford.\nAndreae, J. H. (1977). Thinking with the Teachable Machine.Academic Press, London.\nArthur, W. B. (1991). Designing economic agents that act like human agents: A behavioral approach to bounded rationality. The American Economic Review 81(2):353-359.\nAtkeson, C. G. (1992). Memory-based approaches to approximating continuous functions. In Sante Fe Institute Studies in the Sciences of Complexity, Proceedings Vol. 12, pp. 521\u0026shy;521. Addison-Wesley Publishing Co.\nAtkeson, C. G., Moore, A. W., and Schaal, S. (1997). Locally weighted learning. Artificial Intelligence Review 11:11һ73.\nAuer, P., Cesa-Bianchi, N., Fischer, P. (2002). Finite-time analysis of the multiarmed bandit problem. Machine learning, 47(2-3):235-256.\nBae, J., Chhatbar, P., Francis, J. T., Sanchez, J. C., and Principe, J. C. (2011). Reinforce\u0026shy;ment learning via kernel temporal difference. In Annual International Conference of the IEEE Engineering in Medicine and Biology Society, pp. 5662-5665. IEEE.\nBaird, L. C. (1995). Residual algorithms: Reinforcement learning with function approxi\u0026shy;mation. In Proceedings of the Twelfth International Conference on Machine Learning, pp. 30-37. Morgan Kaufmann, San Francisco.\nBaird, L. C., and Klopf, A. H. (1993). Reinforcement learning with high-dimensional, con\u0026shy;tinuous actions. Wright Laboratory, Wright-Patterson Air Force Base, Tech. Rep. WL- TR-93-1147.\nBaird, L., Moore, A. W. (1999). Gradient descent for general reinforcement learning. Ad\u0026shy;vances in Neural Information Processing Systems,pp. 968-974.\nBaldassarre, G. and Mirolli, M., editors (2013). Intrinsically Motivated Learning in Natural and Artificial Systems. Springer-Verlag, Berlin.\nBalke, A., Pearl, J. (1994). Counterfactual probabilities: Computational methods, bounds and applications. In Proceedings of the Tenth International Conference on Uncertainty in Artificial Intelligence(pp. 46-54). Morgan Kaufmann.\nBao, G., Cassandras, C. G., Djaferis, T. E., Gandhi, A. D., Looze, D. P. (1994). Elevator dispatchers for down peak traffic. Technical report. ECE Department, University of Massachusetts, Amherst.\nBaras, D. and Meir, R. (2007). Reinforcement learning, spike-time-dependent plasticity, and the BCM rule. Neural Computation, 19(8):2245-2279.\nBarnard, E. (1993). Temporal-difference methods and Markov models. IEEE Transactions on Systems, Man, and Cybernetics23:357-365.\nBarnhill, R. E. (1977). Representation and approximation of surfaces. Mathematical Software\n3:69-120.\nBarreto, A. S., Precup, D., and Pineau, J. (2011). Reinforcement learning using kernel- based stochastic factorization. In Advances in Neural Information Processing Systems, pp. 720-728.\nBartlett, P. L. and Baxter, J. (1999). Hebbian synaptic modifications in spiking neurons that learn. Technical report, Research School of Information Sciences and Engineering, Australian National University.\nBartlett, P. L. and Baxter, J. (2000). A biologically plausible and locally optimal learning algorithm for spiking neurons. Rapport technique, Australian National University.\nBarto, A. G. (1985). Learning by statistical cooperation of self-interested neuron-like com\u0026shy;puting elements. Human Neurobiology,4:229-256.\nBarto, A. G. (1986). Game-theoretic cooperativity in networks of self-interested units. In J. S. Denker (ed.), Neural Networks for Computing,pp. 41-46. American Institute of Physics, New York.\nBarto, A. G. (1989). From chemotaxis to cooperativity: Abstract exercises in neuronal learning strategies. In Durbin, R., Maill, R., and Mitchison, G., editors, The Computing Neuron, pages 73-98. Addison-Wesley, Reading, MA.\nBarto, A. G. (1990). Connectionist learning for control: An overview. In T. Miller, R. S. Sutton, and P. J. Werbos (eds.), Neural Networks for Control,pp. 5-58. MIT Press, Cambridge, MA.\nBarto, A. G. (1991). Some learning tasks from a control perspective. In L. Nadel and D. L. Stein (eds.), 1990 Lectures in Complex Systems,pp. 195-223. Addison-Wesley, Redwood City, CA.\nBarto, A. G. (1992). Reinforcement learning and adaptive critic methods. In D. A. White and D. A. Sofge (eds.), Handbook of Intelligent Control: Neural, Fuzzy, and Adaptive Approaches, pp. 469-491. Van Nostrand Reinhold, New York.\nBarto, A. G. (1995a). Adaptive critics and the basal ganglia. In J. C. Houk, J. L. Davis, and D. G. Beiser (eds.), Models of Information Processing in the Basal Ganglia,pp. 215-232. MIT Press, Cambridge, MA.\nBarto, A. G. (1995b). Reinforcement learning. In M. A. Arbib (ed.), Handbook of Brain Theory and Neural Networks, pp. 804-809. MIT Press, Cambridge, MA.\nBarto, A. G. (2011). Adaptive real-time dynamic programming. In Sammut, C. and Webb, G. I. (Eds.) Encyclopedia of machine learning,pp. 19-22. Springer Science and Business Media.\nBarto, A. G. (2013). Intrinsic motivation and reinforcement learning. In Intrinsically Moti\u0026shy;vated Learning in Natural and Artificial Systems,pp. 17-47. Springer Berlin Heidelberg\nBarto, A. G., Anandan, P. (1985). Pattern recognizing stochastic learning automata. IEEE Transactions on Systems, Man, and Cybernetics,15:360-375.\nBarto, A. G., Anderson, C. W. (1985). Structural learning in connectionist systems. In Program of the Seventh Annual Conference of the Cognitive Science Society, pp. 43-54.\nBarto, A. G., Anderson, C. W., Sutton, R. S. (1982). Synthesis of nonlinear control surfaces by a layered associative search network. Biological Cybernetics, 43:175-185.\nBarto, A. G., Bradtke, S. J., Singh, S. P. (1991). Real-time learning and control using asynchronous dynamic programming. Technical Report 91-57. Department of Computer\nand Information Science, University of Massachusetts, Amherst.\nBarto, A. G., Bradtke, S. J., Singh, S. P. (1995). Learning to act using real-time dynamic programming. Artificial Intelligence,72:81-138.\nBarto, A. G., Duff, M. (1994). Monte Carlo matrix inversion and reinforcement learning. In J. D. Cohen, G. Tesauro, and J. Alspector (eds.), Advances in Neural Information Pro\u0026shy;cessing Systems: Proceedings of the 1993 Conference,pp. 687-694. Morgan Kaufmann, San Francisco.\nBarto, A. G., Jordan, M. I. (1987). Gradient following without back-propagation in layered networks. In M. Caudill and C. Butler (eds.), Proceedings of the IEEE First Annual Conference on Neural Networks, pp. II629-II636. SOS Printing, San Diego, CA.\nBarto, A. G., and Mahadevan, S. (2003). Recent advances in hierarchical reinforcement learning. Discrete Event Dynamic Systems 13(4):341-379.\nBarto, A. G., Singh, S., and Chentanez, N. (2004). Intrinsically motivated learning of hierarchical collections of skills. In International Conference on Developmental Learning (ICDL),LaJolla, CA.\nBarto, A. G., Sutton, R. S. (1981a). Goal seeking components for adaptive intelligence: An initial assessment. Technical Report AFWAL-TR-81-1070. Air Force Wright Aeronau\u0026shy;tical Laboratories/Avionics Laboratory, Wright-Patterson AFB, OH.\nBarto, A. G., Sutton, R. S. (1981b). Landmark learning: An illustration of associative search. Biological Cybernetics,42:1-8.\nBarto, A. G., Sutton, R. S. (1982). Simulation of anticipatory responses in classical condi\u0026shy;tioning by a neuron-like adaptive element. Behavioural Brain Research,4:221-235.\nBarto, A. G., Sutton, R. S., Anderson, C. W. (1983). Neuronlike elements that can solve difficult learning control problems. IEEE Transactions on Systems, Man, and Cybernet\u0026shy;ics,13:835-846. Reprinted in J. A. Anderson and E. Rosenfeld (eds.), Neurocomputing: Foundations of Research,pp. 535-549. MIT Press, Cambridge, MA, 1988.\nBarto, A. G., Sutton, R. S., Brouwer, P. S. (1981). Associative search network: A reinforce\u0026shy;ment learning associative memory. Biological Cybernetics, 40:201-211.\nBarto, A. G., Sutton, R. S., and Watkins, C. J. C. H. (1990). Learning and sequential decision making. In M. Gabriel and J. Moore (eds.), Learning and Computational Neuroscience: Foundations of Adaptive Networks, pp. 539-602. MIT Press, Cambridge, MA.\nBellemare, M. G., Naddaf, Y., Veness, J., and Bowling, M. (2012a). The arcade learning environment: An evaluation platform for general agents. Journal of Artificial Intelligence Research, 47:253-279.\nBellemare, M. G., Veness, J., and Bowling, M. (2012b). Investigating contingency aware\u0026shy;ness using Atari 2600 games. In Proceedings of the Twenty-Sixth AAAI Conference on Artificial Intelligence (AAAI 2012),pages 864-871, Palo Alto, CA. The AAAI Press.\nBellman, R. E. (1956). A problem in the sequential design of experiments. Sankhya, 16:221-229.\nBellman, R. E. (1957a). Dynamic Programming.Princeton University Press, Princeton.\nBellman, R. E. (1957b). A Markov decision process. Journal of Mathematical Mechanics, 6:679-684.\nBellman, R. E., Dreyfus, S. E. (1959). Functional approximations and dynamic program\u0026shy;ming. Mathematical Tables and Other Aids to Computation,13:247-251.\nBellman, R. E., Kalaba, R., Kotkin, B. (1973). Polynomial approximation\\A1\\AAA new com\u0026shy;putational technique in dynamic programming: Allocation processes. Mathematical\nComputation,17:155-161.\nBengio, Y. (2009). Learning deep architectures for AI. Foundations and Trends in Machine Learning,2(1):1-27.\nBengio, Y., Courville, A. C., and Vincent, P. (2012). Unsupervised feature learning and deep learning: A review and new perspectives. CoRR 1, arXiv 1206.5538.\nBentley, J. L. (1975). Multidimensional binary search trees used for associative searching. Communications of the ACM 18(9):509-517.\nBerg, H. C. (1975). Chemotaxis in bacteria. Annual review of biophysics and bioengineering, 4(1):119-136.\nBernoulli, D. (1954). Exposition of a new theory on the measurement of risk. Econometrica, 22(1):23-36. English translation of the 1738 paper.\nBerns, G. S., McClure, S. M., Pagnoni, G., and Montague, P. R. (2001). Predictability modulates human brain response to reward. The journal of neuroscience,21(8):2793- 2798.\nBerridge, K. C. and Kringelbach, M. L. (2008). Affective neuroscience of pleasure: reward in humans and animals. Psychopharmacology,199(3):457-480.\nBerridge, K. C. and Robinson, T. E. (1998). What is the role of dopamine in reward: hedonic impact, reward learning, or incentive salience? Brain Research Reviews, 28(3):309-369.\nBerry, D. A., Fristedt, B. (1985). Bandit Problems.Chapman and Hall, London.\nBertsekas, D. P. (1982). Distributed dynamic programming. IEEE Transactions on Auto\u0026shy;matic Control,27:610-616.\nBertsekas, D. P. (1983). Distributed asynchronous computation of fixed points. Mathemat\u0026shy;ical Programming,27:107-120.\nBertsekas, D. P. (1987). Dynamic Programming: Deterministic and Stochastic Models. Prentice-Hall, Englewood Cliffs, NJ.\nBertsekas, D. P. (2005). Dynamic Programming and Optimal Control, Volume 1,third edition. Athena Scientific, Belmont, MA.\nBertsekas, D. P. (2012). Dynamic Programming and Optimal Control, Volume 2: Approxi\u0026shy;mate Dynamic Programming, fourth edition. Athena Scientific, Belmont, MA.\nBertsekas, D. P. (2013). Rollout algorithms for discrete optimization: A survey. In Handbook of Combinatorial Optimization,pp. 2989-3013. Springer New York.\nBertsekas, D. P., Tsitsiklis, J. N. (1989). Parallel and Distributed Computation: Numerical Methods.Prentice-Hall, Englewood Cliffs, NJ.\nBertsekas, D. P., Tsitsiklis, J. N. (1996). Neuro-Dynamic Programming.Athena Scientific, Belmont, MA.\nBertsekas, D. P., Tsitsiklis, J. N., and Wu, C. (1997). Rollout algorithms for combinatorial optimization. Journal of Heuristics 3(3):245-262.\nBertsekas, D. P., Yu, H. (2009). Projected equation methods for approximate solution of large linear systems. Journal of Computational and Applied Mathematics,227(1):27-50.\nBhat, N., Farias, V., and Moallemi, C. C. (2012). Non-parametric approximate dynamic programming via the kernel method. In Advances in Neural Information Processing Systems, pp. 386-394.\nBhatnagar, S., Sutton, R., Ghavamzadeh, M., Lee, M. (2009). Natural actor-critic algo\u0026shy;rithms. Automatica 45(11).\nBiermann, A. W., Fairfield, J. R. C., Beres, T. R. (1982). Signature table systems and\nlearning. IEEE Transactions on Systems, Man, and Cybernetics, 12:635-648.\nBishop, C. M. (1995). Neural Networks for Pattern Recognition.Clarendon, Oxford.\nBishop, C. M. (2006). Pattern Recognition and Machine Learning.Springer.\nBlodgett, H. C. (1929). The effect of the introduction of reward upon the maze performance of rats. University of California Publications in Psychology,4:113-134.\nBoakes, R. A. and Costa, D. S. J. (2014). Temporal contiguity in associative learning: Iinter- ference and decay from an historical perspective. Journal of Experimental Psychology: Animal Learning and Cognition,40(4):381-400.\nBooker, L. B. (1982). Intelligent Behavior as an Adaptation to the Task Environment. Ph.D. thesis, University of Michigan, Ann Arbor.\nBoone, G. (1997). Minimum-time control of the acrobot. In 1997 International Conference on Robotics and Automation, pp. 3281-3287. IEEE Robotics and Automation Society.\nBottou, L., and Vapnik, V. (1992). Local learning algorithms. Neural Computation 4(6):888- 900.\nBoutilier, C., Dearden, R., Goldszmidt, M. (1995). Exploiting structure in policy con\u0026shy;struction. In Proceedings of the Fourteenth International Joint Conference on Artificial Intelligence,pp. 1104-1111. Morgan Kaufmann.\nBoyan, J. A., (1999). Least-squares temporal difference learning. International Conference on Machine Learning 16,pp. 49-56.\nBoyan, J. (2002). Technical update: Least-squares temporal difference learning. Machine Learning49:233-246.\nBoyan, J. A., Moore, A. W. (1995). Generalization in reinforcement learning: Safely ap\u0026shy;proximating the value function. In G. Tesauro, D. S. Touretzky, and T. Leen (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1994 Confer\u0026shy;ence, pp. 369-376. MIT Press, Cambridge, MA.\nBradtke, S. J. (1993). Reinforcement learning applied to linear quadratic regulation. In S. J. Hanson, J. D. Cowan, and C. L. Giles (eds.), Advances in Neural Information Pro\u0026shy;cessing Systems: Proceedings of the 1992 Conference,pp. 295-302. Morgan Kaufmann, San Mateo, CA.\nBradtke, S. J. (1994). Incremental Dynamic Programming for On-Line Adaptive Optimal Control.Ph.D. thesis, University of Massachusetts, Amherst. Appeared as CMPSCI Technical Report 94-62.\nBradtke, S. J., Barto, A. G. (1996). Linear least-squares algorithms for temporal difference learning. Machine Learning, 22:33-57.\nBradtke, S. J., Ydstie, B. E., Barto, A. G. (1994). Adaptive linear quadratic control using policy iteration. In Proceedings of the American Control Conference, pp. 3475-3479. American Automatic Control Council, Evanston, IL.\nBradtke, S. J., Duff, M. O. (1995). Reinforcement learning methods for continuous-time Markov decision problems. In G. Tesauro, D. Touretzky, and T. Leen (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1994 Conference,pp. 393\u0026shy;400. MIT Press, Cambridge, MA.\nBrafman, R. I., Tennenholtz, M. (2003). R-max - a general polynomial time algorithm for near-optimal reinforcement learning. Journal of Machine Learning Research,3, 213-231.\nBreiter, H. C., Aharon, I., Kahneman, D., Dale, A., and Shizgal, P. (2001). Functional imaging of neural responses to expectancy and experience of monetary gains and losses. Neuron,30(2):619-639.\nBreland, K. and Breland, M. (1961). The misbehavior of organisms. American Psychologist, 16(11):681-684.\nBridle, J. S. (1990). Training stochastic model recognition algorithms as networks can lead to maximum mutual information estimates of parameters. In D. S. Touretzky (ed.), Advances in Neural Information Processing Systems: Proceedings of the 1989 Conference, pp. 211-217. Morgan Kaufmann, San Mateo, CA.\nBroomhead, D. S., Lowe, D. (1988). Multivariable functional interpolation and adaptive networks. Complex Systems,2:321-355.\nBromberg-Martin, E. S., Matsumoto, M., Hong, S., and Hikosaka, O. (2010). A pallidus- habenula-dopamine pathway signals inferred stimulus values. Journal of Neurophysiol\u0026shy;ogy,104(2):1068-1076.\nBrowne, C.B., Powley, E., Whitehouse, D., Lucas, S.M., Cowling, P.I., Rohlfshagen, P., Tavener, S., Perez, D., Samothrakis, S. and Colton, S. (2012). A survey of monte carlo tree search methods. IEEE Transactions on Computational Intelligence and AI in Games\n4(1):1-43.\nBrown, J., Bullock, D., and Grossberg, S. (1999). How the basal ganglia use parallel exci\u0026shy;tatory and inhibitory learning pathways to selectively respond to unexpected rewarding cues. The Journal of Neuroscience,19(23):10502-10511.\nBryson, A. E., Jr. (1996). Optimal control\\A1\\AA1950 to 1985. IEEE Control Systems,13(3):26- 33.\nBuchanan, B. G., Mitchell, T., Smith, R. G., and Jr., C. R. J. (1978). Models of learning\nsystems. Encyclopeadia of Computer Science and technology, 11.\nBuhusi, C. V. and Schmajuk, N. A. (1999). Timing in simple conditioning and occasion setting: A neural network approach. Behavioural processes, 45(1):33-57.\nBurke, C. J., Dreher, J.-C., Seymour, B., and Tobler, P. N. (2014). State-dependent value representation: evidence from the stiatum. Frontiers in Neuroscience, 8.\nBusoniu, L., Lazaric, A., Ghavamzadeh, M., Munos, R., Babuska, R., and De Schutter, B.\n(2012)\u0026nbsp; . Least-squares methods for policy iteration. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art,pp. 75-109. Springer Berlin Heidelberg.\nBush, R. R., Mosteller, F. (1955). Stochastic Models for Learning.Wiley, New York.\nByrne, J. H., Gingrich, K. J., Baxter, D. A. (1990). Computational capabilities of single neu\u0026shy;rons: Relationship to simple forms of associative and nonassociative learning in aplysia. In R. D. Hawkins and G. H. Bower (eds.), Computational Models of Learning,pp. 31-63. Academic Press, New York.\nCalabresi, P., Picconi, B., Tozzi, A., and Filippo, M. D. (2007). Dopamine-mediated regu\u0026shy;lation of corticostriatal synaptic plasticity. Trends in Neuroscience, 30(5):211-219.\nCamerer, C. (2003). Behavioral game theory: Experiments in strategic interaction.Princeton University Press.\nCampbell, D. T. (1960). Blind variation and selective survival as a general strategy in knowledge-processes. In M. C. Yovits and S. Cameron (eds.), Self-Organizing Systems, pp. 205-231. Pergamon, New York.\nCao, X. R. (2009). Stochastic learning and optimization\\A1\\AAA sensitivity-based approach. Annual Reviews in Control 33(1):11-24.\nCarlstrom, J., Nordstrom, E. (1997). Control of self-similar ATM call traffic by reinforce\u0026shy;ment learning. In Proceedings of the International Workshop on Applications of Neural Networks to Telecommunications 3,pp. 54-62. Erlbaum, Hillsdale, NJ.\nChapman, D., Kaelbling, L. P. (1991). Input generalization in delayed reinforcement learn\u0026shy;ing: An algorithm and performance comparisons. In Proceedings of the Twelfth In\u0026shy;ternational Conference on Artificial Intelligence, pp. 726-731. Morgan Kaufmann, San Mateo, CA.\nChow, C.-S., Tsitsiklis, J. N. (1991). An optimal one-way multigrid algorithm for discrete\u0026shy;time stochastic control. IEEE Transactions on Automatic Control, 36:898-914.\nChrisman, L. (1992). Reinforcement learning with perceptual aliasing: The perceptual distinctions approach. In Proceedings of the Tenth National Conference on Artificial Intelligence,pp. 183-188. AAAI/MIT Press, Menlo Park, CA.\nChristensen, J., Korf, R. E. (1986). A unified theory of heuristic evaluation functions and its application to learning. In Proceedings of the Fifth National Conference on Artificial Intelligence,pp. 148-152. Morgan Kaufmann, San Mateo, CA.\nCichosz, P. (1995). Truncating temporal differences: On the efficient implementation of TD(A) for reinforcement learning. Journal of Artificial Intelligence Research,2:287-318.\nClaridge-Chang, A., Roorda, R. D., Vrontou, E., Sjulson, L., Li, H., Hirsh, J., and Miesenbock,\nG.\u0026nbsp; (2009). Writing memories with light-addressable reinforcement circuitry.Cell,\n139(2):405-415.\nClark, R. E. and Squire, L. R. (1998). Classical conditioning and brain systems: the role of awareness. Science, 280(5360):77-81.\nClark, W. A., Farley, B. G. (1955). Generalization of pattern recognition in a self-organizing system. In Proceedings of the 1955 Western Joint Computer Conference,pp. 86-91.\nClouse, J. (1996). On Integrating Apprentice Learning and Reinforcement Learning TITLE2.\nPh.D. thesis, University of Massachusetts, Amherst. Appeared as CMPSCI Technical Report 96-026.\nClouse, J., Utgoff, P. (1992). A teaching method for reinforcement learning systems. In Pro\u0026shy;ceedings of the Ninth International Machine Learning Conference,pp. 92-101. Morgan Kaufmann, San Mateo, CA.\nCobo, L. C., Zang, P., Isbell, C. L., and Thomaz, A. L. (2011). Automatic state abstrac\u0026shy;tion from demonstration. In IJCAAI Proceedings: International Joint Conference on Artificial Intelligence, volume 22, page 1243.\nCohen, J. Y., Haesler, S., Vong, L., Lowell, B. B., and Uchida, N. (2012). Neuron-type-\nspecific signals for reward and punishment in the ventral tegmental area. Nature 482(7383):85- 88.\nColombetti, M., Dorigo, M. (1994). Training agent to perform sequential behavior. Adaptive Behavior, 2(3):247-275.\nConnell, J. (1989). A colony architecture for an artificial creature. Technical Report AI- TR-1151. MIT Artificial Intelligence Laboratory, Cambridge, MA.\nConnell, J., Mahadevan, S. (1993). Robot Learning.Kluwer Academic, Boston.\nConnell, M. E., and Utgoff, P. E. (1987). Learning to control a dynamic physical system. Computational intelligence 3(1):330-337.\nContreras-Vidal, J. L. and Schultz, W. (1999). A predictive reinforcement model of dopamine neurons for learning approach behavior. Journal of computational neuroscience,6(3):191- 214.\nCoulom, R. (2006). Efficient selectivity and backup operators in Monte-Carlo tree search. In Proceedings of the 5th International Conference on Computers and Games,pp. 72-83.\nCourville, A. C., Daw, N. D., and Touretzky, D. S. (2006). Bayesian theories of conditioning\nin a changing world. Trends in Cognitive Science,10(7):294-300.\nCraik, K. J. W. (1943). The Nature of Explanation.Cambridge University Press, Cambridge.\nCrites, R. H. (1996). Large-Scale Dynamic Optimization Using Teams of Reinforcement Learning Agents.Ph.D. thesis, University of Massachusetts, Amherst.\nCrites, R. H., Barto, A. G. (1996). Improving elevator performance using reinforcement learning. In D. S. Touretzky, M. C. Mozer, and M. E. Hasselmo (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1995 Conference,pp. 1017\u0026shy;1023. MIT Press, Cambridge, MA.\nCross, J. G. (1973). A stochastic learning model of economic behavior. The Quarterly Journal of Economics 87(2):239-266.\nCrow, T. J. (1968). Cortical synapses and reinforcement: a hypothesis. Nature,219:736-737.\nCurtiss, J. H. (1954). A theoretical comparison of the efficiencies of two classical methods and a Monte Carlo method for computing one component of the solution of a set of linear algebraic equations. In H. A. Meyer (ed.), Symposium on Monte Carlo Methods, pp. 191-233. Wiley, New York.\nCybenko, G. (1989). Approximation by superpositions of a sigmoidal function. Mathematics of control, signals and systems, 2(4):303-314.\nCziko, G. (1995). Without Miracles: Universal Selection Theory and the Second Darvinian Revolution.MIT Press, Cambridge, MA.\nDaniel, J. W. (1976). Splines and efficiency in dynamic programming. Journal of Mathe\u0026shy;matical Analysis and Applications, 54:402-407.\nDann, C., Neumann, G., Peters, J. (2014). Policy evaluation with temporal differences: A survey and comparison. Journal of Machine Learning Research 15:809-883.\nDaw, N. D., Courville, A. C., and Touretzky, D. S. (2003). Timing and partial observability in the dopamine system. In Advances in neural information processing systems, pages 99-106.\nDaw, N. D., Courville, A. C., and Touretzky, D. S. (2006). Representation and timing in theories of the dopamine system. Neural Computation,18(7):1637-1677.\nDaw, N., Niv, Y., and Dayan, P. (2005). Uncertainty based competition between pre- frontal and dorsolateral striatal systems for behavioral control. Nature Neuroscience, 8(12):1704-1711.\nDaw, N. D. and Shohamy, D. (2008). The cognitive neuroscience of motivation and learning. Social Cognition, 26(5):593-620.\nDayan, P. (1991). Reinforcement comparison. In D. S. Touretzky, J. L. Elman, T. J. Se- jnowski, and G. E. Hinton (eds.), Connectionist Models: Proceedings of the 1990 Summer School,pp. 45-51. Morgan Kaufmann, San Mateo, CA.\nDayan, P. (1992). The convergence of TD(A) for general A. Machine Learning,8:341-362.\nDayan, P. (2008). The role of value systems in decision making. In Engel, C. and Singer, W., editors, Better Than Conscious?: Decision Making, the Human Mind, and Implications For Institutions (Strungmann Forum Reports),pages 51-70. MIT Press, Cambridge, MA.\nDayan, P. and Abbott, L. F. (2001). Theoretical Neuroscience: Computational and Mathe\u0026shy;matical Modeling of Neural Systems. MIT Press, Cambridge, MA.\nDayan, P., and Berridge, K. C. (2014). Model-based and model-free Pavlovian reward learning: Revaluation, revision, and revaluation. Cognitive, Affective, \u0026amp; Behavioral Neuroscience, 14(2):473-492.\nDayan, P., and Hinton, G. E. (1993). Feudal reinforcement learning. In S. J. Hanson, J. D. Cohen, and C. L. Giles (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1992 Conference,pp. 271-278. Morgan Kaufmann, San Mateo, CA.\nDayan, P. and Niv, Y. (2008). Reinforcement learning: the good, the bad and the ugly. Current Opinion in Neurobiology, 18(2):185-196.\nDayan, P., Niv, Y., Seymour, B., and Daw, N. D. (2006). The misbehavior of value and the discipline of the will. Neural Networks 19(8):1153-1160.\nDayan, P., and Sejnowski, T. (1994). TD(A) converges with probability 1. Machine Learning, 14:295-301.\nDe Asis, K., Hernandez-Garcia, J. F., Holland, G. Z., and Sutton, R. S. (2017). Multi-step Reinforcement Learning: A Unifying Algorithm. arXiv preprint arXiv:1703.01327.\nDean, T., Lin, S.-H. (1995). Decomposition techniques for planning in stochastic domains. In Proceedings of the Fourteenth International Joint Conference on Artificial Intelli\u0026shy;gence,pp. 1121-1127. Morgan Kaufmann. See also Technical Report CS-95-10, Brown University, Department of Computer Science, 1995.\nDegris, T., White, M., Sutton, R. S. (2012). Off-policy actor-critic. Proceedings of the 29th International Conference on Machine Learning.\nDeJong, G., Spong, M. W. (1994). Swinging up the acrobot: An example of intelligent control. In Proceedings of the American Control Conference,pp. 2158-2162. American Automatic Control Council, Evanston, IL.\nDenardo, E. V. (1967). Contraction mappings in the theory underlying dynamic program\u0026shy;ming. SIAM Review,9:165-177.\nDennett, D. C. (1978). Brainstorms,pp. 71-89. Bradford/MIT Press, Cambridge, MA.\nDerthick, M. (1984). Variations on the Boltzmann machine learning algorithm. Carnegie- Mellon University Department of Computer Science Technical Report No. CMU-CS-84- 120.\nDeutsch, J. A. (1953). A new type of behaviour theory. British Journal of Psychology. General Section,44(4):304-317.\nDeutsch, J. A. (1954). A machine with insight. Quarterly Journal of Experimental Psychol\u0026shy;ogy,6(1):6-11.\nDick, T. (2015). Policy Gradient Reinforcement Learning Without Regret. MSc Thesis, University of Alberta.\nDickinson, A. (1980). Contemporary Animal Learning Theory.Cambridge University Press, Cambridge.\nDickinson, A. (1985). Actions and habits: the development of behavioral autonomy. Phil. Trans. R. Soc. Lond. B,308(1135):67-78.\nDickinson, A. and Balleine, B. W. (2002). The role of learning in motivation. In Gallistel,\nC.\u0026nbsp; R., editor, Stevens handbook of experimental psychology,volume 3, pages 497-533. Wiley, NY.\nDietterich, T. and Buchanan, B. G. (1984). The role of the critic in learning systems. In Selfridge, O. G., Rissland, E. L., and Arbib, M. A., editors, Adaptive Control of Ill- Defined Systems,pages 127-147. Plenum Press, NY. Proceedings of the NATO Advanced Research Institute on Adaptive Control of Ill-defined Systems, NATO Conference Series II, Systems Science, Vol. 16.\nDietterich, T. G., Flann, N. S. (1995). Explanation-based learning and reinforcement learn\u0026shy;ing: A unified view. In A. Prieditis and S. Russell (eds.), Proceedings of the Twelfth\nInternational Conference on Machine Learning,pp. 176-184. Morgan Kaufmann, San Francisco.\nDietterich, T. G. and Wang, X. (2002). Batch value function approximation via support vec\u0026shy;tors. In Advances in Neural Information Processing Systems 14,pp. 1491-1498. Cam\u0026shy;bridge, MA: MIT Press.\nDiuk, C., Cohen, A., and Littman, M. L. (2008). An object-oriented representation for efficient reinforcement learning. In Proceedings of the 25th international conference on machine learning, pages 240-247. ACM New York, NY.\nDolan, R. J. and Dayan, P. (2013). Goals and habits in the brain. Neuron,80(2):312-325.\nDoll, B. B., Simon, D. A., and Daw, N. D. (2012). The ubiquity of model-based reinforcement learning. Current Opinion in Neurobiology,22:1-7.\nDonahoe, J. W. and Burgos, J. E. (2000). Behavior analysis and revaluation. Journal of the Experimental Analysis of Behavior, 74(3):331-346.\nDorigo, M. and Colombetti, M. (1994). Robot shaping: Developing autonomous agents through learning. Artificial Intelligence,71(2):321-370.\nDoya, K. (1996). Temporal difference learning in continuous time and space. In D. S. Touret- zky, M. C. Mozer, and M. E. Hasselmo (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1995 Conference,pp. 1073-1079. MIT Press, Cambridge, MA.\nDoya, K. and Sejnowski, T. J. (1995). A novel reinforcement model of birdsong vocalization learning. In Tesauro, G., Touretzky, D. S., and Leen, T., editors, Advances in Neural Information Processing Systems: Proceedings of the 1994 Conference,pages 101-108, Cambridge, MA. MIT Press.\nDoya, K. and Sejnowski, T. J. (1998). A computational model of birdsong learning by auditory experience and auditory feedback. In Central auditory processing and neural modeling, pages 77-88. Springer US.\nDoyle, P. G., Snell, J. L. (1984). Random Walks and Electric Networks.The Mathematical Association of America. Carus Mathematical Monograph 22.\nDreyfus, S. E., Law, A. M. (1977). The Art and Theory of Dynamic Programming.Academic Press, New York.\nDuda, R. O., Hart, P. E. (1973). Pattern Classification and Scene Analysis.Wiley, New York.\nDuff, M. O. (1995). Q-learning for bandit problems. In A. Prieditis and S. Russell (eds.), Proceedings of the Twelfth International Conference on Machine Learning,pp. 209-217. Morgan Kaufmann, San Francisco.\nEgger, D. M. and Miller, N. E. (1962). Secondary reinforcement in rats as a function of information value and reliability of the stimulus. Journal of Experimental Psychology, 64:97-104.\nEshel, N., Bukwich, M., Rao, V., Hemmelder, V., Tian, J., and Uchida, N. (2015). Arithmetic and local circuitry underlying dopamine prediction errors. Nature 525(7568):243-246.\nEshel, N., Tian, J., Bukwich, M., and Uchida, N. (2016). Dopamine neurons share common response function for reward prediction error. Nature Neuroscience 19(3):479-486.\nEstes, W. K. (1943). Discriminative conditioning. I. A discriminative property of conditioned anticipation. Journal of Experimental Psychology 32(2):150-155.\nEstes, W. K. (1948). Discriminative conditioning. II. Effects of a Pavlovian conditioned stimulus upon a subsequently established operant response. Journal of experimental\npsychology 38(2):173-177.\nEstes, W. K. (1950). Toward a statistical theory of learning. Psychololgical Review,57:94\u0026shy;107.\nFarley, B. G., Clark, W. A. (1954). Simulation of self-organizing systems by digital computer.\nIRE Transactions on Information Theory,4:76-84.\nFarries, M. A. and Fairhall, A. L. (2007). Reinforcement learning with modulated spike timingdependent synaptic plasticity. Journal of neurophysiology,98(6):3648-3665.\nFeldbaum, A. A. (1965). Optimal Control Systems.Academic Press, New York.\nFinch, G., and Culler, E. (1934). Higher order conditioning with constant motivation. The American Journal of Psychology, 596-602.\nFinnsson, H., Bjornsson, Y. (2008). Simulation-based approach to general game playing. In Proceedings of the Association for the Advancement of Artificial Intelligence,259-264.\nFiorillo, C. D., Tobler, P. N., and Schultz, W. (2003). Discrete coding of reward probability and uncertainty by dopamine neurons. Science, 299(5614):1898-1902.\nFiorillo, C. D., Yun, S. R., and Song, M. R. (2013). Diversity and homogeneity in responses of midbrain dopamine neurons. The Journal of Neuroscience,33(11):4693-4709.\nFlorian, R. V. (2007). Reinforcement learning through modulation of spike-timing-dependent synaptic plasticity. Neural Computation, 19(6):1468-1502.\nFogel, L. J., Owens, A. J., Walsh, M. J. (1966). Artificial intelligence through simulated evolution. John Wiley and Sons.\nFrey, U. and Morris, R. G. M. (1997). Synaptic tagging and long-term potentiation. Nature, 385(6616):533-536.\nFriedman, J. H., Bentley, J. L., and Finkel, R. A. (1977). An algorithm for finding best matches in logarithmic expected time. ACM Transactions on Mathematical Software 3(3):209-226.\nFriston, K. J., Tononi, G., Reeke, G. N., Sporns, O., Edelman, G. M. (1994). Value- dependent selection in the brain: Simulation in a synthetic neural model. Neuroscience, 59:229-243.\nFu, K. S. (1970). Learning control systems\\A1\\AAReview and outlook. IEEE Transactions on Automatic Control,15:210-221.\nGalanter, E., Gerstenhaber, M. (1956). On thought: The extrinsic theory. Psychological Review,63:218-227.\nGallant, S. I. (1993). Neural Network Learning and Expert Systems.MIT Press, Cambridge, MA.\nGallistel, C. R. (2005). Deconstructing the law of effect. Games and Economic Behavior 52(2), 410-423.\nGallmo, O., Asplund, L. (1995). Reinforcement learning by construction of hypothetical targets. In J. Alspector, R. Goodman, and T. X. Brown (eds.), Proceedings of the International Workshop on Applications of Neural Networks to Telecommunications2, pp. 300-307. Erlbaum, Hillsdale, NJ.\nGardner, M. (1973). Mathematical games. Scientific American,228(1):108-115.\nGeist, M., Scherrer, B. (2014). Off-policy learning with eligibility traces: A survey. Journal of Machine Learning Research 15:289-333.\nGelperin, A., Hopfield, J. J., Tank, D. W. (1985). The logic of Umaxlearning. In A. Selver- ston (ed.), Model Neural Networks and Behavior,pp. 247-261. Plenum Press, New York.\nGenesereth, M., Thielscher, M. (2014). General game playing. Synthesis Lectures on Artifi\u0026shy;cial Intelligence and Machine Learning, 8(2), 1-229.\nGershman, S. J., Moustafa, A. A., and Ludvig, E. A. (2013). Time representation in rein\u0026shy;forcement learning models of the basal ganglia. Frontiers in computational neuroscience, 7.\nGershman, S. J., Pesaran, B., and Daw, N. D. (2009). Human reinforcement learning sub\u0026shy;divides structured action spaces by learning effector-specific values. Journal of Neuro\u0026shy;science 29(43):13524-13531.\nGershman, S. J. and Niv, Y. (2010). Learning latent structure: Carving nature at its joints. Current Opinions in Neurobiology, 20:251-256.\nGhiassian, S., Rafiee, B., Sutton, R. S. (2016). A first empirical study of emphatic tem\u0026shy;poral difference learning. Workshop on Continual Learning and Deep Learning at the Conference on Neural Information Processing Systems. ArXiv:1705.04185.\nGibbs, C. M., Cool, V., Land, T., Kehoe, E. J., and Gormezano, I. (1991). Second-order conditioning of the rabbits nictitating membrane response. Integrative Physiological and Behavioral Science 26(4):282-295.\nGittins, J. C., Jones, D. M. (1974). A dynamic allocation index for the sequential design of experiments. In J. Gani, K. Sarkadi, and I. Vincze (eds.), Progress in Statistics, pp. 241-266. North-Holland, Amsterdam-London.\nGlimcher, P. W. (2011). Understanding dopamine and reinforcement learning: The dopamine reward prediction error hypothesis. Proceedings of the National Academy of Sciences, 108(Supplement 3):15647-15654.\nGlimcher, P. W. (2003). Decisions, uncertainty, and the brain: The science of neuroeco\u0026shy;nomics. MIT Press, Cambridge, MA.\nGlimcher, P. W. and Fehr, E., editors (2013). Neuroeconomics: Decision making and the brain, Second Edition. Academic Press.\nGoldberg, D. E. (1989). Genetic Algorithms in Search, Optimization, and Machine Learning. Addison-Wesley, Reading, MA.\nGoldstein, H. (1957). Classical Mechanics.Addison-Wesley, Reading, MA.\nGoodfellow, I., Bengio, Y., and Courville, A. (2016). Deep Learning.MIT Press.\nGoodwin, G. C., Sin, K. S. (1984). Adaptive Filtering Prediction and Control. Prentice-Hall, Englewood Cliffs, NJ.\nGopnik, A., Glymour, C., Sobel, D., Schulz, L. E., Kushnir, T., and Danks, D. (2004). A theory of causal learning in children: Causal maps and Bayes nets. Psychological Review, 111(1):3-32.\nGordon, G. J. (1995). Stable function approximation in dynamic programming. In A. Priedi\u0026shy;tis and S. Russell (eds.), Proceedings of the Twelfth International Conference on Machine Learning, pp. 261-268. Morgan Kaufmann, San Francisco. An expanded version was published as Technical Report CMU-CS-95-103. Carnegie Mellon University, Pittsburgh, PA, 1995.\nGordon, G. J. (1996a). Chattering in SARSA(A). CMU learning lab internal report.\nGordon, G. J. (1996b). Stable fitted reinforcement learning. In D. S. Touretzky, M. C. Mozer, M. E. Hasselmo (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1995 Conference,pp. 1052-1058. MIT Press, Cambridge, MA.\nGordon, G. J. (1999). Approximate solutions to Markov decision processes.PhD thesis, School of Computer Science, Carnegie Mellon University, Pittsburgh, PA.\nGordon, G. J. (2001). Reinforcement learning with function approximation converges to a region. Advances in neural information processing systems.\nGraybiel, A. M. (2000). The basal ganglia. Current Biology,10(14):R509-R511.\nGreensmith, E., Bartlett, P. L., Baxter, J. (2001). Variance reduction techniques for gradi\u0026shy;ent estimates in reinforcement learning. In Advances in Neural Information Processing Systems: Proceedings of the 2000 Conference, pp. 1507-1514.\nGreensmith, E., Bartlett, P. L., Baxter, J. (2004). Variance reduction techniques for gradient estimates in reinforcement learning. Journal of Machine Learning Research 5(Nov), 1471-1530.\nGriffith, A. K. (1966). A new machine learning technique applied to the game of checkers. Technical Report Project MAC, Artificial Intelligence Memo 94. Massachusetts Institute of Technology, Cambridge, MA.\nGriffith, A. K. (1974). A comparison and evaluation of three machine learning procedures as applied to the game of checkers. Artificial Intelligence,5:137-148.\nGrondman, I., Busoniu, L., Lopes, G. A., Babuska, R. (2012). A survey of actor-critic reinforcement learning: Standard and natural policy gradients. IEEE Transactions on Systems, Man, and Cybernetics, Part C (Applications and Reviews) 42(6), 1291-1307.\nGrossberg, S. (1975). A neural model of attention, reinforcement, and discrimination learn\u0026shy;ing. International Review of Neurobiology,18:263-327.\nGrossberg, S. and Schmajuk, N. A. (1989). Neural dynamics of adaptive timing and temporal discrimination during associative learning. Neural Networks, 2(2):79-102.\nGullapalli, V. (1990). A stochastic reinforcement algorithm for learning real-valued functions. Neural Networks, 3:671-692.\nGullapalli, V. and Barto, A. G. (1992). Shaping as a method for accelerating reinforcement learning. In Proceedings of the 1992 IEEE International Symposium on Intelligent Control, pages 554-559. IEEE.\nGurney, K., Prescott, T. J., and Redgrave, P. (2001). A computational model of action selection in the basal ganglia I. A new functional anatomy. Biological cybernetics, 84(6):401-410.\nGurvits, L., Lin, L.-J., Hanson, S. J. (1994). Incremental learning of evaluation functions for absorbing Markov chains: New methods and theorems. Preprint.\nHackman, L. (2012). Faster Gradient-TD Algorithms(MSc dissertation, University of Al\u0026shy;berta).\nHallak, A., Tamar, A., Munos, R., Mannor, S. (2016). Generalized emphatic temporal difference learning: Bias-variance analysis. In Thirtieth AAAIConference on Artificial Intelligence.\nHammer, M. (1997). The neural basis of associative reward learning in honeybees. Trends in Neuroscience, 20:245-252.\nHammer, M. and Menzel, R. (1995). Learning and memory in the honeybee. Journal of Neuroscience, 15(3):1617-1630.\nHampson, S. E. (1983). A Neural Model of Adaptive Behavior. Ph.D. thesis, University of California, Irvine.\nHampson, S. E. (1989). Connectionist Problem Solving: Computational Aspects of Biological Learning. Birkhauser, Boston.\nHare, T. A., O,Doherty, J., Camerer, C. F., Schultz, W., and Rangel, A. (2008). Dissociating the role of the orbitofrontal cortex and the striatum in the computation of goal values\nand prediction errors. The Journal of Neuroscience,28(22):5623-5630.\nHassabis, D. and Maguire, E. A. (2007). Deconstructing episodic memory with construction. Trends in cognitive sciences, 11(7):299-306.\nHawkins, R. D., Kandel, E. R. (1984). Is there a cell-biological alphabet for simple forms of learning? Psychological Review,91:375-391.\nHe, K., Huertas, M., Hong, S. Z., Tie, X., Hell, J. W., Shouval, H., and Kirkwood, A. (2015). Distinct eligibility traces for LTP and LTD in cortical synapses. Neuron,88(3):528-538.\nHe, K., Zhang, X., Ren, S., and Sun, J. (2016). Deep residual learning for image recog\u0026shy;nition. In Proceedings of the 1992 IEEE Conference on Computer Vision and Pattern Recognition, pages 770-778.\nHebb, D. O. (1949). The organization of behavior: A neuropsychological theory.John Wiley and Sons Inc., New York. Reissued by Lawrence Erlbaum Associates Inc., Mahwah NJ, 2002.\nHengst, B. (2012). Hierarchical approaches. In Wiering and van Otterlo (Eds.) Reinforce\u0026shy;ment Learning: State-of-the Art,pp. 293-323. Springer Berlin Heidelberg.\nHerrnstein, R. J. (1970). On the Law of Effect. Journal of the Experimental Analysis of Behavior 13(2), 243-266.\nHersh, R., Griego, R. J. (1969). Brownian motion and potential theory. Scientific American, 220:66-74.\nHester, T., and Stone, P. (2012). Learning and using models. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art,pp. 111-141. Springer Berlin Heidel\u0026shy;berg.\nHesterberg, T. C. (1988), Advances in importance sampling, Ph.D. Dissertation, Statistics Department, Stanford University.\nHilgard, E. R. (1956). Theories of Learning, Second Edition.Appleton-Century-Cofts, Inc., New York.\nHilgard, E. R., Bower, G. H. (1975). Theories of Learning.Prentice-Hall, Englewood Cliffs, NJ.\nHinton, G. E. (1984). Distributed representations. Technical Report CMU-CS-84-157. Department of Computer Science, Carnegie-Mellon University, Pittsburgh, PA.\nHinton, G. E., Osindero, S., and Teh, Y. (2006). A fast learning algorithm for deep belief nets. Neural Computation, 18(7):1527-1554.\nHochreiter, S., Schmidhuber, J. (1997). LTSM can solve hard time lag problems. In Advances in Neural Information Processing Systems: Proceedings of the 1996 Conference,pp. 473\u0026shy;479. MIT Press, Cambridge, MA.\nHolland, J. H. (1975). Adaptation in Natural and Artificial Systems. University of Michigan Press, Ann Arbor.\nHolland, J. H. (1976). Adaptation. In R. Rosen and F. M. Snell (eds.), Progress in Theoretical Biology,vol. 4, pp. 263-293. Academic Press, New York.\nHolland, J. H. (1986). Escaping brittleness: The possibility of general-purpose learning algorithms applied to rule-based systems. In R. S. Michalski, J. G. Carbonell, and T. M. Mitchell (eds.), Machine Learning: An Artificial Intelligence Approach,vol. 2, pp. 593-623. Morgan Kaufmann, San Mateo, CA.\nHollerman, J. R. and Schultz, W. (1998). Dopmine neurons report an error in the temporal prediction of reward during learning. Nature Neuroscience,1:304-309.\nHouk, J. C., Adams, J. L., Barto, A. G. (1995). A model of how the basal ganglia generates and uses neural signals that predict reinforcement. In J. C. Houk, J. L. Davis, and\nD.G. Beiser (eds.), Models of Information Processing in the Basal Ganglia,pp. 249-270. MIT Press, Cambridge, MA.\nHoward, R. (1960). Dynamic Programming and Markov Processes. MIT Press, Cambridge, MA.\nHull, C. L. (1932). The goal-gradient hypothesis and maze learning. Psychological Review, 39(1):25-43.\nHull, C. L. (1943). Principles of Behavior.Appleton-Century, New York.\nHull, C. L. (1952). A Behavior System.Wiley, New York.\nIoffe, S., and Szegedy, C. (2015). Batch normalization: Accelerating deep network training by reducing internal covariate shift. arXiv:1502.03167.\nipek, E., Mutlu, O., Martinez, J. F., and Caruana, R. (2008). Self-optimizing memory controllers: A reinforcement learning approach. In 35th International Symposium on Computer Architecture, ISCA?08,pages 39-50. IEEE.\nIzhikevich, E. M. (2007). Solving the distal reward problem through linkage of STDP and dopamine signaling. Cerebral cortex, 17(10):2443-2452.\nJaakkola, T., Jordan, M. I., Singh, S. P. (1994). On the convergence of stochastic iterative dynamic programming algorithms. Neural Computation,6:1185-1201.\nJaakkola, T., Singh, S. P., Jordan, M. I. (1995). Reinforcement learning algorithm for partially observable Markov decision problems. In G. Tesauro, D. S. Touretzky, T. Leen (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1994 Conference, pp. 345-352. MIT Press, Cambridge, MA.\nJoel, D., Niv, Y., and Ruppin, E. (2002). Actor-critic models of the basal ganglia: New anatomical and computational perspectives. Neural networks, 15(4):535-547.\nJohanson, E. B., Killeen, P. R., Russell, V. A., Tripp, G., Wickens, J. R., Tannock, R., Williams, J., and Sagvolden, T. (2009). Origins of altered reinforcement effects in ADHD. Behavioral and Brain Functions,5(7).\nJohnson, A. and Redish, A. D. (2007). Neural ensembles in CA3 transiently encode paths forward of the animal at a decision point. The Journal of neuroscience,27(45):12176- 12189.\nKaelbling, L. P. (1993a). Hierarchical learning in stochastic domains: Preliminary results. In Proceedings of the Tenth International Conference on Machine Learning,pp. 167-173. Morgan Kaufmann, San Mateo, CA.\nKaelbling, L. P. (1993b). Learning in Embedded Systems.MIT Press, Cambridge, MA.\nKaelbling, L. P. (Ed.) (1996). Special triple issue on reinforcement learning, Machine Learning 22(1/2/3).\nKaelbling, L. P., Littman, M. L., Moore, A. W. (1996). Reinforcement learning: A survey. Journal of Artificial Intelligence Research, 4:237-285.\nKahneman, D. and Tversky, A. (1979). Prospect theory: An analysis of decision under risk. Econometrica: Journal of the Econometric Society,47:263-291.\nKakade, S. (2002). A natural policy gradient. Advances in neural information processing systems 2,1531-1538.\nKakade, S. M. (2003). On the Sample Complexity of Reinforcement Learning (Doctoral dissertation, University of London).\nKakutani, S. (1945). Markov processes and the Dirichlet problem. Proceedings of the Japan Academy,21:227-233.\nKalos, M. H., Whitlock, P. A. (1986). Monte Carlo Methods.Wiley, New York.\nKamin, L. J. (1968). \\A1\\B0Attention-like\\A1\\B1 processes in classical conditioning. In Jones, M. R. editor, Miami Symposium on the Prediction of Behavior, 1967: Aversive Stimulation pages 9-31. University of Miami Press, Coral Gables, Florida.\nKamin, L. J. (1969). Predictability, surprise, attention, and conditioning. In Campbell B. A. and Church, R. M., editors, Punishment and Aversive Behavior, pages 279-296 Appleton-Century-Crofts, New York, NY.\nKandel, E. R., Schwartz, J. H., Jessell, T. M., Siegelbaum, S. A., and Hudspeth, A. J. editors (2013). Principles of Neural Science, Fifth Edition.McGraw-Hill Companies Inc.\nKanerva, P. (1988). Sparse Distributed Memory.MIT Press, Cambridge, MA.\nKanerva, P. (1993). Sparse distributed memory and related models. In M. H. Hassoun (ed.), Associative Neural Memories: Theory and Implementation,pp. 50-76. Oxford University Press, New York.\nKarampatziakis, N., and Langford, J. (2010). Online importance weight aware updates. ArXiv:1011.1576.\nKashyap, R. L., Blaydon, C. C., Fu, K. S. (1970). Stochastic approximation. In J. M. Mendel and K. S. Fu (eds.), Adaptive, Learning, and Pattern Recognition Systems: Theory and Applications,pp. 329-355. Academic Press, New York.\nKearns, M., Singh, S. (2002). Near-optimal reinforcement learning in polynomial time. Ma\u0026shy;chine Learning, 49(2-3), 209-232.\nKeerthi, S. S., Ravindran, B. (1997). Reinforcement learning. In E. Fiesler and R. Beale (eds.), Handbook of Neural Computation,C3. Oxford University Press, New York.\nKehoe, E. J. (1982). Conditioning with serial compound stimuli: Theoretical and empirical issues. Experimental Animal Behavior,1:30-65.\nKehoe, E. J., Schreurs, B. G., and Graham, P. (1987). Temporal primacy overrides prior training in serial compound conditioning of the rabbits nictitating membrane response. Animal Learning \u0026amp; Behavior,15(4):455-464.\nKeiflin, R. and Janak, P. H. (2015). Dopamine prediction errors in reward learning and addiction: Ffrom theory to neural circuitry. Neuron,88(2):247- 263.\nKimble, G. A. (1961). Hilgard and Marquis\\A3\\ACConditioning and Learning.Appleton-Century- Crofts, New York.\nKimble, G. A. (1967). Foundations of Conditioning and Learning.Appleton-Century-Crofts, New York.\nKlopf, A. H. (1972). Brain function and adaptive systems\\A1\\AAA heterostatic theory. Technical Report AFCRL-72-0164, Air Force Cambridge Research Laboratories, Bedford, MA. A summary appears in Proceedings of the International Conference on Systems, Man, and Cybernetics. IEEE Systems, Man, and Cybernetics Society, Dallas, TX, 1974.\nKlopf, A. H. (1975). A comparison of natural and artificial intelligence. SIGART Newsletter, 53:11-13.\nKlopf, A. H. (1982). The Hedonistic Neuron: A Theory of Memory, Learning, and Intelli\u0026shy;gence.Hemisphere, Washington, DC.\nKlopf, A. H. (1988). A neuronal model of classical conditioning. Psychobiology, 16:85-125.\nKober, J. and Peters, J. (2012). Reinforcement learning in robotics: A survey. In Wiering, M. and van Otterlo, M., editors, Reinforcement Learning: State-of-the-Art, pages 579\u0026shy;610. Springer-Verlag, Berlin.\nKocsis, L., Szepesvari, Cs. (2006). Bandit based Monte-Carlo planning. In Proceedings of the European Conference on Machine Learning, 282-293. Springer Berlin Heidelberg.\nKohonen, T. (1977). Associative Memory: A System Theoretic Approach.Springer-Verlag, Berlin.\nKoller, D., Friedman, N. (2009). Probabilistic Graphical Models: Principles and Techniques. MIT Press, 2009.\nKolodziejski, C., Porr, B., and Worgotter, F. (2009). On the asymptotic equivalence between differential Hebbian and temporal difference learning. Neural computation, 21(4):1173- 1202.\nKolter, J. Z. (2011). The fixed points of off-policy TD. Advances in Neural Information Processing Systems 24,pp. 2169-2177.\nKonidaris, G. D., Osentoski, S., Thomas, P. S. (2011). Value function approximation in rein\u0026shy;forcement learning using the Fourier basis, Proceedings of the Twenty-Fifth Conference of the Association for the Advancement of Artificial Intelligence,pp. 380-385.\nKorf, R. E. (1988). Optimal path finding algorithms. In L. N. Kanal and V. Kumar (eds.), Search in Artificial Intelligence,pp. 223-267. Springer Verlag, Berlin.\nKorf, R. E. (1990). Real-time heuristic search. Artificial Intelligence 42(2-3), 189-211.\nKoshland, D. E. (1980). Bacterial Chemotaxis as a Model Bhavioral System. Raven Press, New York.\nKoza, J. R. (1992). Genetic programming: On the programming of computers by means of natural selection(Vol. 1). MIT press.\nKraft, L. G., Campagna, D. P. (1990). A summary comparison of CMAC neural network and traditional adaptive control systems. In T. Miller, R. S. Sutton, and P. J. Werbos (eds.), Neural Networks for Control,pp. 143-169. MIT Press, Cambridge, MA.\nKraft, L. G., Miller, W. T., Dietz, D. (1992). Development and application of CMAC neural network-based control. In D. A. White and D. A. Sofge (eds.), Handbook of Intelligent Control: Neural, Fuzzy, and Adaptive Approaches,pp. 215-232. Van Nostrand Reinhold, New York.\nKumar, P. R., Varaiya, P. (1986). Stochastic Systems: Estimation, Identification, and Adaptive Control.Prentice-Hall, Englewood Cliffs, NJ.\nKumar, P. R. (1985). A survey of some results in stochastic adaptive control. SIAM Journal of Control and Optimization, 23:329-380.\nKumar, V., Kanal, L. N. (1988). The CDP: A unifying formulation for heuristic search, dynamic programming, and branch-and-bound. In L. N. Kanal and V. Kumar (eds.), Search in Artificial Intelligence, pp. 1-37. Springer-Verlag, Berlin.\nKushner, H. J., Dupuis, P. (1992). Numerical Methods for Stochastic Control Problems in Continuous Time.Springer-Verlag, New York.\nLagoudakis, M., Parr, R. (2003). Least squares policy iteration. Journal of Machine Learning Research 4:1107-1149.\nLai, T. L., Robbins, H. (1985). Asymptotically efficient adaptive allocation rules. Advances in applied mathematics,6(1):4-22.\nLakshmivarahan, S. and Narendra, K. S. (1982). Learning algorithms for two-person zero- sum stochastic games with incomplete information: A unified approach. SIAM Journal of Control and Optimization, 20:541-552.\nLammel, S., Lim, B. K., and Malenka, R. C. (2014). Reward and aversion in a heterogeneous midbrain dopamine system. Neuropharmacology,76:353-359.\nLane, S. H., Handelman, D. A., Gelfand, J. J. (1992). Theory and development of higher- order CMAC neural networks. IEEE Control Systems 12(2):23-30.\nLang, K. J., Waibel, A. H., Hinton, G. E. (1990). A time-delay neural network architecture for isolated word recognition. Neural Networks, 3:33-43.\nLange, S., Gabel, T., and Riedmiller, M. (2012). Batch reinforcement learning. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art,pp. 45-73. Springer Berlin Heidelberg.\nLeCun, Y. (1985). Une procdure d,apprentissage pour rseau a seuil asymmetrique (a learn\u0026shy;ing scheme for asymmetric threshold networks). In Proceedings of Cognitiva 85,Paris, France.\nLeCun, Y., Bottou, L., Bengio, Y., and Haffner, P. (1998). Gradient-based learning applied to document recognition. Proceedings of the IEEE,86(11):2278-2324.\nLegenstein, R. and andW. Maass, D. P. (2008). A learning theory for reward-modulated spike-timing-dependent plasticity with application to biofeedback. PLoS Computational Biology, 4(10).\nLevy, W. B. and Steward, D. (1983). Temporal contiguity requirements for long-term associative potentiation/depression in thehippocampus. Neuroscience,8:791-797.\nLewis, F. L., Liu, D. (Eds.). (2013). Reinforcement Learning and Approximate Dynamic Programming for Feedback Control.John Wiley and Sons.\nLewis, R. L., Howes, A., and Singh, S. (2014). Computational rationality: Linking mecha\u0026shy;nism and behavior through utility maximization. Topics in Cognitive Science,6(2):279-\n311.\nLi, L. (2012). Sample complexity bounds of exploration. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art,pp. 175-204. Springer Berlin Heidelberg.\nLi, L., Chu, W., Langford, J., and Schapire, R. E. (2010). A contextual-bandit approach to personalized news article recommendation. In Proceedings of the 19th International Conference on World Wide Web,pages 661-670. ACM.\nLin, C.-S., Kim, H. (1991). CMAC-based adaptive critic self-learning control. IEEE Transactions on Neural Networks, 2:530-533.\nLin, L.-J. (1992). Self-improving reactive agents based on reinforcement learning, planning and teaching. Machine Learning,8:293-321.\nLin, L.-J., Mitchell, T. (1992). Reinforcement learning with hidden states. In Proceedings of the Second International Conference on Simulation of Adaptive Behavior: From Animals to Animats, pp. 271-280. MIT Press, Cambridge, MA.\nLittman, M. L. (1994). Markov games as a framework for multi-agent reinforcement learning. In Proceedings of the Eleventh International Conference on Machine Learning,pp. 157\u0026shy;163. Morgan Kaufmann, San Francisco.\nLittman, M. L., Cassandra, A. R., Kaelbling, L. P. (1995). Learning policies for partially observable environments: Scaling up. In A. Prieditis and S. Russell (eds.), Proceedings of the Twelfth International Conference on Machine Learning,pp. 362-370. Morgan Kaufmann, San Francisco.\nLittman, M. L., Dean, T. L., Kaelbling, L. P. (1995). On the complexity of solving Markov decision problems. In Proceedings of the Eleventh Annual Conference on Uncertainty in Artificial Intelligence, pp. 394-402.\nLiu, J. S. (2001). Monte Carlo strategies in scientific computing.Berlin, Springer-Verlag.\nLiu, W., Pokharel, P. P., and Principe, J. C. (2008). The kernel least-mean-square algorithm.\nIEEE Transactions on Signal Processing 56(2):543-554.\nLjung, L. (1998). System identification. In Prochazka, A., Uhli^, J., Rayner, P. W. J., and Kingsbury, N. G., editors, Signal Analysis and Prediction,pages 163-173. Springer Science ʮBusiness Media New York, LLC.\nLjung, L., Soderstrom, T. (1983). Theory and Practice of Recursive Identification.MIT Press, Cambridge, MA.\nLjungberg, T., Apicella, P., and Schultz, W. (1992). Responses of monkey dopamine neurons during learning of behavioral reactions. Journal of Neurophysiology,67(1):145-163.\nLovejoy, W. S. (1991). A survey of algorithmic methods for partially observed Markov decision processes. Annals of Operations Research,28:47-66.\nLuce, D. (1959). Individual Choice Behavior.Wiley, New York.\nLudvig, E. A., Bellemare, M. G., and Pearson, K. G. (2011). A primer on reinforcement learning in the brain: Psychological, computational, and neural perspectives. In Alonso,\nE.\u0026nbsp; and Mondragon, E., editors, Computational neuroscience for advancing artificial in\u0026shy;telligence: Models, methods and applications,pages 111-44. Medical Information Science Reference, Hershey PA.\nLudvig, E. A., Sutton, R. S., and Kehoe, E. J. (2008). Stimulus representation and the timing of reward-prediction errors in models of the dopamine system. Neural Computation, 20(12):3034-3054.\nLudvig, E. A., Sutton, R. S., and Kehoe, E. J. (2012). Evaluating the TD model of classical conditioning. Learning \u0026amp; behavior, 40(3):305-319.\nMachado, A. (1997). Learning the temporal dynamics of behavior. Psychological review, 104(2):241-265.\nMackintosh, N. J. (1975). A theory of attention: Variations in the associability of stimuli with reinforcement. Psychological Review,82(4):276-298.\nMackintosh, N. J. (1983). Conditioning and Associative Learning.Oxford: Clarendon Press.\nMaclin, R., and Shavlik, J. W. (1994). Incorporating advice into agents that learn from rein\u0026shy;forcements. In Proceedings of the Twelfth National Conference on Artificial Intelligence, pp. 694-699. AAAI Press, Menlo Park, CA.\nMaei, H. R. (2011). Gradient temporal-difference learning algorithms.PhD thesis, University of Alberta.\nMaei, H. R., and Sutton, R. S. (2010). GQ(A): A general gradient algorithm for temporal- difference prediction learning with eligibility traces. In Proceedings of the Third Confer\u0026shy;ence on Artificial General Intelligence,pp. 91-96.\nMaei, H. R., Szepesvari, Cs., Bhatnagar, S., Precup, D., Silver, D., and Sutton, R. S. (2009). Convergent temporal-difference learning with arbitrary smooth function approximation. In Advances in Neural Information Processing Systems,pp. 1204-1212.\nMaei, H. R., Szepesvari, Cs., Bhatnagar, S., and Sutton, R. S. (2010). Toward off-policy learning control with function approximation. In Proceedings of the 27th International Conference on Machine Learning,pp. 719-726).\nMahadevan, S. (1996). Average reward reinforcement learning: Foundations, algorithms, and empirical results. Machine Learning,22:159-196.\nMahadevan, S., Liu, B., Thomas, P., Dabney, W., Giguere, S., Jacek, N., Gemp, I., Liu, J. (2014). Proximal reinforcement learning: A new theory of sequential decision making in primal-dual spaces. ArXiv preprint arXiv:1405.6757.\nMahadevan, S., and Connell, J. (1992). Automatic programming of behavior-based robots\nusing reinforcement learning. Artificial Intelligence,55:311-365.\nMahmood, A. R. (2017). Incremental Off-policy Reinforcement Learning Algorithms. Uni\u0026shy;versity of Alberta PhD thesis.\nMahmood, A. R., and Sutton, R. S. (2015). Off-policy learning based on weighted importance sampling with linear computational complexity. In Proceedings of the 31st Conference on Uncertainty in Artificial Intelligence, Amsterdam, Netherlands.\nMahmood, A. R., Sutton, R. S., Degris, T., and Pilarski, P. M. (2012). Tuning-free step-size adaptation. In Acoustics, Speech and Signal Processing (ICASSP), 2012 IEEE Interna\u0026shy;tional Conference on(pp. 2121-2124). IEEE.\nMahmood, A. R., Yu, H, Sutton, R. S. (2017). Multi-step off-policy learning without impor\u0026shy;tance sampling ratios. ArXiv 1702.03006.\nMahmood, A. R., van Hasselt, H., and Sutton, R. S. (2014). Weighted importance sam\u0026shy;pling for off-policy learning with linear function approximation. Advances in Neural Information Processing Systems 27.\nMarbach, P., Tsitsiklis, J. N. (2001). Simulation-based optimization of Markov reward pro\u0026shy;cesses. IEEE Transactions on Automatic Control 46(2), 191-209. Also MIT Technical Report LIDS-P-2411 (1998).\nMarkey, K. L. (1994). Efficient learning of multiple degree-of-freedom control problems with quasi-independent Q-agents. In M. C. Mozer, P. Smolensky, D. S. Touretzky, J. L. Elman, and A. S. Weigend (eds.), Proceedings of the 1990 Connectionist Models Summer School. Erlbaum, Hillsdale, NJ.\nMarkram, H., Liibke, J., Frotscher, M., and Sakmann, B. (1997). Regulation of synaptic efficacy by coincidence of postsynaptic APs and EPSPs. Science,275:213-215.\nMartinez, J. F. and ipek, E. (2009). Dynamic multicore resource management: A machine learning approach. Micro, IEEE, 29(5):8-17.\nMataric, M. J. (1994). Reward functions for accelerated learning. In Machine Learning: Proceedings of the Eleventh international conference,pages 181-189.\nMatsuda, W., Furuta, T., Nakamura, K. C., Hioki, H., Fujiyama, F., Arai, R., and Kaneko, T. (2009). Single nigrostriatal dopaminergic neurons form widely spread and highly dense axonal arborizations in the neostriatum. The Journal of Neuroscience,29(2):444-453.\nMazur, J. E. (1994). Learning and Behavior,3rd ed. Prentice-Hall, Englewood Cliffs, NJ.\nMcCallum, A. K. (1993). Overcoming incomplete perception with utile distinction memory. In Proceedings of the Tenth International Conference on Machine Learning,pp. 190-196. Morgan Kaufmann, San Mateo, CA.\nMcCallum, A. K. (1995). Reinforcement Learning with Selective Perception and Hidden State. Ph.D. thesis, University of Rochester, Rochester, NY.\nMcCulloch, W. S., and Pitts, W. (1943). A logical calculus of the ideas immanent in nervous activity. Bulletin of Mathematical Biophysics 5(4):115-133.\nMelo, F. S., Meyn, S. P., Ribeiro, M. I. (2008). An analysis of reinforcement learning with function approximation. In Proceedings of the 25th international conference on Machine learning(pp. 664-671).\nMendel, J. M. (1966). A survey of learning control systems. ISA Transactions,5:297-303.\nMendel, J. M., McLaren, R. W. (1970). Reinforcement learning control and pattern recog\u0026shy;nition systems. In J. M. Mendel and K. S. Fu (eds.), Adaptive, Learning and Pattern Recognition Systems: Theory and Applications, pp. 287-318. Academic Press, New York.\nMichie, D. (1961). Trial and error. In S. A. Barnett and A. McLaren (eds.), Science Survey,\nPart 2, pp. 129-145. Penguin, Harmondsworth.\nMichie, D. (1963). Experiments on the mechanisation of game learning. 1. characterization of the model and its parameters. Computer Journal,1:232-263.\nMichie, D. (1974). On Machine Intelligence.Edinburgh University Press, Edinburgh.\nMichie, D., Chambers, R. A. (1968). BOXES: An experiment in adaptive control. In E. Dale and D. Michie (eds.), Machine Intelligence 2,pp. 137-152. Oliver and Boyd, Edinburgh.\nMiller, R. (1981). Meaning and Purpose in the Intact Brain: A Philosophical, Psychological, and Biological Account of Conscious Process. Clarendon Press, Oxford.\nMiller, W. T., An, E., Glanz, F., Carter, M. (1990). The design of CMAC neural networks for control. Adaptive and Learning Systems 1:140-145.\nMiller, W. T., Glanz, F. H. (1996). UNH\\A1\\AACMAC verison 2.1: The University of New Hamp\u0026shy;shire Implementation of the Cerebellar Model Arithmetic Computer - CMAC.Robotics Laboratory Technical Report, University of New Hampshire, Durham, New Hampshire.\nMiller, S., Williams, R. J. (1992). Learning to control a bioreactor using a neural net Dyna- Q system. In Proceedings of the Seventh Yale Workshop on Adaptive and Learning Systems,pp. 167-172. Center for Systems Science, Dunham Laboratory, Yale University, New Haven.\nMiller, W. T., Scalera, S. M., Kim, A. (1994). Neural network control of dynamic balance for a biped walking robot. In Proceedings of the Eighth Yale Workshop on Adaptive and Learning Systems, pp. 156-161. Center for Systems Science, Dunham Laboratory, Yale University, New Haven.\nMinsky, M. L. (1954). Theory of Neural-Analog Reinforcement Systems and Its Application to the Brain-Model Problem.Ph.D. thesis, Princeton University.\nMinsky, M. L. (1961). Steps toward artificial intelligence. Proceedings of the Institute of Radio Engineers,49:8-30. Reprinted in E. A. Feigenbaum and J. Feldman (eds.), Computers and Thought,pp. 406-450. McGraw-Hill, New York, 1963.\nMinsky, M. L. (1967). Computation: Finite and Infinite Machines.Prentice-Hall, Englewood Cliffs, NJ.\nMnih, V., Kavukcuoglu, K., Silver, D., Rusu, A. A., Veness, J., Bellemare, M. G., Graves, A., Riedmiller, M., Fidjeland, A. K., Ostrovski, G., Petersen, S., Beattie, C., Sadik, A., Antonoglou, I., King, H., Kumaran, D., Wierstra, D., Legg, S., and Hassabis, D. (2015). Human-level control through deep reinforcement learning. Nature, 518(7540):529-533.\nModayil, J., and Sutton, R. S. (2014). Prediction driven behavior: Learning predictions that drive fixed responses. In AAAI-14 Workshop on Artificial Intelligence and Robotics, Quebec City, Canada.\nModayil, J., White, A., and Sutton, R. S. (2014). Multi-timescale nexting in a reinforcement learning robot. Adaptive Behavior,22(2):146-160.\nMontague, P. R., Dayan, P., Nowlan, S. J., Pouget, A., and Sejnowski, T. J. (1992). Using aperiodic reinforcement for directed self-organization during development. In Advances in neural information processing systems 5, pages 969-976.\nMontague, P. R., Dayan, P., Person, C., and Sejnowski, T. J. (1995). Bee foraging in uncertain environments using predictive hebbian learning. Nature, 377(6551):725-728.\nMontague, P. R., Dayan, P., Sejnowski, T. J. (1996). A framework for mesencephalic dopamine systems based on predictive Hebbian learning. Journal of Neuroscience, 16:1936-1947.\nMontague, P. R., Dolan, R. J., Friston, K. J., and Dayan, P. (2012). Computational psychi\u0026shy;atry. Trends in Cognitive Sciences 16(1):72-80.\nMontague, P. R. and Sejnowski, T. J. (1994). The predictive brain: Temporal coincidence and temporal order in synaptic learningmechanisms. Learning \u0026amp; Memory,1:1-33.\nMoore, A. W. (1990). Efficient Memory-Based Learning for Robot Control.Ph.D. thesis, University of Cambridge.\nMoore, A. W. (1994). The parti-game algorithm for variable resolution reinforcement learn\u0026shy;ing in multidimensional spaces. In J. D. Cohen, G. Tesauro and J. Alspector (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1993 Confer\u0026shy;ence,pp. 711-718. Morgan Kaufmann, San Francisco.\nMoore, A. W., Atkeson, C. G. (1993). Prioritized sweeping: Reinforcement learning with less data and less real time. Machine Learning,13:103-130.\nMoore, A. W., Schneider, J., and Deng, K. (1997). Efficient locally weighted polynomial regression predictions. In Proceedings of the 1997 International Machine Learning Con\u0026shy;ference.Morgan Kaufmann.\nMoore, J. W. and Blazis, D. E. J. (1989). Simulation of a classically conditioned response: A cerebellar implementation of the sutton-barto-desmond model. In Byrne, J. H. and Berry, W. O., editors, Neural Models of Plasticity,pages 187-207. Academic Press, San Diego, CA.\nMoore, J. W., Choi, J.-S., and Brunzell, D. H. (1998). Predictive timing under temporal un\u0026shy;certainty: The time derivative model of the conditioned response. In Rosenbaum, D. A. and Collyer, C. E., editors, Timing of Behavior, pages 3-34. MIT Press, Cambridge, MA.\nMoore, J. W., Desmond, J. E., Berthier, N. E., Blazis, E. J., Sutton, R. S., and Barto, A. G. (1986). Simulation of the classically conditioned nictitating membrane response by a neuron-like adaptive element: I. Response topography, neuronal firing, and interstimulus intervals. Behavioural Brain Research, 21:143-154.\nMoore, J. W., Marks, J. S., Castagna, V. E., and Polewan, R. J. (2001). Parameter stability in the TD model of complex CR topographies. Society for Neuroscience Abstract 642.2.\nMoore, J. W. and Schmajuk, N. A. (2008). Kamin blocking. Scholarpedia,3(5):3542.\nMoore, J. W. and Stickney, K. J. (1980). Formation of attentional-associative networks in real time:Role of the hippocampus and implications for conditioning. Physiological Psychology, 8(2):207-217.\nMukundan, J. and Martinez, J. F. (2012). MORSE: Multi-objective reconfigurable self- optimizing memory scheduler. In IEEE 18th International Symposium on High Perfor\u0026shy;mance Computer Architecture (HPCA),pages 1-12.\nMuller, M. (2002). Computer Go. Artificial Intelligence,134(1):145-179.\nMunos, R., Stepleton, T., Harutyunyan, A., and Bellemare, M. (2016). Safe and efficient off- policy reinforcement learning. In Advances in Neural Information Processing Systems, pp. 1046-1054.\nNaddaf, Y. (2010). Game-independent AI agents for playing Atari 2600 console games.PhD thesis, University of Alberta.\nNarendra, K. S., Thathachar, M. A. L. (1974). Learning automata\\A1\\AAA survey. IEEE Transactions on Systems, Man, and Cybernetics, 4:323-334.\nNarendra, K. S., Thathachar, M. A. L. (1989). Learning Automata: An Introduction. Prentice-Hall, Englewood Cliffs, NJ.\nNarendra, K. S. and Wheeler, R. M. (1983). An n-player sequential stochastic game with\nidentical payoffs. IEEE Transactions on Systems, Man, and Cybernetics,13:1154-1158.\nNarendra, K. S., Wheeler, R. M. (1986). Decentralized learning in finite Markov chains. IEEE Transactions on Automatic Control,AC31(6):519-526.\nNedic, A., Bertsekas, D. P. (2003). Least squares policy evaluation algorithms with linear function approximation. Discrete Event Dynamic Systems 13(1-2):79-110.\nNg, A. Y. (2003). Shaping and policy search in reinforcement learning.PhD thesis, Univer\u0026shy;sity of California, Berkeley, Berkeley, CA.\nNg, A. Y., Harada, D., and Russell, S. (1999). Policy invariance under reward trans\u0026shy;formations: Theory and application to reward shaping. In Bratko, I. and Dzeroski, S., editors, Proceedings of the Sixteenth International Conference on Machine Learning (ICML 1999),volume 99, pp. 278-287.\nNg, A. Y., and Russell, S. J. (2000). Algorithms for inverse reinforcement learning. In International Conference on Machine Learning,pp. 663-670.\nNie, J., Haykin, S. (1996). A dynamic channel assignment policy through Q-learning. CRL Report 334. Communications Research Laboratory, McMaster University, Hamilton, Ontario.\nNiv, Y. (2009). Reinforcement learning in the brain. Journal of Mathematical Psychology, 53(3):139-154.\nNiv, Y., Daw, N. D., and Dayan, P. (2005). How fast to work: Response vigor, motivation and tonic dopamine. In Yeiss, Y., Scholkopft, B., and Platt, J., editors, Advances in Neural Information Processing Systems 18 (NIPS 2005),pages 1019-1026. MIT Press, Cambridge, MA.\nNiv, Y., Daw, N. D., Joel, D., and Dayan, P. (2007). Tonic dopamine: opportunity costs and the control of response vigor. Psychopharmacology,191(3):507-520.\nNiv, Y., Joel, D., and Dayan, P. (2006). A normative perspective on motivation. Trends in Cognitive Sciences,10(8):375-381.\nNowe, A., Vrancx, P., and Hauwere, Y.-M. D. (2012). Game theory and multi-agent reinforce\u0026shy;ment learning. In Wiering, M. and van Otterlo, M., editors, Reinforcement Learning: State-of-the-Art, pages 441-467. Springer-Verlag, Berlin.\nNutt, D. J., Lingford-Hughes, A., Erritzoe, D., and Stokes, P. R. A. (2015). The dopamine theory of addiction: 40 years of highs and lows. Nature Reviews Neuroscience,16:305\u0026shy;\n312.\nO,Doherty, J. P., Dayan, P., Friston, K., Critchley, H., and Dolan, R. J. (2003). Temporal difference models and reward-related learning in the human brain. Neuron,38(2):329- 337.\nO,Doherty, J. P., Dayan, P., Schultz, J., Deichmann, R., Friston, K., and Dolan, R. J. (2004). Dissociable roles of ventral and dorsal striatum in instrumental conditioning. Science, 304(5669):452-454.\n(Olafsdottir, H. F., Barry, C., Saleem, A. B., Hassabis, D., and Spiers, H. J. (2015). Hip\u0026shy;pocampal place cells construct reward related sequences through unexplored space. Elife, 4:e06063.\nOh, J., Guo, X., Lee, H., Lewis, R. L., and Singh, S. (2015). Action-conditional video prediction using deep networks in Atari games. In Advances in Neural Information Processing Systems, pages 2845-2853.\nOlds, J. and Milner, P. (1954). Positive reinforcement produced by electrical stimulation of the septal area and other regions of rat brain. Journal of Comparative and Physiological\nPsychology, 47(6):419-427.\nOliehoek, F. A. (2012). Decentralized POMDPs. In Wiering and van Otterlo (Eds.) Rein\u0026shy;forcement Learning: State-of-the Art,pp. 471-503. Springer Berlin Heidelberg.\nO\\A1\\AFReilly, R. C. and Frank, M. J. (2006). Making working memory work: A computational model of learning in the prefrontal cortex and basal ganglia. Neural Computation, 18(2):283-328.\nO\\A1\\AFReilly, R. C., Frank, M. J., Hazy, T. E., and Watz, B. (2007). PVLV: the primary value and learned value Pavlovian learning algorithm. Behavioral neuroscience,121(1):31-49.\nOmohundro, S. M. (1987). Efficient algorithms with neural network behavior. Technical Report, Department of Computer Science, University of Illinois at Urbana-Champaign.\nOrenstein, J. A. (1982). Multidimensional tries used for associative searching. Information Processing Letters 14(4):150-157.\nOrmoneit, D., and Sen, S. (2002). Kernel-based reinforcement learning. Machine learning 49(2-3):161-178.\nOudeyer, P.-Y. and Kaplan, F. (2007). What is intrinsic motivation? A typology of compu\u0026shy;tational approaches. Frontiers in Neurorobotics, 1.\nOudeyer, P.-Y., Kaplan, F., and Hafner, V. V. (2007). Intrinsic motivation systems for autonomous mental development. IEEE Transactions on Evolutionary Computation, 11(2):265-286.\nPadoa-Schioppa, C., and Assad, J. A. (2006). Neurons in the orbitofrontal cortex encode economic value. Nature 441(7090):223-226.\nPage, C. V. (1977). Heuristics for signature table analysis as a pattern recognition technique. IEEE Transactions on Systems, Man, and Cybernetics,7:77-86.\nPagnoni, G., Zink, C. F., Montague, P. R., and Berns, G. S. (2002). Activity in human ventral striatum locked to errors of reward prediction. Nature neuroscience,5(2):97-98.\nPan, W.-X., Schmidt, R., Wickens, J. R., and Hyland, B. I. (2005). Dopamine cells respond to predicted events during classical conditioning: Evidence for eligibility traces in the reward-learning network. The Journal of Neuroscience,25(26):6235-6242.\nPark, J., Kim, J., Kang, D. (2005). An RLS-based natural actor-critic algorithm for loco\u0026shy;motion of a two-linked robot arm. Computational Intelligence and Security,65-72.\nParker, D. B. (1985). Learning Logic.???\nParks, P. C., Militzer, J. (1991). Improved allocation of weights for associative memory storage in learning control systems. IFAC Design Methods of Control Systems,Zurich, Switzerland, 507-512.\nParr, R., Russell, S. (1995). Approximating optimal policies for partially observable stochas\u0026shy;tic domains. In Proceedings of the Fourteenth International Joint Conference on Artifi\u0026shy;cial Intelligence,pp. 1088-1094. Morgan Kaufmann.\nPavlov, P. I. (1927). Conditioned Reflexes.Oxford University Press, London.\nPawlak, V. and Kerr, J. N. D. (2008). Dopamine receptor activation is required for corti\u0026shy;costriatal spike-timing-dependent plasticity. The Journal of Neuroscience,28(10):2435- 2446.\nPawlak, V., Wickens, J. R., Kirkwood, A., and Kerr, J. N. D. (2010). Timing is not everything: neuromodulation opens the STDP gate. Frontiers in synaptic neuroscience, 2.\nPearce, J. M. and Hall, G. (1980). A model for Pavlovian learning: Variation in the effective\u0026shy;ness of conditioning but not unconditioned stimuli. Psychological Review,87(6):532-552.\nPearl, J. (1984). Heuristics: Intelligent Search Strategies for Computer Problem Solving. Addison-Wesley, Reading, MA.\nPearl, J. (1995). Causal diagrams for empirical research. Biometrika,82(4), 669-688.\nPecevski, D., Maass, W., and Legenstein, R. A. (2007). Theoretical analysis of learning with reward-modulated spike-timing-dependent plasticity. In Advances in Neural Information Processing Systems,pp. 881-888.\nPeng, J. (1993). Efficient Dynamic Programming-Based Learning for Control.Ph.D. thesis, Northeastern University, Boston.\nPeng, J. (1995). Efficient memory-based dynamic programming. In 12th International Con\u0026shy;ference on Machine Learning,pp. 438-446.\nPeng, J., Williams, R. J. (1993). Efficient learning and planning within the Dyna framework. Adaptive Behavior,1(4):437-454.\nPeng, J., Williams, R. J. (1994). Incremental multi-step Q-learning. In W. W. Cohen and H. Hirsh (eds.), Proceedings of the Eleventh International Conference on Machine Learning,pp. 226-232. Morgan Kaufmann, San Francisco.\nPeng, J., Williams, R. J. (1996). Incremental multi-step Q-learning. Machine Learning, 22:283-290.\nPerkins, T. J., Pendrith, M. D. (2002). On the existence of fixed points for Q-learning and Sarsa in partially observable domains. In Proceedings of the International Conference on Machine Learning,pp. 490-497.\nPerkins, T. J., Precup, D. (2003). A convergent form of approximate policy iteration. In\nAdvances in neural information processing systems, proceedings of the 2002 conference, pp. 1595-1602.\nPeters, J. and Buchel, C. (2010). Neural representations of subjective reward value. Behav\u0026shy;ioral brain research,213(2):135-141.\nPeters, J., Schaal, S. (2008). Natural actor-critic. Neurocomputing 71(7), 1180-1190.\nPeters, J., Vijayakumar, S., Schaal, S. (2005). Natural actor-critic. In European Conference on Machine Learning(pp. 280-291). Springer Berlin Heidelberg.\nPeterson, G. B. (2004). A day of great illumination: B.F. Skinner\\A1\\AFs discovery of shaping. Journal of the Experimental Analysis of Behavior,82(3):317-28.\nPezzulo, G., van der Meer, M. A. A., Lansink, C. S., and Pennartz, C. M. A. (2014). Inter\u0026shy;nally generated sequences in learning and executing goal-directed behavior. Trends in Cognitive Science,18(12):647-657.\nPfeiffer, B. E. and Foster, D. J. (2013). Hippocampal place-cell sequences depict future paths to remembered goals. Nature,497(7447):74-79.\nPhansalkar, V. V., Thathachar, M. A. L. (1995). Local and global optimization algorithms for generalized learning automata. Neural Computation, 7:950-973.\nPoggio, T., Girosi, F. (1989). A theory of networks for approximation and learning. A.I. Memo 1140. Artificial Intelligence Laboratory, Massachusetts Institute of Technology, Cambridge, MA.\nPoggio, T., Girosi, F. (1990). Regularization algorithms for learning that are equivalent to multilayer networks. Science,247:978-982.\nPolyak, B. T. (1990). New stochastic approximation type procedures. Automat. i Telemekh 7(98-107), 2 (in Russian).\nPolyak, B. T., Juditsky, A. B. (1992). Acceleration of stochastic approximation by averaging. SIAM Journal on Control and Optimization 30(4), 838-855.\nPowell, M. J. D. (1987). Radial basis functions for multivariate interpolation: A review.\nIn J. C. Mason and M. G. Cox (eds.), Algorithms for Approximation,pp. 143-167. Clarendon Press, Oxford.\nPowell, W. B. (2011). Approximate Dynamic Programming: Solving the Curses of Dimen\u0026shy;sionality, Second edition. John Wiley and Sons.\nPowers, W. T. (1973). Behavior: The Control of Perception.Aldine de Gruyter, Chicago. 2nd expanded edition 2005.\nPrecup, D., Sutton, R. S., Dasgupta, S. (2001). Off-policy temporal-difference learning with function approximation. In Proceedings of the 18th International Conference on Machine Learning.\nPrecup, D., Sutton, R. S., Paduraru, C., Koop, A., and Singh, S. (2005). Off-policy learning with options and recognizers. In Advances in Neural Processing Systems,pp. 1097-1104.\nPrecup, D., Sutton, R. S., Singh, S. (2000). Eligibility traces for off-policy policy evaluation.\nIn Proceedings of the 17th International Conference on Machine Learning, pp. 759-766. Morgan Kaufmann.\nPuterman, M. L. (1994). Markov Decision Problems.Wiley, New York.\nPuterman, M. L., Shin, M. C. (1978). Modified policy iteration algorithms for discounted Markov decision problems. Management Science, 24:1127-1137.\nQuartz, S., Dayan, P., Montague, P. R., and Sejnowski, T. J. (1992). Expectation learning in the brain using diffuse ascending connections. In Society for Neuroscience Abstracts, volume 18, page 1210.\nRandl0v, J. and Alstr0m, P. (1998). Learning to drive a bicycle using reinforcement learning and shaping. In Proceedings of the Fifteenth International Conference on Machine Learning,pages 463-471.\nRangel, A., Camerer, C., and Montague, P. R. (2008). A framework for studying the neurobiology of value-based decision making. Nature Reviews Neuroscience,9(7):545- 556.\nRangel, A. and Hare, T. (2010). Neural computations associated with goal-directed choice. Current opinion in neurobiology, 20(2):262-270.\nReddy, G., Celani, A., Sejnowski, T. J., and Vergassola, M. (2016). Learning to soar in tur\u0026shy;bulent environments. Proceedings of the National Academy of Sciences,113(33):E4877- E4884.\nRedgrave, P. and Gurney, K. (2006). The short-latency dopamine signal: a role in discovering novel actions? Nature Reviews Neuroscience, 7:967-975.\nRedish, D. A. (2004). Addiction as a computational process gone awry. Science,306(5703):1944- 1947.\nReetz, D. (1977). Approximate solutions of a discounted Markovian decision process. Bonner Mathematische Schriften,98:77-92.\nRescorla, R. A. and Wagner, A. R. (1972). A theory of Pavlovian conditioning: Variations in the effectiveness of reinforcement and nonreinforcement. In Black, A. H. and Prokasy,\nW. F., editors, Classical ConditioningII, pages 64-99. Appleton-Century-Crofts, New York.\nRevusky, S. and Garcia, J. (1970). Learned associations over long delays. In Bower, G., editor, The psychology of learning and motivation,volume 4, pages 1-84. Academic Press, Inc., New York.\nReynolds, J. N. J. and Wickens, J. R. (2002). Dopamine-dependent plasticity of corticostri- atal synapses. Neural Networks, 15(4):507-521.\nRing, M. B. (1994). Continual Learning in Reinforcement Environments.Ph.D. thesis, University of Texas, Austin.\nRipley, B. D. (2007). Pattern Recognition and Neural Networks.Cambridge University Press.\nRivest, R. L., Schapire, R. E. (1987). Diversity-based inference of finite automata. In Pro\u0026shy;ceedings of the Twenty-Eighth Annual Symposium on Foundations of Computer Science, pp. 78-87. Computer Society Press of the IEEE, Washington, DC.\nRixner, S. (2004). Memory controller optimizations for web servers. In Proceedings of the 37th annual IEEE/A CM International Symposium on Microarchitecture,pages 355-366. IEEE Computer Society.\nRobbins, H. (1952). Some aspects of the sequential design of experiments. Bulletin of the American Mathematical Society, 58:527-535.\nRobertie, B. (1992). Carbon versus silicon: Matching wits with TD-Gammon. Inside Backgammon,2:14-22.\nRoesch, M. R., Calu, D. J., and Schoenbaum, G. (2007). Dopamine neurons encode the better option in rats deciding between differently delayed or sized rewards. Nature Neuroscience,10(12):1615-1624.\nRomo, R. and Schultz, W. (1990). Dopamine neurons of the monkey midbrain: Contin\u0026shy;gencies of responses to active touch during self-initiated arm movements. Journal of Neurophysiology,63(3):592-624.\nRosenblatt, F. (1962). Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms. Spartan Books, Washington, DC.\nRoss, S. (1983). Introduction to Stochastic Dynamic Programming. Academic Press, New York.\nRoss, T. (1933). Machines that think. Scientific American,pages 206-208.\nRubinstein, R. Y. (1981). Simulation and the Monte Carlo Method.Wiley, New York.\nRumelhart, D. E., Hinton, G. E., Williams, R. J. (1986). Learning internal representations by error propagation. In D. E. Rumelhart and J. L. McClelland (eds.), Parallel Dis\u0026shy;tributed Processing: Explorations in the Microstructure of Cognition,vol. I, Foundations. Bradford/MIT Press, Cambridge, MA.\nRummery, G. A. (1995). Problem Solving with Reinforcement Learning.Ph.D. thesis, Cambridge University.\nRummery, G. A., Niranjan, M. (1994). On-line Q-learning using connectionist systems. Technical Report CUED/F-INFENG/TR 166. Engineering Department, Cambridge University.\nRuppert, D. (1988). Efficient estimations from a slowly convergent Robbins-Monro process. Cornell University Operations Research and Industrial Engineering Technical Report No. 781.\nRussell, S., Norvig, P. (2010). Artificial Intelligence: A Modern Approach,3rd edition. Prentice-Hall, Englewood Cliffs, NJ.\nRust, J. (1996). Numerical dynamic programming in economics. In H. Amman, D. Kendrick, and J. Rust (eds.), Handbook of Computational Economics,pp. 614-722. Elsevier, Am\u0026shy;sterdam.\nRyan, R. M. and Deci, E. L. (2000). Intrinsic and extrinsic motivations: Classic definitions and new directions. Contemporary Educational Psychology,25(1):54-67.\nSaddoris, M. P., Cacciapaglia, F., Wightmman, R. M., and Carelli, R. M. (2015). Differential dopamine release dynamics in the nucleus accumbens core and shell reveal complemen\u0026shy;tary signals for error prediction and incentive motivation. The Journal of Neuroscience, 35(33):11572-11582.\nSaksida, L. M., Raymond, S. M., and Touretzky, D. S. (1997). Shaping robot behavior using principles from instrumental conditioning. Robotics and Autonomous Systems, 22(3):231-249.\nSamuel, A. L. (1959). Some studies in machine learning using the game of checkers. IBM Journal on Research and Development,3:211-229. Reprinted in E. A. Feigenbaum and J. Feldman (eds.), Computers and Thought, pp. 71-105. McGraw-Hill, New York, 1963.\nSamuel, A. L. (1967). Some studies in machine learning using the game of checkers. II\\A1\\AA Recent progress. IBM Journal on Research and Development, 11:601-617.\nSchaal, S., and Atkeson, C. G. (1994). Robot juggling: Implementation of memory-based learning. IEEE Control Systems 14(1):57-71.\nSchmajuk, N. A. (2008). Computational models of classical conditioning. Scholarpedia, 3(3):1664.\nSchmidhuber, J. (1991a). Adaptive confidence and adaptive curiosity. Technical Report FKI-149-91, Institut fiir Informatik, Technische Universitat Munchen, Arcisstr. 21, 800 Miinchen 2, Germany.\nSchmidhuber, J. (1991b). A possibility for implementing curiosity and boredom in model- building neural controllers. In From Animals to Animats: Proceedings of the First In\u0026shy;ternational Conference on Simulation of Adaptive Behavior,pages 222-227, Cambridge, MA. MIT Press.\nSchmidhuber, J. (2009). Driven by compression progress: A simple principle explains essen\u0026shy;tial aspects of subjective beauty, novelty, surprise, interestingness, attention, curiosity, creativity, art, science, music, jokes. In Pezzulo, G., Butz, M. V., Sigaud, O., and Baldassarre, G., editors, Anticipatory Behavior in Adaptive Learning Systems. From Psychological Theories to Artificial Cognitive Systems, pages 48-76. Springer, Berlin.\nSchmidhuber, J. (2015). Deep learning in neural networks: An overview. Neural Networks 61,85-117.\nSchmidhuber, J., Storck, J., and Hochreiter, S. (1994). Reinforcement driven information acquisition in nondeterministic environments. Technical report, Fakultat fiir Informatik, Technische Universitat Miinchen, Miinchen, Germany.\nSchultz, D. G., Melsa, J. L. (1967). State Functions and Linear Control Systems.McGraw- Hill, New York.\nSchultz, W. (1998). Predictive reward signal of dopamine neurons. Journal of Neurophysi\u0026shy;ology,80:1-27.\nSchultz, W., Apicella, P., and Ljungberg, T. (1993). Responses of monkey dopamine neurons to reward and conditioned stimuli during successive steps of learning a delayed response task. Journal of Neuroscience 13(3):900-913.\nSchultz, W., Dayan, P., Montague, P. R. (1997). A neural substrate of prediction and reward. Science,275:1593-1598.\nSchultz, W. and Romo, R. (1990). Dopamine neurons of the monkey midbrain: contingencies of responses to stimuli eliciting immediate behavioral reactions. Journal of Neurophysi\u0026shy;ology,63(3):607-624.\nSchultz, W., Romo, R., Ljungberg, T., Mirenowicz, J., Hollerman, J. R., and Dickinson, A. (1995). Reward-related signals carried by dopamine neurons. In Houk, Davis, and Beiser (Eds.) Models of Information Processing in the Basal Ganglia,pp. 233-248. MIT Press\n \nSchumaker, L. L. (1976). Fitting Surfaces to Scattered Data.University of Texas at Austin,\nDept. of Mathematics.\nSchwartz, A. (1993). A reinforcement learning method for maximizing undiscounted rewards.\nIn Proceedings of the Tenth International Conference on Machine Learning,pp. 298-305.\nMorgan Kaufmann, San Mateo, CA.\nSchweitzer, P. J., Seidmann, A. (1985). Generalized polynomial approximations in Marko\u0026shy;vian decision processes. Journal of Mathematical Analysis and Applications, 110:568\u0026shy;582.\nSelfridge, O. G. (1978). Tracking and trailing: Adaptation in movement strategies. Technical report, Bolt Beranek and Newman, Inc. Unpublished report.\nSelfridge, O. G. (1984). Some themes and primitives in ill-defined systems. In Selfridge,\nO. G., Rissland, E. L., and Arbib, M. A., editors, Adaptive Control of Ill-Defined Systems, pages 21-26. Plenum Press, NY. Proceedings of the NATO Advanced Research Institute on Adaptive Control of Ill-defined Systems, NATO Conference Series II, Systems Science,\nVol. 16.\nSelfridge, O. J., Sutton, R. S., Barto, A. G. (1985). Training and tracking in robotics.\nIn A. Joshi (ed.), Proceedings of the Ninth International Joint Conference on Artificial Intelligence, pp. 670-672. Morgan Kaufmann, San Mateo, CA.\nSeo, H., Barraclough, D., and Lee, D. (2007). Dynamic signals related to choices and outcomes in the dorsolateral prefrontal cortex. Cerebral Cortex,17(suppl 1):110-117.\nSeung, H. S. (2003). Learning in spiking neural networks by reinforcement of stochastic synaptic transmission. Neuron, 40(6):1063-1073.\nShah, A. (2012). Psychological and neuroscientific connections with reinforcement learning.\nIn Wiering, M. and van Otterlo, M., editors, Reinforcement Learning: State of the Art, pages 507-537. Springer-Verlag, Berlin.\nShannon, C. E. (1950). Programming a computer for playing chess. Philosophical Magazine, 41:256-275.\nShannon, C. E. (1951). Presentation of a maze-solving machine. In Forester, H. V., editor, Cybernetics. Transactions of the Eighth Conference,pages 173-180. Josiah Macy Jr. Foundation.\nShannon, C. E. (1952). \\A1\\B0Theseus\\A1\\B1 maze-solving mouse. http://cyberneticzoo.com/mazesolvers/1952--theseus-maze-solving-mouse--claude-shannon-american/.\nShelton, C. R. (2001). Importance Sampling for Reinforcement Learning with Multiple Ob\u0026shy;jectives.PhD thesis, Massachusetts Institute of Technology.\nShepard, D. (1968). A two-dimensional interpolation function for irregularly-spaced data.\nIn Proceedings of the 23rd ACM National Conference,pp. 517-524. ACM.\nSherman, J., Morrison, W. J. (1949). Adjustment of an inverse matrix corresponding to changes in the elements of a given column or a given row of the original matrix (abstract).\nAnnals of Mathematical Statistics 20:621.\nShewchuk, J., Dean, T. (1990). Towards learning time-varying functions with high input dimensionality. In Proceedings of the Fifth IEEE International Symposium on Intelligent Control,pp. 383-388. IEEE Computer Society Press, Los Alamitos, CA.\nShimansky, Y. P. (2009). Biologically plausible learning in neural networks: a lesson from bacterial chemotaxis. Biological Cybernetics,101(5-6):379-385.\nSi, J., Barto, A., Powell, W., Wunsch, D. (Eds.). (2004). Handbook of learning and approxi\u0026shy;mate dynamic programming.John Wiley and Sons.\nSilver, D. (2009). Reinforcement learning and simulation based search in the game of Go. University of Alberta Doctoral dissertation.\nSilver, D., Huang, A., Maddison, C. J., Guez, A., Sifre, L., van den Driessche, G., Schrit- twieser, J., Antonoglou, I., Panneershelvam, V., Lanctot, M., Dieleman, S., Grewe, D., Nham, J., Kalchbrenner, N., Sutskever, I., Lillicrap, T., Leach, M., Kavukcuoglu, K., Graepel, T., and Hassabis, D. (2016). Mastering the game of go with deep neural networks and tree search. Nature,529(7587):484-489.\nSilver, D., Lever, G., Heess, N., Degris, T., Wierstra, D., Riedmiller, M. (2014). Determin\u0026shy;istic policy gradient algorithms. In Proceedings of the 31st International Conference on Machine Learning(ICML-14) (pp. 387-395).\nSimsek, O., Algorta, S., and Kothiyal, A. (2016). Why most decisions are easy in tetris-and perhaps in other sequential decision problems, as well. Proceedings of 33rd International Conference on Machine Learning.\nSingh, S. P. (1992a). Reinforcement learning with a hierarchy of abstract models. In Proceedings of the Tenth National Conference on Artificial Intelligence, pp. 202-207. AAAI/MIT Press, Menlo Park, CA.\nSingh, S. P. (1992b). Scaling reinforcement learning algorithms by learning variable tem\u0026shy;poral resolution models. In Proceedings of the Ninth International Machine Learning Conference,pp. 406-415. Morgan Kaufmann, San Mateo, CA.\nSingh, S. P. (1993). Learning to Solve Markovian Decision Processes.Ph.D. thesis, Univer\u0026shy;sity of Massachusetts, Amherst. Appeared as CMPSCI Technical Report 93-77.\nSingh, S. P. (Ed.) (2002). Special double issue on reinforcement learning, Machine Learning\n49(2/3).\nSingh, S., Barto, A. G., and Chentanez, N. (2005). Intrinsically motivated reinforcement learning. In Advances in Neural Information Processing Systems 17: Proceedings of the 2004 Conference,pages 1281-1288, Cambridge MA. MIT Press.\nSingh, S. P., Bertsekas, D. (1997). Reinforcement learning for dynamic channel allocation in cellular telephone systems. In Advances in Neural Information Processing Systems: Proceedings of the 1996 Conference,pp. 974-980. MIT Press, Cambridge, MA.\nSingh, S. P., Jaakkola, T., Jordan, M. I. (1994). Learning without state-estimation in partially observable Markovian decision problems. In W. W. Cohen and H. Hirsch (eds.), Proceedings of the Eleventh International Conference on Machine Learning, pp. 284-292. Morgan Kaufmann, San Francisco.\nSingh, S. P., Jaakkola, T., Jordan, M. I. (1995). Reinforcement learing with soft state aggregation. In G. Tesauro, D. S. Touretzky, T. Leen (eds.), Advances in Neural In\u0026shy;formation Processing Systems: Proceedings of the 1994 Conference,pp. 359-368. MIT Press, Cambridge, MA.\nSingh, S., Lewis, R. L., and Barto, A. G. (2009). Where do rewards come from? In Taatgen, N. and van Rijn, H., editors, Proceedings of the 31st Annual Conference of the Cognitive Science Society, pages 2601-2606. Cognitive Science Society.\nSingh, S., Lewis, R. L., Barto, A. G., and Sorg, J. (2010). Intrinsically motivated reinforce\u0026shy;ment learning: An evolutionary perspective. IEEE Transactions on Autonomous Mental Development,2(2):7082. Special issue on Active Learning and Intrinsically Motivated Exploration in Robots: Advances and Challenges.\nSingh, S. P., Sutton, R. S. (1996). Reinforcement learning with replacing eligibility traces. Machine Learning, 22:123-158.\nSivarajan, K. N., McEliece, R. J., Ketchum, J. W. (1990). Dynamic channel assignment in cellular radio. In Proceedings of the 40th Vehicular Technology Conference,pp. 631-637.\nSkinner, B. F. (1938). The Behavior of Organisms: An Experimental Analysis.Appleton- Century, New York.\nSkinner, B. F. (1958). Reinforcement today. American Psychologist,13(3):94-99.\nSkinner, B. F. (1981). Selection by consequences. Science 213(4507):501-504.\nSmith, K. S. and Greybiel, A. M. (2013). A dual operator view of habitual behavior reflecting cortical and striatal dynamics. Neuron,79(2):361-374.\nSofge, D. A., White, D. A. (1992). Applied learning: Optimal control for manufacturing. In D. A. White and D. A. Sofge (eds.), Handbook of Intelligent Control: Neural, Fuzzy, and Adaptive Approaches,pp. 259-281. Van Nostrand Reinhold, New York.\nSorg, J. D. (2011). The Optimal Reward Problem:Designing Effective Reward for Bounded Agents.PhD thesis, Computer Science and Engineering, The University of Michigan.\nSorg, J., Lewis, R. L., and Singh, S. P. (2010). Reward design via online gradient ascent. In Advances in Neural Information Processing Systems,pp. 2190-2198.\nSorg, J., Singh, S., and Lewis, R. (2010). Internal rewards mitigate agent boundedness. In Proceedings of the 27th International Conference on Machine Learning (ICML),pages 1007-1014.\nSpaan, M. T. (2012). Partially observable Markov decision processes. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art,pp. 387-414. Springer Berlin Heidelberg.\nSpence, K. W. (1947). The role of secondary reinforcement in delayed reward learning. Psychological Review,54(1):1-8.\nSpong, M. W. (1994). Swing up control of the acrobot. In Proceedings of the 1994 IEEE Conference on Robotics and Automation,pp. 2356-2361. IEEE Computer Society Press, Los Alamitos, CA.\nSrivastava, N., Hinton, G., Krizhevsky, A., Sutskever, I., and Salakhutdinov, R. (2014). Dropout: A simple way to prevent neural networks from overfitting. The Journal of Machine Learning Research,15(1):1929-1958.\nStaddon, J. E. R. (1983). Adaptive Behavior and Learning.Cambridge University Press, Cambridge.\nStanfill, C., and Waltz, D. (1986). Toward memory-based reasoning. Communications of the ACM 29(12):1213-1228.\nSteinberg, E. E., Keiflin, R., Boivin, J. R., Witten, I. B., Deisseroth, K., and Janak, P. H.\n(2013)\u0026nbsp; . A causal link between prediction errors, dopamine neurons and learning. Nature Neuroscience,16(7):966-973.\nSterling, P. and Laughlin, S. (2015). Principles of Neural Design.MIT Press, Cambridge, MA.\nStorck, J., Hochreiter, S., and Schmidhuber, J. (1995). Reinforcement-driven information acquisition in non-deterministic environments. In Proceedings of ICANN\\A3\\AC95, Paris, France, volume 2, pages 159-164.\nSugiyama, M., Hachiya, H., Morimura, T. (2013). Statistical Reinforcement Learning: Mod\u0026shy;ern Machine Learning Approaches.Chapman \u0026amp; Hall/CRC.\nSuri, R. E., Bargas, J., and Arbib, M. A. (2001). Modeling functions of striatal dopamine modulation in learning and planning. Neuroscience,103(1):65-85.\nSuri, R. E. and Schultz, W. (1998). Learning of sequential movements by neural net\u0026shy;work model with dopamine-like reinforcement signal. Experimental Brain Research, 121(3):350-354.\nSuri, R. E. and Schultz, W. (1999). A neural network model with dopamine-like reinforce\u0026shy;ment signal that learns a spatial delayed response task. Neuroscience,91(3):871-890.\nSutton, R. S. (1978a). Learning theory support for a single channel theory of the brain. Unpublished report.\nSutton, R. S. (1978b). Single channel theory: A neuronal theory of learning. Brain Theory Newsletter,4:72-75. Center for Systems Neuroscience, University of Massachusetts, Amherst, MA.\nSutton, R. S. (1978c). A unified theory of expectation in classical and instrumental condi\u0026shy;tioning. Bachelors thesis, Stanford University.\nSutton, R. S. (1984). Temporal Credit Assignment in Reinforcement Learning.Ph.D. thesis, University of Massachusetts, Amherst.\nSutton, R. S. (1988). Learning to predict by the method of temporal differences. Machine Learning,3:9-44.\nSutton, R. S. (1990). Integrated architectures for learning, planning, and reacting based on approximating dynamic programming. In Proceedings of the Seventh International Conference on Machine Learning,pp. 216-224. Morgan Kaufmann, San Mateo, CA.\nSutton, R. S. (1991a). Dyna, an integrated architecture for learning, planning, and reacting. SIGART Bulletin,2:160-163. ACM Press.\nSutton, R. S. (1991b). Planning by incremental dynamic programming. In L. A. Birnbaum and G. C. Collins (eds.), Proceedings of the Eighth International Workshop on Machine Learning,pp. 353-357. Morgan Kaufmann, San Mateo, CA.\nSutton, R. S. (Ed.) (1992). Reinforcement Learning.Kluwer Academic Press. Reprinting of a special double issue on reinforcement learning, Machine Learning 8(3/4).\nSutton, R. S. (1995a). TD models: Modeling the world at a mixture of time scales. In A. Prieditis and S. Russell (eds.), Proceedings of the Twelfth International Conference on Machine Learning, pp. 531-539. Morgan Kaufmann, San Francisco.\nSutton, R. S. (1995). On the virtues of linear learning and trajectory distributions. Proceed\u0026shy;ings of the Workshop on Value Function Approximationat the International Conference on Machine Learning.\nSutton, R. S. (1996). Generalization in reinforcement learning: Successful examples using sparse coarse coding. In D. S. Touretzky, M. C. Mozer and M. E. Hasselmo (eds.), Advances in Neural Information Processing Systems: Proceedings of the 1995 Conference, pp. 1038-1044. MIT Press, Cambridge, MA.\nSutton, R. S. (2009). The grand challenge of predictive empirical abstract knowledge. Work\u0026shy;ing Notes of the IJCAI-09 Workshop on Grand Challenges for Reasoning from Experi\u0026shy;ences.\nSutton, R. S. (2015a) Introduction to reinforcement learning with function approximation. Tutorial at the Conference on Neural Information Processing Systems, Montreal, De\u0026shy;cember 7, 2015.\nSutton, R. S. (2015b) True online Emphatic TD(A): Quick reference and implementation guide. ArXiv:1507.07147. Code is available in Python and C++ by downloading the source files of this arXiv paper as a zip archive.\nSutton, R. S., Barto, A. G. (1981a). Toward a modern theory of adaptive networks: Expec\u0026shy;tation and prediction. Psychological Review, 88:135-170.\nSutton, R. S., Barto, A. G. (1981b). An adaptive network that constructs and uses an internal model of its world. Cognition and Brain Theory,3:217-246.\nSutton, R. S., Barto, A. G. (1987). A temporal-difference model of classical conditioning. In Proceedings of the Ninth Annual Conference of the Cognitive Science Society, pp. 355\u0026shy;378. Erlbaum, Hillsdale, NJ.\nSutton, R. S., Barto, A. G. (1990). Time-derivative models of Pavlovian reinforcement. In M. Gabriel and J. Moore (eds.), Learning and Computational Neuroscience: Foundations of Adaptive Networks, pp. 497-537. MIT Press, Cambridge, MA.\nSutton, R. S., Maei, H. R., Precup, D., Bhatnagar, S., Silver, D., Szepesvari, Cs., and Wiewiora, E. (2009). Fast gradient-descent methods for temporal-difference learning with linear function approximation. In Proceedings of the 26th Annual International Conference on Machine Learning, pp. 993-1000. ACM.\nSutton, R. S., Maei, H. R., and Szepesvari, Cs. (2009). A convergent O(d2) temporal- difference algorithm for off-policy learning with linear function approximation. In Ad\u0026shy;vances in Neural Information Processing Systems, pp. 1609-1616.\nSutton, R. S., Mahmood, A. R., Precup, D., van Hasselt, H. (2014). A new Q(A) with interim forward view and Monte Carlo equivalence. International Conference on Machine Learning 31. JMLR W\u0026amp;CP 32(2).\nSutton, R. S., Mahmood, A. R., White, M. (2016). An emphatic approach to the problem of off-policy temporal-difference learning. Journal of Machine Learning Research 17(73):1- 29.\nSutton, R. S., McAllester, D. A., Singh, S. P., Mansour, Y. (2000). Policy gradient methods for reinforcement learning with function approximation. In Advances in Neural Infor\u0026shy;mation Processing Systems 99, pp. 1057-1063.\nSutton, R. S., Modayil, J., Delp, M., Degris, T., Pilarski, P. M., White, A., Precup, D. (2011). Horde: A scalable real-time architecture for learning knowledge from unsuper\u0026shy;vised sensorimotor interaction. In Proceedings of the Tenth International Conference on Autonomous Agents and Multiagent Systems,pp. 761-768, Taipei, Taiwan.\nSutton, R. S., Pinette, B. (1985). The learning of world models by connectionist networks. In Proceedings of the Seventh Annual Conference of the Cognitive Science Society,pp. 54\u0026shy;64.\nSutton, R. S., Singh, S. (1994). On bias and step size in temporal-difference learning. In Proceedings of the Eighth Yale Workshop on Adaptive and Learning Systems,pp. 91-96. Center for Systems Science, Dunham Laboratory, Yale University, New Haven.\nSutton, R. S., Whitehead, D. S. (1993). Online learning with random representations. In Proceedings of the Tenth International Machine Learning Conference,pp. 314-321. Morgan Kaufmann, San Mateo, CA.\nSzepesvari, C. (2010). Algorithms for reinforcement learning. Synthesis Lectures on Artificial Intelligence and Machine Learning 4(1), 1-103.\nSzita, I. (2012). Reinforcement learning in games. In Reinforcement Learning(pp. 539-577). Springer Berlin Heidelberg.\nTadepalli, P., Ok, D. (1994). H-learning: A reinforcement learning method to optimize undiscounted average reward. Technical Report 94-30-01. Oregon State University, Computer Science Department, Corvallis.\nTadepalli, P., and Ok, D. (1996). Scaling up average reward reinforcement learning by approximating the domain models and the value function. In International Conference on Machine Learning, pp. 471-479.\nTakahashi, Y., Schoenbaum, G., and Niv, Y. (2008). Silencing the critics: understanding the effects of cocaine sensitization on dorsolateral and ventral striatum in the context of an actor/critic model. Frontiers in Neuroscience,2(1):86-99.\nTan, M. (1991). Learning a cost-sensitive internal representation for reinforcement learning. In L. A. Birnbaum and G. C. Collins (eds.), Proceedings of the Eighth International Workshop on Machine Learning,pp. 358-362. Morgan Kaufmann, San Mateo, CA.\nTan, M. (1993). Multi-agent reinforcement learning: Independent vs. cooperative agents. In Proceedings of the Tenth International Conference on Machine Learning, pp. 330-337. Morgan Kaufmann, San Mateo, CA.\nTaylor, G., and Parr, R. (2009). Kernelized value function approximation for reinforce\u0026shy;ment learning. In Proceedings of the 26th Annual International Conference on Machine Learning, pp. 1017-1024. ACM.\nTaylor, M. E., and Stone, P. (2009). Transfer learning for reinforcement learning domains: A survey. Journal of Machine Learning Research 10:1633-1685.\nTesauro, G. J. (1986). Simple neural models of classical conditioning. Biological Cybernetics, 55:187-200.\nTesauro, G. J. (1992). Practical issues in temporal difference learning. Machine Learning, 8:257-277.\nTesauro, G. J. (1994). TD-Gammon, a self-teaching backgammon program, achieves master- level play. Neural Computation,6(2):215-219.\nTesauro, G. J. (1995). Temporal difference learning and TD-Gammon. Communications of the ACM,38:58-68.\nTesauro, G. (2002). Programming backgammon using self-teaching neural nets. Artificial Intelligence, 134(1):181-199.\nTesauro, G. J., Galperin, G. R. (1997). On-line policy improvement using Monte-Carlo search. In Advances in Neural Information Processing Systems: Proceedings of the 1996 Conference, pp. 1068-1074. MIT Press, Cambridge, MA.\nTesauro, G., Gondek, D. C., Lechner, J., Fan, J., and Prager, J. M. (2012). Simulation, learning, and optimization techniques in watson\\A1\\AFs game strategies. IBM Journal of Research and Development, 56(3.4):16-1-16-11.\nTesauro, G., Gondek, D. C., Lenchner, J., Fan, J., and Prager, J. M. (2013). Analysis of WATSON\\A1\\AFs strategies for playing Jeopardy! Journal of Artificial Intelligence Research, 21:205-251.\nTham, C. K. (1994). Modular On-Line Function Approximation for Scaling up Reinforcement Learning. PhD thesis, Cambridge University.\nThathachar, M. A. L. and Sastry, P. S. (1985). A new approach to the design of reinforcement schemes for learning automata. IEEE Transactions on Systems, Man, and Cybernetics, 15:168-175.\nThathachar, M. and Sastry, P. S. (2002). Varieties of learning automata: an overview. IEEE Transactions on Systems, Man, and Cybernetics, Part B: Cybernetics,36(6):711-722.\nThathachar, M. and Sastry, P. S. (2011). Networks of learning automata: Techniques for online stochastic optimization.Springer Science \u0026amp; Business Media.\nTheocharous, G., Thomas, P. S., and Ghavamzadeh, M. (2015). Personalized ad recommen\u0026shy;dation for life-time value optimization guarantees. In Proceedings of the Twenty-Fourth International Joint Conference on Artificial Intelligence (IJCAI-15).\nThistlethwaite, D. (1951). A critical review of latent learning and related experiments.\nPsychological Bulletin,48(2):97-129.\nThomas, P. (2014). Bias in natural actor-critic algorithms. International Conference on Machine Learning 31. JMLR W\u0026amp;CP 32(1):441-448.\nThomas, P. S. (2015). Safe Reinforcement Learning.PhD thesis, University of Massachusetts Amherst.\nThomas, P. S., Theocharous, G., and Ghavamzadeh, M. (2015). High-confidence off-policy evaluation. In Proceedings of the Twenty-Ninth AAAIConference on Artificial Intelli\u0026shy;gence,pages 3000-3006. The AAAI Press, Palo Alto, CA.\nThompson, W. R. (1933). On the likelihood that one unknown probability exceeds another in view of the evidence of two samples. Biometrika, 25:285-294.\nThompson, W. R. (1934). On the theory of apportionment. American Journal of Mathe\u0026shy;matics,57:450-457.\nThorndike, E. L. (1898). Animal intelligence: An experimental study of the associative processes in animals. The Psychological Review, Series of Monograph Supplements, II(4).\nThorndike, E. L. (1911). Animal Intelligence. Hafner, Darien, CT.\nThorp, E. O. (1966). Beat the Dealer: A Winning Strategy for the Game of Twenty-One. Random House, New York.\nTian, T. (2017) Empirical Study of Sliding-Step Methods in Temporal Difference Learning. University of Alberta MSc thesis.\nTieleman, T. and Hinton, G. (2012). Lecture 6.5-rmsprop. COURSERA: Neural networks for machine learning.\nTobler, P. N., Fiorillo, C. D., and Schultz, W. (2005). Adaptive coding of reward value by dopamine neurons. Science, 307(5715):1642-1645.\nTolman, E. C. (1932). Purposive Behavior in Animals and Men.Century, New York.\nTolman, E. C. (1948). Cognitive maps in rats and men. Psychological Review,55(4):189-208.\nTsai, H.-S., Zhang, F., Adamantidis, A., Stuber, G. D., Bonci, A., de Lecea, L., and Deis- seroth, K. (2009). Phasic firing in dopaminergic neurons is sufficient for behavioral conditioning. Science, 324(5930):1080-1084.\nTsetlin, M. L. (1973). Automaton Theory and Modeling of Biological Systems.Academic Press, New York.\nTsitsiklis, J. N. (1994). Asynchronous stochastic approximation and Q-learning. Machine Learning,16:185-202.\nTsitsiklis, J. N. (2002). On the convergence of optimistic policy iteration. Journal of Machine Learning Research,3:59-72.\nTsitsiklis, J. N. and Van Roy, B. (1996). Feature-based methods for large scale dynamic programming. Machine Learning, 22:59-94.\nTsitsiklis, J. N., Van Roy, B. (1997). An analysis of temporal-difference learning with function approximation. IEEE Transactions on Automatic Control,42:674-690.\nTsitsiklis, J. N., Van Roy, B. (1999). Average cost temporal-difference learning. Automatica, 35:1799-1808.\nTuring, A. M. (1950). Computing machinery and intelligence. Mind433-460.\nTuring, A. M. (1948). Intelligent Machinery, A Heretical Theory. The Turing Test: Verbal Behavior as the Hallmark of Intelligence, 105.\nUngar, L. H. (1990). A bioreactor benchmark for adaptive network-based process control.\nIn W. T. Miller, R. S. Sutton, and P. J. Werbos (eds.), Neural Networks for Control, pp. 387-402. MIT Press, Cambridge, MA.\nUrbanczik, R. and Senn, W. (2009). Reinforcement learning in populations of spiking neurons. Nature neuroscience, 12(3):250-252.\nUrbanowicz, R. J., Moore, J. H. (2009). Learning classifier systems: A complete introduction, review, and roadmap. Journal of Artificial Evolution and Applications.\nValentin, V. V., Dickinson, A., and O\\A1\\AFDoherty, J. P. (2007). Determining the neural sub\u0026shy;strates of goal-directed learning in the human brain. The Journal of Neuroscience, 27(15):4019-4026.\nvan Hasselt, H. (2010). Double Q-learning. In Advances in Neural Information Processing Systems, pp. 2613-2621.\nvan Hasselt, H. (2011). Insights in Reinforcement Learning: Formal Analysis and Empircal Evaluation of Temporal-difference Learning.SIKS dissertation series number 2011-04.\nvan Hasselt, H. (2012). Reinforcement learning in continuous state and action spaces. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art,pp. 207-251. Springer Berlin Heidelberg.\nvan Hasselt, H., and Sutton, R. S. (2015). Learning to predict independent of span. ArXiv 1508.04582.\nvan Otterlo, M. (2009). The Logic of Adaptive Behavior.IOS Press.\nvan Otterlo, M. (2012). Solving relational and first-order logical markov decision processes: A survey. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art, pp. 253-292. Springer Berlin Heidelberg.\nVan Roy, B., Bertsekas, D. P., Lee, Y., Tsitsiklis, J. N. (1997). A neuro-dynamic pro\u0026shy;gramming approach to retailer inventory management. In Proceedings of the 36th IEEE Conference on Decision and Control, Vol. 4, pp. 4052-4057.\nvan Seijen, H. (2016). Effective multi-step temporal-difference learning for non-linear func\u0026shy;tion approximation. arXiv preprint arXiv:1608.05151.\nvan Seijen, H., and Sutton, R. S. (2014). True online TD(A). In Proceedings of the 31st International Conference on Machine Learning.JMLR W\u0026amp;CP 32(1):692-700.\nVan Seijen, H., Mahmood, A. R., Pilarski, P. M., Machado, M. C., and Sutton, R. S. (2016). True online temporal-difference learning. Journal of Machine Learning Research 17(145), 1-40.\nvan Seijen, H., Van Hasselt, H., Whiteson, S., Wiering, M. (2009). A theoretical and empiri\u0026shy;cal analysis of Expected Sarsa. In IEEE Symposium on Adaptive Dynamic Programming and Reinforcement Learning,pp. 177-184.\nVarga, R. S. (1962). Matrix Iterative Analysis.Englewood Cliffs, NJ: Prentice-Hall.\nVasilaki, E., Fremaux, N., Urbanczik, R., Senn, W., and Gerstner, W. (2009).\u0026nbsp;\u0026nbsp;\u0026nbsp; Spike-\nbased reinforcement learning in continuous state and action space: when policy gradient methods fail. PLoS Computational Biology,5(12).\nViswanathan, R. and Narendra, K. S. (1974). Games of stochastic automata.\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; IEEE\nTransactions on Systems, Man, and Cybernetics,4:131-135.\nVlassis, N., Ghavamzadeh, M., Mannor, S., and Poupart, P. (2012). Bayesian reinforcement learning. In Wiering and van Otterlo (Eds.) Reinforcement Learning: State-of-the Art, pp. 359-386. Springer Berlin Heidelberg.\nWalter, W. G. (1950). An imitation of life. Scientific American,pages 42-45.\nWalter, W. G. (1951). A machine that learns. Scientific American,185(2):60-63.\nWaltz, M. D., Fu, K. S. (1965). A heuristic approach to reinforcement learning control systems. IEEE Transactions on Automatic Control,10:390-398.\nWatkins, C. J. C. H. (1989). Learning from Delayed Rewards. Ph.D. thesis, Cambridge University.\nWatkins, C. J. C. H., Dayan, P. (1992). Q-learning. Machine Learning,8:279-292.\nWiering, M., Van Otterlo, M. (2012). Reinforcement Learning.Springer Berlin Heidelberg.\nWerbos, P. (1974). Beyond regression: New tools for prediction and analysis in the behavioral sciences. Phd Thesis, Harvard University, Cambridge, Massachusetts.\nWerbos, P. J. (1977). Advanced forecasting methods for global crisis warning and models of intelligence. General Systems Yearbook,22:25-38.\nWerbos, P. J. (1982). Applications of advances in nonlinear sensitivity analysis. In R. F. Drenick and F. Kozin (eds.), System Modeling and Optimization,pp. 762-770. Springer-Verlag, Berlin.\nWerbos, P. J. (1987). Building and understanding adaptive systems: A statistical/numerical approach to factory automation and brain research. IEEE Transactions on Systems, Man, and Cybernetics,17:7-20.\nWerbos, P. J. (1988). Generalization of back propagation with applications to a recurrent gas market model. Neural Networks, 1:339-356.\nWerbos, P. J. (1989). Neural networks for control and system identification. In Proceedings of the 28th Conference on Decision and Control, pp. 260-265. IEEE Control Systems Society.\nWerbos, P. J. (1990). Consistency of HDP applied to a simple reinforcement learning problem. Neural Networks,3:179-189.\nWerbos, P. J. (1992). Approximate dynamic programming for real-time control and neural modeling. In D. A. White and D. A. Sofge (eds.), Handbook of Intelligent Control: Neural, Fuzzy, and Adaptive Approaches, pp. 493-525. Van Nostrand Reinhold, New York.\nWerbos, P. J. (1994). The Roots of Backpropagation: From Ordered Derivatives to Neural Networks and Political Forecasting(Vol. 1). John Wiley and Sons.\nWhite, A. (2015). Developing a Predictive Approach to Knowledge.Phd thesis, University of Alberta.\nWhite, D. J. (1969). Dynamic Programming. Holden-Day, San Francisco.\nWhite, D. J. (1985). Real applications of Markov decision processes. Interfaces,15:73-83.\nWhite, D. J. (1988). Further real applications of Markov decision processes. Interfaces, 18:55-61.\nWhite, D. J. (1993). A survey of applications of Markov decision processes. Journal of the Operational Research Society, 44:1073-1096.\nWhite, A., and White, M. (2016). Investigating practical linear temporal difference learn\u0026shy;ing. In Proceedings of the 2016 International Conference on Autonomous Agents and Multiagent Systems, pp. 494-502.\nWhitehead, S. D., Ballard, D. H. (1991). Learning to perceive and act by trial and error. Machine Learning,7:45-83.\nWhitt, W. (1978). Approximations of dynamic programs I. Mathematics of Operations Research,3:231-243.\nWhittle, P. (1982). Optimization over Time, vol. 1. Wiley, New York.\nWhittle, P. (1983). Optimization over Time, vol. 2. Wiley, New York.\nWickens, J. and Kotter, R. (1995). Cellular models of reinforcement. In Houk, J. C., Davis, J. L., and Beiser, D. G., editors, Models of Information Processing in the Basal Ganglia, pages 187-214. MIT Press, Cambridge, MA.\nWidrow, B., Gupta, N. K., Maitra, S. (1973). Punish/reward: Learning with a critic in adaptive threshold systems. IEEE Transactions on Systems, Man, and Cybernetics, 3:455-465.\nWidrow, B., Hoff, M. E. (1960). Adaptive switching circuits. In 1960 WESCON Convention Record Part IV,pp. 96-104. Institute of Radio Engineers, New York. Reprinted in J. A. Anderson and E. Rosenfeld, Neurocomputing: Foundations of Research,pp. 126-134. MIT Press, Cambridge, MA, 1988.\nWidrow, B., Smith, F. W. (1964). Pattern-recognizing control systems. In J. T. Tou and R. H. Wilcox (eds.), Computer and Information Sciences,pp. 288-317. Spartan, Washington, DC.\nWidrow, B., Stearns, S. D. (1985). Adaptive Signal Processing. Prentice-Hall, Englewood Cliffs, NJ.\nWiewiora, E. (2003). Potential-based shaping and Q-value initialization are equivalent. Jour\u0026shy;nal of Artificial Intelligence Research 19:205-208.\nWilliams, R. J. (1986). Reinforcement learning in connectionist networks: A mathematical analysis. Technical Report ICS 8605. Institute for Cognitive Science, University of California at San Diego, La Jolla.\nWilliams, R. J. (1987). Reinforcement-learning connectionist systems. Technical Report NU-CCS-87-3. College of Computer Science, Northeastern University, Boston.\nWilliams, R. J. (1988). On the use of backpropagation in associative reinforcement learning. In Proceedings of the IEEE International Conference on Neural Networks,pp. I263-I270. IEEE San Diego section and IEEE TAB Neural Network Committee.\nWilliams, R. J. (1992). Simple statistical gradient-following algorithms for connectionist reinforcement learning. Machine Learning,8:229-256.\nWilliams, R. J., Baird, L. C. (1990). A mathematical analysis of actor-critic architectures for learning optimal controls through incremental dynamic programming. In Proceedings of the Sixth Yale Workshop on Adaptive and Learning Systems,pp. 96-101. Center for Systems Science, Dunham Laboratory, Yale University, New Haven.\nWilson, R. C., Takahashi, Y. K., Schoenbaum, G., and Niv, Y. (2014). Orbitofrontal cortex as a cognitive map of task space. Neuron, 81(2):267-279.\nWilson, S. W. (1994). ZCS: A zeroth order classifier system. Evolutionary Computation, 2:1-18.\nWise, R. A. (2004). Dopamine, learning, and motivation. Nature Reviews Neuroscience, 5(6):1-12.\nWitten, I. H. (1976). The apparent conflict between estimation and control\\A1\\AAA survey of the two-armed problem. Journal of the Franklin Institute,301:161-189.\nWitten, I. H. (1977). An adaptive optimal controller for discrete-time Markov environments. Information and Control, 34:286-295.\nWitten, I. H., Corbin, M. J. (1973). Human operators and automatic adaptive controllers: A comparative study on a particular control task. International Journal of Man-Machine Studies,5:75-104.\nWoodbury, T., Dunn, C., and Valasek, J. (2014). Autonomous soaring using reinforcement\nlearning for trajectory generation. In 52nd Aerospace Sciences Meeting, page 0990.\nWoodworth, R. S., Schlosberg, H. (1938). Experimental psychology.New York: Henry Holt and Company.\nXie, X. and Seung, H. S. (2004). Learning in neural networks by reinforcement of irregular spiking. Physical Review E,69(4).\nXu, X., Xie, T., Hu, D., and Lu, X. (2005). Kernel least-squares temporal difference learning. International Journal of Information Technology 11(9):54-63.\nYagishita, S., Hayashi-Takagi, A., Ellis-Davies, G. C. R., Urakubo, H., Ishii, S., and Kasai,\nH.\u0026nbsp; (2014). A critical time window for dopamine actions on the structural plasticity of dendritic spines. Science, 345(6204):1616-1619.\nYee, R. C., Saxena, S., Utgoff, P. E., Barto, A. G. (1990). Explaining temporal differences to create useful concepts for evaluating states. In Proceedings of the Eighth National Conference on Artificial Intelligence, pp. 882-888. AAAI Press, Menlo Park, CA.\nYin, H. H. and Knowlton, B. J. (2006). The role of the basal ganglia in habit formation. Nature Reviews Neuroscience,7(6):464-476.\nYoung, P. (1984). Recursive Estimation and Time-Series Analysis. Springer-Verlag, Berlin.\nYu, H. (2010). Convergence of least squares temporal difference methods under general conditions. International Conference on Machine Learning 27,pp. 1207-1214.\nYu, H. (2012). Least squares temporal difference methods: An analysis under general con\u0026shy;ditions. SIAM Journal on Control and Optimization,50(6), 3310-3343.\nYu, H. (2015a). On convergence of emphatic temporal-difference learning. ArXiv:1506.02582. A shorter version appeared in Conference on Learning Theory 18, JMLR W\u0026amp;CP 40.\nYu, H. (2015b). Weak convergence properties of constrained emphatic temporal-difference learning with constant and slowly diminishing stepsize. ArXiv:1511.07471.\nZhang, M., Yum, T. P. (1989). Comparisons of channel-assignment strategies in cellular mobile telephone systems. IEEE Transactions on Vehicular Technology,38:211-215.\nZhang, W. (1996). Reinforcement Learning for Job-shop Scheduling. Ph.D. thesis, Oregon State University. Technical Report CS-96-30-1.\nZhang, W., Dietterich, T. G. (1995). A reinforcement learning approach to job-shop schedul\u0026shy;ing. In Proceedings of the Fourteenth International Joint Conference on Artificial Intel\u0026shy;ligence, pp. 1114-1120. Morgan Kaufmann.\nZhang, W., Dietterich, T. G. (1996). High-performance job-shop scheduling with a time- delay TD(A) network. In D. S. Touretzky, M. C. Mozer, M. E. Hasselmo (eds.), Ad\u0026shy;vances in Neural Information Processing Systems: Proceedings of the 1995 Conference, pp. 1024-1030. MIT Press, Cambridge, MA.\nZweben, M., Daun, B., Deale, M. (1994). Scheduling and rescheduling with iterative re\u0026shy;pair. In M. Zweben and M. S. Fox (eds.), Intelligent Scheduling,pp. 241-255. Morgan Kaufmann, San Francisco.\n \niht=IHT(4096) and tiles(iht, 8, [8*x/(0.5+1.2), 8*xdot/(0.07+0.07)], A) to get the indices of the ones in the feature vector for state (x, xdot) and action A.\n  [1]The notation (a, b] as a set denotes the real interval between a and b including b but not including\n a.Thus, here we are saying that 0 \u0026lt; a \u0026lt; 1.\n [3]Associative search tasks are often now termed contextual banditsin the literature.\n [4]We use the terms agent, environment,and actioninstead of the engineers\\A1\\AF terms controller, controlled system(or plant), and control signalbecause they are meaningful to a wider audience.\n [5]We restrict attention todiscrete time tokeep things as simple as possible, even though many of the ideas can be extended to the continuous-time case (e.g., see Bertsekas and Tsitsiklis, 1996; Werbos, 1992; Doya, 1996).\n [6]We use Rt+iinstead of Rtto denote the reward due to Atbecause it emphasizes that the next reward and next state, Rt+i and St+i,are jointly determined. Unfortunately, both conventions are widely used in the literature.\n [7]Better places for imparting this kind of prior knowledge are the initial policy or value function, or in influences on these. See Lin (1992), Maclin and Shavlik (1994), and Clouse (1996).\n [8]Episodes are sometimes called \\A1\\B0trials\\A1\\B1 in the literature.\n [9]This algorithm has a subtle bug, in that it may never terminate if the policy continually switches between two or more policies that are equally good. The bug can be fixed by adding additional flags, but it makes the pseudocode so ugly that it is not worth it.\nPolicy iteration often converges in surprisingly few iterations. This is illustrated by the example in Figure 4.1. The bottom-left diagram shows the value function for the equiprobable random policy, and the bottom-right diagram shows a greedy policy for this value function. The policy improvement theorem assures us that these policies are better than the original random policy. In this case, however, these policies are not just better, but optimal, proceeding to the terminal states in the minimum number of steps. In this example, policy iteration would find the optimal policy after just one iteration.\nExample 4.2: Jack\\A1\\AFs Car Rental Jack manages two locations for a nationwide car rental company. Each day, some number of customers arrive at each location to rent cars. If Jack has a car available, he rents it out and is credited $10 by the national company. If he is out of cars at that location, then the business is lost. Cars become available for renting the day after they are returned. To help ensure that cars are available where they are needed, Jack can move them between the two locations overnight, at a cost of $2 per car moved. We assume that the number of cars requested and returned at each location are Poisson random variables, meaning that the probability that the number is n is \\B1\\B8e-A, where \\C8\\EBis the expected number. Suppose \\C8\\EBis 3 and 4 for rental requests at the first and second locations and 3 and 2 for returns. To simplify the problem slightly, we assume that there can be no more than 20cars at each location (any additional cars are returned to the nationwide company, and thus disappear from the problem) and a maximum of five cars can\n [10]If this were a control problem with the objective of minimizing travel time, then we would of course make the rewards the negativeof the elapsed time. But since we are concerned here only with prediction (policy evaluation), we can keep things simple by using positive numbers.\n [11]-step Sarsa\naka Sarsa(0) 2-step Sarsa 3-step Sarsa\nPseudocode is shown in the box below, and an example of why it can speed up learning compared to one-step methods is given in Figure 7.4.\nWhat about Expected Sarsa? The backup diagram for the n-step version of Ex\u0026shy;pected Sarsa is shown on the far right in Figure 7.3. It consists of a linear string of sampled actions and states, just as in n-step Sarsa, except that its last element is a branch over all action possibilities weighted, as always, by their probability under n. This algorithm can be described by the same equation as n-step Sarsa (above) except with the n-step return redefined as\nGt:t+n = Rt+i + \\A1\\AD+ Yn iRt+n +\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; أ(a|St+n)Qt+n-i(St+n, a),\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; (7.6)\na\nfor all n and t such that n 1 and 0 t T n.\n [12]The Dyna-Q+ agent was changed in two other ways as well. First, actions that had never been tried before from a state were allowed to be considered in the planning step (f) of the Tabular Dyna-Q algorithm in the box above. Second, the initial model for such actions was that they would\nlead back to the same state with a reward of zero.\n [13]This policy might be stochastic because RTDP continues to randomly select among all the\n [14]There are interesting exceptions to this. See, e.g., Pearl (1984).\n [15]In particular, in the episodic case with discounting (7\u0026lt; 1) it can be argued that we should be more concerned about accurately valuing the states that occur early in the episode than those that occur later. This can be expressed by altering the on-policy distibution \\DA\\E0to include a factor of 7in the second term of (9.2). Although this might be more general, it would complicate the following\npresentation of algorithms, and concerns a rare case, so we omit it here.\n [16]The T denotes transpose, needed here to turn the horizontal row vector in the text into a vertical column vector; in this book vectors are generally taken to be column vectors unless explicitly written out horizontally, as here, or transposed.\n [17]This data is actually from the \\A1\\B0semi-gradient Sarsa(A)\\A1\\B1 algorithm that we will not meet until Chapter 12, but semi-gradient Sarsa behaves similarly.\n [18]For state values there remains a small difference in the treatment of the importance sampling ratio pt.In the analagous action-value case (which is the most important case for control algorithms), the residual gradient algorithm would reduce exactly to the naive version.\n [19]They would of course be estimateable if the statesequence were observed rather than only the corresponding feature vectors.\n [20]These MRPs can equivalently be considered MDPs with a single action in all states; what we conclude about them here applies as well to MDPs.\n [21]The lone exception is the gradient bandit algorithms of Section 2.8. In fact, that section goes through many of the same steps, in the single-state bandit case, as we go through here for full MDPs. Reviewing that section would be good preparation for fully understanding this chapter.\n The vector\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp;\u0026nbsp; in the REINFORCE update is the only place the policy\nparameterization appears in the algorithm. This vector has been given several names and notations in the literature; we will refer to it simply as the eligibility vector.The eligibility vector is often written in the compact form Ve logn(At|St, 6), using the identity V log x =\\BE\\AF.Thisform is used in all the boxed pseudocode in this chapter. In earlier examples in this chapter we considered exponential softmax policies (13.2) with linear action preferences (13.3). For this parameterization, the eligibility vector is\nVe logn(a|s, 6) = x(s, a) - ^ n(b|s, 6)x(s, b).\nb\n [23]Technically, this is only true if each episode\\A1\\AFs updates are done off-line,meaning they are accumulated on the side during the episode and only used to change 6by their sum at the episode\\A1\\AFs end. However, this would probably be a worse algorithm in practice, and its desireable theoretical properties would probably be shared by the algorithm as given (although this has not been proved).\n The generalizations to the forward view of multi-step methods and then to a X-return algorithm are straightforward. The one-step return in (13.10) is merely replaced by G^\\A3\\BAt+fc and G^ respectively. The backward views are also straightforward, using separate eligibility traces for the actor and critic, each after the patterns in Chapter 12. Pseudocode for the complete algorithm is given in the box on the next page.\n [25]What control means for us is different from what it typically means in animal learning theories; there the environment controls the agent instead of the other way around. See our comments on terminology at the end of this chapter.\n [26]Comparison with a control group is necessary to show that the previous conditioning to the tone is responsible for blocking learning to the light. This is done by trials with the tone/light CS but with no prior conditioning to the tone. Learning to the light in this case is unimpaired. Moore and Schmajuk (2008) give a full account of this procedure.\n [27]The only differences between the LMS rule and the Rescorla-Wagner model are that for LMS the input vectors xt can have any real numbers as components, and\\A1\\AAat least in the simplest version of the LMS rule\\A1\\AAthe step-size parameter adoes not depend on the input vector or the identity of the stimulus setting the prediction target.\n [28]In our formalism, there is a different state, St,for each time step tduring a trial, and for a trial in which a compound CS consists of ncomponent CSs of various durations occurring at various times\n [29]As we mentioned in Section 6.1, Stin our notation is defined to be ֻt+i + 7V(St+i) \\A1\\AA V(St),so St is not available until time t+1. The TD error availableat tis actually St-i = Rt+ 7V(St) \\A1\\AA V(St-i). Since we are thinking of time steps as very small, or even infinitesimal, time intervals, one should not attribute undue importance to this one-step time shift.\n [30]In the literature relating TD errors to the activity of dopamine neurons, their Stis the same as our St-i = Rt+ YV (St) - V (St-i).\n [31]Registered trademark of IBM Corp.\n [32]Registered trademark of Jeopardy Productions Inc.\n \n\n\n","date":1559347200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1559347200,"objectID":"d7f1d9e9410e97623b99989e14417685","permalink":"https://wormcode.github.io/post/reinforcement-learning-an-introduction-translate-copy/","publishdate":"2019-06-01T00:00:00Z","relpermalink":"/post/reinforcement-learning-an-introduction-translate-copy/","section":"post","summary":"v\\:* {behavior:url(#default#VML);} o\\:* {behavior:url(#default#VML);} w\\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);}    common Normal common 2 233 2019-06-01T06:56:00Z 2019-06-01T06:56:00Z 544 199385 1136498 Microsoft Corporation 9470 2666 1333217 14.00         false   9.05 pt 9.05 pt  false false false  EN-US ZH-CN X-NONE                        /* Style Definitions */ table.","tags":[],"title":"reinforcement learning","type":"post"},{"authors":["JM  Liu"],"categories":[],"content":"Projects\n 1. comments classification  this is the first deep learning project use the baby neural network, it is a binary classification. it have some problems, the accurate is low. please fix the problem.\ndata: http://www.cs.cornell.edu/people/pabo/movie-review-data/rt-polaritydata.tar.gz more data: http://www.cs.cornell.edu/people/pabo/movie-review-data/\n\u0026rdquo;\u0026lsquo;sh 安装nltk（自然语言工具库 Natural Language Toolkit） $ pip install nltk\n$ python Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \u0026ldquo;help\u0026rdquo;, \u0026ldquo;copyright\u0026rdquo;, \u0026ldquo;credits\u0026rdquo; or \u0026ldquo;license\u0026rdquo; for more information.\n   import nltk nltk.download()\n   下载nltk数据： $ python Python 3.5.2 (v3.5.2:4def2a2901a5, Jun 26 2016, 10:47:25) [GCC 4.2.1 (Apple Inc. build 5666) (dot 3)] on darwin Type \u0026ldquo;help\u0026rdquo;, \u0026ldquo;copyright\u0026rdquo;, \u0026ldquo;credits\u0026rdquo; or \u0026ldquo;license\u0026rdquo; for more information. \u0026gt;\u0026gt;\u0026gt; import nltk \u0026gt;\u0026gt;\u0026gt; nltk.download()\nntlk有详细安装文档。\n测试nltk安装： \u0026gt;\u0026gt;\u0026gt; from nltk.corpus import brown \u0026gt;\u0026gt;\u0026gt; brown.words() [\u0026lsquo;The\u0026rsquo;, \u0026lsquo;Fulton\u0026rsquo;, \u0026lsquo;County\u0026rsquo;, \u0026lsquo;Grand\u0026rsquo;, \u0026lsquo;Jury\u0026rsquo;, \u0026lsquo;said\u0026rsquo;, \u0026hellip;]\n\u0026rdquo;\u0026rsquo;\nthere are problems with this neural networks, that result not work there are couple of tips for you to figure it out: 1. Is it get enough data? 2. How about the capacity of networks?\n","date":1559174400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1559174400,"objectID":"c677252bbdef2c2a8702a9cb21aa4198","permalink":"https://wormcode.github.io/post/dl_projects/","publishdate":"2019-05-30T00:00:00Z","relpermalink":"/post/dl_projects/","section":"post","summary":"through those projects you will be a Deep learning engineer","tags":[],"title":"Deep learning 100+ projects","type":"post"},{"authors":["JM  Liu"],"categories":[],"content":"  v\\:* {behavior:url(#default#VML);} o\\:* {behavior:url(#default#VML);} w\\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);}   Conditional Generative Adversarial Nets   common Normal common 25 1243 2019-06-03T11:15:00Z 2019-06-06T05:48:00Z 6 3051 17395 Microsoft Corporation 144 40 20406 14.00      \u0026lt;!\u0026ndash;[if gte mso 9]\u0026gt;  200/w:Zoom Clean/w:SpellingState false/w:TrackMoves   false/w:SaveIfXMLInvalid false/w:IgnoreMixedContent\nfalse EN-US/w:LidThemeOther ZH-CN/w:LidThemeAsian X-NONE/w:LidThemeComplexScript     /w:Compatibility MicrosoftInternetExplorer4/w:BrowserLevel   /m:mathPr/w:WordDocument \u0026lt;![endif]\u0026ndash;\u0026gt;    \u0026lt;!\u0026ndash;.MJX-CHTML {display: inline-block; font-size-adjust: none; word-wrap: normal; max-width: none; max-height: none; min-width: 0; min-height: 0; float:none; word-spacing:normal;} .mjx-chtml[tabindex]:focus, body :focus .mjx-chtml[tabindex] {display: inline-table} .MJX-FULL-WIDTH {display: table-cell!important;} .MJX-MATH {display: inline-block; border-spacing: 0;} .mjx-math * {display: inline-block; -webkit-box-sizing: content-box!important; -moz-box-sizing: content-box!important; box-sizing: content-box!important; text-align: left} .MJXC-STACKED {position:relative;} .MJXc-stacked \u0026gt; * {position: absolute} .MJXc-bevelled \u0026gt; * {display: inline-block} .MJX-STACK {display: inline-block;} .MJX-UNDER {display: table-cell;} .mjx-over \u0026gt; * {padding-left: 0px!important; padding-right: 0px!important} .mjx-under \u0026gt; * {padding-left: 0px!important; padding-right: 0px!important} .mjx-stack \u0026gt; .mjx-sup {display: block} .mjx-stack \u0026gt; .mjx-sub {display: block} .mjx-prestack \u0026gt; .mjx-presup {display: block} .mjx-prestack \u0026gt; .mjx-presub {display: block} .mjx-delim-h \u0026gt; .mjx-char {display: inline-block} .mjx-mphantom * {visibility: hidden} .mjx-menclose \u0026gt; svg {fill: none; stroke: currentColor} .MJX-MTR {display: table-row;} .MJX-MLABELEDTR {display: table-row;} .MJX-MTD {display: table-cell;} .MJX-LABEL {display: table-row;} .MJX-BOX {display: inline-block;} .MJX-ITABLE {display: inline-table;} .MJX-ROW {display: table-row;} .MJX-CELL {display: table-cell;} .MJX-TABLE {display: table;} .mjx-test.mjx-test-display {display: table!important} .mjx-test.mjx-test-inline {display: inline!important; margin- right: -1px} .mjx-test.mjx-test-default {display: block!important; clear: both} .MJX-EX-BOX {display: inline-block!important; min-height: 0; max-height: none; overflow:hidden; position:absolute;} .MJX-TEST-INLINE .MJX-LEFT-BOX {display: inline-block; float:left;} .MJX-TEST-INLINE .MJX-RIGHT-BOX {display: inline-block; float:right;} .MJX-TEST-DISPLAY .MJX-RIGHT-BOX {display: table-cell!important; width: 10000em!important; min-width: 0; max-width: none;} @font-face {src: local(\u0026lsquo;MathJax_AMS\u0026rsquo;), local(\u0026lsquo;MathJax_AMS- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_AMS-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_AMS-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_AMS-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Caligraphic Bold\u0026rsquo;), local (\u0026lsquo;MathJax_Caligraphic-Bold\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Caligraphic\u0026rsquo;); font-weight:bold;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Caligraphic-Bold.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Caligraphic-Bold.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Caligraphic-Bold.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Fraktur\u0026rsquo;), local (\u0026lsquo;MathJax_Fraktur-Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Fraktur-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Fraktur-Regular.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Fraktur-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Fraktur Bold\u0026rsquo;), local (\u0026lsquo;MathJax_Fraktur-Bold\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Fraktur\u0026rsquo;); font-weight:bold;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Fraktur-Bold.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Fraktur-Bold.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Fraktur-Bold.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Math BoldItalic\u0026rsquo;), local (\u0026lsquo;MathJax_Math-BoldItalic\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Math\u0026rsquo;); font-style:italic; font-weight:bold;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Math-BoldItalic.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Math-BoldItalic.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Math-BoldItalic.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_SansSerif\u0026rsquo;), local (\u0026lsquo;MathJax_SansSerif-Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_SansSerif-Regular.woff\u0026rsquo;) format (\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_SansSerif-Regular.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_SansSerif-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_SansSerif Bold\u0026rsquo;), local (\u0026lsquo;MathJax_SansSerif-Bold\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_SansSerif\u0026rsquo;); font-weight:bold;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_SansSerif-Bold.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_SansSerif-Bold.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_SansSerif-Bold.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_SansSerif Italic\u0026rsquo;), local (\u0026lsquo;MathJax_SansSerif-Italic\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_SansSerif\u0026rsquo;); font-style:italic;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_SansSerif-Italic.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_SansSerif-Italic.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_SansSerif-Italic.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Script\u0026rsquo;), local(\u0026lsquo;MathJax_Script- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Script-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Script-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Script-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Typewriter\u0026rsquo;), local (\u0026lsquo;MathJax_Typewriter-Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Typewriter-Regular.woff\u0026rsquo;) format (\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Typewriter-Regular.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Typewriter-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Caligraphic\u0026rsquo;), local (\u0026lsquo;MathJax_Caligraphic-Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Caligraphic-Regular.woff\u0026rsquo;) format (\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Caligraphic-Regular.otf\u0026rsquo;) format (\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Caligraphic-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Main Bold\u0026rsquo;), local(\u0026lsquo;MathJax_Main- Bold\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Main\u0026rsquo;); font-weight:bold;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Main-Bold.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Main-Bold.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Main-Bold.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Main Italic\u0026rsquo;), local (\u0026lsquo;MathJax_Main-Italic\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Main\u0026rsquo;); font-style:italic;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Main-Italic.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Main-Italic.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Main-Italic.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Main\u0026rsquo;), local(\u0026lsquo;MathJax_Main- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Main-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Main-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Main-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Math Italic\u0026rsquo;), local (\u0026lsquo;MathJax_Math-Italic\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Math\u0026rsquo;); font-style:italic;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Math-Italic.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Math-Italic.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Math-Italic.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Size1\u0026rsquo;), local(\u0026lsquo;MathJax_Size1- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Size1-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Size1-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Size1-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Size2\u0026rsquo;), local(\u0026lsquo;MathJax_Size2- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Size2-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Size2-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Size2-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Size3\u0026rsquo;), local(\u0026lsquo;MathJax_Size3- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Size3-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Size3-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Size3-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Size4\u0026rsquo;), local(\u0026lsquo;MathJax_Size4- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Size4-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Size4-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Size4-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Vector\u0026rsquo;), local(\u0026lsquo;MathJax_Vector- Regular\u0026rsquo;);} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Vector-Regular.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Vector-Regular.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Vector-Regular.eot\u0026rdquo;);} @font-face {src: local(\u0026lsquo;MathJax_Vector Bold\u0026rsquo;), local (\u0026lsquo;MathJax_Vector-Bold\u0026rsquo;);} @font-face {src: local(\u0026lsquo;MathJax_Vector\u0026rsquo;); font-weight:bold;} @font-face {src /2/: url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/woff/MathJax_Vector-Bold.woff\u0026rsquo;) format(\u0026lsquo;woff\u0026rsquo;), url (\u0026lsquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/otf/MathJax_Vector-Bold.otf\u0026rsquo;) format(\u0026lsquo;opentype\u0026rsquo;); src:url (\u0026ldquo;https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/fonts/HT ML-CSS/TeX/eot/MathJax_Vector-Bold.eot\u0026rdquo;);}\n/* Font Definitions / @font-face {font-family:Wingdings; panose-1:5 0 0 0 0 0 0 0 0 0; mso-font-charset:2; mso-generic-font-family:auto; mso-font-pitch:variable; mso-font-signature:0 268435456 0 0 -2147483648 0;} @font-face {font-family:\u0026ldquo;MS Mincho\u0026rdquo;; panose-1:2 2 6 9 4 2 5 8 3 4; mso-font-alt:\u0026ldquo;ＭＳ 明朝\u0026rdquo;; mso-font-charset:128; mso-generic-font-family:modern; mso-font-pitch:fixed; mso-font-signature:-536870145 1791491579 18 0 131231 0;} @font-face {font-family:宋体; panose-1:2 1 6 0 3 1 1 1 1 1; mso-font-alt:SimSun; mso-font-charset:134; mso-generic-font-family:auto; mso-font-pitch:variable; mso-font-signature:3 680460288 22 0 262145 0;} @font-face {font-family:\u0026ldquo;Cambria Math\u0026rdquo;; panose-1:2 4 5 3 5 4 6 3 2 4; mso-font-charset:0; mso-generic-font-family:roman; mso-font-pitch:variable; mso-font-signature:-536870145 1107305727 0 0 415 0;} @font-face {font-family:\u0026rdquo;\\@宋体\u0026rdquo;; panose-1:2 1 6 0 3 1 1 1 1 1; mso-font-charset:134; mso-generic-font-family:auto; mso-font-pitch:variable; mso-font-signature:3 680460288 22 0 262145 0;} @font-face {font-family:\u0026rdquo;\\@MS Mincho\u0026rdquo;; panose-1:2 2 6 9 4 2 5 8 3 4; mso-font-charset:128; mso-generic-font-family:modern; mso-font-pitch:fixed; mso-font-signature:-536870145 1791491579 18 0 131231 0;} @font-face {font-family:MJXc-TeX-ams-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-cal-Bw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-frak-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-frak-Bw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-math-BIw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-sans-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-sans-Bw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-sans-Iw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-script-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-type-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-cal-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-main-Bw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-main-Iw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-main-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-math-Iw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-size1-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-size2-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-size3-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-size4-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-vec-Rw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} @font-face {font-family:MJXc-TeX-vec-Bw; panose-1:0 0 0 0 0 0 0 0 0 0; mso-font-charset:0; mso-generic-font-family:roman; mso-font-format:other; mso-font-pitch:auto; mso-font-signature:0 0 0 0 0 0;} / Style Definitions / p.MsoNormal, li.MsoNormal, div.MsoNormal {mso-style-unhide:no; mso-style-qformat:yes; mso-style-parent:\u0026ldquo;\u0026rdquo;; margin:0cm; margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} h1 {mso-style-priority:9; mso-style-unhide:no; mso-style-qformat:yes; mso-style-link:\u0026ldquo;Heading 1 Char\u0026rdquo;; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; mso-outline-level:1; font-size:24.0pt; font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} h2 {mso-style-priority:9; mso-style-unhide:no; mso-style-qformat:yes; mso-style-link:\u0026ldquo;Heading 2 Char\u0026rdquo;; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; mso-outline-level:2; font-size:18.0pt; font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} h3 {mso-style-priority:9; mso-style-unhide:no; mso-style-qformat:yes; mso-style-link:\u0026ldquo;Heading 3 Char\u0026rdquo;; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; mso-outline-level:3; font-size:13.5pt; font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} h4 {mso-style-priority:9; mso-style-unhide:no; mso-style-qformat:yes; mso-style-link:\u0026ldquo;Heading 4 Char\u0026rdquo;; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; mso-outline-level:4; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} h5 {mso-style-priority:9; mso-style-unhide:no; mso-style-qformat:yes; mso-style-link:\u0026ldquo;Heading 5 Char\u0026rdquo;; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; mso-outline-level:5; font-size:10.0pt; font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} h6 {mso-style-priority:9; mso-style-unhide:no; mso-style-qformat:yes; mso-style-link:\u0026ldquo;Heading 6 Char\u0026rdquo;; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; mso-outline-level:6; font-size:7.5pt; font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} a:link, span.MsoHyperlink {mso-style-noshow:yes; mso-style-priority:99; color:blue; text-decoration:underline; text-underline:single;} a:visited, span.MsoHyperlinkFollowed {mso-style-noshow:yes; mso-style-priority:99; color:purple; text-decoration:underline; text-underline:single;} p {mso-style-noshow:yes; mso-style-priority:99; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.MsoAcetate, li.MsoAcetate, div.MsoAcetate {mso-style-noshow:yes; mso-style-priority:99; mso-style-link:\u0026ldquo;Balloon Text Char\u0026rdquo;; margin:0cm; margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:8.0pt; font-family:宋体; mso-bidi-font-family:宋体;} span.Heading1Char {mso-style-name:\u0026ldquo;Heading 1 Char\u0026rdquo;; mso-style-priority:9; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Heading 1\u0026rdquo;; mso-ansi-font-size:22.0pt; mso-bidi-font-size:22.0pt; font-family:宋体; mso-ascii-font-family:宋体; mso-fareast-font-family:宋体; mso-hansi-font-family:宋体; mso-bidi-font-family:宋体; mso-font-kerning:22.0pt; font-weight:bold;} span.Heading2Char {mso-style-name:\u0026ldquo;Heading 2 Char\u0026rdquo;; mso-style-priority:9; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Heading 2\u0026rdquo;; mso-ansi-font-size:16.0pt; mso-bidi-font-size:16.0pt; font-family:\u0026ldquo;Cambria\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-ascii-font-family:Cambria; mso-ascii-theme-font:major-latin; mso-fareast-font-family:宋体; mso-fareast-theme-font:major-fareast; mso-hansi-font-family:Cambria; mso-hansi-theme-font:major-latin; mso-bidi-font-family:\u0026ldquo;Times New Roman\u0026rdquo;; mso-bidi-theme-font:major-bidi; font-weight:bold;} span.Heading3Char {mso-style-name:\u0026ldquo;Heading 3 Char\u0026rdquo;; mso-style-priority:9; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Heading 3\u0026rdquo;; mso-ansi-font-size:16.0pt; mso-bidi-font-size:16.0pt; font-family:宋体; mso-ascii-font-family:宋体; mso-fareast-font-family:宋体; mso-hansi-font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} span.Heading4Char {mso-style-name:\u0026ldquo;Heading 4 Char\u0026rdquo;; mso-style-priority:9; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Heading 4\u0026rdquo;; mso-ansi-font-size:14.0pt; mso-bidi-font-size:14.0pt; font-family:\u0026ldquo;Cambria\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-ascii-font-family:Cambria; mso-ascii-theme-font:major-latin; mso-fareast-font-family:宋体; mso-fareast-theme-font:major-fareast; mso-hansi-font-family:Cambria; mso-hansi-theme-font:major-latin; mso-bidi-font-family:\u0026ldquo;Times New Roman\u0026rdquo;; mso-bidi-theme-font:major-bidi; font-weight:bold;} span.Heading5Char {mso-style-name:\u0026ldquo;Heading 5 Char\u0026rdquo;; mso-style-noshow:yes; mso-style-priority:9; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Heading 5\u0026rdquo;; mso-ansi-font-size:14.0pt; mso-bidi-font-size:14.0pt; font-family:宋体; mso-ascii-font-family:宋体; mso-fareast-font-family:宋体; mso-hansi-font-family:宋体; mso-bidi-font-family:宋体; font-weight:bold;} span.Heading6Char {mso-style-name:\u0026ldquo;Heading 6 Char\u0026rdquo;; mso-style-priority:9; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Heading 6\u0026rdquo;; mso-ansi-font-size:12.0pt; mso-bidi-font-size:12.0pt; font-family:\u0026ldquo;Cambria\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-ascii-font-family:Cambria; mso-ascii-theme-font:major-latin; mso-fareast-font-family:宋体; mso-fareast-theme-font:major-fareast; mso-hansi-font-family:Cambria; mso-hansi-theme-font:major-latin; mso-bidi-font-family:\u0026ldquo;Times New Roman\u0026rdquo;; mso-bidi-theme-font:major-bidi; font-weight:bold;} span.BalloonTextChar {mso-style-name:\u0026ldquo;Balloon Text Char\u0026rdquo;; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;Balloon Text\u0026rdquo;; mso-ansi-font-size:8.0pt; mso-bidi-font-size:8.0pt; font-family:宋体; mso-ascii-font-family:宋体; mso-fareast-font-family:宋体; mso-hansi-font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-chtml, li.mjx-chtml, div.mjx-chtml {mso-style-name:mjx-chtml; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; margin:0cm; margin-bottom:.0001pt; line-height:0%; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-display, li.mjxc-display, div.mjxc-display {mso-style-name:mjxc-display; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; margin-top:12.0pt; margin-right:0cm; margin-bottom:12.0pt; margin-left:0cm; text-align:center; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-full-width, li.mjx-full-width, div.mjx-full-width {mso-style-name:mjx-full-width; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; text-align:center; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-numerator, li.mjx-numerator, div.mjx-numerator {mso-style-name:mjx-numerator; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; text-align:center; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-denominator, li.mjx-denominator, div.mjx-denominator {mso-style-name:mjx-denominator; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; text-align:center; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-stacked, li.mjxc-stacked, div.mjxc-stacked {mso-style-name:mjxc-stacked; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-op, li.mjx-op, div.mjx-op {mso-style-name:mjx-op; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-over, li.mjx-over, div.mjx-over {mso-style-name:mjx-over; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-surd, li.mjx-surd, div.mjx-surd {mso-style-name:mjx-surd; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-merror, li.mjx-merror, div.mjx-merror {mso-style-name:mjx-merror; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; background:#FFFF88; border:none; mso-border-alt:solid #CC0000 .75pt; padding:0cm; mso-padding-alt:2.0pt 2.0pt 2.0pt 2.0pt; font-size:11.0pt; font-family:宋体; mso-bidi-font-family:宋体; color:#CC0000;} p.mjx-annotation-xml, li.mjx-annotation-xml, div.mjx- annotation-xml {mso-style-name:mjx-annotation-xml; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-mtd, li.mjx-mtd, div.mjx-mtd {mso-style-name:mjx-mtd; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; text-align:center; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-block, li.mjx-block, div.mjx-block {mso-style-name:mjx-block; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-span, li.mjx-span, div.mjx-span {mso-style-name:mjx-span; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-char, li.mjx-char, div.mjx-char {mso-style-name:mjx-char; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-itable, li.mjx-itable, div.mjx-itable {mso-style-name:mjx-itable; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-table, li.mjx-table, div.mjx-table {mso-style-name:mjx-table; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-line, li.mjx-line, div.mjx-line {mso-style-name:mjx-line; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-strut, li.mjx-strut, div.mjx-strut {mso-style-name:mjx-strut; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-vsize, li.mjx-vsize, div.mjx-vsize {mso-style-name:mjx-vsize; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-space1, li.mjxc-space1, div.mjxc-space1 {mso-style-name:mjxc-space1; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:2.0pt; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-space2, li.mjxc-space2, div.mjxc-space2 {mso-style-name:mjxc-space2; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:2.65pt; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-space3, li.mjxc-space3, div.mjxc-space3 {mso-style-name:mjxc-space3; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:3.35pt; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-ex-box, li.mjx-ex-box, div.mjx-ex-box {mso-style-name:mjx-ex-box; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; margin:0cm; margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-unknown-r, li.mjxc-tex-unknown-r, div.mjxc-tex- unknown-r {mso-style-name:mjxc-tex-unknown-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;Courier New\u0026rdquo;; mso-fareast-font-family:宋体;} p.mjxc-tex-unknown-i, li.mjxc-tex-unknown-i, div.mjxc-tex- unknown-i {mso-style-name:mjxc-tex-unknown-i; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;Courier New\u0026rdquo;; mso-fareast-font-family:宋体; font-style:italic;} p.mjxc-tex-unknown-b, li.mjxc-tex-unknown-b, div.mjxc-tex- unknown-b {mso-style-name:mjxc-tex-unknown-b; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;Courier New\u0026rdquo;; mso-fareast-font-family:宋体; font-weight:bold;} p.mjxc-tex-unknown-bi, li.mjxc-tex-unknown-bi, div.mjxc-tex- unknown-bi {mso-style-name:mjxc-tex-unknown-bi; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;Courier New\u0026rdquo;; mso-fareast-font-family:宋体; font-weight:bold; font-style:italic;} p.mjxc-tex-ams-r, li.mjxc-tex-ams-r, div.mjxc-tex-ams-r {mso-style-name:mjxc-tex-ams-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-ams-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-cal-b, li.mjxc-tex-cal-b, div.mjxc-tex-cal-b {mso-style-name:mjxc-tex-cal-b; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-cal-Bw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-frak-r, li.mjxc-tex-frak-r, div.mjxc-tex-frak-r {mso-style-name:mjxc-tex-frak-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-frak-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-frak-b, li.mjxc-tex-frak-b, div.mjxc-tex-frak-b {mso-style-name:mjxc-tex-frak-b; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-frak-Bw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-math-bi, li.mjxc-tex-math-bi, div.mjxc-tex-math-bi {mso-style-name:mjxc-tex-math-bi; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-math-BIw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-sans-r, li.mjxc-tex-sans-r, div.mjxc-tex-sans-r {mso-style-name:mjxc-tex-sans-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-sans-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-sans-b, li.mjxc-tex-sans-b, div.mjxc-tex-sans-b {mso-style-name:mjxc-tex-sans-b; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-sans-Bw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-sans-i, li.mjxc-tex-sans-i, div.mjxc-tex-sans-i {mso-style-name:mjxc-tex-sans-i; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-sans-Iw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-script-r, li.mjxc-tex-script-r, div.mjxc-tex- script-r {mso-style-name:mjxc-tex-script-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-script-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-type-r, li.mjxc-tex-type-r, div.mjxc-tex-type-r {mso-style-name:mjxc-tex-type-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-type-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-cal-r, li.mjxc-tex-cal-r, div.mjxc-tex-cal-r {mso-style-name:mjxc-tex-cal-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-cal-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-main-b, li.mjxc-tex-main-b, div.mjxc-tex-main-b {mso-style-name:mjxc-tex-main-b; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-main-Bw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-main-i, li.mjxc-tex-main-i, div.mjxc-tex-main-i {mso-style-name:mjxc-tex-main-i; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-main-Iw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-main-r, li.mjxc-tex-main-r, div.mjxc-tex-main-r {mso-style-name:mjxc-tex-main-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-main-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-math-i, li.mjxc-tex-math-i, div.mjxc-tex-math-i {mso-style-name:mjxc-tex-math-i; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-math-Iw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-size1-r, li.mjxc-tex-size1-r, div.mjxc-tex-size1-r {mso-style-name:mjxc-tex-size1-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-size1-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-size2-r, li.mjxc-tex-size2-r, div.mjxc-tex-size2-r {mso-style-name:mjxc-tex-size2-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-size2-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-size3-r, li.mjxc-tex-size3-r, div.mjxc-tex-size3-r {mso-style-name:mjxc-tex-size3-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-size3-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-size4-r, li.mjxc-tex-size4-r, div.mjxc-tex-size4-r {mso-style-name:mjxc-tex-size4-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-size4-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-vec-r, li.mjxc-tex-vec-r, div.mjxc-tex-vec-r {mso-style-name:mjxc-tex-vec-r; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-vec-Rw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjxc-tex-vec-b, li.mjxc-tex-vec-b, div.mjxc-tex-vec-b {mso-style-name:mjxc-tex-vec-b; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:\u0026ldquo;MJXc-TeX-vec-Bw\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;; mso-fareast-font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-left-box, li.mjx-left-box, div.mjx-left-box {mso-style-name:mjx-left-box; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-right-box, li.mjx-right-box, div.mjx-right-box {mso-style-name:mjx-right-box; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-left-box1, li.mjx-left-box1, div.mjx-left-box1 {mso-style-name:mjx-left-box1; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-right-box1, li.mjx-right-box1, div.mjx-right-box1 {mso-style-name:mjx-right-box1; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.mjx-right-box2, li.mjx-right-box2, div.mjx-right-box2 {mso-style-name:mjx-right-box2; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; margin:0cm; margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.ltxp, li.ltxp, div.ltxp {mso-style-name:ltx_p; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} p.feedback-current-screenshot, li.feedback-current-screenshot, div.feedback-current-screenshot {mso-style-name:feedback-current-screenshot; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-margin-top-alt:auto; margin-right:0cm; mso-margin-bottom-alt:auto; margin-left:0cm; mso-pagination:widow-orphan; font-size:12.0pt; font-family:宋体; mso-bidi-font-family:宋体;} span.ltxcreator {mso-style-name:ltx_creator; mso-style-unhide:no;} span.ltxpersonname {mso-style-name:ltx_personname; mso-style-unhide:no;} span.ltxtext {mso-style-name:ltx_text; mso-style-unhide:no;} span.ltxerror {mso-style-name:ltx_error; mso-style-unhide:no;} span.ltxmath {mso-style-name:ltx_math; mso-style-unhide:no;} span.mjpage {mso-style-name:mjpage; mso-style-unhide:no;} span.mjx-chtml1 {mso-style-name:mjx-chtml1; mso-style-unhide:no; mso-ansi-font-size:12.0pt; mso-bidi-font-size:12.0pt; text-transform:none; letter-spacing:0pt; border:none windowtext 1.0pt; mso-border-alt:none windowtext 0cm; padding:0cm; font-weight:normal; font-style:normal;} span.mjx-math {mso-style-name:mjx-math; mso-style-unhide:no;} span.mjx-mrow {mso-style-name:mjx-mrow; mso-style-unhide:no;} span.mjx-texatom {mso-style-name:mjx-texatom; mso-style-unhide:no;} span.mjx-mi {mso-style-name:mjx-mi; mso-style-unhide:no;} span.mjx-char1 {mso-style-name:mjx-char1; mso-style-unhide:no; mso-hide:none;} span.ltxtag {mso-style-name:ltx_tag; mso-style-unhide:no;} span.mjx-msubsup {mso-style-name:mjx-msubsup; mso-style-unhide:no;} span.mjx-base {mso-style-name:mjx-base; mso-style-unhide:no;} span.mjx-sub {mso-style-name:mjx-sub; mso-style-unhide:no;} span.mjx-mo {mso-style-name:mjx-mo; mso-style-unhide:no;} span.mjx-mn {mso-style-name:mjx-mn; mso-style-unhide:no;} span.ltxdisplaymath {mso-style-name:ltx_displaymath; mso-style-unhide:no;} span.mjx-munderover {mso-style-name:mjx-munderover; mso-style-unhide:no;} span.mjx-itable1 {mso-style-name:mjx-itable1; mso-style-unhide:no;} span.mjx-row {mso-style-name:mjx-row; mso-style-unhide:no;} span.mjx-cell {mso-style-name:mjx-cell; mso-style-unhide:no;} span.mjx-op1 {mso-style-name:mjx-op1; mso-style-unhide:no; mso-hide:none;} span.mjx-under {mso-style-name:mjx-under; mso-style-unhide:no;} span.mjx-mtext {mso-style-name:mjx-mtext; mso-style-unhide:no;} span.mjx-charbox {mso-style-name:mjx-charbox; mso-style-unhide:no;} span.ltxnote {mso-style-name:ltx_note; mso-style-unhide:no;} span.ltxnoteouter {mso-style-name:ltx_note_outer; mso-style-unhide:no;} span.ltxnotecontent {mso-style-name:ltx_note_content; mso-style-unhide:no;} span.ltxbibblock {mso-style-name:ltx_bibblock; mso-style-unhide:no;} span.z-TopofFormChar {mso-style-name:\u0026ldquo;z-Top of Form Char\u0026rdquo;; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;z-Top of Form\u0026rdquo;; mso-ansi-font-size:8.0pt; mso-bidi-font-size:8.0pt; font-family:\u0026ldquo;Arial\u0026rdquo;,\u0026ldquo;sans-serif\u0026rdquo;; mso-ascii-font-family:Arial; mso-fareast-font-family:宋体; mso-hansi-font-family:Arial; mso-bidi-font-family:Arial; display:none; mso-hide:all;} span.z-BottomofFormChar {mso-style-name:\u0026ldquo;z-Bottom of Form Char\u0026rdquo;; mso-style-noshow:yes; mso-style-priority:99; mso-style-unhide:no; mso-style-locked:yes; mso-style-link:\u0026ldquo;z-Bottom of Form\u0026rdquo;; mso-ansi-font-size:8.0pt; mso-bidi-font-size:8.0pt; font-family:\u0026ldquo;Arial\u0026rdquo;,\u0026ldquo;sans-serif\u0026rdquo;; mso-ascii-font-family:Arial; mso-fareast-font-family:宋体; mso-hansi-font-family:Arial; mso-bidi-font-family:Arial; display:none; mso-hide:all;} span.notranslate {mso-style-name:notranslate; mso-style-unhide:no;} span.SpellE {mso-style-name:\u0026ldquo;\u0026rdquo;; mso-spl-e:yes;} .MsoChpDefault {mso-style-type:export-only; mso-default-props:yes; font-size:10.0pt; mso-ansi-font-size:10.0pt; mso-bidi-font-size:10.0pt; mso-ascii-font-family:\u0026ldquo;Times New Roman\u0026rdquo;; mso-hansi-font-family:\u0026ldquo;Times New Roman\u0026rdquo;; mso-font-kerning:0pt;} @page WordSection1 {size:595.3pt 841.9pt; margin:72.0pt 90.0pt 72.0pt 90.0pt; mso-header-margin:42.55pt; mso-footer-margin:49.6pt; mso-paper-source:0;} div.WordSection1 {page:WordSection1;} / List Definitions / @list l0 {mso-list-id:1135484360; mso-list-template-ids:-1828420312;} @list l0:level1 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:36.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l0:level2 {mso-level-number-format:bullet; mso-level-text:o; mso-level-tab-stop:72.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:\u0026ldquo;Courier New\u0026rdquo;; mso-bidi-font-family:\u0026ldquo;Times New Roman\u0026rdquo;;} @list l0:level3 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:108.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l0:level4 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:144.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l0:level5 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:180.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l0:level6 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:216.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l0:level7 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:252.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l0:level8 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:288.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l0:level9 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:324.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Wingdings;} @list l1 {mso-list-id:1153372443; mso-list-template-ids:-1017602180;} @list l1:level1 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:36.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level2 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:72.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level3 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:108.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level4 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:144.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level5 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:180.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level6 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:216.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level7 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:252.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level8 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:288.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} @list l1:level9 {mso-level-number-format:bullet; mso-level-text:; mso-level-tab-stop:324.0pt; mso-level-number-position:left; text-indent:-18.0pt; mso-ansi-font-size:10.0pt; font-family:Symbol;} ol {margin-bottom:0cm;} ul {margin-bottom:0cm;} \u0026ndash;\u0026gt;  \u0026lt;!\u0026ndash;[if gte mso 10]\u0026gt;  / Style Definitions */ table.MsoNormalTable {mso-style-name:\u0026ldquo;Table Normal\u0026rdquo;; mso-tstyle-rowband-size:0; mso-tstyle-colband-size:0; mso-style-noshow:yes; mso-style-priority:99; mso-style-parent:\u0026ldquo;\u0026rdquo;; mso-padding-alt:0cm 5.4pt 0cm 5.4pt; mso-para-margin:0cm; mso-para-margin-bottom:.0001pt; mso-pagination:widow-orphan; font-size:10.0pt; font-family:\u0026ldquo;Times New Roman\u0026rdquo;,\u0026ldquo;serif\u0026rdquo;;}  \u0026lt;![endif]\u0026ndash;\u0026gt; \n   window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments)}; gtag('js', new Date()); gtag('config', 'UA-107304984-1');  (function(c,a){if(!a.__SV){var b=window;try{var d,m,j,k=b.location,f=k.hash;d=function(a,b){return(m=a.match (RegExp(b+\u0026ldquo;=([^\u0026amp;]*)\u0026ldquo;)))?m[1]:null};f\u0026amp;\u0026amp;d(f,\u0026ldquo;state\u0026rdquo;)\u0026amp;\u0026amp; (j=JSON.parse(decodeURIComponent(d (f,\u0026ldquo;state\u0026rdquo;))),\u0026ldquo;mpeditor\u0026rdquo;===j.action\u0026amp;\u0026amp;(b.sessionStorage.setItem (\u0026rdquo;_mpcehash\u0026rdquo;,f),history.replaceState (j.desiredHash||\u0026ldquo;\u0026rdquo;,c.title,k.pathname+k.search)))}catch(n){}var l,h;window.mixpanel=a;a._i=[];a.init=function(b,d,g){function c(b,i){var a=i.split(\u0026ldquo;.\u0026rdquo;);2==a.length\u0026amp;\u0026amp;(b=b[a[0]],i=a[1]);b[i] =function(){b.push([i].concat(Array.prototype.slice.call (arguments, 0)))}}var e=a;\u0026ldquo;undefined\u0026rdquo;!==typeof g?e=a[g]=\n{var a=\u0026ldquo;mixpanel\u0026rdquo;;\u0026ldquo;mixpanel\u0026rdquo;!==g\u0026amp;\u0026amp;(a+=\u0026ldquo;.\u0026rdquo;+g);b||(a+=\u0026rdquo; (stub)\u0026ldquo;);return a};e.people.toString=function(){return e.toString(1)+\u0026ldquo;.people (stub)\u0026rdquo;};l=\u0026ldquo;disable time_event track track_pageview track_links track_forms track_with_groups add_group set_group remove_group register register_once alias unregister identify name_tag set_config reset opt_in_tracking opt_out_tracking has_opted_in_tracking has_opted_out_tracking clear_opt_in_out_tracking people.set people.set_once people.unset people.increment people.append people.union people.track_charge people.clear_charges people.delete_user people.remove\u0026rdquo;.split(\u0026rdquo; \u0026ldquo;); for(h=0;h\u0026lt;l.length;h++)c(e,l[h]);var f=\u0026ldquo;set set_once union unset remove delete\u0026rdquo;.split(\u0026rdquo; \u0026ldquo;);e.get_group=function(){function a\u0026copy;{b[c]=function(){call2_args=arguments;call2=[c].concat (Array.prototype.slice.call(call2_args,0));e.push([d,call2])}} for(var b={},d=[\u0026ldquo;get_group\u0026rdquo;].concat(Array.prototype.slice.call (arguments,0)),c=0;c\u0026lt;f.length;c++)a(f[c]);return b};a._i.push ([b,d,g])};a.__SV=1.2;b=c.createElement (\u0026ldquo;script\u0026rdquo;);b.type=\u0026ldquo;text/javascript\u0026rdquo;;b.async=! 0;b.src=\u0026ldquo;undefined\u0026rdquo;!==typeof MIXPANEL_CUSTOM_LIB_URL?\nMIXPANEL_CUSTOM_LIB_URL:\u0026ldquo;file:\u0026ldquo;===c.location.protocol\u0026amp;\u0026amp;\u0026ldquo;//cdn4. mxpnl.com/libs/mixpanel-2-latest.min.js\u0026rdquo;.match(/^\\/ \\//)?\u0026ldquo;https://cdn4.mxpnl.com/libs/mixpanel-2- latest.min.js\u0026rdquo;:\u0026ldquo;//cdn4.mxpnl.com/libs/mixpanel-2- latest.min.js\u0026rdquo;;d=c.getElementsByTagName(\u0026ldquo;script\u0026rdquo;) [0];d.parentNode.insertBefore(b,d)}}) (document,window.mixpanel||[]); mixpanel.init(\u0026ldquo;84f8e700b4cf5e8ad68b553496eb72cf\u0026rdquo;);     \nConditional Generative Adversarial Nets  Mehdi Mirza Départementd’informatiqueet de recherche opérationnelleUniversitéde Montréal Montréal, QC H3C 3J7 mirzamom@iro.umontreal.ca\\ANDSimonOsindero \nFlickr / Yahoo Inc. \nSan Francisco, CA 94103 \nosindero@yahoo-inc.com\n  摘要 \n最近，Generative Adversarial Nets [ 8 ]被引入作为训练生成模型的 新方法。 在这项工作中，我们介绍了生成对抗网的条件版本，它可以通过简单地提 供数据y来构造，我们希望对生成器和鉴别器 都进行条件化。 我们证明该模型可以生成以类 标签为条件的MNIST数字。 我们还说明了如何使用此模型来学习多模态模型，并提供图像标记应用程 序的初步示例，其中我们演示了此方法如何生成不属于训练标签的描述性 标记。 \n 1简介 \n最近引入了生成性对抗网作为训练生成模型的替代框 架，以避免许多难以处理的概率近似计算的困难。  对抗网具有以下优点：永远不需要马尔可夫链，仅使 用反向传播来获得梯度，在学习期间不需要推理，并且可以容易地将各种 因素和交互作用吸收到模型中。  此外，如[ 8 ]所示 ，它可以产生最先进的对数似然估计和逼真样本。  在无条件的生成模型中，无法控制正在生成的数据的模式 。 但是，通过附加信息调整模型，可以指导数据生成的过程。 这种条件 可以基于类别标签，在某些部分数据上进行修复，如[ 5 ]，甚至是来自不同模态的数据。\n 在这项工作中，我们展示了如何构建条件对抗网。 对于 实证结果，我们展示了两组实验。 一个在MNIST数字数据集上以类标签为条件，一个在MIR Flickr 25,000数据集[ 10 ]上用于多模态学习。\n 2相关工作\n2.1用于图像标签的多模态学习 \n尽管最近监督神经网络（特 别是卷积网络）取得了许多成功[ 13,17 ]，但仍然难以扩展此类模型以适应预测极大量的输出类别。 第二个问题是迄今为止的大部分工作都集中在学习从输入到输出 的一对一映射。 然而，许多有趣的问题更自然地被认为是概率 性的一对多映射。 例如，在图像标记的情况下，对于一给定图像 可以适当地应用许多不同标签，并且不同（人）注释器可以使用不同（但 通常是同义或相关）术语来描述相同图像。\n 帮助解决第一个问题的一种 方法是利用来自其他模态的附加信息：例如，通过使用自然语言语料库来 学习在几何关系上有语义意义的标签的向量表示。 当在这样的空 间中进行预测时，我们受益于以下事实：当预测错误时我们仍然经常“接 近”真实情况（例如，预测“桌子”而不是“椅子”），以及我们可以自然地 做出预测泛化到训练期间未见的标签的事实。 诸如[ 3 ]之类的工作表明，即使从图像特征空间到字表示空间的简单 线性映射也可以产生改进的分类性能。\n 解决第二个问题的一种方法 是使用条件概率生成模型，输入被视为条件变量，并且一对多映射被实例 化为条件预测分布。\n [ 16 ]对这个问题采取了类似的方 法，并在MIR Flickr 25,000数据集上训练多模态Deep Boltzmann机，就像我们在这项工作中所做的那样。 \n此外，在 [ 12 ]中，作者展示了如何训练有监督的多模态神经语言模 型，并且他们能够为图像生成描述性句子。\n 3 条件对抗网络 \n3.1生成性对抗网\n最近引入了生成性对抗网作为训练生成模型的新方法。 它们由两个“对抗”模型组成：一个捕获数据分布的生成模型G ，以及一个估计样本来自训练数据而不是G的概率的判别模型D. G和D都可以是非线性 映射函数，例如多层感知器。\n 为了学习数据数据x上的生成 器分布pg，生成器将 先验噪声分布pz(z)到数据空间的映射函数建立为G(z;θg)。 并且鉴别器 D(x;θd)输出单个标量，该标量表示x来自训练数据而不是pg的概率。\n同时训练G和D ：我们调整G的参数以 最小化log(1 –D(G(z))并调整D的参数以最小化logD(X) ，如同它们跟随- 具有值函数V(G， D)的双人最小- 最大游戏 （two-player min-max game）：\n   minGmaxDV(D,G)=Ex∼pdata(x) [logD(x)]+Ez∼pz(z) [log(1−D(G(z)))].\n  (1) \n    \n\u0026nbsp;\n3.2有条件的对抗网\n如果生成器和鉴别 器都以某些额外信息y为条件，则生成对抗网可以扩展到条件模型。 y可以是任何类型的辅助信息，例如 类标签或来自其他模态的数据。 我们可以通过将y作为附加输入层馈入鉴别器 和生成器来执行调节\n 在生成器中，先验噪声输入pz(z)和y在联合隐藏表示中被组合，并且对抗训练框架允许 在如何组成该隐藏表示时具有相当大的灵活性。 1\n--------------------------------------------------------- \n1现在我们只需要将条件输入和先验噪声作为MLP的单个隐藏层的输入，但是可以想象使用更高阶 的交互允许复杂的生成机制，这种机制在传统的生成框架中非常难以使用 。\n \u0026nbsp;\n在鉴别器中，x和y被表示为输入和判别函数（在这种情况下由MLP再次体现）。\n The objective function of a two-player minimax game would be as Eq 2 \n双人迷你极限游戏的目标函数将是Eq2\n$$\\min_{G}\\max_{D}V(D,G)=\\mathbb{E}_{{x}\\sim p_{\\text{data}}({x})}[\\log D({x}|{y})]+\\mathbb{E}_{{z}\\sim p_{z}({z})}[\\log(1-D(G({z}|{y})))]$$ (2)  ---------------------------------------   $$\\min_{G}\\max_{D}V(D,G)=\\mathbb{E}_{{x}\\sim p_{\\text{data}}({x})}[\\log D({x}|{y})]+\\mathbb{E}_{{z}\\sim p_{z}({z})}[\\log(1-D(G({z}|{y})))]$$    $$\\min_{G}\\max_{D}V(D,G)=\\mathbb{E}_{{x}\\sim p_{\\text{data}}({x})}[\\log D({x}|{y})]+\\mathbb{E}_{{z}\\sim p_{z}({z})}[\\log(1-D(G({z}|{y})))] $$ test2 minGmaxDV(D,G)=Ex∼pdata(x) [logD(x|y)]+Ez∼pz(z) [log(1−D(G(z| y)))].\n  (2) \n    \n\u0026nbsp;\n图1展示了一种简 单条件对抗网的结构。\n ![figure1](x1.png)图1：条件对抗网 \n4实验结果\n4.1 Unimodal（单模态，只有一个 峰的分布 ） 我们在MNIST图像上训练了条件对抗网，这些图像以其类标 签为条件，编码为one-hot矢量。\n 在生成器网中，从单位超立方体内的均匀分布中抽样 到具有维数100的噪声先验z 。 z和y都被映射到具有整流线性单元（ReLu）激活[4,11 ] 的隐藏层，分别具有层大小200和1000，然后被映射 到第二层， 该层为维度1200的ReLu组合隐藏层。然后我们有一个最终的，生成784维MNIST样本的sigmoid单 元层作为输出。  鉴别器将x映射到具有240个单元 和5片的maxout[ 6 ]层，并且y映射到具有50个单元和 5片的maxout层。 两个隐藏 层在被馈送到sigmoid层之前， 映射到具有240个单元和4片 联合的maxout层。 （鉴别器的精确架构并不重要，只要它具有足够的功率;我们发现 maxout单元通常非常 适合该任务。）Both of the hidden layers mapped to a joint maxout layer with 240 units and 4 pieces before being fed to the sigmoid layer. (The precise architecture of the discriminator is not critical as long as it has sufficient power;)\n 该模型采用随机梯度下降训练，小批量为 100，初始学习率为0.1 ，指数下降至.000001 ，衰减系数为1.00004 。 还使用动量，初始值为.5 ，增加到0.7 。 以概率为0.5的 dropout[ 9 ]应用于生成器和鉴别 器。 并且验证集上的对数似然的最佳估计被用作停止点。\n Table 1 shows Gaussian Parzen window log-likelihood estimate for the MNIST dataset test data. 1000 samples weredrawn from each 10 class and a Gaussian Parzen window was fitted to these samples. We then estimate the log-likelihood of the test set using the Parzen window distribution.\n 表1示出了MNIST测试数据集的高斯Parzen窗口对数似然估计。 从每10类中抽取1000个样品，并将高这些样本拟合到高斯Parzen窗口上。 然后 ，我们使用Parzen窗口分布估计 测试集的对数似然。 （有关如何构建此估计的更多详细信息，请参见 [ 8 ]。）  我们提出的条件性对抗净结果与其他一些基于网络的 结果相当，但是其他几种方法（包括非条件对抗网）的表现都优于我们的 方法。 我们将这些结果更多地作为概念验证而不是效力的证明，并且相信通过进 一步探索超参数空间和架构，条件模型应该匹配或超过非条件结果。 图2显示了一些生成的样本。 每行以一个标签为条件，每 列是不同的生成样本。 \u0026nbsp;\n  Model\n MNIST\n   DBN\u0026nbsp;[1] \n 138±2\n  Stacked CAE\u0026nbsp;[1] \n 121±1.6\n  Deep GSN\u0026nbsp;[2] \n 214±1.1\n  Adversarial nets\n 225±2\n  Conditional adversarial nets\n 132±1.8\n   Table 1: Parzenwindow-based log-likelihood estimates for MNIST. 我们遵循像 [8]一样的程序来计算这些值. ![mnist.png](mnist.png)Figure 2: 生成的MNIST数字, 每一行 以一个标 签为条件\n4.2 Multimodal多模态数 据 （多峰分布）\n\u0026nbsp;\n诸如Flickr之类的照片网站是图像形式的标记数据及其相 关的用户生成元数据（UGM）的丰富来源 - 特别是用户标签。\n用户生成的元数据与更多“典 型”图像标记方案的不同之处在于它们通常更具描述性，并且在语义上更 接近人类用自然语言描述图像的方式，而不仅仅是识别图像中存在的对象 。 UGM的另一个方面是synoymy是普遍的，不 同的用户可能使用不同的词汇来描述相同的概念- 因此，有一种有效的方法来规范化这些标签变得 很重要。 概念词嵌入 [ 14 ]在这里非常有用，因为相关 概念最终由类似的向量表示。\n 在本节中，我们演示了具有多标签预测的 图像的自动标记，使用条件对抗网络生成（可能是多模态的）标记向量分 布，条件是图像特征。\n 对于图像特征，我们预先训练卷积模型， 类似于[ 13 ]中的卷积模型，在有21,000个标签[ 15 ]的 完整的ImageNet数据集上。 我们使用最后一个完全连接层的输出，其中 4096个单位作为图像表示。\n \u0026nbsp;\n对于表示性世界，我们首先从YFCC100M 2 2Yahoo Flickr Creative Common 100M http://webscope.sandbox.yahoo.com/catalog.php? datatype=i\u0026amp;did收集用户标签 ，标题和描述的串联文本集。  = 67 。 数据集元数据 。 在对文本进行预处理和清理之后，我们训练了 一个单词矢量大小为200的skip-gram模型 [ 14 ]。我们省略了从词汇表中出现少于200次的任何单词，从而最终得到一个大小为247465的字典\n\u0026nbsp;\n We keep the convolutional model and the language model fixed during training of the adversarial net.And leave the experiments when we even backpropagate through these models as future work.\n我们在对抗网的训练期间保持卷积模型和 语言模型的固定。 当我们甚至通过这些模型反向传播时，留下实 验作为未来的工作。\n 对于我们的实验，我们使用 MIR Flickr 25,000数据集[ 10 ]，并使用我们上面描述的卷积模型和语言模型提取图像和标签特 征。 我们的实验中省略了没有任何标签的图像，并 将注释视为额外标签​​。 前150,000个例子被用作训练集。 对于每个关联的标签，在训练集内将具有多个 标签的图像重复一次。\n 为了评估，我们为每个图像生成100个样本，并使用词汇表中单词的向量表示的 余弦 相似性找到前20个最接近的单词到每个样本。  然后我们在所有100个样本中选择前10个 最常用的单词。 表2显示了用户分配的标签和 注释以及生成的标签的一些样本。\n 最佳的可以工作的模型的生 成器接收大小为100的高斯噪声作为噪声先验 ，并将其映射到500维ReLu层。 并将4096维图像特征向量映射到2000维ReLu隐藏层。  这两个层都映射到200维线性层的联合表示中，它将输出生成的词矢量 \n The discriminator is consisted of 500 and 1200 dimension ReLu hidden layers for word vectors and image features respectively and maxout layer with 1000 units and 3 pieces as the join layer which is finally fed to the one single sigmoid unit.\n鉴别器由分别用于字向量和图像特征的500和1200维ReLu隐藏层组成，并且具有1000个单元的maxout层和3片， 作为联合层， 并最终馈送到1个 sigmoid单元。\n 该模型采用随机梯度体积训练，小批量为100，初始学习率为0.1 ，指数下降至.000001 ，衰减系数为1.00004 。 还使用动量，初始值为.5 ，增加到0.7 。 对dropout概率 为0.5应用于生成器和鉴别器。\n 超参数和架构选择是通过交叉 验证以及随机网格搜索和手动选择的混合获得的（尽管在一个有限的搜索 空间内）。\n\u0026nbsp;\n   User tags + annotations\n Generated tags\n    track   ![track](track.jpg)\n montanha, trem, inverno, frio, people, male, plant life, tree, structures, transport, car\n taxi, passenger, line, transportation, railway station, passengers, railways, signals, rail, rails\n  ![cake](cake.jpg)\n food, raspberry, delicious, homemade\n chicken, fattening, cooked, peanut, cream, cookie, house made, bread, biscuit, bakes\n  ![river](river.jpg)\n water, river\n creek, lake, along, near, river, rocky, treeline, valley, woods, waters\n  ![baby](baby.jpg)\n people, portrait, female, baby, indoor\n love, people, posing, girl, young, strangers, pretty, women, happy, life\n   Table 2: 生成的标签样本\n5未来的工作\n本文中显示的结果非常初级，但它们展示 了条件对抗网的潜力，并展示了有趣和有用的应用程序的前景。  从现在到研讨会之间的未来探索中，我们期望提供 更复杂的模型，以及对其性能和特征的更详细和彻底的分析。 \n 此外，在当前的实验中，我 们仅单独使用每个标签。 但是通过同时使用多个标签（有效地将生成问题作为' 集合生成'之一），我们希望获得更 好的结果。 \n未来工作的另一个明显方向是建立一个联合训练计划 来学习语言模型。 诸如[ 12 ]之类的作品表明我们可以学习适合特定任务的语言模型。  \n 致谢  \n该项目是在Pylearn2 [ 7 ]框架中开发的，我们要感谢 Pylearn2开发人员。 我们还要感谢Ian Goodfellow在蒙 特利尔大学期间进行的有益讨论。 作者非常感谢Flickr视觉与机器学习和生产工 程团队的支持（按字母顺序排列：Andrew Stadlen，ArelCordero，Clayton Mellina，CyprienNoel，Frank Liu，Gerry Pesavento，HuyNguyen，Jack Culpepper，John Ko ，Pierre Garrigues，Rob Hess，Stacey Svetlichnaya，Tobi Baumgartner和Ye Lu）。 \u0026nbsp;\n References Bengioet\u0026nbsp;al. [2013]Bengio, Y., Mesnil, G., Dauphin, Y., and Rifai, S. (2013). Better mixing via deep representations. In ICML’2013.  Bengioet\u0026nbsp;al. [2014]Bengio, Y., Thibodeau-Laufer, E., Alain, G., and Yosinski, J. (2014). Deep generative stochastic networks trainable by backprop. In Proceedings of the 30th International Conference on Machine Learning (ICML’14).  Fromeet\u0026nbsp;al. [2013]Frome, A., Corrado, G.\u0026nbsp;S., Shlens, J., Bengio, S., Dean, J., Mikolov, T., et\u0026nbsp;al. (2013). Devise: A deep visual-semantic embedding model. In Advances in Neural Information Processing Systems, pages 2121–2129.  Glorotet\u0026nbsp;al. [2011]Glorot, X., Bordes, A., and Bengio, Y. (2011). Deep sparse rectifier neural networks. In International Conference on Artificial Intelligence and Statistics, pages 315–323.  Goodfellowet\u0026nbsp;al. [2013a]Goodfellow, I., Mirza, M., Courville, A., and Bengio, Y. (2013a). Multi-prediction deep boltzmann machines. In Advances in Neural Information Processing Systems, pages 548–556.  Goodfellowet\u0026nbsp;al. [2013b]Goodfellow, I.\u0026nbsp;J., Warde-Farley, D., Mirza, M., Courville, A., and Bengio, Y. (2013b). Maxout networks. In ICML’2013.  Goodfellowet\u0026nbsp;al. [2013c]Goodfellow, I.\u0026nbsp;J., Warde-Farley, D., Lamblin, P., Dumoulin, V., Mirza, M., Pascanu, R., Bergstra, J., Bastien, F., and Bengio, Y. (2013c). Pylearn2: a machine learning research library. arXiv preprint arXiv:1308.4214.  Goodfellowet\u0026nbsp;al. [2014]Goodfellow, I.\u0026nbsp;J., Pouget-Abadie, J., Mirza, M., Xu, B., Warde-Farley, D., Ozair, S., Courville, A., and Bengio, Y. (2014). Generative adversarial nets. In NIPS’2014.  Hinton et\u0026nbsp;al. [2012]Hinton, G.\u0026nbsp;E., Srivastava, N., Krizhevsky, A., Sutskever, I., and Salakhutdinov, R. (2012). Improving neural networks by preventing co-adaptation of feature detectors. Technical report, arXiv:1207.0580.  Huiskesand Lew [2008]Huiskes, M.\u0026nbsp;J. and Lew, M.\u0026nbsp;S. (2008). The mir flickr retrieval evaluation. In MIR ’08: Proceedings of the 2008 ACM International Conference on Multimedia Information Retrieval, New York, NY, USA. ACM.  Jarrett et\u0026nbsp;al. [2009]Jarrett, K., Kavukcuoglu, K., Ranzato, M., and LeCun, Y. (2009). What is the best multi-stage architecture for object recognition? In ICCV’09.  Kiroset\u0026nbsp;al. [2013]Kiros, R., Zemel, R., and Salakhutdinov, R. (2013). Multimodal neural language models. In Proc. NIPS Deep Learning Workshop.  Krizhevskyet\u0026nbsp;al. [2012]Krizhevsky, A., Sutskever, I., and Hinton, G. (2012). ImageNet classification with deep convolutional neural networks. In Advances in Neural Information Processing Systems 25 (NIPS’2012).  Mikolovet\u0026nbsp;al. [2013]Mikolov, T., Chen, K., Corrado, G., and Dean, J. (2013). Efficient estimation of word representations in vector space. In International Conference on Learning Representations: Workshops Track.  Russakovskyand Fei-Fei [2010]Russakovsky, O. and Fei-Fei, L. (2010). Attribute learning in large- scale datasets. In European Conference of Computer Vision (ECCV), International Workshop on Parts and Attributes, Crete, Greece.  Srivastava and Salakhutdinov [2012]Srivastava, N. and Salakhutdinov, R. (2012). Multimodal learning with deep boltzmann machines. In NIPS’2012.  Szegedyet\u0026nbsp;al. [2014]Szegedy, C., Liu, W., Jia, Y., Sermanet, P., Reed, S., Anguelov, D., Erhan, D., Vanhoucke, V., and Rabinovich, A. (2014). Going deeper with convolutions. arXiv preprint arXiv:1409.4842.   \n\n\n","date":1559174400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1559174400,"objectID":"0840817744849237243ba3967d830fec","permalink":"https://wormcode.github.io/post/cgan/","publishdate":"2019-05-30T00:00:00Z","relpermalink":"/post/cgan/","section":"post","summary":"v\\:* {behavior:url(#default#VML);} o\\:* {behavior:url(#default#VML);} w\\:* {behavior:url(#default#VML);} .shape {behavior:url(#default#VML);}   Conditional Generative Adversarial Nets   common Normal common 25 1243 2019-06-03T11:15:00Z 2019-06-06T05:48:00Z 6 3051 17395 Microsoft Corporation 144 40 20406 14.00      \u0026lt;!\u0026ndash;[if gte mso 9]\u0026gt;  200/w:Zoom Clean/w:SpellingState false/w:TrackMoves   false/w:SaveIfXMLInvalid false/w:IgnoreMixedContent\nfalse EN-US/w:LidThemeOther ZH-CN/w:LidThemeAsian X-NONE/w:LidThemeComplexScript     /w:Compatibility MicrosoftInternetExplorer4/w:BrowserLevel   /m:mathPr/w:WordDocument \u0026lt;![endif]\u0026ndash;\u0026gt;    \u0026lt;!\u0026ndash;.MJX-CHTML {display: inline-block; font-size-adjust: none; word-wrap: normal; max-width: none; max-height: none; min-width: 0; min-height: 0; float:none; word-spacing:normal;} .","tags":[],"title":"翻译 Conditional Generative Adversarial Nets","type":"post"},{"authors":["JM  Liu"],"categories":null,"content":" Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1554595200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1554595200,"objectID":"557dc08fd4b672a0c08e0a8cf0c9ff7d","permalink":"https://wormcode.github.io/publication/preprint/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/preprint/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example preprint / working paper","type":"publication"},{"authors":["JM  Liu"],"categories":[],"content":" from IPython.core.display import Image Image('https://www.python.org/static/community_logos/python-logo-master-v3-TM-flattened.png')  print(\u0026quot;Welcome to Academic!\u0026quot;)  Welcome to Academic!  Install Python and Jupyter Install Anaconda which includes Python 3 and Jupyter notebook.\nOtherwise, for advanced users, install Jupyter notebook with pip3 install jupyter.\nCreate a new blog post as usual Run the following commands in your Terminal, substituting \u0026lt;MY_WEBSITE_FOLDER\u0026gt; and my-post with the file path to your Academic website folder and a name for your blog post (without spaces), respectively:\ncd \u0026lt;MY_WEBSITE_FOLDER\u0026gt; hugo new --kind post post/my-post cd \u0026lt;MY_WEBSITE_FOLDER\u0026gt;/content/post/my-post/  Create or upload a Jupyter notebook Run the following command to start Jupyter within your new blog post folder. Then create a new Jupyter notebook (New \u0026gt; Python Notebook) or upload a notebook.\njupyter notebook  Convert notebook to Markdown jupyter nbconvert Untitled.ipynb --to markdown --NbConvertApp.output_files_dir=. # Copy the contents of Untitled.md and append it to index.md: cat Untitled.md | tee -a index.md # Remove the temporary file: rm Untitled.md  Edit your post metadata Open index.md in your text editor and edit the title etc. in the front matter according to your preference.\nTo set a featured image, place an image named featured into your post\u0026rsquo;s folder.\nFor other tips, such as using math, see the guide on writing content with Academic.\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"6e929dc84ed3ef80467b02e64cd2ed64","permalink":"https://wormcode.github.io/post/jupyter/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/post/jupyter/","section":"post","summary":"Learn how to blog in Academic using Jupyter notebooks","tags":[],"title":"Display Jupyter Notebooks with Academic","type":"post"},{"authors":[],"categories":[],"content":" Welcome to Slides Academic\nFeatures  Efficiently write slides in Markdown 3-in-1: Create, Present, and Publish your slides Supports speaker notes Mobile friendly slides  Controls  Next: Right Arrow or Space Previous: Left Arrow Start: Home Finish: End Overview: Esc Speaker notes: S Fullscreen: F Zoom: Alt + Click PDF Export: E  Code Highlighting Inline code: variable\nCode block:\nporridge = \u0026quot;blueberry\u0026quot; if porridge == \u0026quot;blueberry\u0026quot;: print(\u0026quot;Eating...\u0026quot;)  Math In-line math: $x + y = z$\nBlock math:\n$$ f\\left( x \\right) = \\;\\frac{{2\\left( {x + 4} \\right)\\left( {x - 4} \\right)}}{{\\left( {x + 4} \\right)\\left( {x + 1} \\right)}} $$\nFragments Make content appear incrementally\n{{% fragment %}} One {{% /fragment %}} {{% fragment %}} **Two** {{% /fragment %}} {{% fragment %}} Three {{% /fragment %}}  Press Space to play!\nOne  Two  Three \nA fragment can accept two optional parameters:\n class: use a custom style (requires definition in custom CSS) weight: sets the order in which a fragment appears  Speaker Notes Add speaker notes to your presentation\n{{% speaker_note %}} - Only the speaker can read these notes - Press `S` key to view {{% /speaker_note %}}  Press the S key to view the speaker notes!\n Only the speaker can read these notes Press S key to view   Themes  black: Black background, white text, blue links (default) white: White background, black text, blue links league: Gray background, white text, blue links beige: Beige background, dark text, brown links sky: Blue background, thin dark text, blue links   night: Black background, thick white text, orange links serif: Cappuccino background, gray text, brown links simple: White background, black text, blue links solarized: Cream-colored background, dark green text, blue links  Custom Slide Customize the slide style and background\n{{\u0026lt; slide background-image=\u0026quot;/img/boards.jpg\u0026quot; \u0026gt;}} {{\u0026lt; slide background-color=\u0026quot;#0000FF\u0026quot; \u0026gt;}} {{\u0026lt; slide class=\u0026quot;my-style\u0026quot; \u0026gt;}}  Custom CSS Example Let\u0026rsquo;s make headers navy colored.\nCreate assets/css/reveal_custom.css with:\n.reveal section h1, .reveal section h2, .reveal section h3 { color: navy; }  Questions? Ask\nDocumentation\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"0e6de1a61aa83269ff13324f3167c1a9","permalink":"https://wormcode.github.io/slides/example/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/slides/example/","section":"slides","summary":"An introduction to using Academic's Slides feature.","tags":[],"title":"Slides","type":"slides"},{"authors":["JM  Liu"],"categories":[],"content":" from IPython.core.display import Image Image('https://www.python.org/static/community_logos/python-logo-master-v3-TM-flattened.png')  print(\u0026quot;Welcome to Academic!\u0026quot;)  Welcome to Academic!  Install Python and Jupyter Install Anaconda which includes Python 3 and Jupyter notebook.\nOtherwise, for advanced users, install Jupyter notebook with pip3 install jupyter.\nCreate a new blog post as usual Run the following commands in your Terminal, substituting \u0026lt;MY_WEBSITE_FOLDER\u0026gt; and my-post with the file path to your Academic website folder and a name for your blog post (without spaces), respectively:\ncd \u0026lt;MY_WEBSITE_FOLDER\u0026gt; hugo new --kind post post/my-post cd \u0026lt;MY_WEBSITE_FOLDER\u0026gt;/content/post/my-post/  Create or upload a Jupyter notebook Run the following command to start Jupyter within your new blog post folder. Then create a new Jupyter notebook (New \u0026gt; Python Notebook) or upload a notebook.\njupyter notebook  Convert notebook to Markdown jupyter nbconvert Untitled.ipynb --to markdown --NbConvertApp.output_files_dir=. # Copy the contents of Untitled.md and append it to index.md: cat Untitled.md | tee -a index.md # Remove the temporary file: rm Untitled.md  Edit your post metadata Open index.md in your text editor and edit the title etc. in the front matter according to your preference.\nTo set a featured image, place an image named featured into your post\u0026rsquo;s folder.\nFor other tips, such as using math, see the guide on writing content with Academic.\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"e368e80244db4f7a9c74bc3236074d9e","permalink":"https://wormcode.github.io/post/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/post/","section":"post","summary":"Learn how to blog in Academic using Jupyter notebooks","tags":[],"title":"test post","type":"post"},{"authors":["JM  Liu"],"categories":[],"content":" 翻译者:wormcode, 如发现问题请邮件\nSC-FEGAN: Face Editing Generative Adversarial Network with User’s Sketch and Color Youngjoo Jo Jongyoul Park ETRI South Korea frun.youngjoo,jongyoulg@etri.re.kr\nSC-FEGAN 使用用户输入的草图和颜色进行脸部编辑生成对抗网络\nYoungjoo Jo Jongyoul Park\nETRI\nSouth Korea\nfrun.youngjoo,jongyoulg@etri.re.kr\n\n摘要 我们提出了一种新颖的图像编辑系统，可以在用户提供任意形状的蒙版，草图和颜色作为输入时生成图像。 我们的系统包括端到端可训练的卷积网络。 与现有方法相反，我们的系统完全利用具有颜色和形状的任意形状用户输入。 这允许系统响应用户的草图和颜色输入，使用它作为生成图像的指南。 在我们的特定工作中，我们训练的网络具有额外的风格损失[3]，这使得即使在图像的大部分被移除情况下可以生成更加逼真的结果。 我们提出的网络架构SC-FEGAN非常适合使用直观的用户输入生成高质量的合成图像。\n1. 引言 生成对抗网络（GAN）的图像补全是计算机视觉中高度认可的主题。 随着图像交换成为当今日常通信中的常见介质媒体，在最小图像补全特征（痕迹）上对生成图像中的真实感的需求增加。 这种需求反映在社交媒体统计数据上。 但是，大多数图像编辑软件都需要专业知识，例如知道在特定情况下使用哪些特定工具，以便按照我们想要的方式有效地修改图像。 相反，响应用户输入的图像补全方法将允许新手根据需要容易地修改图像。 类似地，即使图像中存在擦除部分，我们提出的系统也能够轻松生成高质量的人脸图像，前提是草图和颜色作为输入。\n在最近的工作中，已经使用基于深度学习的图像补全方法来恢复图像的擦除部分。最典型的方法是使用普通（方形）蒙版，然后使用编码器解码器生成器恢复遮挡区域。然后使用全局和局部鉴别器来估计结果是真实的还是假的[5,9]。然而，该系统限于低分辨率图像，并且所生成的图像在遮挡区域上具有令人尴尬的边缘。此外，修复区上合成图像经常达不到用户的期望，因为生成器从未被给予任何用户输入以用作指导。改进此限制的一些工作包括Deepfillv2 [17]，一种利用用户草图作为输入的工作，以及GuidedInpating [20]，它将另一个图像的一部分作为输入来恢复缺失的部分。但是，由于Deepfillv2不使用颜色输入，因此合成图像中的颜色通过来自从训练数据集学习的先前分布的推断来进行计算。 Guided-Inpating使用其他图像的一部分来恢复已删除的区域。然而，很难恢复细节，因为这样的过程需要推断用户偏好的参考图像。最近的另一项工作Ideepcolor [19]提出了一种系统，它接受用户输入的颜色作为参考，以创建黑白图像对应的彩色图像。但是，Ideepcolor中的系统不允许编辑对象结构或恢复图像上已删除的部分。在另一项工作中，引入了一个面部编辑系统FaceShop [12]，它接受草图和颜色作为用户输入。但是，FaceShop用作生成合成图像的交互系统有一些限制。首先，它利用随机矩形和 可旋转蒙版来擦除那些由局部和全局鉴别器中使用的区域。这意味着局部鉴别器必须调整 修复的局部补丁 的大小以接受拟合输入尺寸，并且调整大小的过程中将使图像的擦除部分和剩余部分中的信息失真。结果，所产生的图像在修复部分将具有尴尬（明显的？）的边缘。其次，如果太多区域被擦除，FaceShop会产生不合理的合成图像。通常，当给定整个头发部分被擦除的图像时，系统会以扭曲的形状恢复它。\n图1.我们系统的面部图像编辑结果。 它可以采取任意形状的输入，包括面具，草图和颜色。 对于每个示例，它表明我们的系统使用户可以轻松编辑脸部的形状和颜色，即使用户想要完全改变发型和眼睛（第三行）。 有趣的是，用户可以通过我们的系统编辑耳环（第四行）。\n为了解决上述限制，我们提出了一种具有全卷积网络的SC-FEGAN，能够进行端到端的训练。 我们提出的网络使用SN-patchGAN [17]鉴别器来解决和改善尴尬的边缘。 该系统不仅具有一般的GAN损失，而且还具有风格损失，即使在大面积缺失的情况下也可以编辑面部图像的各部分。 我们的系统使用用户的自由形状输入创建高质量的逼真合成图像。 草图和颜色的任意形状域输入也有一个有趣的叠加效应，如图1所示。总之，我们做出以下贡献：\n 我们提出一种类似于Unet [13]的网络体系结构，带有门控卷积层[17]。 对于训练和推理阶段，这种架构更容易，更快捷。 与我们案例中的粗糙-精细网络相比，它产生了优越而细致的结果。\n We created a free-form domain data of masks, color and sketch. This data is used for making incomplete image data for training instead of stereotyped form input.\n我们创建了蒙版，颜色和草图的自由格式域数据。 该数据用于 使 不完整图像数据用于训练 而不是刻板形式的输入。\n 我们应用了SN-patchGAN [17]鉴别器，并以额外的风格损失训练了我们的网络。 该应用程序涵盖了大部分被擦除的情况，并且在管理蒙版边缘时表现出稳健性。 它还允许生成所生成图像的细节，例如高质量的合成发型和耳环。\n  2. Related Work 交互式图像修改具有广泛的历史，主要涉及使用手工特征而非深度学习的技术。 这种优势反映在商业图像编辑软件和我们的使用实践中。 因为大多数商业图像编辑软件使用定义好的操作，所以典型的图像修改任务需要专业知识来策略性地应用图像的变换组合。 除了专业知识，用户还需要花费很长的工作时间来生产精致的产品。 因此，传统方法对于非专家来说是不利的，并且用于产生高质量结果是繁琐的。 除了这些传统的建模方法之外，通过使用大数据集训练生成模型，GAN研究方面的最新突破已经开发了几种补全，修改和转换图像的方法。\n在本节中，我们将讨论使用深度学习流行的图像编辑方法中的 图像补全和图像转换领域的几项工作。\n2.1. Image Translation 用于图像翻译的GAN首先被提出用于学习两个数据集[21,6]之间的图像域变换。 Pix2Pix [6]提出了一个系统使用了一种数据集，该数据集由成对图像组成，可用于创建模型，这种模型或将分割标签转换为原始图像，或将草图转换为图像，或将黑白图像转换为彩色图像。 但是该系统要求图像和目标图像必须成对存在于训练数据集中，以便学习域之间的变换。 CycleGAN [21]提出了对这种要求进行改进的建议。 给定没有目标图像的目标域，在转换原 域中图像时，目标域中存在虚拟结果。 如果再次反转虚拟结果，则2次反转后的结果必须是原始图像。 因此，它需要两个生成器来完成转换任务。\n最近，在域到域更改之后，一些研究工作已经展示了 可采用用户输入以将所需方向效果？添加到生成结果的系统。 StarGAN [2]使用单个生成器和鉴别器通过域标签训练将输入图像灵活地转换为任何期望的目标域。 Ideepcolor [19]是作为一种系统引入的，该系统通过将用户所需的颜色作为蒙版将单色图像转换为彩色图像。 在这些工作中，与用户输入交互的图像变换已经表明，可以通过将载有用户输入的图像输入到生成器来学习用户输入。\n2.2. Image Completion 图像补全领域有两个主要挑战：1）填充图像中的删除区域，2）在修复区域中正确反映用户输入。 在之前的研究中，GAN系统探索了生成原来有擦除区域的完整图像的可能性[5]。 它使用来自U-net [13]结构的发生器并利用局部和全局鉴别器。 鉴别器分别确定在新填充的部分图像和完整的重建图像上是真实的还是假的。 Deepfillv1 [18]也使用矩形蒙版和全局和局部鉴别器模型来表明上下文关注层广泛地改善了性能。 然而，全局和局部鉴别器仍然在已修复部分的边界上产生尴尬的区域。\n在后续研究中Deepfillv2 [17]，引入了任意形状蒙版和SN-patchGAN，代替现有的矩形蒙版，用单个鉴别器代替全局和局部鉴别器。此外，还提出了学习遮挡区域特征的门控卷积层。此图层可以通过训练自动从数据中显示蒙版，这使网络能够在结果上反映用户输入的草图\n我们在下一节中描述的网络不仅允许使用草图而且还使用颜色数据作为编辑图像的输入。即使我们使用U-net结构而不是像Deepfillv1,2 [5,17]那样的粗-细网结构，我们的网络也可以生成高质量的结果，而无需复杂的训练计划，也不需要其他复杂的层。\n3. Approach 在本文中，我们描述了所提出的SC-FEGAN，一种基于神经网络的人脸图像编辑系统，并且还描述了用于制作输入批量数据的方法。该网络可以端到端地进行训练，并生成具有逼真纹理细节的高质量合成图像。在3.1节中，我们讨论了制作训练数据的方法。在3.2节中，我们描述了我们的网络结构和损失函数，它们允许从草图和颜色输入中提取特征，同时实现训练的稳定性。\nThe color maps are generated by median color of segmented areas from using GFC [9]. 图2.草图和颜色域数据集以及批处理的输入。 我们使用HED边缘检测器提取草图[16]。 使用GFC [9]，通过分割区域的中间颜色生成颜色图。 网络的输入包括不完整的图像，蒙版，草图，颜色和噪声。\n3.1. Training Data 合适的训练数据是提高网络训练性能和增加对用户输入的响应性的非常重要的因素。为了训练我们的模型，我们在几个预处理步骤之后使用了CelebA-HQ [8]数据集，如下所述。我们首先随机选择2组29,000张用于训练的图像和1,000张用于测试的图像。在获得草图和颜色数据集之前，我们将图像的大小调整为512 x 512像素。\n为了更好地表达面部图像中眼睛的复杂性，我们使用基于眼睛位置的任意形状蒙版来训练网络。此外，我们通过使用任意形状的蒙版和面部分割GFC [9]创建了适当的草图域和颜色域。 这是一个至关重要的步骤，使我们的系统能够为用户输入手绘案例产生有说服力的结果。我们在输入数据中随机将蒙版应用于头发区域，因为它与脸部的其他部分相比具有不同的属性。我们在下面讨论更多细节。\nFree-form masking with eye-positions 具有眼睛位置的任意形状蒙版\n我们使用类似于Deepfillv2 [17]中提出的蒙版方法来制作不完整的图像。然而，当对面部图像进行训练时，我们随机应用一个以眼睛位置为起点的自由绘制的面具，以表达眼睛的复杂部分。我们还使用GFC[9]随机添加了头发蒙版。算法1中描述了细节。\nSketch \u0026amp; Color domain 草图和颜色域\n------------------------------------------------------------------------- Algorithm 1 Free-form masking with eye-positions ------------------------------------------------------------------------- maxDraw, maxLine, maxAngle, maxLength are hyperparameters GFCHair is the GFC for get hair mask of input image Mask=zeros(inputSize,inputSize) HairMask=GFCHair(IntputImage) numLine=random.range(maxDraw) for i=0 to numLine do startX = random.range(inputSize) startY = random.range(inputSize) startAngle = random.range(360) numV = random.range(maxLine) for j=0 to numV do angleP = random.range(-maxAngle,maxAngle) if j is even then angle = startAngle+angleP else angle = startAngle+angleP+180 end if length = random.range(maxLength) Draw a line on Mask from point (startX, startY) with angle and length. startX = startX + length * sin(angle) startY = stateY + length * cos(angle) end for Draw a line on Mask from eye postion randomly. end for Mask = Mask + HairMask (randomly) ---------------------------------------------------------------------------------------  对于这部分，我们使用了类似于FaceShop [12]中使用的方法。但是，我们排除了将草图数据的位图转换为矢量图形的AutoTrace [15]。我们使用HED [16]边缘检测器生成与用户输入相对应的草图数据，以修改面部图像。之后，我们平滑了曲线并擦除了小边缘。为了创建颜色域数据，我们首先通过应用大小为3的中值滤波创建模糊图像，we first created blurred images by applying a median filtering with size 3 followed by 20 application of bilateral filter.然后应用双边滤波器来。之后，使用GFC [9]对面部进行分割，并将每个分割的部分替换为相应部分的中间中值median颜色。在为色域创建数据时，没有使用直方图均衡，目的是为了避免光反射和阴影造成的颜色污染。然而，不考虑光干涉引起的模糊，因为用户在草图域中表达脸部的所有部分更加共鸣，所以在从域数据创建草图时使用了直方图均衡。更具体地说，在直方图均衡之后，我们应用HED从图像中获得边缘。然后，我们平滑了曲线并擦除了小的对象（objects）。最后，我们将蒙版相乘，采用类似于先前任意形状蒙版的处理，以及彩色图像并获得彩色刷图像。有关我们数据的示例，请参见图2。\n3.2. Network Architecture 受近期图像补全研究[5,17,12]的启发，我们的补全网络（即发生器）基于编码器 - 解码器架构，如U-net [13]，我们的鉴别网络基于SN-patchGAN [17]。我们的网络结构可产生高质量的合成结果，图像大小为512x 512，同时实现稳定和快速的训练。我们的网络也像其他网络一样同时训练生成器和鉴别器。生成器接收具有用户输入的不完整图像以在RGB通道中创建输出图像，并将输出图像的遮挡遮挡区域插入到不完整的输入图像中以创建完整图像。鉴别器接收完成的图像或原始图像（没有遮挡）以确定给定输入是真实的还是假的。在对抗训练中，鉴别器的额外用户输入也有助于提高性能。此外，我们发现与一般GAN损失不同的额外损失对于恢复大的擦除部分是有效的。我们的网络详情如下所示。\n图3. SC-FEGAN的网络架构。 在输入和输出之外的所有卷积层之后应用LRN。 我们使用tanh作为生成器输出的激活函数。 我们使用SN卷积层[11]作为鉴别器。\n生成器 图3详细显示了我们的网络架构。我们的发生器基于U-net [10]，所有卷积层都使用门控卷积[17]，使用3x3大小的卷积核。在除了其他软门之外的特征映射卷积层之后应用局部信号归一化（LRN）[8]。 LRN应用于除输入和输出层之外的所有卷积层。我们的发生器的编码器接收大小为512 x512 x 9的输入张量：具有要被编辑的有移除区域的不完整RGB通道图像，描述被移除部分的结构的二进制草图，RGB颜色笔划图，二值蒙版和噪音（见图2）。编码器使用2个步幅的卷积核对输入进行7次下采样，然后在上采样之前进行膨胀卷积。\n解码器使用转置卷积进行上采样。然后，添加跳线连接以允许与具有相同空间分辨率的先前层进行连接。除了使用tanh函数的输出层之外，我们在每一层之后使用了leaky ReLU激活函数。总的来说，我们的生成器由16个卷积层组成，网络的输出是与输入（512 x 512）相同大小的的RGB图像。在将损失函数应用于输入图像之前，我们用输入图像替换了蒙版之外的剩余图像部分。这种替换允许生成器专门在编辑区域上进行训练。我们的生成器使用在PartialConv [10]中引入的损失函数训练：逐个像素损失，感知损失，风格损失和总方差损失。还使用通用GAN损失函数。\n鉴别器\n我们的鉴别器具有SNPatchGAN [17]结构。与Deepfillv2 [17]不同，我们没有对GAN损失应用ReLu函数。我们还使用了3 x 3大小的卷积核并应用了梯度惩罚损失项。我们添加了一个额外的术语，以避免鉴别器输出接近零值的补丁。我们的整体损失函数如下所示：\n我们的生成器用LG训练，鉴别器用LD训练。 D（I）是给定输入I的鉴别器的输出。在编辑诸如发型的大区域时，额外的损失，Lsytle和Lpercept是关键的。 每种损失的细节描述如下。 真实图像Igt与发生器Igen的输出之间的L1距离的Lper-pixel计算为 其中，Na是特征a的元素个数，M是二元蒙版图，Igen是生成器的输出。 我们使用因子α\u0026gt; 1来增加擦除部分的损失的权重。 感知损失Lpercept也计算L=\u0026ndash;1距离，但是在使用在ImageNet上预先训练过的VGG-16 [14]将图像投影到特征空间之后。 它计算为 这里， 是VGG-16 [14]的第q层的特征图，给定输入x，Icomp是Igen的完成图像，非擦除部分直接设置为真实图像。 q是从 VGG-16中的选定的图层，我们使用了pool1， pool2和pool3的层;。 样式损失使用Gram矩阵比较两个图像的内容。 我们计算风格损失为\n其中是用于在VGG-16的每个特征图上执行自相关的Gram矩阵。 当特征具有形状时，Gram矩阵的输出具有形状 是快速神经风格[7]建议的总变异损失，用于改善感知损失项下的棋盘伪影。 它计算为\n图4.当移除眼睛区域时，我们使用U-net（左）和粗 - 精网（右）的结果。\n其中R是擦除部分的区域。 WGANGP [4]损失用于改进训练并计算为\n这里，U是沿着 来自Icomp的鉴别器输入和Igt之间的直线 均匀采样的数据点。 在我们的案例中，这个术语对合成图像的质量至关重要。 我们用= 0 4. Results 在本节中，我们将消融研究与最近的相关工作进行比较，然后是面部编辑结果。 所有实验均在具有Tensorflow [1] v1.12，CUDA v10，Cudnn v7和Python 3的NVIDIA（R）Tesla（R）V100 GPU和Power9@2.3GHz CPU上执行。 测试，无论输入的大小和形状如何，分辨率为512 X 512 的图片，GPU上平均需要44ms，CPU上平均需要53ms，。 源代码和更多结果显示在https://github.com/JoYoungjoo/SC-FEGAN。\nhttps://github.com/JoYoungjoo/SC-FEGAN.\n4.1. Ablation Studies and Comparisons Figure 5. 在有和没有VGG 损失的网络训练的结果。在没有VGG 损失的情况下，我们遇到了和FaceShop 类似的问题[12]. 图6.与CelebA-HQ验证集上的Deepfillv1 [18]的定性比较。\n我们首先将我们的结果与Coarse-Refined结构网络和U-net结构网络进行了比较。在Deepfillv2 [17]中，它表明Coarse-Refined结构和上下文注意模块对于生成是有效的。但是，我们测试了Coarse-Refined结构网络，并注意到精炼阶段使输出模糊。我们发现其原因是因为精炼网络输出的L1损失总是小于粗网络。粗网络通过使用不完整输入生成恢复区域的粗略估计。然后将该粗略图像传递到精炼网络。这种设置允许精细网络学习地面实况和粗略恢复的不完整输入之间的转换。为了通过卷积运算实现这种效果，使输入数据变模糊 被用作其他更复杂训练方法的变通方法。它可以改善棋盘格，但需要大量的记忆/内存？和时间进行训练。图4显示了我们的系统关于粗细结构网络的结果。\nThe system in FaceShop [12] has shown difficulty in modifying the huge erased image like whole hair regions. FaceShop [12]中的系统显示出难以修改像整个头发区域那样的巨大擦除的图像。\n图7.来自我们系统的面部图像编辑结果。 它表明我们的系统可以正确地改变面部的形状和颜色。 它还表明它可以用于改变眼睛的颜色或擦除不必要的部分。 特别是右下角的两个结果表明我们的系统也可以用于新的发型修饰。\n由于感知和风格损失，我们的系统在这方面表现更好。 图5显示了有和没有VGG损失的结果。 我们还与最近的研究Deepfillv1 [18]进行了比较，其中发布了测试系统。 图6显示我们的系统在结构和形状质量方面使用任意形状的蒙版产生更好的结果。\n4.2. Face Image Editing and Restoration 图7显示了草图和颜色输入的各种结果。它表明我们的系统允许用户直观地编辑脸部图像功能，如发型，脸型，眼睛，嘴巴等。即使整个头发区域被删除，我们的系统一旦提供了用户草图它就能够产生适当的结果。用户可以使用草图和颜色直观地编辑图像，同时网络可以容忍小的绘图错误。用户可以通过输入草图和颜色直观地修改面部图像，以获得逼真地反映阴影和形状的合成图像。图9显示了验证数据集的一些结果，它显示即使用户进行了大量修改，用户也可以获得的高质量合成图像在提供足够的用户输入情况下。此外，为了检查网络对学习所用数据集的依赖性，我们尝试输入所有区域的擦除图像。与Deepfillv1[18]相比，Deepfillv1会产生模糊的脸部图像，但我们的SC-FEGAN会产生模糊的头发图像（参见图10）。这意味着，如果没有草图和颜色等附加信息，面部元素的形状和位置具有一定的依赖值。因此，除非在期望的方向上修复图像，否则不需要提供附加信息。此外，即使输入图像被完全擦除，我们的SC-FEGAN也可以在仅具有草图和彩色任意形状输入的情况下生成人脸图像（参见图10）。\n4.3. Interesting results 由GAN生成的图像结果通常显示对训练数据集的高依赖性。 Deepfillv2 [17]使用相同的数据集CelebA-HQ，但仅使用真实图像来制作草图数据集。 在Faceshop [12]中，AutoTrace [15]删除了数据集图像中的小细节。 在我们的研究中，我们将HED应用于所有区域，并通过安排它来扩展遮蔽覆盖？遮盖区域，我们能够获得产生面部图像和耳环的特殊结果。 图8显示了这些选择的有趣结果。 这些例子表明，即使对于小输入，我们的网络也能够学习小细节并产生合理的结果。\n5. Conclusions 在本文中，我们提出了一种新颖的图像编辑系统，用于任意形状的蒙版，草图，颜色输入，它基于具有新颖GAN损失的端到端可训练生成网络。 我们发现，与其他研究相比，我们的网络架构和损失函数显著改善了修复效果。 我们基于celebA-HQ数据集的高分辨率图像对我们的系统进行了训练，并在许多情况下显示了各种成功和逼真的编辑结果。 我们已经证明，我们的系统能够一次性修改和恢复大区域，并且只需要用户付出最小的努力就可以产生高质量和逼真的结果。\nFigure 8. 我们的关于编辑耳环特殊 结果\n图9.我们关于面部修复的结果。 如果给出足够的输入信息，即使很多区域被删除，我们的系统也可以令人满意地恢复脸部。 图10.关于全区域修复的结果。 在左侧，它显示Deepfillv1 [18]和SC-FEGAN关于完全擦除的图像的结果。 在右侧，它表明SC-FEGAN可以像翻译一样工作。 它只能通过草图和颜色输入生成面部图像。\nReferences [1] M. Abadi, P. Barham, J. Chen, Z. Chen, A. Davis, J. Dean, M. Devin, S. Ghemawat, G. Irving, M. Isard, et al. Tensorflow: a system for large-scale machine learning. In OSDI, volume 16, pages 265–283, 2016. 6\n[2] Y. Choi, M. Choi, M. Kim, J.-W. Ha, S. Kim, and J. Choo. Stargan: Unified generative adversarial networks for multidomain image-to-image translation. In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), June 2018. 3\n[3] L. A. Gatys, A. S. Ecker, and M. Bethge. Image style transfer using convolutional neural networks. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition, pages 2414–2423, 2016. 1\n[4] I. Gulrajani, F. Ahmed, M. Arjovsky, V. Dumoulin, and A. C. Courville. Improved training of wasserstein gans. In Advances in Neural Information Processing Systems, pages 5767–5777, 2017. 6\n[5] S. Iizuka, E. Simo-Serra, and H. Ishikawa. Globally and locally consistent image completion. ACM Transactions on Graphics (TOG), 36(4):107, 2017. 1, 3, 4\n[6] P. Isola, J.-Y. Zhu, T. Zhou, and A. A. Efros. Image-to-image translation with conditional adversarial networks. CVPR, 2017. 2\n[7] J. Johnson, A. Alahi, and L. Fei-Fei. Perceptual losses for real-time style transfer and super-resolution. In European Conference on Computer Vision, pages 694–711. Springer, 2016. 5\n[8] T. Karras, T. Aila, S. Laine, and J. Lehtinen. Progressive growing of gans for improved quality, stability, and variation. arXiv preprint arXiv:1710.10196, 2017. 3, 4\n[9] Y. Li, S. Liu, J. Yang, and M.-H. Yang. Generative face completion. In The IEEE Conference on Computer Vision and Pattern Recognition (CVPR), volume 1, page 3, 2017. 1, 3, 4\n[10] G. Liu, F. A. Reda, K. J. Shih, T.-C. Wang, A. Tao, and B. Catanzaro. Image inpainting for irregular holes using partial convolutions. arXiv preprint arXiv:1804.07723, 2018.4\n[11] T. Miyato, T. Kataoka, M. Koyama, and Y. Yoshida. Spectral normalization for generative adversarial networks. arXiv preprint arXiv:1802.05957, 2018. 5\n[12] T. Portenier, Q. Hu, A. Szabo, S. Bigdeli, P. Favaro, and M. Zwicker. Faceshop: Deep sketch-based face image editing. arXiv preprint arXiv:1804.08972, 2018. 2, 3, 4, 6, 7\n[13] O. Ronneberger, P. Fischer, and T. Brox. U-net: Convolutional networks for biomedical image segmentation. In International Conference on Medical image computing and computer-assisted intervention, pages 234–241. Springer, 2015. 2, 3, 4\n[14] O. Russakovsky, J. Deng, H. Su, J. Krause, S. Satheesh, S. Ma, Z. Huang, A. Karpathy, A. Khosla, M. Bernstein, et al. Imagenet large scale visual recognition challenge. International Journal of Computer Vision, 115(3):211–252, 2015. 5\n[15] M.Weber. Autotrace, 2018. http://autotrace.sourceforge.net. 3, 7\n[16] S. ”Xie and Z. Tu. Holistically-nested edge detection. In Proceedings of IEEE International Conference on Computer Vision, 2015. 3\n[17] J. Yu, Z. Lin, J. Yang, X. Shen, X. Lu, and T. S. Huang. Free-form image inpainting with gated convolution. arXiv preprint arXiv:1806.03589, 2018. 2, 3, 4, 6, 7\n[18] J. Yu, Z. Lin, J. Yang, X. Shen, X. Lu, and T. S. Huang. Generative image inpainting with contextual attention. arXiv preprint arXiv:1801.07892, 2018. 3, 6, 7, 9\n[19] R. Zhang, J.-Y. Zhu, P. Isola, X. Geng, A. S. Lin, T. Yu, and A. A. Efros. Real-time user-guided image colorization with learned deep priors. arXiv preprint arXiv:1705.02999, 2017. 2, 3\n[20] Y. Zhao, B. Price, S. Cohen, and D. Gurari. Guided image inpainting: Replacing an image region by pulling content from another image. arXiv preprint arXiv:1803.08435, 2018. 2\n[21] J.-Y. Zhu, T. Park, P. Isola, and A. A. Efros. Unpaired imageto- image translation using cycle-consistent adversarial networkss. In Computer Vision (ICCV), 2017 IEEE International Conference on, 2017. 2\n","date":1549324800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1549324800,"objectID":"ff7ce8d87d5df2b0fa146b855faeb92c","permalink":"https://wormcode.github.io/post/sc-fegan/","publishdate":"2019-02-05T00:00:00Z","relpermalink":"/post/sc-fegan/","section":"post","summary":"Learn how to blog in Academic using Jupyter notebooks","tags":[],"title":"翻译 SC-FEGAN:Face Editing Generative Adversarial Network with User’s Sketch and Color","type":"post"},{"authors":null,"categories":null,"content":"","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"d1311ddf745551c9e117aa4bb7e28516","permalink":"https://wormcode.github.io/project/external-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/external-project/","section":"project","summary":"An example of linking directly to an external project website using `external_link`.","tags":["Demo"],"title":"External Project","type":"project"},{"authors":null,"categories":null,"content":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum. Sed ac faucibus dolor, scelerisque sollicitudin nisi. Cras purus urna, suscipit quis sapien eu, pulvinar tempor diam. Quisque risus orci, mollis id ante sit amet, gravida egestas nisl. Sed ac tempus magna. Proin in dui enim. Donec condimentum, sem id dapibus fringilla, tellus enim condimentum arcu, nec volutpat est felis vel metus. Vestibulum sit amet erat at nulla eleifend gravida.\nNullam vel molestie justo. Curabitur vitae efficitur leo. In hac habitasse platea dictumst. Sed pulvinar mauris dui, eget varius purus congue ac. Nulla euismod, lorem vel elementum dapibus, nunc justo porta mi, sed tempus est est vel tellus. Nam et enim eleifend, laoreet sem sit amet, elementum sem. Morbi ut leo congue, maximus velit ut, finibus arcu. In et libero cursus, rutrum risus non, molestie leo. Nullam congue quam et volutpat malesuada. Sed risus tortor, pulvinar et dictum nec, sodales non mi. Phasellus lacinia commodo laoreet. Nam mollis, erat in feugiat consectetur, purus eros egestas tellus, in auctor urna odio at nibh. Mauris imperdiet nisi ac magna convallis, at rhoncus ligula cursus.\nCras aliquam rhoncus ipsum, in hendrerit nunc mattis vitae. Duis vitae efficitur metus, ac tempus leo. Cras nec fringilla lacus. Quisque sit amet risus at ipsum pharetra commodo. Sed aliquam mauris at consequat eleifend. Praesent porta, augue sed viverra bibendum, neque ante euismod ante, in vehicula justo lorem ac eros. Suspendisse augue libero, venenatis eget tincidunt ut, malesuada at lorem. Donec vitae bibendum arcu. Aenean maximus nulla non pretium iaculis. Quisque imperdiet, nulla in pulvinar aliquet, velit quam ultrices quam, sit amet fringilla leo sem vel nunc. Mauris in lacinia lacus.\nSuspendisse a tincidunt lacus. Curabitur at urna sagittis, dictum ante sit amet, euismod magna. Sed rutrum massa id tortor commodo, vitae elementum turpis tempus. Lorem ipsum dolor sit amet, consectetur adipiscing elit. Aenean purus turpis, venenatis a ullamcorper nec, tincidunt et massa. Integer posuere quam rutrum arcu vehicula imperdiet. Mauris ullamcorper quam vitae purus congue, quis euismod magna eleifend. Vestibulum semper vel augue eget tincidunt. Fusce eget justo sodales, dapibus odio eu, ultrices lorem. Duis condimentum lorem id eros commodo, in facilisis mauris scelerisque. Morbi sed auctor leo. Nullam volutpat a lacus quis pharetra. Nulla congue rutrum magna a ornare.\nAliquam in turpis accumsan, malesuada nibh ut, hendrerit justo. Cum sociis natoque penatibus et magnis dis parturient montes, nascetur ridiculus mus. Quisque sed erat nec justo posuere suscipit. Donec ut efficitur arcu, in malesuada neque. Nunc dignissim nisl massa, id vulputate nunc pretium nec. Quisque eget urna in risus suscipit ultricies. Pellentesque odio odio, tincidunt in eleifend sed, posuere a diam. Nam gravida nisl convallis semper elementum. Morbi vitae felis faucibus, vulputate orci placerat, aliquet nisi. Aliquam erat volutpat. Maecenas sagittis pulvinar purus, sed porta quam laoreet at.\n","date":1461715200,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1461715200,"objectID":"8f66d660a9a2edc2d08e68cc30f701f7","permalink":"https://wormcode.github.io/project/internal-project/","publishdate":"2016-04-27T00:00:00Z","relpermalink":"/project/internal-project/","section":"project","summary":"An example of using the in-built project page.","tags":["Deep Learning"],"title":"Internal Project","type":"project"},{"authors":["JM  Liu"],"categories":[],"content":" Create a free website with Academic using Markdown, Jupyter, or RStudio. Choose a beautiful color theme and build anything with the Page Builder - over 40 widgets, themes, and language packs included!\nCheck out the latest demo of what you\u0026rsquo;ll get in less than 10 minutes, or view the showcase of personal, project, and business sites.\n Setup Academic Get Started View the documentation Ask a question Request a feature or report a bug Updating? View the Update Guide and Release Notes Support development of Academic:  Donate a coffee Become a backer on Patreon Decorate your laptop or journal with an Academic sticker Wear the T-shirt   \nKey features:\n Page builder - Create anything with widgets and elements Edit any type of content - Blog posts, publications, talks, slides, projects, and more! Create content in Markdown, Jupyter, or RStudio Plugin System - Fully customizable color and font themes Display Code and Math - Code highlighting and LaTeX math supported Integrations - Google Analytics, Disqus commenting, Maps, Contact Forms, and more! Beautiful Site - Simple and refreshing one page design Industry-Leading SEO - Help get your website found on search engines and social media Media Galleries - Display your images and videos with captions in a customizable gallery Mobile Friendly - Look amazing on every screen with a mobile friendly version of your site Multi-language - 15+ language packs including English, 中文, and Português Multi-user - Each author gets their own profile page Privacy Pack - Assists with GDPR Stand Out - Bring your site to life with animation, parallax backgrounds, and scroll effects One-Click Deployment - No servers. No databases. Only files.  Color Themes Academic comes with day (light) and night (dark) mode built-in. Click the sun/moon icon in the top right of the Demo to see it in action!\nChoose a stunning color and font theme for your site. Themes are fully customizable and include:\n         Ecosystem  Academic Admin: An admin tool to import publications from BibTeX or import assets for an offline site Academic Scripts: Scripts to help migrate content to new versions of Academic  Install You can choose from one of the following four methods to install:\n one-click install using your web browser (recommended) install on your computer using Git with the Command Prompt/Terminal app install on your computer by downloading the ZIP files install on your computer with RStudio  Then personalize and deploy your new site.\nUpdating View the Update Guide.\nFeel free to star the project on Github to help keep track of updates.\nLicense Copyright 2016-present George Cushen.\nReleased under the MIT license.\n","date":1461110400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1555459200,"objectID":"279b9966ca9cf3121ce924dca452bb1c","permalink":"https://wormcode.github.io/post/getting-started/","publishdate":"2016-04-20T00:00:00Z","relpermalink":"/post/getting-started/","section":"post","summary":"Create a beautifully simple website in under 10 minutes.","tags":["Academic"],"title":"Academic: the website builder for Hugo","type":"post"},{"authors":["JM  Liu","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1441065600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1441065600,"objectID":"966884cc0d8ac9e31fab966c4534e973","permalink":"https://wormcode.github.io/publication/journal-article/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/journal-article/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example journal article","type":"publication"},{"authors":["JM  Liu","Robert Ford"],"categories":null,"content":" Click the Cite button above to demo the feature to enable visitors to import publication metadata into their reference management software.    Click the Slides button above to demo Academic\u0026rsquo;s Markdown slides feature.   Supplementary notes can be added here, including code and math.\n","date":1372636800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1372636800,"objectID":"69425fb10d4db090cfbd46854715582c","permalink":"https://wormcode.github.io/publication/conference-paper/","publishdate":"2017-01-01T00:00:00Z","relpermalink":"/publication/conference-paper/","section":"publication","summary":"Lorem ipsum dolor sit amet, consectetur adipiscing elit. Duis posuere tellus ac convallis placerat. Proin tincidunt magna sed ex sollicitudin condimentum.","tags":["Source Themes"],"title":"An example conference paper","type":"publication"}]